"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/concaveman";
exports.ids = ["vendor-chunks/concaveman"];
exports.modules = {

/***/ "(ssr)/./node_modules/concaveman/index.js":
/*!******************************************!*\
  !*** ./node_modules/concaveman/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ concaveman)\n/* harmony export */ });\n/* harmony import */ var rbush__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rbush */ \"(ssr)/./node_modules/concaveman/node_modules/rbush/index.js\");\n/* harmony import */ var tinyqueue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tinyqueue */ \"(ssr)/./node_modules/tinyqueue/index.js\");\n/* harmony import */ var point_in_polygon__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! point-in-polygon */ \"(ssr)/./node_modules/point-in-polygon/index.js\");\n/* harmony import */ var robust_predicates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! robust-predicates */ \"(ssr)/./node_modules/robust-predicates/index.js\");\n\n\n\n\n\n\nfunction concaveman(points, concavity, lengthThreshold) {\n    // a relative measure of concavity; higher value means simpler hull\n    concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n\n    // when a segment goes below this length threshold, it won't be drilled down further\n    lengthThreshold = lengthThreshold || 0;\n\n    // start with a convex hull of the points\n    const hull = fastConvexHull(points);\n\n    // index the points with an R-tree\n    const tree = new rbush__WEBPACK_IMPORTED_MODULE_0__[\"default\"](16);\n    tree.toBBox = function (a) {\n        return {\n            minX: a[0],\n            minY: a[1],\n            maxX: a[0],\n            maxY: a[1]\n        };\n    };\n    tree.compareMinX = function (a, b) { return a[0] - b[0]; };\n    tree.compareMinY = function (a, b) { return a[1] - b[1]; };\n\n    tree.load(points);\n\n    // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n    const queue = [];\n    let last;\n    for (let i = 0; i < hull.length; i++) {\n        const p = hull[i];\n        tree.remove(p);\n        last = insertNode(p, last);\n        queue.push(last);\n    }\n\n    // index the segments with an R-tree (for intersection checks)\n    const segTree = new rbush__WEBPACK_IMPORTED_MODULE_0__[\"default\"](16);\n    for (let i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\n\n    const sqConcavity = concavity * concavity;\n    const sqLenThreshold = lengthThreshold * lengthThreshold;\n\n    // process edges one by one\n    while (queue.length) {\n        const node = queue.shift();\n        const a = node.p;\n        const b = node.next.p;\n\n        // skip the edge if it's already short enough\n        const sqLen = getSqDist(a, b);\n        if (sqLen < sqLenThreshold) continue;\n\n        const maxSqLen = sqLen / sqConcavity;\n\n        // find the best connection point for the current edge to flex inward to\n        const p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);\n\n        // if we found a connection and it satisfies our concavity measure\n        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n            // connect the edge endpoints through this point and add 2 new edges to the queue\n            queue.push(node);\n            queue.push(insertNode(p, node));\n\n            // update point and segment indexes\n            tree.remove(p);\n            segTree.remove(node);\n            segTree.insert(updateBBox(node));\n            segTree.insert(updateBBox(node.next));\n        }\n    }\n\n    // convert the resulting hull linked list to an array of points\n    let node = last;\n    const concave = [];\n    do {\n        concave.push(node.p);\n        node = node.next;\n    } while (node !== last);\n\n    concave.push(node.p);\n\n    return concave;\n}\n\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\n    const queue = new tinyqueue__WEBPACK_IMPORTED_MODULE_1__[\"default\"]([], compareDist);\n    let node = tree.data;\n\n    // search through the point R-tree with a depth-first search using a priority queue\n    // in the order of distance to the edge (b, c)\n    while (node) {\n        for (let i = 0; i < node.children.length; i++) {\n            const child = node.children[i];\n\n            const dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n            if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n\n            queue.push({\n                node: child,\n                dist\n            });\n        }\n\n        while (queue.length && !queue.peek().node.children) {\n            const item = queue.pop();\n            const p = item.node;\n\n            // skip all points that are as close to adjacent edges (a,b) and (c,d),\n            // and points that would introduce self-intersections when connected\n            const d0 = sqSegDist(p, a, b);\n            const d1 = sqSegDist(p, c, d);\n            if (item.dist < d0 && item.dist < d1 &&\n                noIntersections(b, p, segTree) &&\n                noIntersections(c, p, segTree)) return p;\n        }\n\n        node = queue.pop();\n        if (node) node = node.node;\n    }\n\n    return null;\n}\n\nfunction compareDist(a, b) {\n    return a.dist - b.dist;\n}\n\n// square distance from a segment bounding box to the given one\nfunction sqSegBoxDist(a, b, bbox) {\n    if (inside(a, bbox) || inside(b, bbox)) return 0;\n    const d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);\n    if (d1 === 0) return 0;\n    const d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);\n    if (d2 === 0) return 0;\n    const d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);\n    if (d3 === 0) return 0;\n    const d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);\n    if (d4 === 0) return 0;\n    return Math.min(d1, d2, d3, d4);\n}\n\nfunction inside(a, bbox) {\n    return a[0] >= bbox.minX &&\n           a[0] <= bbox.maxX &&\n           a[1] >= bbox.minY &&\n           a[1] <= bbox.maxY;\n}\n\n// check if the edge (a,b) doesn't intersect any other edges\nfunction noIntersections(a, b, segTree) {\n    const minX = Math.min(a[0], b[0]);\n    const minY = Math.min(a[1], b[1]);\n    const maxX = Math.max(a[0], b[0]);\n    const maxY = Math.max(a[1], b[1]);\n\n    const edges = segTree.search({minX, minY, maxX, maxY});\n    for (let i = 0; i < edges.length; i++) {\n        if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n    }\n    return true;\n}\n\nfunction cross(p1, p2, p3) {\n    return (0,robust_predicates__WEBPACK_IMPORTED_MODULE_3__.orient2d)(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\n// check if the edges (p1,q1) and (p2,q2) intersect\nfunction intersects(p1, q1, p2, q2) {\n    return p1 !== q2 && q1 !== p2 &&\n        cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 &&\n        cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;\n}\n\n// update the bounding box of a node's edge\nfunction updateBBox(node) {\n    const p1 = node.p;\n    const p2 = node.next.p;\n    node.minX = Math.min(p1[0], p2[0]);\n    node.minY = Math.min(p1[1], p2[1]);\n    node.maxX = Math.max(p1[0], p2[0]);\n    node.maxY = Math.max(p1[1], p2[1]);\n    return node;\n}\n\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\nfunction fastConvexHull(points) {\n    let left = points[0];\n    let top = points[0];\n    let right = points[0];\n    let bottom = points[0];\n\n    // find the leftmost, rightmost, topmost and bottommost points\n    for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        if (p[0] < left[0]) left = p;\n        if (p[0] > right[0]) right = p;\n        if (p[1] < top[1]) top = p;\n        if (p[1] > bottom[1]) bottom = p;\n    }\n\n    // filter out points that are inside the resulting quadrilateral\n    const cull = [left, top, right, bottom];\n    const filtered = cull.slice();\n    for (let i = 0; i < points.length; i++) {\n        if (!point_in_polygon__WEBPACK_IMPORTED_MODULE_2__(points[i], cull)) filtered.push(points[i]);\n    }\n\n    // get convex hull around the filtered points\n    return convexHull(filtered);\n}\n\n// create a new node in a doubly linked list\nfunction insertNode(p, prev) {\n    const node = {\n        p,\n        prev: null,\n        next: null,\n        minX: 0,\n        minY: 0,\n        maxX: 0,\n        maxY: 0\n    };\n\n    if (!prev) {\n        node.prev = node;\n        node.next = node;\n\n    } else {\n        node.next = prev.next;\n        node.prev = prev;\n        prev.next.prev = node;\n        prev.next = node;\n    }\n    return node;\n}\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    const dx = p1[0] - p2[0],\n        dy = p1[1] - p2[1];\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction sqSegDist(p, p1, p2) {\n\n    let x = p1[0],\n        y = p1[1],\n        dx = p2[0] - x,\n        dy = p2[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p[0] - x;\n    dy = p[1] - y;\n\n    return dx * dx + dy * dy;\n}\n\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const ux = x1 - x0;\n    const uy = y1 - y0;\n    const vx = x3 - x2;\n    const vy = y3 - y2;\n    const wx = x0 - x2;\n    const wy = y0 - y2;\n    const a = ux * ux + uy * uy;\n    const b = ux * vx + uy * vy;\n    const c = vx * vx + vy * vy;\n    const d = ux * wx + uy * wy;\n    const e = vx * wx + vy * wy;\n    const D = a * c - b * b;\n\n    let sN, tN;\n    let sD = D;\n    let tD = D;\n\n    if (D === 0) {\n        sN = 0;\n        sD = 1;\n        tN = e;\n        tD = c;\n    } else {\n        sN = b * e - c * d;\n        tN = a * e - b * d;\n        if (sN < 0) {\n            sN = 0;\n            tN = e;\n            tD = c;\n        } else if (sN > sD) {\n            sN = sD;\n            tN = e + b;\n            tD = c;\n        }\n    }\n\n    if (tN < 0.0) {\n        tN = 0.0;\n        if (-d < 0.0) sN = 0.0;\n        else if (-d > a) sN = sD;\n        else {\n            sN = -d;\n            sD = a;\n        }\n    } else if (tN > tD) {\n        tN = tD;\n        if ((-d + b) < 0.0) sN = 0;\n        else if (-d + b > a) sN = sD;\n        else {\n            sN = -d + b;\n            sD = a;\n        }\n    }\n\n    const sc = sN === 0 ? 0 : sN / sD;\n    const tc = tN === 0 ? 0 : tN / tD;\n\n    const cx = (1 - sc) * x0 + sc * x1;\n    const cy = (1 - sc) * y0 + sc * y1;\n    const cx2 = (1 - tc) * x2 + tc * x3;\n    const cy2 = (1 - tc) * y2 + tc * y3;\n    const dx = cx2 - cx;\n    const dy = cy2 - cy;\n\n    return dx * dx + dy * dy;\n}\n\nfunction compareByX(a, b) {\n    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n}\n\nfunction convexHull(points) {\n    points.sort(compareByX);\n\n    const lower = [];\n    for (let i = 0; i < points.length; i++) {\n        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n            lower.pop();\n        }\n        lower.push(points[i]);\n    }\n\n    const upper = [];\n    for (let ii = points.length - 1; ii >= 0; ii--) {\n        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {\n            upper.pop();\n        }\n        upper.push(points[ii]);\n    }\n\n    upper.pop();\n    lower.pop();\n    return lower.concat(upper);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29uY2F2ZW1hbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFDMEI7QUFDSTtBQUNnQjtBQUNIOztBQUU1QjtBQUNmLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsNkNBQUs7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3Qiw2Q0FBSztBQUM3QixvQkFBb0Isa0JBQWtCOztBQUV0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsaURBQUs7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyx1QkFBdUI7QUFDekQsb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsMkRBQVE7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsYUFBYSw2Q0FBYztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWRiYXNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2NvbmNhdmVtYW4vaW5kZXguanM/YWE3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCBSQnVzaCBmcm9tICdyYnVzaCc7XG5pbXBvcnQgUXVldWUgZnJvbSAndGlueXF1ZXVlJztcbmltcG9ydCBwb2ludEluUG9seWdvbiBmcm9tICdwb2ludC1pbi1wb2x5Z29uJztcbmltcG9ydCB7b3JpZW50MmR9IGZyb20gJ3JvYnVzdC1wcmVkaWNhdGVzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29uY2F2ZW1hbihwb2ludHMsIGNvbmNhdml0eSwgbGVuZ3RoVGhyZXNob2xkKSB7XG4gICAgLy8gYSByZWxhdGl2ZSBtZWFzdXJlIG9mIGNvbmNhdml0eTsgaGlnaGVyIHZhbHVlIG1lYW5zIHNpbXBsZXIgaHVsbFxuICAgIGNvbmNhdml0eSA9IE1hdGgubWF4KDAsIGNvbmNhdml0eSA9PT0gdW5kZWZpbmVkID8gMiA6IGNvbmNhdml0eSk7XG5cbiAgICAvLyB3aGVuIGEgc2VnbWVudCBnb2VzIGJlbG93IHRoaXMgbGVuZ3RoIHRocmVzaG9sZCwgaXQgd29uJ3QgYmUgZHJpbGxlZCBkb3duIGZ1cnRoZXJcbiAgICBsZW5ndGhUaHJlc2hvbGQgPSBsZW5ndGhUaHJlc2hvbGQgfHwgMDtcblxuICAgIC8vIHN0YXJ0IHdpdGggYSBjb252ZXggaHVsbCBvZiB0aGUgcG9pbnRzXG4gICAgY29uc3QgaHVsbCA9IGZhc3RDb252ZXhIdWxsKHBvaW50cyk7XG5cbiAgICAvLyBpbmRleCB0aGUgcG9pbnRzIHdpdGggYW4gUi10cmVlXG4gICAgY29uc3QgdHJlZSA9IG5ldyBSQnVzaCgxNik7XG4gICAgdHJlZS50b0JCb3ggPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluWDogYVswXSxcbiAgICAgICAgICAgIG1pblk6IGFbMV0sXG4gICAgICAgICAgICBtYXhYOiBhWzBdLFxuICAgICAgICAgICAgbWF4WTogYVsxXVxuICAgICAgICB9O1xuICAgIH07XG4gICAgdHJlZS5jb21wYXJlTWluWCA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzBdIC0gYlswXTsgfTtcbiAgICB0cmVlLmNvbXBhcmVNaW5ZID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMV0gLSBiWzFdOyB9O1xuXG4gICAgdHJlZS5sb2FkKHBvaW50cyk7XG5cbiAgICAvLyB0dXJuIHRoZSBjb252ZXggaHVsbCBpbnRvIGEgbGlua2VkIGxpc3QgYW5kIHBvcHVsYXRlIHRoZSBpbml0aWFsIGVkZ2UgcXVldWUgd2l0aCB0aGUgbm9kZXNcbiAgICBjb25zdCBxdWV1ZSA9IFtdO1xuICAgIGxldCBsYXN0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaHVsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwID0gaHVsbFtpXTtcbiAgICAgICAgdHJlZS5yZW1vdmUocCk7XG4gICAgICAgIGxhc3QgPSBpbnNlcnROb2RlKHAsIGxhc3QpO1xuICAgICAgICBxdWV1ZS5wdXNoKGxhc3QpO1xuICAgIH1cblxuICAgIC8vIGluZGV4IHRoZSBzZWdtZW50cyB3aXRoIGFuIFItdHJlZSAoZm9yIGludGVyc2VjdGlvbiBjaGVja3MpXG4gICAgY29uc3Qgc2VnVHJlZSA9IG5ldyBSQnVzaCgxNik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykgc2VnVHJlZS5pbnNlcnQodXBkYXRlQkJveChxdWV1ZVtpXSkpO1xuXG4gICAgY29uc3Qgc3FDb25jYXZpdHkgPSBjb25jYXZpdHkgKiBjb25jYXZpdHk7XG4gICAgY29uc3Qgc3FMZW5UaHJlc2hvbGQgPSBsZW5ndGhUaHJlc2hvbGQgKiBsZW5ndGhUaHJlc2hvbGQ7XG5cbiAgICAvLyBwcm9jZXNzIGVkZ2VzIG9uZSBieSBvbmVcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBjb25zdCBhID0gbm9kZS5wO1xuICAgICAgICBjb25zdCBiID0gbm9kZS5uZXh0LnA7XG5cbiAgICAgICAgLy8gc2tpcCB0aGUgZWRnZSBpZiBpdCdzIGFscmVhZHkgc2hvcnQgZW5vdWdoXG4gICAgICAgIGNvbnN0IHNxTGVuID0gZ2V0U3FEaXN0KGEsIGIpO1xuICAgICAgICBpZiAoc3FMZW4gPCBzcUxlblRocmVzaG9sZCkgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgbWF4U3FMZW4gPSBzcUxlbiAvIHNxQ29uY2F2aXR5O1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3QgY29ubmVjdGlvbiBwb2ludCBmb3IgdGhlIGN1cnJlbnQgZWRnZSB0byBmbGV4IGlud2FyZCB0b1xuICAgICAgICBjb25zdCBwID0gZmluZENhbmRpZGF0ZSh0cmVlLCBub2RlLnByZXYucCwgYSwgYiwgbm9kZS5uZXh0Lm5leHQucCwgbWF4U3FMZW4sIHNlZ1RyZWUpO1xuXG4gICAgICAgIC8vIGlmIHdlIGZvdW5kIGEgY29ubmVjdGlvbiBhbmQgaXQgc2F0aXNmaWVzIG91ciBjb25jYXZpdHkgbWVhc3VyZVxuICAgICAgICBpZiAocCAmJiBNYXRoLm1pbihnZXRTcURpc3QocCwgYSksIGdldFNxRGlzdChwLCBiKSkgPD0gbWF4U3FMZW4pIHtcbiAgICAgICAgICAgIC8vIGNvbm5lY3QgdGhlIGVkZ2UgZW5kcG9pbnRzIHRocm91Z2ggdGhpcyBwb2ludCBhbmQgYWRkIDIgbmV3IGVkZ2VzIHRvIHRoZSBxdWV1ZVxuICAgICAgICAgICAgcXVldWUucHVzaChub2RlKTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goaW5zZXJ0Tm9kZShwLCBub2RlKSk7XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwb2ludCBhbmQgc2VnbWVudCBpbmRleGVzXG4gICAgICAgICAgICB0cmVlLnJlbW92ZShwKTtcbiAgICAgICAgICAgIHNlZ1RyZWUucmVtb3ZlKG5vZGUpO1xuICAgICAgICAgICAgc2VnVHJlZS5pbnNlcnQodXBkYXRlQkJveChub2RlKSk7XG4gICAgICAgICAgICBzZWdUcmVlLmluc2VydCh1cGRhdGVCQm94KG5vZGUubmV4dCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29udmVydCB0aGUgcmVzdWx0aW5nIGh1bGwgbGlua2VkIGxpc3QgdG8gYW4gYXJyYXkgb2YgcG9pbnRzXG4gICAgbGV0IG5vZGUgPSBsYXN0O1xuICAgIGNvbnN0IGNvbmNhdmUgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGNvbmNhdmUucHVzaChub2RlLnApO1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0O1xuICAgIH0gd2hpbGUgKG5vZGUgIT09IGxhc3QpO1xuXG4gICAgY29uY2F2ZS5wdXNoKG5vZGUucCk7XG5cbiAgICByZXR1cm4gY29uY2F2ZTtcbn1cblxuZnVuY3Rpb24gZmluZENhbmRpZGF0ZSh0cmVlLCBhLCBiLCBjLCBkLCBtYXhEaXN0LCBzZWdUcmVlKSB7XG4gICAgY29uc3QgcXVldWUgPSBuZXcgUXVldWUoW10sIGNvbXBhcmVEaXN0KTtcbiAgICBsZXQgbm9kZSA9IHRyZWUuZGF0YTtcblxuICAgIC8vIHNlYXJjaCB0aHJvdWdoIHRoZSBwb2ludCBSLXRyZWUgd2l0aCBhIGRlcHRoLWZpcnN0IHNlYXJjaCB1c2luZyBhIHByaW9yaXR5IHF1ZXVlXG4gICAgLy8gaW4gdGhlIG9yZGVyIG9mIGRpc3RhbmNlIHRvIHRoZSBlZGdlIChiLCBjKVxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gbm9kZS5sZWFmID8gc3FTZWdEaXN0KGNoaWxkLCBiLCBjKSA6IHNxU2VnQm94RGlzdChiLCBjLCBjaGlsZCk7XG4gICAgICAgICAgICBpZiAoZGlzdCA+IG1heERpc3QpIGNvbnRpbnVlOyAvLyBza2lwIHRoZSBub2RlIGlmIGl0J3MgZmFydGhlciB0aGFuIHdlIGV2ZXIgbmVlZFxuXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBkaXN0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggJiYgIXF1ZXVlLnBlZWsoKS5ub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICBjb25zdCBwID0gaXRlbS5ub2RlO1xuXG4gICAgICAgICAgICAvLyBza2lwIGFsbCBwb2ludHMgdGhhdCBhcmUgYXMgY2xvc2UgdG8gYWRqYWNlbnQgZWRnZXMgKGEsYikgYW5kIChjLGQpLFxuICAgICAgICAgICAgLy8gYW5kIHBvaW50cyB0aGF0IHdvdWxkIGludHJvZHVjZSBzZWxmLWludGVyc2VjdGlvbnMgd2hlbiBjb25uZWN0ZWRcbiAgICAgICAgICAgIGNvbnN0IGQwID0gc3FTZWdEaXN0KHAsIGEsIGIpO1xuICAgICAgICAgICAgY29uc3QgZDEgPSBzcVNlZ0Rpc3QocCwgYywgZCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5kaXN0IDwgZDAgJiYgaXRlbS5kaXN0IDwgZDEgJiZcbiAgICAgICAgICAgICAgICBub0ludGVyc2VjdGlvbnMoYiwgcCwgc2VnVHJlZSkgJiZcbiAgICAgICAgICAgICAgICBub0ludGVyc2VjdGlvbnMoYywgcCwgc2VnVHJlZSkpIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICBpZiAobm9kZSkgbm9kZSA9IG5vZGUubm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURpc3QoYSwgYikge1xuICAgIHJldHVybiBhLmRpc3QgLSBiLmRpc3Q7XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgc2VnbWVudCBib3VuZGluZyBib3ggdG8gdGhlIGdpdmVuIG9uZVxuZnVuY3Rpb24gc3FTZWdCb3hEaXN0KGEsIGIsIGJib3gpIHtcbiAgICBpZiAoaW5zaWRlKGEsIGJib3gpIHx8IGluc2lkZShiLCBiYm94KSkgcmV0dXJuIDA7XG4gICAgY29uc3QgZDEgPSBzcVNlZ1NlZ0Rpc3QoYVswXSwgYVsxXSwgYlswXSwgYlsxXSwgYmJveC5taW5YLCBiYm94Lm1pblksIGJib3gubWF4WCwgYmJveC5taW5ZKTtcbiAgICBpZiAoZDEgPT09IDApIHJldHVybiAwO1xuICAgIGNvbnN0IGQyID0gc3FTZWdTZWdEaXN0KGFbMF0sIGFbMV0sIGJbMF0sIGJbMV0sIGJib3gubWluWCwgYmJveC5taW5ZLCBiYm94Lm1pblgsIGJib3gubWF4WSk7XG4gICAgaWYgKGQyID09PSAwKSByZXR1cm4gMDtcbiAgICBjb25zdCBkMyA9IHNxU2VnU2VnRGlzdChhWzBdLCBhWzFdLCBiWzBdLCBiWzFdLCBiYm94Lm1heFgsIGJib3gubWluWSwgYmJveC5tYXhYLCBiYm94Lm1heFkpO1xuICAgIGlmIChkMyA9PT0gMCkgcmV0dXJuIDA7XG4gICAgY29uc3QgZDQgPSBzcVNlZ1NlZ0Rpc3QoYVswXSwgYVsxXSwgYlswXSwgYlsxXSwgYmJveC5taW5YLCBiYm94Lm1heFksIGJib3gubWF4WCwgYmJveC5tYXhZKTtcbiAgICBpZiAoZDQgPT09IDApIHJldHVybiAwO1xuICAgIHJldHVybiBNYXRoLm1pbihkMSwgZDIsIGQzLCBkNCk7XG59XG5cbmZ1bmN0aW9uIGluc2lkZShhLCBiYm94KSB7XG4gICAgcmV0dXJuIGFbMF0gPj0gYmJveC5taW5YICYmXG4gICAgICAgICAgIGFbMF0gPD0gYmJveC5tYXhYICYmXG4gICAgICAgICAgIGFbMV0gPj0gYmJveC5taW5ZICYmXG4gICAgICAgICAgIGFbMV0gPD0gYmJveC5tYXhZO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgZWRnZSAoYSxiKSBkb2Vzbid0IGludGVyc2VjdCBhbnkgb3RoZXIgZWRnZXNcbmZ1bmN0aW9uIG5vSW50ZXJzZWN0aW9ucyhhLCBiLCBzZWdUcmVlKSB7XG4gICAgY29uc3QgbWluWCA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIGNvbnN0IG1pblkgPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBjb25zdCBtYXhYID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgY29uc3QgbWF4WSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuXG4gICAgY29uc3QgZWRnZXMgPSBzZWdUcmVlLnNlYXJjaCh7bWluWCwgbWluWSwgbWF4WCwgbWF4WX0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoZWRnZXNbaV0ucCwgZWRnZXNbaV0ubmV4dC5wLCBhLCBiKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3Jvc3MocDEsIHAyLCBwMykge1xuICAgIHJldHVybiBvcmllbnQyZChwMVswXSwgcDFbMV0sIHAyWzBdLCBwMlsxXSwgcDNbMF0sIHAzWzFdKTtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIGVkZ2VzIChwMSxxMSkgYW5kIChwMixxMikgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgcmV0dXJuIHAxICE9PSBxMiAmJiBxMSAhPT0gcDIgJiZcbiAgICAgICAgY3Jvc3MocDEsIHExLCBwMikgPiAwICE9PSBjcm9zcyhwMSwgcTEsIHEyKSA+IDAgJiZcbiAgICAgICAgY3Jvc3MocDIsIHEyLCBwMSkgPiAwICE9PSBjcm9zcyhwMiwgcTIsIHExKSA+IDA7XG59XG5cbi8vIHVwZGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIGEgbm9kZSdzIGVkZ2VcbmZ1bmN0aW9uIHVwZGF0ZUJCb3gobm9kZSkge1xuICAgIGNvbnN0IHAxID0gbm9kZS5wO1xuICAgIGNvbnN0IHAyID0gbm9kZS5uZXh0LnA7XG4gICAgbm9kZS5taW5YID0gTWF0aC5taW4ocDFbMF0sIHAyWzBdKTtcbiAgICBub2RlLm1pblkgPSBNYXRoLm1pbihwMVsxXSwgcDJbMV0pO1xuICAgIG5vZGUubWF4WCA9IE1hdGgubWF4KHAxWzBdLCBwMlswXSk7XG4gICAgbm9kZS5tYXhZID0gTWF0aC5tYXgocDFbMV0sIHAyWzFdKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuLy8gc3BlZWQgdXAgY29udmV4IGh1bGwgYnkgZmlsdGVyaW5nIG91dCBwb2ludHMgaW5zaWRlIHF1YWRyaWxhdGVyYWwgZm9ybWVkIGJ5IDQgZXh0cmVtZSBwb2ludHNcbmZ1bmN0aW9uIGZhc3RDb252ZXhIdWxsKHBvaW50cykge1xuICAgIGxldCBsZWZ0ID0gcG9pbnRzWzBdO1xuICAgIGxldCB0b3AgPSBwb2ludHNbMF07XG4gICAgbGV0IHJpZ2h0ID0gcG9pbnRzWzBdO1xuICAgIGxldCBib3R0b20gPSBwb2ludHNbMF07XG5cbiAgICAvLyBmaW5kIHRoZSBsZWZ0bW9zdCwgcmlnaHRtb3N0LCB0b3Btb3N0IGFuZCBib3R0b21tb3N0IHBvaW50c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHAgPSBwb2ludHNbaV07XG4gICAgICAgIGlmIChwWzBdIDwgbGVmdFswXSkgbGVmdCA9IHA7XG4gICAgICAgIGlmIChwWzBdID4gcmlnaHRbMF0pIHJpZ2h0ID0gcDtcbiAgICAgICAgaWYgKHBbMV0gPCB0b3BbMV0pIHRvcCA9IHA7XG4gICAgICAgIGlmIChwWzFdID4gYm90dG9tWzFdKSBib3R0b20gPSBwO1xuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgcG9pbnRzIHRoYXQgYXJlIGluc2lkZSB0aGUgcmVzdWx0aW5nIHF1YWRyaWxhdGVyYWxcbiAgICBjb25zdCBjdWxsID0gW2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbV07XG4gICAgY29uc3QgZmlsdGVyZWQgPSBjdWxsLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFwb2ludEluUG9seWdvbihwb2ludHNbaV0sIGN1bGwpKSBmaWx0ZXJlZC5wdXNoKHBvaW50c1tpXSk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IGNvbnZleCBodWxsIGFyb3VuZCB0aGUgZmlsdGVyZWQgcG9pbnRzXG4gICAgcmV0dXJuIGNvbnZleEh1bGwoZmlsdGVyZWQpO1xufVxuXG4vLyBjcmVhdGUgYSBuZXcgbm9kZSBpbiBhIGRvdWJseSBsaW5rZWQgbGlzdFxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShwLCBwcmV2KSB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgcCxcbiAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgbWluWDogMCxcbiAgICAgICAgbWluWTogMCxcbiAgICAgICAgbWF4WDogMCxcbiAgICAgICAgbWF4WTogMFxuICAgIH07XG5cbiAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgbm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgbm9kZS5uZXh0ID0gbm9kZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUubmV4dCA9IHByZXYubmV4dDtcbiAgICAgICAgbm9kZS5wcmV2ID0gcHJldjtcbiAgICAgICAgcHJldi5uZXh0LnByZXYgPSBub2RlO1xuICAgICAgICBwcmV2Lm5leHQgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuLy8gc3F1YXJlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbmZ1bmN0aW9uIGdldFNxRGlzdChwMSwgcDIpIHtcblxuICAgIGNvbnN0IGR4ID0gcDFbMF0gLSBwMlswXSxcbiAgICAgICAgZHkgPSBwMVsxXSAtIHAyWzFdO1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgc2VnbWVudFxuZnVuY3Rpb24gc3FTZWdEaXN0KHAsIHAxLCBwMikge1xuXG4gICAgbGV0IHggPSBwMVswXSxcbiAgICAgICAgeSA9IHAxWzFdLFxuICAgICAgICBkeCA9IHAyWzBdIC0geCxcbiAgICAgICAgZHkgPSBwMlsxXSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICBjb25zdCB0ID0gKChwWzBdIC0geCkgKiBkeCArIChwWzFdIC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyWzBdO1xuICAgICAgICAgICAgeSA9IHAyWzFdO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHBbMF0gLSB4O1xuICAgIGR5ID0gcFsxXSAtIHk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNlZ21lbnQgdG8gc2VnbWVudCBkaXN0YW5jZSwgcG9ydGVkIGZyb20gaHR0cDovL2dlb21hbGdvcml0aG1zLmNvbS9hMDctX2Rpc3RhbmNlLmh0bWwgYnkgRGFuIFN1bmRheVxuZnVuY3Rpb24gc3FTZWdTZWdEaXN0KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIGNvbnN0IHV4ID0geDEgLSB4MDtcbiAgICBjb25zdCB1eSA9IHkxIC0geTA7XG4gICAgY29uc3QgdnggPSB4MyAtIHgyO1xuICAgIGNvbnN0IHZ5ID0geTMgLSB5MjtcbiAgICBjb25zdCB3eCA9IHgwIC0geDI7XG4gICAgY29uc3Qgd3kgPSB5MCAtIHkyO1xuICAgIGNvbnN0IGEgPSB1eCAqIHV4ICsgdXkgKiB1eTtcbiAgICBjb25zdCBiID0gdXggKiB2eCArIHV5ICogdnk7XG4gICAgY29uc3QgYyA9IHZ4ICogdnggKyB2eSAqIHZ5O1xuICAgIGNvbnN0IGQgPSB1eCAqIHd4ICsgdXkgKiB3eTtcbiAgICBjb25zdCBlID0gdnggKiB3eCArIHZ5ICogd3k7XG4gICAgY29uc3QgRCA9IGEgKiBjIC0gYiAqIGI7XG5cbiAgICBsZXQgc04sIHROO1xuICAgIGxldCBzRCA9IEQ7XG4gICAgbGV0IHREID0gRDtcblxuICAgIGlmIChEID09PSAwKSB7XG4gICAgICAgIHNOID0gMDtcbiAgICAgICAgc0QgPSAxO1xuICAgICAgICB0TiA9IGU7XG4gICAgICAgIHREID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgICBzTiA9IGIgKiBlIC0gYyAqIGQ7XG4gICAgICAgIHROID0gYSAqIGUgLSBiICogZDtcbiAgICAgICAgaWYgKHNOIDwgMCkge1xuICAgICAgICAgICAgc04gPSAwO1xuICAgICAgICAgICAgdE4gPSBlO1xuICAgICAgICAgICAgdEQgPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKHNOID4gc0QpIHtcbiAgICAgICAgICAgIHNOID0gc0Q7XG4gICAgICAgICAgICB0TiA9IGUgKyBiO1xuICAgICAgICAgICAgdEQgPSBjO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHROIDwgMC4wKSB7XG4gICAgICAgIHROID0gMC4wO1xuICAgICAgICBpZiAoLWQgPCAwLjApIHNOID0gMC4wO1xuICAgICAgICBlbHNlIGlmICgtZCA+IGEpIHNOID0gc0Q7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc04gPSAtZDtcbiAgICAgICAgICAgIHNEID0gYTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodE4gPiB0RCkge1xuICAgICAgICB0TiA9IHREO1xuICAgICAgICBpZiAoKC1kICsgYikgPCAwLjApIHNOID0gMDtcbiAgICAgICAgZWxzZSBpZiAoLWQgKyBiID4gYSkgc04gPSBzRDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzTiA9IC1kICsgYjtcbiAgICAgICAgICAgIHNEID0gYTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNjID0gc04gPT09IDAgPyAwIDogc04gLyBzRDtcbiAgICBjb25zdCB0YyA9IHROID09PSAwID8gMCA6IHROIC8gdEQ7XG5cbiAgICBjb25zdCBjeCA9ICgxIC0gc2MpICogeDAgKyBzYyAqIHgxO1xuICAgIGNvbnN0IGN5ID0gKDEgLSBzYykgKiB5MCArIHNjICogeTE7XG4gICAgY29uc3QgY3gyID0gKDEgLSB0YykgKiB4MiArIHRjICogeDM7XG4gICAgY29uc3QgY3kyID0gKDEgLSB0YykgKiB5MiArIHRjICogeTM7XG4gICAgY29uc3QgZHggPSBjeDIgLSBjeDtcbiAgICBjb25zdCBkeSA9IGN5MiAtIGN5O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuXG5mdW5jdGlvbiBjb21wYXJlQnlYKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSA9PT0gYlswXSA/IGFbMV0gLSBiWzFdIDogYVswXSAtIGJbMF07XG59XG5cbmZ1bmN0aW9uIGNvbnZleEh1bGwocG9pbnRzKSB7XG4gICAgcG9pbnRzLnNvcnQoY29tcGFyZUJ5WCk7XG5cbiAgICBjb25zdCBsb3dlciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdoaWxlIChsb3dlci5sZW5ndGggPj0gMiAmJiBjcm9zcyhsb3dlcltsb3dlci5sZW5ndGggLSAyXSwgbG93ZXJbbG93ZXIubGVuZ3RoIC0gMV0sIHBvaW50c1tpXSkgPD0gMCkge1xuICAgICAgICAgICAgbG93ZXIucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgbG93ZXIucHVzaChwb2ludHNbaV0pO1xuICAgIH1cblxuICAgIGNvbnN0IHVwcGVyID0gW107XG4gICAgZm9yIChsZXQgaWkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgICB3aGlsZSAodXBwZXIubGVuZ3RoID49IDIgJiYgY3Jvc3ModXBwZXJbdXBwZXIubGVuZ3RoIC0gMl0sIHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCBwb2ludHNbaWldKSA8PSAwKSB7XG4gICAgICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB1cHBlci5wdXNoKHBvaW50c1tpaV0pO1xuICAgIH1cblxuICAgIHVwcGVyLnBvcCgpO1xuICAgIGxvd2VyLnBvcCgpO1xuICAgIHJldHVybiBsb3dlci5jb25jYXQodXBwZXIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/concaveman/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/concaveman/node_modules/rbush/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/concaveman/node_modules/rbush/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RBush)\n/* harmony export */ });\n/* harmony import */ var quickselect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! quickselect */ \"(ssr)/./node_modules/quickselect/index.js\");\n\n\nclass RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        (0,quickselect__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29uY2F2ZW1hbi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBc0M7O0FBRXZCO0FBQ2Y7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsMEJBQTBCO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGtCQUFrQjtBQUNoQzs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjs7QUFFbkIsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEIsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLDJCQUEyQixZQUFZOztBQUV2Qzs7QUFFQTs7QUFFQSw0QkFBNEIsYUFBYTs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDLGlDQUFpQzs7QUFFakMseUJBQXlCO0FBQ3pCLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxRQUFRLHVEQUFXOztBQUVuQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWRiYXNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL2NvbmNhdmVtYW4vbm9kZV9tb2R1bGVzL3JidXNoL2luZGV4LmpzPzY1YjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHF1aWNrc2VsZWN0IGZyb20gJ3F1aWNrc2VsZWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUkJ1c2gge1xuICAgIGNvbnN0cnVjdG9yKG1heEVudHJpZXMgPSA5KSB7XG4gICAgICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzKTtcbiAgICAgICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGwodGhpcy5kYXRhLCBbXSk7XG4gICAgfVxuXG4gICAgc2VhcmNoKGJib3gpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjb25zdCB0b0JCb3ggPSB0aGlzLnRvQkJveDtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1NlYXJjaCA9IFtdO1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBjb2xsaWRlcyhiYm94KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5kYXRhO1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEJCb3ggPSBub2RlLmxlYWYgPyB0aGlzLnRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBsb2FkKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc2NyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgICAgIGxldCBub2RlID0gdGhpcy5fYnVpbGQoZGF0YS5zbGljZSgpLCAwLCBkYXRhLmxlbmd0aCAtIDEsIDApO1xuXG4gICAgICAgIGlmICghdGhpcy5kYXRhLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc2F2ZSBhcyBpcyBpZiB0cmVlIGlzIGVtcHR5XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmhlaWdodCA9PT0gbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIC8vIHNwbGl0IHJvb3QgaWYgdHJlZXMgaGF2ZSB0aGUgc2FtZSBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuX3NwbGl0Um9vdCh0aGlzLmRhdGEsIG5vZGUpO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhLmhlaWdodCA8IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gc3dhcCB0cmVlcyBpZiBpbnNlcnRlZCBvbmUgaXMgYmlnZ2VyXG4gICAgICAgICAgICAgICAgY29uc3QgdG1wTm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaW5zZXJ0KGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHRoaXMuX2luc2VydChpdGVtLCB0aGlzLmRhdGEuaGVpZ2h0IC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGl0ZW0sIGVxdWFsc0ZuKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmRhdGE7XG4gICAgICAgIGNvbnN0IGJib3ggPSB0aGlzLnRvQkJveChpdGVtKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IFtdO1xuICAgICAgICBjb25zdCBpbmRleGVzID0gW107XG4gICAgICAgIGxldCBpLCBwYXJlbnQsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRvQkJveChpdGVtKSB7IHJldHVybiBpdGVtOyB9XG5cbiAgICBjb21wYXJlTWluWChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cbiAgICBjb21wYXJlTWluWShhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cblxuICAgIHRvSlNPTigpIHsgcmV0dXJuIHRoaXMuZGF0YTsgfVxuXG4gICAgZnJvbUpTT04oZGF0YSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfYWxsKG5vZGUsIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaCguLi5ub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKC4uLm5vZGUuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIF9idWlsZChpdGVtcywgbGVmdCwgcmlnaHQsIGhlaWdodCkge1xuXG4gICAgICAgIGNvbnN0IE4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICBsZXQgTSA9IHRoaXMuX21heEVudHJpZXM7XG4gICAgICAgIGxldCBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICBjb25zdCBOMiA9IE1hdGguY2VpbChOIC8gTSk7XG4gICAgICAgIGNvbnN0IE4xID0gTjIgKiBNYXRoLmNlaWwoTWF0aC5zcXJ0KE0pKTtcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICBjb25zdCByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPD0gcmlnaHQyOyBqICs9IE4yKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCByaWdodDMgPSBNYXRoLm1pbihqICsgTjIgLSAxLCByaWdodDIpO1xuXG4gICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2J1aWxkKGl0ZW1zLCBqLCByaWdodDMsIGhlaWdodCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG5cbiAgICBfY2hvb3NlU3VidHJlZShiYm94LCBub2RlLCBsZXZlbCwgcGF0aCkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBsZXQgbWluQXJlYSA9IEluZmluaXR5O1xuICAgICAgICAgICAgbGV0IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0Tm9kZTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBiYm94QXJlYShjaGlsZCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIF9pbnNlcnQoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuICAgICAgICBjb25zdCBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRoaXMudG9CQm94KGl0ZW0pO1xuICAgICAgICBjb25zdCBpbnNlcnRQYXRoID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH1cblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCkge1xuICAgICAgICBjb25zdCBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF07XG4gICAgICAgIGNvbnN0IE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX21pbkVudHJpZXM7XG5cbiAgICAgICAgdGhpcy5fY2hvb3NlU3BsaXRBeGlzKG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIGNvbnN0IHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIGNvbnN0IG5ld05vZGUgPSBjcmVhdGVOb2RlKG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCkpO1xuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfVxuXG4gICAgX3NwbGl0Um9vdChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuZGF0YS5sZWFmID0gZmFsc2U7XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH1cblxuICAgIF9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pIHtcbiAgICAgICAgbGV0IGluZGV4O1xuICAgICAgICBsZXQgbWluT3ZlcmxhcCA9IEluZmluaXR5O1xuICAgICAgICBsZXQgbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgY29uc3QgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgICAgICBjb25zdCBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXggfHwgTSAtIG07XG4gICAgfVxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSkge1xuICAgICAgICBjb25zdCBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblg7XG4gICAgICAgIGNvbnN0IGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWTtcbiAgICAgICAgY29uc3QgeE1hcmdpbiA9IHRoaXMuX2FsbERpc3RNYXJnaW4obm9kZSwgbSwgTSwgY29tcGFyZU1pblgpO1xuICAgICAgICBjb25zdCB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcbiAgICB9XG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIGNvbnN0IHRvQkJveCA9IHRoaXMudG9CQm94O1xuICAgICAgICBjb25zdCBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0QkJveCA9IGRpc3RCQm94KG5vZGUsIE0gLSBtLCBNLCB0b0JCb3gpO1xuICAgICAgICBsZXQgbWFyZ2luID0gYmJveE1hcmdpbihsZWZ0QkJveCkgKyBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQobGVmdEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpID0gTSAtIG0gLSAxOyBpID49IG07IGktLSkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgZXh0ZW5kKHJpZ2h0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKHJpZ2h0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWFyZ2luO1xuICAgIH1cblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgcGF0aCwgbGV2ZWwpIHtcbiAgICAgICAgLy8gYWRqdXN0IGJib3hlcyBhbG9uZyB0aGUgZ2l2ZW4gdHJlZSBwYXRoXG4gICAgICAgIGZvciAobGV0IGkgPSBsZXZlbDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGV4dGVuZChwYXRoW2ldLCBiYm94KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9jb25kZW5zZShwYXRoKSB7XG4gICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIHBhdGgsIHJlbW92aW5nIGVtcHR5IG5vZGVzIGFuZCB1cGRhdGluZyBiYm94ZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMSwgc2libGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpXS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3MgPSBwYXRoW2kgLSAxXS5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICAgICAgc2libGluZ3Muc3BsaWNlKHNpYmxpbmdzLmluZGV4T2YocGF0aFtpXSksIDEpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHRoaXMuY2xlYXIoKTtcblxuICAgICAgICAgICAgfSBlbHNlIGNhbGNCQm94KHBhdGhbaV0sIHRoaXMudG9CQm94KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZmluZEl0ZW0oaXRlbSwgaXRlbXMsIGVxdWFsc0ZuKSB7XG4gICAgaWYgKCFlcXVhbHNGbikgcmV0dXJuIGl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gsIG5vZGUpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94LCBkZXN0Tm9kZSkge1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTtcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFggPSAtSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAobGV0IGkgPSBrOyBpIDwgcDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgZXh0ZW5kKGRlc3ROb2RlLCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiBkZXN0Tm9kZTtcbn1cblxuZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICBhLm1pblggPSBNYXRoLm1pbihhLm1pblgsIGIubWluWCk7XG4gICAgYS5taW5ZID0gTWF0aC5taW4oYS5taW5ZLCBiLm1pblkpO1xuICAgIGEubWF4WCA9IE1hdGgubWF4KGEubWF4WCwgYi5tYXhYKTtcbiAgICBhLm1heFkgPSBNYXRoLm1heChhLm1heFksIGIubWF4WSk7XG4gICAgcmV0dXJuIGE7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWChhLCBiKSB7IHJldHVybiBhLm1pblggLSBiLm1pblg7IH1cbmZ1bmN0aW9uIGNvbXBhcmVOb2RlTWluWShhLCBiKSB7IHJldHVybiBhLm1pblkgLSBiLm1pblk7IH1cblxuZnVuY3Rpb24gYmJveEFyZWEoYSkgICB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSAqIChhLm1heFkgLSBhLm1pblkpOyB9XG5mdW5jdGlvbiBiYm94TWFyZ2luKGEpIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICsgKGEubWF4WSAtIGEubWluWSk7IH1cblxuZnVuY3Rpb24gZW5sYXJnZWRBcmVhKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgubWF4KGIubWF4WCwgYS5tYXhYKSAtIE1hdGgubWluKGIubWluWCwgYS5taW5YKSkgKlxuICAgICAgICAgICAoTWF0aC5tYXgoYi5tYXhZLCBhLm1heFkpIC0gTWF0aC5taW4oYi5taW5ZLCBhLm1pblkpKTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uQXJlYShhLCBiKSB7XG4gICAgY29uc3QgbWluWCA9IE1hdGgubWF4KGEubWluWCwgYi5taW5YKTtcbiAgICBjb25zdCBtaW5ZID0gTWF0aC5tYXgoYS5taW5ZLCBiLm1pblkpO1xuICAgIGNvbnN0IG1heFggPSBNYXRoLm1pbihhLm1heFgsIGIubWF4WCk7XG4gICAgY29uc3QgbWF4WSA9IE1hdGgubWluKGEubWF4WSwgYi5tYXhZKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5taW5YIDw9IGIubWluWCAmJlxuICAgICAgICAgICBhLm1pblkgPD0gYi5taW5ZICYmXG4gICAgICAgICAgIGIubWF4WCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5tYXhZIDw9IGEubWF4WTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGIubWluWCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5taW5ZIDw9IGEubWF4WSAmJlxuICAgICAgICAgICBiLm1heFggPj0gYS5taW5YICYmXG4gICAgICAgICAgIGIubWF4WSA+PSBhLm1pblk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICBtaW5YOiBJbmZpbml0eSxcbiAgICAgICAgbWluWTogSW5maW5pdHksXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WTogLUluZmluaXR5XG4gICAgfTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIGNvbnN0IHN0YWNrID0gW2xlZnQsIHJpZ2h0XTtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgY29uc3QgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/concaveman/node_modules/rbush/index.js\n");

/***/ })

};
;