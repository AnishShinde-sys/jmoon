"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/turf-jsts";
exports.ids = ["vendor-chunks/turf-jsts"];
exports.modules = {

/***/ "(ssr)/./node_modules/turf-jsts/jsts.mjs":
/*!*****************************************!*\
  !*** ./node_modules/turf-jsts/jsts.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferOp: () => (/* binding */ BufferOp),\n/* harmony export */   GeoJSONReader: () => (/* binding */ GeoJSONReader),\n/* harmony export */   GeoJSONWriter: () => (/* binding */ GeoJSONWriter),\n/* harmony export */   OverlayOp: () => (/* binding */ OverlayOp),\n/* harmony export */   UnionOp: () => (/* binding */ UnionOp)\n/* harmony export */ });\n/* Polyfill service v3.13.0\n * For detailed credits and licence information see http://github.com/financial-times/polyfill-service\n *\n * - Array.prototype.fill, License: CC0 */\n\nif (!('fill' in Array.prototype)) {\n  Object.defineProperty(Array.prototype, 'fill', {\n    configurable: true,\n    value: function fill (value) {\n      if (this === undefined || this === null) {\n        throw new TypeError(this + ' is not an object')\n      }\n\n      var arrayLike = Object(this);\n\n      var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;\n\n      var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;\n\n      relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);\n\n      var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;\n\n      relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);\n\n      while (relativeStart < relativeEnd) {\n        arrayLike[relativeStart] = value;\n\n        ++relativeStart;\n      }\n\n      return arrayLike\n    },\n    writable: true\n  });\n}\n\n/**\n * Polyfill for IE support\n */\nNumber.isFinite = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value)\n};\n\nNumber.isInteger = Number.isInteger || function (val) {\n  return typeof val === 'number' &&\n  isFinite(val) &&\n  Math.floor(val) === val\n};\n\nNumber.parseFloat = Number.parseFloat || parseFloat;\n\nNumber.isNaN = Number.isNaN || function (value) {\n  return value !== value // eslint-disable-line\n};\n\n/**\n * Polyfill for IE support\n */\nMath.trunc = Math.trunc || function (x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x)\n};\n\nvar NumberUtil = function NumberUtil () {};\n\nNumberUtil.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNumberUtil.prototype.getClass = function getClass () {\n  return NumberUtil\n};\nNumberUtil.prototype.equalsWithTolerance = function equalsWithTolerance (x1, x2, tolerance) {\n  return Math.abs(x1 - x2) <= tolerance\n};\n\nvar IllegalArgumentException = (function (Error) {\n\tfunction IllegalArgumentException (message) {\n\t\tError.call(this, message);\n\t\tthis.name = 'IllegalArgumentException';\n\t\tthis.message = message;\n\t\tthis.stack = (new Error()).stack;\n\t}\n\n\tif ( Error ) IllegalArgumentException.__proto__ = Error;\n\tIllegalArgumentException.prototype = Object.create( Error && Error.prototype );\n\tIllegalArgumentException.prototype.constructor = IllegalArgumentException;\n\n\treturn IllegalArgumentException;\n}(Error));\n\nvar Double = function Double () {};\n\nvar staticAccessors$1 = { MAX_VALUE: { configurable: true } };\n\nDouble.isNaN = function isNaN (n) { return Number.isNaN(n) };\nDouble.doubleToLongBits = function doubleToLongBits (n) { return n };\nDouble.longBitsToDouble = function longBitsToDouble (n) { return n };\nDouble.isInfinite = function isInfinite (n) { return !Number.isFinite(n) };\nstaticAccessors$1.MAX_VALUE.get = function () { return Number.MAX_VALUE };\n\nObject.defineProperties( Double, staticAccessors$1 );\n\nvar Comparable = function Comparable () {};\n\nvar Clonable = function Clonable () {};\n\nvar Comparator = function Comparator () {};\n\nfunction Serializable () {}\n\n// import Assert from '../util/Assert'\n\nvar Coordinate = function Coordinate () {\n  this.x = null;\n  this.y = null;\n  this.z = null;\n  if (arguments.length === 0) {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.z = Coordinate.NULL_ORDINATE;\n  } else if (arguments.length === 1) {\n    var c = arguments[0];\n    this.x = c.x;\n    this.y = c.y;\n    this.z = c.z;\n  } else if (arguments.length === 2) {\n    this.x = arguments[0];\n    this.y = arguments[1];\n    this.z = Coordinate.NULL_ORDINATE;\n  } else if (arguments.length === 3) {\n    this.x = arguments[0];\n    this.y = arguments[1];\n    this.z = arguments[2];\n  }\n};\n\nvar staticAccessors = { DimensionalComparator: { configurable: true },serialVersionUID: { configurable: true },NULL_ORDINATE: { configurable: true },X: { configurable: true },Y: { configurable: true },Z: { configurable: true } };\nCoordinate.prototype.setOrdinate = function setOrdinate (ordinateIndex, value) {\n  switch (ordinateIndex) {\n    case Coordinate.X:\n      this.x = value;\n      break\n    case Coordinate.Y:\n      this.y = value;\n      break\n    case Coordinate.Z:\n      this.z = value;\n      break\n    default:\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n  }\n};\nCoordinate.prototype.equals2D = function equals2D () {\n  if (arguments.length === 1) {\n    var other = arguments[0];\n    if (this.x !== other.x) {\n      return false\n    }\n    if (this.y !== other.y) {\n      return false\n    }\n    return true\n  } else if (arguments.length === 2) {\n    var c = arguments[0];\n    var tolerance = arguments[1];\n    if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n      return false\n    }\n    if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n      return false\n    }\n    return true\n  }\n};\nCoordinate.prototype.getOrdinate = function getOrdinate (ordinateIndex) {\n  switch (ordinateIndex) {\n    case Coordinate.X:\n      return this.x\n    case Coordinate.Y:\n      return this.y\n    case Coordinate.Z:\n      return this.z\n    default:\n  }\n  throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n};\nCoordinate.prototype.equals3D = function equals3D (other) {\n  return this.x === other.x &&\n         this.y === other.y &&\n         ((this.z === other.z || Double.isNaN(this.z)) &&\n         Double.isNaN(other.z))\n};\nCoordinate.prototype.equals = function equals (other) {\n  if (!(other instanceof Coordinate)) {\n    return false\n  }\n  return this.equals2D(other)\n};\nCoordinate.prototype.equalInZ = function equalInZ (c, tolerance) {\n  return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance)\n};\nCoordinate.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  if (this.x < other.x) { return -1 }\n  if (this.x > other.x) { return 1 }\n  if (this.y < other.y) { return -1 }\n  if (this.y > other.y) { return 1 }\n  return 0\n};\nCoordinate.prototype.clone = function clone () {\n  // try {\n  // var coord = null\n  // return coord\n  // } catch (e) {\n  // if (e instanceof CloneNotSupportedException) {\n  //   Assert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\")\n  //   return null\n  // } else throw e\n  // } finally {}\n};\nCoordinate.prototype.copy = function copy () {\n  return new Coordinate(this)\n};\nCoordinate.prototype.toString = function toString () {\n  return '(' + this.x + ', ' + this.y + ', ' + this.z + ')'\n};\nCoordinate.prototype.distance3D = function distance3D (c) {\n  var dx = this.x - c.x;\n  var dy = this.y - c.y;\n  var dz = this.z - c.z;\n  return Math.sqrt(dx * dx + dy * dy + dz * dz)\n};\nCoordinate.prototype.distance = function distance (c) {\n  var dx = this.x - c.x;\n  var dy = this.y - c.y;\n  return Math.sqrt(dx * dx + dy * dy)\n};\nCoordinate.prototype.hashCode = function hashCode () {\n  var result = 17;\n  result = 37 * result + Coordinate.hashCode(this.x);\n  result = 37 * result + Coordinate.hashCode(this.y);\n  return result\n};\nCoordinate.prototype.setCoordinate = function setCoordinate (other) {\n  this.x = other.x;\n  this.y = other.y;\n  this.z = other.z;\n};\nCoordinate.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable, Clonable, Serializable]\n};\nCoordinate.prototype.getClass = function getClass () {\n  return Coordinate\n};\nCoordinate.hashCode = function hashCode () {\n  if (arguments.length === 1) {\n    var x = arguments[0];\n    var f = Double.doubleToLongBits(x);\n    return Math.trunc((f ^ f) >>> 32)\n  }\n};\nstaticAccessors.DimensionalComparator.get = function () { return DimensionalComparator };\nstaticAccessors.serialVersionUID.get = function () { return 6683108902428366910 };\nstaticAccessors.NULL_ORDINATE.get = function () { return Double.NaN };\nstaticAccessors.X.get = function () { return 0 };\nstaticAccessors.Y.get = function () { return 1 };\nstaticAccessors.Z.get = function () { return 2 };\n\nObject.defineProperties( Coordinate, staticAccessors );\n\nvar DimensionalComparator = function DimensionalComparator (dimensionsToTest) {\n  this._dimensionsToTest = 2;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var dimensionsToTest$1 = arguments[0];\n    if (dimensionsToTest$1 !== 2 && dimensionsToTest$1 !== 3) { throw new IllegalArgumentException('only 2 or 3 dimensions may be specified') }\n    this._dimensionsToTest = dimensionsToTest$1;\n  }\n};\nDimensionalComparator.prototype.compare = function compare (o1, o2) {\n  var c1 = o1;\n  var c2 = o2;\n  var compX = DimensionalComparator.compare(c1.x, c2.x);\n  if (compX !== 0) { return compX }\n  var compY = DimensionalComparator.compare(c1.y, c2.y);\n  if (compY !== 0) { return compY }\n  if (this._dimensionsToTest <= 2) { return 0 }\n  var compZ = DimensionalComparator.compare(c1.z, c2.z);\n  return compZ\n};\nDimensionalComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nDimensionalComparator.prototype.getClass = function getClass () {\n  return DimensionalComparator\n};\nDimensionalComparator.compare = function compare (a, b) {\n  if (a < b) { return -1 }\n  if (a > b) { return 1 }\n  if (Double.isNaN(a)) {\n    if (Double.isNaN(b)) { return 0 }\n    return -1\n  }\n  if (Double.isNaN(b)) { return 1 }\n  return 0\n};\n\n// import hasInterface from '../../../../hasInterface'\n// import CoordinateSequence from './CoordinateSequence'\n\nvar CoordinateSequenceFactory = function CoordinateSequenceFactory () {};\n\nCoordinateSequenceFactory.prototype.create = function create () {\n  // if (arguments.length === 1) {\n  // if (arguments[0] instanceof Array) {\n  //   let coordinates = arguments[0]\n  // } else if (hasInterface(arguments[0], CoordinateSequence)) {\n  //   let coordSeq = arguments[0]\n  // }\n  // } else if (arguments.length === 2) {\n  // let size = arguments[0]\n  // let dimension = arguments[1]\n  // }\n};\nCoordinateSequenceFactory.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateSequenceFactory.prototype.getClass = function getClass () {\n  return CoordinateSequenceFactory\n};\n\nvar Location = function Location () {};\n\nvar staticAccessors$4 = { INTERIOR: { configurable: true },BOUNDARY: { configurable: true },EXTERIOR: { configurable: true },NONE: { configurable: true } };\n\nLocation.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLocation.prototype.getClass = function getClass () {\n  return Location\n};\nLocation.toLocationSymbol = function toLocationSymbol (locationValue) {\n  switch (locationValue) {\n    case Location.EXTERIOR:\n      return 'e'\n    case Location.BOUNDARY:\n      return 'b'\n    case Location.INTERIOR:\n      return 'i'\n    case Location.NONE:\n      return '-'\n    default:\n  }\n  throw new IllegalArgumentException('Unknown location value: ' + locationValue)\n};\nstaticAccessors$4.INTERIOR.get = function () { return 0 };\nstaticAccessors$4.BOUNDARY.get = function () { return 1 };\nstaticAccessors$4.EXTERIOR.get = function () { return 2 };\nstaticAccessors$4.NONE.get = function () { return -1 };\n\nObject.defineProperties( Location, staticAccessors$4 );\n\nvar hasInterface = function (o, i) {\n  return o.interfaces_ && o.interfaces_().indexOf(i) > -1\n};\n\nvar MathUtil = function MathUtil () {};\n\nvar staticAccessors$5 = { LOG_10: { configurable: true } };\n\nMathUtil.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMathUtil.prototype.getClass = function getClass () {\n  return MathUtil\n};\nMathUtil.log10 = function log10 (x) {\n  var ln = Math.log(x);\n  if (Double.isInfinite(ln)) { return ln }\n  if (Double.isNaN(ln)) { return ln }\n  return ln / MathUtil.LOG_10\n};\nMathUtil.min = function min (v1, v2, v3, v4) {\n  var min = v1;\n  if (v2 < min) { min = v2; }\n  if (v3 < min) { min = v3; }\n  if (v4 < min) { min = v4; }\n  return min\n};\nMathUtil.clamp = function clamp () {\n  if (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number')) {\n    var x = arguments[0];\n    var min = arguments[1];\n    var max = arguments[2];\n    if (x < min) { return min }\n    if (x > max) { return max }\n    return x\n  } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {\n    var x$1 = arguments[0];\n    var min$1 = arguments[1];\n    var max$1 = arguments[2];\n    if (x$1 < min$1) { return min$1 }\n    if (x$1 > max$1) { return max$1 }\n    return x$1\n  }\n};\nMathUtil.wrap = function wrap (index, max) {\n  if (index < 0) {\n    return max - -index % max\n  }\n  return index % max\n};\nMathUtil.max = function max () {\n  if (arguments.length === 3) {\n    var v1 = arguments[0];\n    var v2 = arguments[1];\n    var v3 = arguments[2];\n    var max = v1;\n    if (v2 > max) { max = v2; }\n    if (v3 > max) { max = v3; }\n    return max\n  } else if (arguments.length === 4) {\n    var v1$1 = arguments[0];\n    var v2$1 = arguments[1];\n    var v3$1 = arguments[2];\n    var v4 = arguments[3];\n    var max$1 = v1$1;\n    if (v2$1 > max$1) { max$1 = v2$1; }\n    if (v3$1 > max$1) { max$1 = v3$1; }\n    if (v4 > max$1) { max$1 = v4; }\n    return max$1\n  }\n};\nMathUtil.average = function average (x1, x2) {\n  return (x1 + x2) / 2.0\n};\nstaticAccessors$5.LOG_10.get = function () { return Math.log(10) };\n\nObject.defineProperties( MathUtil, staticAccessors$5 );\n\nvar StringBuffer = function StringBuffer (str) {\n  this.str = str;\n};\nStringBuffer.prototype.append = function append (e) {\n  this.str += e;\n};\n\nStringBuffer.prototype.setCharAt = function setCharAt (i, c) {\n  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n};\n\nStringBuffer.prototype.toString = function toString (e) {\n  return this.str\n};\n\nvar Integer = function Integer (value) {\n  this.value = value;\n};\nInteger.prototype.intValue = function intValue () {\n  return this.value\n};\nInteger.prototype.compareTo = function compareTo (o) {\n  if (this.value < o) { return -1 }\n  if (this.value > o) { return 1 }\n  return 0\n};\nInteger.isNaN = function isNaN (n) { return Number.isNaN(n) };\n\nvar Character = function Character () {};\n\nCharacter.isWhitespace = function isWhitespace (c) { return ((c <= 32 && c >= 0) || c === 127) };\nCharacter.toUpperCase = function toUpperCase (c) { return c.toUpperCase() };\n\nvar DD = function DD () {\n  this._hi = 0.0;\n  this._lo = 0.0;\n  if (arguments.length === 0) {\n    this.init(0.0);\n  } else if (arguments.length === 1) {\n    if (typeof arguments[0] === 'number') {\n      var x = arguments[0];\n      this.init(x);\n    } else if (arguments[0] instanceof DD) {\n      var dd = arguments[0];\n      this.init(dd);\n    } else if (typeof arguments[0] === 'string') {\n      var str = arguments[0];\n      DD.call(this, DD.parse(str));\n    }\n  } else if (arguments.length === 2) {\n    var hi = arguments[0];\n    var lo = arguments[1];\n    this.init(hi, lo);\n  }\n};\n\nvar staticAccessors$7 = { PI: { configurable: true },TWO_PI: { configurable: true },PI_2: { configurable: true },E: { configurable: true },NaN: { configurable: true },EPS: { configurable: true },SPLIT: { configurable: true },MAX_PRINT_DIGITS: { configurable: true },TEN: { configurable: true },ONE: { configurable: true },SCI_NOT_EXPONENT_CHAR: { configurable: true },SCI_NOT_ZERO: { configurable: true } };\nDD.prototype.le = function le (y) {\n  return (this._hi < y._hi || this._hi === y._hi) && this._lo <= y._lo\n};\nDD.prototype.extractSignificantDigits = function extractSignificantDigits (insertDecimalPoint, magnitude) {\n  var y = this.abs();\n  var mag = DD.magnitude(y._hi);\n  var scale = DD.TEN.pow(mag);\n  y = y.divide(scale);\n  if (y.gt(DD.TEN)) {\n    y = y.divide(DD.TEN);\n    mag += 1;\n  } else if (y.lt(DD.ONE)) {\n    y = y.multiply(DD.TEN);\n    mag -= 1;\n  }\n  var decimalPointPos = mag + 1;\n  var buf = new StringBuffer();\n  var numDigits = DD.MAX_PRINT_DIGITS - 1;\n  for (var i = 0; i <= numDigits; i++) {\n    if (insertDecimalPoint && i === decimalPointPos) {\n      buf.append('.');\n    }\n    var digit = Math.trunc(y._hi);\n    if (digit < 0) {\n      break\n    }\n    var rebiasBy10 = false;\n    var digitChar = 0;\n    if (digit > 9) {\n      rebiasBy10 = true;\n      digitChar = '9';\n    } else {\n      digitChar = '0' + digit;\n    }\n    buf.append(digitChar);\n    y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n    if (rebiasBy10) { y.selfAdd(DD.TEN); }\n    var continueExtractingDigits = true;\n    var remMag = DD.magnitude(y._hi);\n    if (remMag < 0 && Math.abs(remMag) >= numDigits - i) { continueExtractingDigits = false; }\n    if (!continueExtractingDigits) { break }\n  }\n  magnitude[0] = mag;\n  return buf.toString()\n};\nDD.prototype.sqr = function sqr () {\n  return this.multiply(this)\n};\nDD.prototype.doubleValue = function doubleValue () {\n  return this._hi + this._lo\n};\nDD.prototype.subtract = function subtract () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    return this.add(y.negate())\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    return this.add(-y$1)\n  }\n};\nDD.prototype.equals = function equals () {\n  if (arguments.length === 1) {\n    var y = arguments[0];\n    return this._hi === y._hi && this._lo === y._lo\n  }\n};\nDD.prototype.isZero = function isZero () {\n  return this._hi === 0.0 && this._lo === 0.0\n};\nDD.prototype.selfSubtract = function selfSubtract () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    if (this.isNaN()) { return this }\n    return this.selfAdd(-y._hi, -y._lo)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    if (this.isNaN()) { return this }\n    return this.selfAdd(-y$1, 0.0)\n  }\n};\nDD.prototype.getSpecialNumberString = function getSpecialNumberString () {\n  if (this.isZero()) { return '0.0' }\n  if (this.isNaN()) { return 'NaN ' }\n  return null\n};\nDD.prototype.min = function min (x) {\n  if (this.le(x)) {\n    return this\n  } else {\n    return x\n  }\n};\nDD.prototype.selfDivide = function selfDivide () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof DD) {\n      var y = arguments[0];\n      return this.selfDivide(y._hi, y._lo)\n    } else if (typeof arguments[0] === 'number') {\n      var y$1 = arguments[0];\n      return this.selfDivide(y$1, 0.0)\n    }\n  } else if (arguments.length === 2) {\n    var yhi = arguments[0];\n    var ylo = arguments[1];\n    var hc = null;\n    var tc = null;\n    var hy = null;\n    var ty = null;\n    var C = null;\n    var c = null;\n    var U = null;\n    var u = null;\n    C = this._hi / yhi;\n    c = DD.SPLIT * C;\n    hc = c - C;\n    u = DD.SPLIT * yhi;\n    hc = c - hc;\n    tc = C - hc;\n    hy = u - yhi;\n    U = C * yhi;\n    hy = u - hy;\n    ty = yhi - hy;\n    u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n    c = (this._hi - U - u + this._lo - C * ylo) / yhi;\n    u = C + c;\n    this._hi = u;\n    this._lo = C - u + c;\n    return this\n  }\n};\nDD.prototype.dump = function dump () {\n  return 'DD<' + this._hi + ', ' + this._lo + '>'\n};\nDD.prototype.divide = function divide () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    var hc = null;\n    var tc = null;\n    var hy = null;\n    var ty = null;\n    var C = null;\n    var c = null;\n    var U = null;\n    var u = null;\n    C = this._hi / y._hi;\n    c = DD.SPLIT * C;\n    hc = c - C;\n    u = DD.SPLIT * y._hi;\n    hc = c - hc;\n    tc = C - hc;\n    hy = u - y._hi;\n    U = C * y._hi;\n    hy = u - hy;\n    ty = y._hi - hy;\n    u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n    c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n    u = C + c;\n    var zhi = u;\n    var zlo = C - u + c;\n    return new DD(zhi, zlo)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    if (Double.isNaN(y$1)) { return DD.createNaN() }\n    return DD.copy(this).selfDivide(y$1, 0.0)\n  }\n};\nDD.prototype.ge = function ge (y) {\n  return (this._hi > y._hi || this._hi === y._hi) && this._lo >= y._lo\n};\nDD.prototype.pow = function pow (exp) {\n  if (exp === 0.0) { return DD.valueOf(1.0) }\n  var r = new DD(this);\n  var s = DD.valueOf(1.0);\n  var n = Math.abs(exp);\n  if (n > 1) {\n    while (n > 0) {\n      if (n % 2 === 1) {\n        s.selfMultiply(r);\n      }\n      n /= 2;\n      if (n > 0) { r = r.sqr(); }\n    }\n  } else {\n    s = r;\n  }\n  if (exp < 0) { return s.reciprocal() }\n  return s\n};\nDD.prototype.ceil = function ceil () {\n  if (this.isNaN()) { return DD.NaN }\n  var fhi = Math.ceil(this._hi);\n  var flo = 0.0;\n  if (fhi === this._hi) {\n    flo = Math.ceil(this._lo);\n  }\n  return new DD(fhi, flo)\n};\nDD.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  if (this._hi < other._hi) { return -1 }\n  if (this._hi > other._hi) { return 1 }\n  if (this._lo < other._lo) { return -1 }\n  if (this._lo > other._lo) { return 1 }\n  return 0\n};\nDD.prototype.rint = function rint () {\n  if (this.isNaN()) { return this }\n  var plus5 = this.add(0.5);\n  return plus5.floor()\n};\nDD.prototype.setValue = function setValue () {\n  if (arguments[0] instanceof DD) {\n    var value = arguments[0];\n    this.init(value);\n    return this\n  } else if (typeof arguments[0] === 'number') {\n    var value$1 = arguments[0];\n    this.init(value$1);\n    return this\n  }\n};\nDD.prototype.max = function max (x) {\n  if (this.ge(x)) {\n    return this\n  } else {\n    return x\n  }\n};\nDD.prototype.sqrt = function sqrt () {\n  if (this.isZero()) { return DD.valueOf(0.0) }\n  if (this.isNegative()) {\n    return DD.NaN\n  }\n  var x = 1.0 / Math.sqrt(this._hi);\n  var ax = this._hi * x;\n  var axdd = DD.valueOf(ax);\n  var diffSq = this.subtract(axdd.sqr());\n  var d2 = diffSq._hi * (x * 0.5);\n  return axdd.add(d2)\n};\nDD.prototype.selfAdd = function selfAdd () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof DD) {\n      var y = arguments[0];\n      return this.selfAdd(y._hi, y._lo)\n    } else if (typeof arguments[0] === 'number') {\n      var y$1 = arguments[0];\n      var H = null;\n      var h = null;\n      var S = null;\n      var s = null;\n      var e = null;\n      var f = null;\n      S = this._hi + y$1;\n      e = S - this._hi;\n      s = S - e;\n      s = y$1 - e + (this._hi - s);\n      f = s + this._lo;\n      H = S + f;\n      h = f + (S - H);\n      this._hi = H + h;\n      this._lo = h + (H - this._hi);\n      return this\n    }\n  } else if (arguments.length === 2) {\n    var yhi = arguments[0];\n    var ylo = arguments[1];\n    var H$1 = null;\n    var h$1 = null;\n    var T = null;\n    var t = null;\n    var S$1 = null;\n    var s$1 = null;\n    var e$1 = null;\n    var f$1 = null;\n    S$1 = this._hi + yhi;\n    T = this._lo + ylo;\n    e$1 = S$1 - this._hi;\n    f$1 = T - this._lo;\n    s$1 = S$1 - e$1;\n    t = T - f$1;\n    s$1 = yhi - e$1 + (this._hi - s$1);\n    t = ylo - f$1 + (this._lo - t);\n    e$1 = s$1 + T;\n    H$1 = S$1 + e$1;\n    h$1 = e$1 + (S$1 - H$1);\n    e$1 = t + h$1;\n    var zhi = H$1 + e$1;\n    var zlo = e$1 + (H$1 - zhi);\n    this._hi = zhi;\n    this._lo = zlo;\n    return this\n  }\n};\nDD.prototype.selfMultiply = function selfMultiply () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof DD) {\n      var y = arguments[0];\n      return this.selfMultiply(y._hi, y._lo)\n    } else if (typeof arguments[0] === 'number') {\n      var y$1 = arguments[0];\n      return this.selfMultiply(y$1, 0.0)\n    }\n  } else if (arguments.length === 2) {\n    var yhi = arguments[0];\n    var ylo = arguments[1];\n    var hx = null;\n    var tx = null;\n    var hy = null;\n    var ty = null;\n    var C = null;\n    var c = null;\n    C = DD.SPLIT * this._hi;\n    hx = C - this._hi;\n    c = DD.SPLIT * yhi;\n    hx = C - hx;\n    tx = this._hi - hx;\n    hy = c - yhi;\n    C = this._hi * yhi;\n    hy = c - hy;\n    ty = yhi - hy;\n    c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n    var zhi = C + c;\n    hx = C - zhi;\n    var zlo = c + hx;\n    this._hi = zhi;\n    this._lo = zlo;\n    return this\n  }\n};\nDD.prototype.selfSqr = function selfSqr () {\n  return this.selfMultiply(this)\n};\nDD.prototype.floor = function floor () {\n  if (this.isNaN()) { return DD.NaN }\n  var fhi = Math.floor(this._hi);\n  var flo = 0.0;\n  if (fhi === this._hi) {\n    flo = Math.floor(this._lo);\n  }\n  return new DD(fhi, flo)\n};\nDD.prototype.negate = function negate () {\n  if (this.isNaN()) { return this }\n  return new DD(-this._hi, -this._lo)\n};\nDD.prototype.clone = function clone () {\n  // try {\n  // return null\n  // } catch (ex) {\n  // if (ex instanceof CloneNotSupportedException) {\n  //   return null\n  // } else throw ex\n  // } finally {}\n};\nDD.prototype.multiply = function multiply () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    if (y.isNaN()) { return DD.createNaN() }\n    return DD.copy(this).selfMultiply(y)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    if (Double.isNaN(y$1)) { return DD.createNaN() }\n    return DD.copy(this).selfMultiply(y$1, 0.0)\n  }\n};\nDD.prototype.isNaN = function isNaN () {\n  return Double.isNaN(this._hi)\n};\nDD.prototype.intValue = function intValue () {\n  return Math.trunc(this._hi)\n};\nDD.prototype.toString = function toString () {\n  var mag = DD.magnitude(this._hi);\n  if (mag >= -3 && mag <= 20) { return this.toStandardNotation() }\n  return this.toSciNotation()\n};\nDD.prototype.toStandardNotation = function toStandardNotation () {\n  var specialStr = this.getSpecialNumberString();\n  if (specialStr !== null) { return specialStr }\n  var magnitude = new Array(1).fill(null);\n  var sigDigits = this.extractSignificantDigits(true, magnitude);\n  var decimalPointPos = magnitude[0] + 1;\n  var num = sigDigits;\n  if (sigDigits.charAt(0) === '.') {\n    num = '0' + sigDigits;\n  } else if (decimalPointPos < 0) {\n    num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n  } else if (sigDigits.indexOf('.') === -1) {\n    var numZeroes = decimalPointPos - sigDigits.length;\n    var zeroes = DD.stringOfChar('0', numZeroes);\n    num = sigDigits + zeroes + '.0';\n  }\n  if (this.isNegative()) { return '-' + num }\n  return num\n};\nDD.prototype.reciprocal = function reciprocal () {\n  var hc = null;\n  var tc = null;\n  var hy = null;\n  var ty = null;\n  var C = null;\n  var c = null;\n  var U = null;\n  var u = null;\n  C = 1.0 / this._hi;\n  c = DD.SPLIT * C;\n  hc = c - C;\n  u = DD.SPLIT * this._hi;\n  hc = c - hc;\n  tc = C - hc;\n  hy = u - this._hi;\n  U = C * this._hi;\n  hy = u - hy;\n  ty = this._hi - hy;\n  u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n  c = (1.0 - U - u - C * this._lo) / this._hi;\n  var zhi = C + c;\n  var zlo = C - zhi + c;\n  return new DD(zhi, zlo)\n};\nDD.prototype.toSciNotation = function toSciNotation () {\n  if (this.isZero()) { return DD.SCI_NOT_ZERO }\n  var specialStr = this.getSpecialNumberString();\n  if (specialStr !== null) { return specialStr }\n  var magnitude = new Array(1).fill(null);\n  var digits = this.extractSignificantDigits(false, magnitude);\n  var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n  if (digits.charAt(0) === '0') {\n    throw new Error('Found leading zero: ' + digits)\n  }\n  var trailingDigits = '';\n  if (digits.length > 1) { trailingDigits = digits.substring(1); }\n  var digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;\n  if (this.isNegative()) { return '-' + digitsWithDecimal + expStr }\n  return digitsWithDecimal + expStr\n};\nDD.prototype.abs = function abs () {\n  if (this.isNaN()) { return DD.NaN }\n  if (this.isNegative()) { return this.negate() }\n  return new DD(this)\n};\nDD.prototype.isPositive = function isPositive () {\n  return (this._hi > 0.0 || this._hi === 0.0) && this._lo > 0.0\n};\nDD.prototype.lt = function lt (y) {\n  return (this._hi < y._hi || this._hi === y._hi) && this._lo < y._lo\n};\nDD.prototype.add = function add () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    return DD.copy(this).selfAdd(y)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    return DD.copy(this).selfAdd(y$1)\n  }\n};\nDD.prototype.init = function init () {\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'number') {\n      var x = arguments[0];\n      this._hi = x;\n      this._lo = 0.0;\n    } else if (arguments[0] instanceof DD) {\n      var dd = arguments[0];\n      this._hi = dd._hi;\n      this._lo = dd._lo;\n    }\n  } else if (arguments.length === 2) {\n    var hi = arguments[0];\n    var lo = arguments[1];\n    this._hi = hi;\n    this._lo = lo;\n  }\n};\nDD.prototype.gt = function gt (y) {\n  return (this._hi > y._hi || this._hi === y._hi) && this._lo > y._lo\n};\nDD.prototype.isNegative = function isNegative () {\n  return (this._hi < 0.0 || this._hi === 0.0) && this._lo < 0.0\n};\nDD.prototype.trunc = function trunc () {\n  if (this.isNaN()) { return DD.NaN }\n  if (this.isPositive()) { return this.floor(); } else { return this.ceil() }\n};\nDD.prototype.signum = function signum () {\n  if (this._hi > 0) { return 1 }\n  if (this._hi < 0) { return -1 }\n  if (this._lo > 0) { return 1 }\n  if (this._lo < 0) { return -1 }\n  return 0\n};\nDD.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable, Comparable, Clonable]\n};\nDD.prototype.getClass = function getClass () {\n  return DD\n};\nDD.sqr = function sqr (x) {\n  return DD.valueOf(x).selfMultiply(x)\n};\nDD.valueOf = function valueOf () {\n  if (typeof arguments[0] === 'string') {\n    var str = arguments[0];\n    return DD.parse(str)\n  } else if (typeof arguments[0] === 'number') {\n    var x = arguments[0];\n    return new DD(x)\n  }\n};\nDD.sqrt = function sqrt (x) {\n  return DD.valueOf(x).sqrt()\n};\nDD.parse = function parse (str) {\n  var i = 0;\n  var strlen = str.length;\n  while (Character.isWhitespace(str.charAt(i))) { i++; }\n  var isNegative = false;\n  if (i < strlen) {\n    var signCh = str.charAt(i);\n    if (signCh === '-' || signCh === '+') {\n      i++;\n      if (signCh === '-') { isNegative = true; }\n    }\n  }\n  var val = new DD();\n  var numDigits = 0;\n  var numBeforeDec = 0;\n  var exp = 0;\n  while (true) {\n    if (i >= strlen) { break }\n    var ch = str.charAt(i);\n    i++;\n    if (Character.isDigit(ch)) {\n      var d = ch - '0';\n      val.selfMultiply(DD.TEN);\n      val.selfAdd(d);\n      numDigits++;\n      continue\n    }\n    if (ch === '.') {\n      numBeforeDec = numDigits;\n      continue\n    }\n    if (ch === 'e' || ch === 'E') {\n      var expStr = str.substring(i);\n      try {\n        exp = Integer.parseInt(expStr);\n      } catch (ex) {\n        if (ex instanceof Error) {\n          throw new Error('Invalid exponent ' + expStr + ' in string ' + str)\n        } else { throw ex }\n      } finally {}\n      break\n    }\n    throw new Error(\"Unexpected character '\" + ch + \"' at position \" + i + ' in string ' + str)\n  }\n  var val2 = val;\n  var numDecPlaces = numDigits - numBeforeDec - exp;\n  if (numDecPlaces === 0) {\n    val2 = val;\n  } else if (numDecPlaces > 0) {\n    var scale = DD.TEN.pow(numDecPlaces);\n    val2 = val.divide(scale);\n  } else if (numDecPlaces < 0) {\n    var scale$1 = DD.TEN.pow(-numDecPlaces);\n    val2 = val.multiply(scale$1);\n  }\n  if (isNegative) {\n    return val2.negate()\n  }\n  return val2\n};\nDD.createNaN = function createNaN () {\n  return new DD(Double.NaN, Double.NaN)\n};\nDD.copy = function copy (dd) {\n  return new DD(dd)\n};\nDD.magnitude = function magnitude (x) {\n  var xAbs = Math.abs(x);\n  var xLog10 = Math.log(xAbs) / Math.log(10);\n  var xMag = Math.trunc(Math.floor(xLog10));\n  var xApprox = Math.pow(10, xMag);\n  if (xApprox * 10 <= xAbs) { xMag += 1; }\n  return xMag\n};\nDD.stringOfChar = function stringOfChar (ch, len) {\n  var buf = new StringBuffer();\n  for (var i = 0; i < len; i++) {\n    buf.append(ch);\n  }\n  return buf.toString()\n};\nstaticAccessors$7.PI.get = function () { return new DD(3.141592653589793116e+00, 1.224646799147353207e-16) };\nstaticAccessors$7.TWO_PI.get = function () { return new DD(6.283185307179586232e+00, 2.449293598294706414e-16) };\nstaticAccessors$7.PI_2.get = function () { return new DD(1.570796326794896558e+00, 6.123233995736766036e-17) };\nstaticAccessors$7.E.get = function () { return new DD(2.718281828459045091e+00, 1.445646891729250158e-16) };\nstaticAccessors$7.NaN.get = function () { return new DD(Double.NaN, Double.NaN) };\nstaticAccessors$7.EPS.get = function () { return 1.23259516440783e-32 };\nstaticAccessors$7.SPLIT.get = function () { return 134217729.0 };\nstaticAccessors$7.MAX_PRINT_DIGITS.get = function () { return 32 };\nstaticAccessors$7.TEN.get = function () { return DD.valueOf(10.0) };\nstaticAccessors$7.ONE.get = function () { return DD.valueOf(1.0) };\nstaticAccessors$7.SCI_NOT_EXPONENT_CHAR.get = function () { return 'E' };\nstaticAccessors$7.SCI_NOT_ZERO.get = function () { return '0.0E0' };\n\nObject.defineProperties( DD, staticAccessors$7 );\n\nvar CGAlgorithmsDD = function CGAlgorithmsDD () {};\n\nvar staticAccessors$6 = { DP_SAFE_EPSILON: { configurable: true } };\n\nCGAlgorithmsDD.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCGAlgorithmsDD.prototype.getClass = function getClass () {\n  return CGAlgorithmsDD\n};\nCGAlgorithmsDD.orientationIndex = function orientationIndex (p1, p2, q) {\n  var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n  if (index <= 1) { return index }\n  var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n  var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n  var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n  var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n  return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum()\n};\nCGAlgorithmsDD.signOfDet2x2 = function signOfDet2x2 (x1, y1, x2, y2) {\n  var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n  return det.signum()\n};\nCGAlgorithmsDD.intersection = function intersection (p1, p2, q1, q2) {\n  var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n  var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n  var denom = denom1.subtract(denom2);\n  var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n  var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n  var numx = numx1.subtract(numx2);\n  var fracP = numx.selfDivide(denom).doubleValue();\n  var x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n  var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n  var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n  var numy = numy1.subtract(numy2);\n  var fracQ = numy.selfDivide(denom).doubleValue();\n  var y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n  return new Coordinate(x, y)\n};\nCGAlgorithmsDD.orientationIndexFilter = function orientationIndexFilter (pa, pb, pc) {\n  var detsum = null;\n  var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n  var detright = (pa.y - pc.y) * (pb.x - pc.x);\n  var det = detleft - detright;\n  if (detleft > 0.0) {\n    if (detright <= 0.0) {\n      return CGAlgorithmsDD.signum(det)\n    } else {\n      detsum = detleft + detright;\n    }\n  } else if (detleft < 0.0) {\n    if (detright >= 0.0) {\n      return CGAlgorithmsDD.signum(det)\n    } else {\n      detsum = -detleft - detright;\n    }\n  } else {\n    return CGAlgorithmsDD.signum(det)\n  }\n  var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n  if (det >= errbound || -det >= errbound) {\n    return CGAlgorithmsDD.signum(det)\n  }\n  return 2\n};\nCGAlgorithmsDD.signum = function signum (x) {\n  if (x > 0) { return 1 }\n  if (x < 0) { return -1 }\n  return 0\n};\nstaticAccessors$6.DP_SAFE_EPSILON.get = function () { return 1e-15 };\n\nObject.defineProperties( CGAlgorithmsDD, staticAccessors$6 );\n\nvar CoordinateSequence = function CoordinateSequence () {};\n\nvar staticAccessors$8 = { X: { configurable: true },Y: { configurable: true },Z: { configurable: true },M: { configurable: true } };\n\nstaticAccessors$8.X.get = function () { return 0 };\nstaticAccessors$8.Y.get = function () { return 1 };\nstaticAccessors$8.Z.get = function () { return 2 };\nstaticAccessors$8.M.get = function () { return 3 };\nCoordinateSequence.prototype.setOrdinate = function setOrdinate (index, ordinateIndex, value) {};\nCoordinateSequence.prototype.size = function size () {};\nCoordinateSequence.prototype.getOrdinate = function getOrdinate (index, ordinateIndex) {};\nCoordinateSequence.prototype.getCoordinate = function getCoordinate () {};\nCoordinateSequence.prototype.getCoordinateCopy = function getCoordinateCopy (i) {};\nCoordinateSequence.prototype.getDimension = function getDimension () {};\nCoordinateSequence.prototype.getX = function getX (index) {};\nCoordinateSequence.prototype.clone = function clone () {};\nCoordinateSequence.prototype.expandEnvelope = function expandEnvelope (env) {};\nCoordinateSequence.prototype.copy = function copy () {};\nCoordinateSequence.prototype.getY = function getY (index) {};\nCoordinateSequence.prototype.toCoordinateArray = function toCoordinateArray () {};\nCoordinateSequence.prototype.interfaces_ = function interfaces_ () {\n  return [Clonable]\n};\nCoordinateSequence.prototype.getClass = function getClass () {\n  return CoordinateSequence\n};\n\nObject.defineProperties( CoordinateSequence, staticAccessors$8 );\n\nvar Exception = function Exception () {};\n\nvar NotRepresentableException = (function (Exception$$1) {\n  function NotRepresentableException () {\n    Exception$$1.call(this, 'Projective point not representable on the Cartesian plane.');\n  }\n\n  if ( Exception$$1 ) NotRepresentableException.__proto__ = Exception$$1;\n  NotRepresentableException.prototype = Object.create( Exception$$1 && Exception$$1.prototype );\n  NotRepresentableException.prototype.constructor = NotRepresentableException;\n  NotRepresentableException.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  NotRepresentableException.prototype.getClass = function getClass () {\n    return NotRepresentableException\n  };\n\n  return NotRepresentableException;\n}(Exception));\n\nvar System = function System () {};\n\nSystem.arraycopy = function arraycopy (src, srcPos, dest, destPos, len) {\n  var c = 0;\n  for (var i = srcPos; i < srcPos + len; i++) {\n    dest[destPos + c] = src[i];\n    c++;\n  }\n};\n\nSystem.getProperty = function getProperty (name) {\n  return {\n    'line.separator': '\\n'\n  }[name]\n};\n\nvar HCoordinate = function HCoordinate () {\n  this.x = null;\n  this.y = null;\n  this.w = null;\n  if (arguments.length === 0) {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.w = 1.0;\n  } else if (arguments.length === 1) {\n    var p = arguments[0];\n    this.x = p.x;\n    this.y = p.y;\n    this.w = 1.0;\n  } else if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      var _x = arguments[0];\n      var _y = arguments[1];\n      this.x = _x;\n      this.y = _y;\n      this.w = 1.0;\n    } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n      var p1 = arguments[0];\n      var p2 = arguments[1];\n      this.x = p1.y * p2.w - p2.y * p1.w;\n      this.y = p2.x * p1.w - p1.x * p2.w;\n      this.w = p1.x * p2.y - p2.x * p1.y;\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n      var p1$1 = arguments[0];\n      var p2$1 = arguments[1];\n      this.x = p1$1.y - p2$1.y;\n      this.y = p2$1.x - p1$1.x;\n      this.w = p1$1.x * p2$1.y - p2$1.x * p1$1.y;\n    }\n  } else if (arguments.length === 3) {\n    var _x$1 = arguments[0];\n    var _y$1 = arguments[1];\n    var _w = arguments[2];\n    this.x = _x$1;\n    this.y = _y$1;\n    this.w = _w;\n  } else if (arguments.length === 4) {\n    var p1$2 = arguments[0];\n    var p2$2 = arguments[1];\n    var q1 = arguments[2];\n    var q2 = arguments[3];\n    var px = p1$2.y - p2$2.y;\n    var py = p2$2.x - p1$2.x;\n    var pw = p1$2.x * p2$2.y - p2$2.x * p1$2.y;\n    var qx = q1.y - q2.y;\n    var qy = q2.x - q1.x;\n    var qw = q1.x * q2.y - q2.x * q1.y;\n    this.x = py * qw - qy * pw;\n    this.y = qx * pw - px * qw;\n    this.w = px * qy - qx * py;\n  }\n};\nHCoordinate.prototype.getY = function getY () {\n  var a = this.y / this.w;\n  if (Double.isNaN(a) || Double.isInfinite(a)) {\n    throw new NotRepresentableException()\n  }\n  return a\n};\nHCoordinate.prototype.getX = function getX () {\n  var a = this.x / this.w;\n  if (Double.isNaN(a) || Double.isInfinite(a)) {\n    throw new NotRepresentableException()\n  }\n  return a\n};\nHCoordinate.prototype.getCoordinate = function getCoordinate () {\n  var p = new Coordinate();\n  p.x = this.getX();\n  p.y = this.getY();\n  return p\n};\nHCoordinate.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nHCoordinate.prototype.getClass = function getClass () {\n  return HCoordinate\n};\nHCoordinate.intersection = function intersection (p1, p2, q1, q2) {\n  var px = p1.y - p2.y;\n  var py = p2.x - p1.x;\n  var pw = p1.x * p2.y - p2.x * p1.y;\n  var qx = q1.y - q2.y;\n  var qy = q2.x - q1.x;\n  var qw = q1.x * q2.y - q2.x * q1.y;\n  var x = py * qw - qy * pw;\n  var y = qx * pw - px * qw;\n  var w = px * qy - qx * py;\n  var xInt = x / w;\n  var yInt = y / w;\n  if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {\n    throw new NotRepresentableException()\n  }\n  return new Coordinate(xInt, yInt)\n};\n\nvar Envelope = function Envelope () {\n  this._minx = null;\n  this._maxx = null;\n  this._miny = null;\n  this._maxy = null;\n  if (arguments.length === 0) {\n    this.init();\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      this.init(p.x, p.x, p.y, p.y);\n    } else if (arguments[0] instanceof Envelope) {\n      var env = arguments[0];\n      this.init(env);\n    }\n  } else if (arguments.length === 2) {\n    var p1 = arguments[0];\n    var p2 = arguments[1];\n    this.init(p1.x, p2.x, p1.y, p2.y);\n  } else if (arguments.length === 4) {\n    var x1 = arguments[0];\n    var x2 = arguments[1];\n    var y1 = arguments[2];\n    var y2 = arguments[3];\n    this.init(x1, x2, y1, y2);\n  }\n};\n\nvar staticAccessors$9 = { serialVersionUID: { configurable: true } };\nEnvelope.prototype.getArea = function getArea () {\n  return this.getWidth() * this.getHeight()\n};\nEnvelope.prototype.equals = function equals (other) {\n  if (!(other instanceof Envelope)) {\n    return false\n  }\n  var otherEnvelope = other;\n  if (this.isNull()) {\n    return otherEnvelope.isNull()\n  }\n  return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY()\n};\nEnvelope.prototype.intersection = function intersection (env) {\n  if (this.isNull() || env.isNull() || !this.intersects(env)) { return new Envelope() }\n  var intMinX = this._minx > env._minx ? this._minx : env._minx;\n  var intMinY = this._miny > env._miny ? this._miny : env._miny;\n  var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n  var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n  return new Envelope(intMinX, intMaxX, intMinY, intMaxY)\n};\nEnvelope.prototype.isNull = function isNull () {\n  return this._maxx < this._minx\n};\nEnvelope.prototype.getMaxX = function getMaxX () {\n  return this._maxx\n};\nEnvelope.prototype.covers = function covers () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      return this.covers(p.x, p.y)\n    } else if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      if (this.isNull() || other.isNull()) {\n        return false\n      }\n      return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    if (this.isNull()) { return false }\n    return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy\n  }\n};\nEnvelope.prototype.intersects = function intersects () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      if (this.isNull() || other.isNull()) {\n        return false\n      }\n      return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny)\n    } else if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      return this.intersects(p.x, p.y)\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    if (this.isNull()) { return false }\n    return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny)\n  }\n};\nEnvelope.prototype.getMinY = function getMinY () {\n  return this._miny\n};\nEnvelope.prototype.getMinX = function getMinX () {\n  return this._minx\n};\nEnvelope.prototype.expandToInclude = function expandToInclude () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      this.expandToInclude(p.x, p.y);\n    } else if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      if (other.isNull()) {\n        return null\n      }\n      if (this.isNull()) {\n        this._minx = other.getMinX();\n        this._maxx = other.getMaxX();\n        this._miny = other.getMinY();\n        this._maxy = other.getMaxY();\n      } else {\n        if (other._minx < this._minx) {\n          this._minx = other._minx;\n        }\n        if (other._maxx > this._maxx) {\n          this._maxx = other._maxx;\n        }\n        if (other._miny < this._miny) {\n          this._miny = other._miny;\n        }\n        if (other._maxy > this._maxy) {\n          this._maxy = other._maxy;\n        }\n      }\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    if (this.isNull()) {\n      this._minx = x;\n      this._maxx = x;\n      this._miny = y;\n      this._maxy = y;\n    } else {\n      if (x < this._minx) {\n        this._minx = x;\n      }\n      if (x > this._maxx) {\n        this._maxx = x;\n      }\n      if (y < this._miny) {\n        this._miny = y;\n      }\n      if (y > this._maxy) {\n        this._maxy = y;\n      }\n    }\n  }\n};\nEnvelope.prototype.minExtent = function minExtent () {\n  if (this.isNull()) { return 0.0 }\n  var w = this.getWidth();\n  var h = this.getHeight();\n  if (w < h) { return w }\n  return h\n};\nEnvelope.prototype.getWidth = function getWidth () {\n  if (this.isNull()) {\n    return 0\n  }\n  return this._maxx - this._minx\n};\nEnvelope.prototype.compareTo = function compareTo (o) {\n  var env = o;\n  if (this.isNull()) {\n    if (env.isNull()) { return 0 }\n    return -1\n  } else {\n    if (env.isNull()) { return 1 }\n  }\n  if (this._minx < env._minx) { return -1 }\n  if (this._minx > env._minx) { return 1 }\n  if (this._miny < env._miny) { return -1 }\n  if (this._miny > env._miny) { return 1 }\n  if (this._maxx < env._maxx) { return -1 }\n  if (this._maxx > env._maxx) { return 1 }\n  if (this._maxy < env._maxy) { return -1 }\n  if (this._maxy > env._maxy) { return 1 }\n  return 0\n};\nEnvelope.prototype.translate = function translate (transX, transY) {\n  if (this.isNull()) {\n    return null\n  }\n  this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n};\nEnvelope.prototype.toString = function toString () {\n  return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']'\n};\nEnvelope.prototype.setToNull = function setToNull () {\n  this._minx = 0;\n  this._maxx = -1;\n  this._miny = 0;\n  this._maxy = -1;\n};\nEnvelope.prototype.getHeight = function getHeight () {\n  if (this.isNull()) {\n    return 0\n  }\n  return this._maxy - this._miny\n};\nEnvelope.prototype.maxExtent = function maxExtent () {\n  if (this.isNull()) { return 0.0 }\n  var w = this.getWidth();\n  var h = this.getHeight();\n  if (w > h) { return w }\n  return h\n};\nEnvelope.prototype.expandBy = function expandBy () {\n  if (arguments.length === 1) {\n    var distance = arguments[0];\n    this.expandBy(distance, distance);\n  } else if (arguments.length === 2) {\n    var deltaX = arguments[0];\n    var deltaY = arguments[1];\n    if (this.isNull()) { return null }\n    this._minx -= deltaX;\n    this._maxx += deltaX;\n    this._miny -= deltaY;\n    this._maxy += deltaY;\n    if (this._minx > this._maxx || this._miny > this._maxy) { this.setToNull(); }\n  }\n};\nEnvelope.prototype.contains = function contains () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      return this.covers(other)\n    } else if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      return this.covers(p)\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    return this.covers(x, y)\n  }\n};\nEnvelope.prototype.centre = function centre () {\n  if (this.isNull()) { return null }\n  return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0)\n};\nEnvelope.prototype.init = function init () {\n  if (arguments.length === 0) {\n    this.setToNull();\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      this.init(p.x, p.x, p.y, p.y);\n    } else if (arguments[0] instanceof Envelope) {\n      var env = arguments[0];\n      this._minx = env._minx;\n      this._maxx = env._maxx;\n      this._miny = env._miny;\n      this._maxy = env._maxy;\n    }\n  } else if (arguments.length === 2) {\n    var p1 = arguments[0];\n    var p2 = arguments[1];\n    this.init(p1.x, p2.x, p1.y, p2.y);\n  } else if (arguments.length === 4) {\n    var x1 = arguments[0];\n    var x2 = arguments[1];\n    var y1 = arguments[2];\n    var y2 = arguments[3];\n    if (x1 < x2) {\n      this._minx = x1;\n      this._maxx = x2;\n    } else {\n      this._minx = x2;\n      this._maxx = x1;\n    }\n    if (y1 < y2) {\n      this._miny = y1;\n      this._maxy = y2;\n    } else {\n      this._miny = y2;\n      this._maxy = y1;\n    }\n  }\n};\nEnvelope.prototype.getMaxY = function getMaxY () {\n  return this._maxy\n};\nEnvelope.prototype.distance = function distance (env) {\n  if (this.intersects(env)) { return 0 }\n  var dx = 0.0;\n  if (this._maxx < env._minx) { dx = env._minx - this._maxx; } else if (this._minx > env._maxx) { dx = this._minx - env._maxx; }\n  var dy = 0.0;\n  if (this._maxy < env._miny) { dy = env._miny - this._maxy; } else if (this._miny > env._maxy) { dy = this._miny - env._maxy; }\n  if (dx === 0.0) { return dy }\n  if (dy === 0.0) { return dx }\n  return Math.sqrt(dx * dx + dy * dy)\n};\nEnvelope.prototype.hashCode = function hashCode () {\n  var result = 17;\n  result = 37 * result + Coordinate.hashCode(this._minx);\n  result = 37 * result + Coordinate.hashCode(this._maxx);\n  result = 37 * result + Coordinate.hashCode(this._miny);\n  result = 37 * result + Coordinate.hashCode(this._maxy);\n  return result\n};\nEnvelope.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable, Serializable]\n};\nEnvelope.prototype.getClass = function getClass () {\n  return Envelope\n};\nEnvelope.intersects = function intersects () {\n  if (arguments.length === 3) {\n    var p1 = arguments[0];\n    var p2 = arguments[1];\n    var q = arguments[2];\n    if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {\n      return true\n    }\n    return false\n  } else if (arguments.length === 4) {\n    var p1$1 = arguments[0];\n    var p2$1 = arguments[1];\n    var q1 = arguments[2];\n    var q2 = arguments[3];\n    var minq = Math.min(q1.x, q2.x);\n    var maxq = Math.max(q1.x, q2.x);\n    var minp = Math.min(p1$1.x, p2$1.x);\n    var maxp = Math.max(p1$1.x, p2$1.x);\n    if (minp > maxq) { return false }\n    if (maxp < minq) { return false }\n    minq = Math.min(q1.y, q2.y);\n    maxq = Math.max(q1.y, q2.y);\n    minp = Math.min(p1$1.y, p2$1.y);\n    maxp = Math.max(p1$1.y, p2$1.y);\n    if (minp > maxq) { return false }\n    if (maxp < minq) { return false }\n    return true\n  }\n};\nstaticAccessors$9.serialVersionUID.get = function () { return 5873921885273102420 };\n\nObject.defineProperties( Envelope, staticAccessors$9 );\n\nvar regExes = {\n  'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n  'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n  'spaces': /\\s+/,\n  'parenComma': /\\)\\s*,\\s*\\(/,\n  'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/, // can't use {2} here\n  'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n};\n\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/** Create a new parser for WKT\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of WKTParser.\n * @constructor\n * @private\n */\nvar WKTParser = function WKTParser (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n};\n/**\n * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n * and GEOMETRYCOLLECTION.\n *\n * @param {String} wkt A WKT string.\n * @return {Geometry} A geometry instance.\n * @private\n */\nWKTParser.prototype.read = function read (wkt) {\n  var geometry, type, str;\n  wkt = wkt.replace(/[\\n\\r]/g, ' ');\n  var matches = regExes.typeStr.exec(wkt);\n  if (wkt.search('EMPTY') !== -1) {\n    matches = regExes.emptyTypeStr.exec(wkt);\n    matches[2] = undefined;\n  }\n  if (matches) {\n    type = matches[1].toLowerCase();\n    str = matches[2];\n    if (parse$1[type]) {\n      geometry = parse$1[type].apply(this, [str]);\n    }\n  }\n\n  if (geometry === undefined) { throw new Error('Could not parse WKT ' + wkt) }\n\n  return geometry\n};\n\n/**\n * Serialize a geometry into a WKT string.\n *\n * @param {Geometry} geometry A feature or array of features.\n * @return {String} The WKT string representation of the input geometries.\n * @private\n */\nWKTParser.prototype.write = function write (geometry) {\n  return this.extractGeometry(geometry)\n};\n\n/**\n * Entry point to construct the WKT for a single Geometry object.\n *\n * @param {Geometry} geometry\n * @return {String} A WKT string of representing the geometry.\n * @private\n */\nWKTParser.prototype.extractGeometry = function extractGeometry (geometry) {\n  var type = geometry.getGeometryType().toLowerCase();\n  if (!extract$1[type]) {\n    return null\n  }\n  var wktType = type.toUpperCase();\n  var data;\n  if (geometry.isEmpty()) {\n    data = wktType + ' EMPTY';\n  } else {\n    data = wktType + '(' + extract$1[type].apply(this, [geometry]) + ')';\n  }\n  return data\n};\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual data extraction.\n * @private\n */\nvar extract$1 = {\n  coordinate: function coordinate (coordinate$1) {\n    return coordinate$1.x + ' ' + coordinate$1.y\n  },\n\n  /**\n   * Return a space delimited string of point coordinates.\n   *\n   * @param {Point}\n   *          point\n   * @return {String} A string of coordinates representing the point.\n   */\n  point: function point (point$1) {\n    return extract$1.coordinate.call(this, point$1._coordinates._coordinates[0])\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a multipoint.\n   *\n   * @param {MultiPoint}\n   *          multipoint\n   * @return {String} A string of point coordinate strings representing the\n   *         multipoint.\n   */\n  multipoint: function multipoint (multipoint$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = multipoint$1._geometries.length; i < len; ++i) {\n      array.push('(' + extract$1.point.apply(this$1, [multipoint$1._geometries[i]]) + ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a line.\n   *\n   * @param {LineString} linestring\n   * @return {String} A string of point coordinate strings representing the linestring.\n   */\n  linestring: function linestring (linestring$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = linestring$1._points._coordinates.length; i < len; ++i) {\n      array.push(extract$1.coordinate.apply(this$1, [linestring$1._points._coordinates[i]]));\n    }\n    return array.join(',')\n  },\n\n  linearring: function linearring (linearring$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = linearring$1._points._coordinates.length; i < len; ++i) {\n      array.push(extract$1.coordinate.apply(this$1, [linearring$1._points._coordinates[i]]));\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linestring strings from a\n   * multilinestring.\n   *\n   * @param {MultiLineString} multilinestring\n   * @return {String} A string of of linestring strings representing the multilinestring.\n   */\n  multilinestring: function multilinestring (multilinestring$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = multilinestring$1._geometries.length; i < len; ++i) {\n      array.push('(' +\n        extract$1.linestring.apply(this$1, [multilinestring$1._geometries[i]]) +\n        ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linear ring arrays from a polygon.\n   *\n   * @param {Polygon} polygon\n   * @return {String} An array of linear ring arrays representing the polygon.\n   */\n  polygon: function polygon (polygon$1) {\n    var this$1 = this;\n\n    var array = [];\n    array.push('(' + extract$1.linestring.apply(this, [polygon$1._shell]) + ')');\n    for (var i = 0, len = polygon$1._holes.length; i < len; ++i) {\n      array.push('(' + extract$1.linestring.apply(this$1, [polygon$1._holes[i]]) + ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return an array of polygon arrays from a multipolygon.\n   *\n   * @param {MultiPolygon} multipolygon\n   * @return {String} An array of polygon arrays representing the multipolygon.\n   */\n  multipolygon: function multipolygon (multipolygon$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = multipolygon$1._geometries.length; i < len; ++i) {\n      array.push('(' + extract$1.polygon.apply(this$1, [multipolygon$1._geometries[i]]) + ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n   * geometrycollection.\n   *\n   * @param {GeometryCollection} collection\n   * @return {String} internal WKT representation of the collection.\n   */\n  geometrycollection: function geometrycollection (collection) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = collection._geometries.length; i < len; ++i) {\n      array.push(this$1.extractGeometry(collection._geometries[i]));\n    }\n    return array.join(',')\n  }\n};\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual parsing.\n * @private\n */\nvar parse$1 = {\n  /**\n   * Return point geometry given a point WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the point.\n   * @return {Point} A point geometry.\n   * @private\n   */\n  point: function point (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPoint()\n    }\n\n    var coords = str.trim().split(regExes.spaces);\n    return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]),\n      Number.parseFloat(coords[1])))\n  },\n\n  /**\n   * Return a multipoint geometry given a multipoint WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipoint.\n   * @return {Point} A multipoint feature.\n   * @private\n   */\n  multipoint: function multipoint (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPoint()\n    }\n\n    var point;\n    var points = str.trim().split(',');\n    var components = [];\n    for (var i = 0, len = points.length; i < len; ++i) {\n      point = points[i].replace(regExes.trimParens, '$1');\n      components.push(parse$1.point.apply(this$1, [point]));\n    }\n    return this.geometryFactory.createMultiPoint(components)\n  },\n\n  /**\n   * Return a linestring geometry given a linestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linestring.\n   * @return {LineString} A linestring geometry.\n   * @private\n   */\n  linestring: function linestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLineString()\n    }\n\n    var points = str.trim().split(',');\n    var components = [];\n    var coords;\n    for (var i = 0, len = points.length; i < len; ++i) {\n      coords = points[i].trim().split(regExes.spaces);\n      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    }\n    return this.geometryFactory.createLineString(components)\n  },\n\n  /**\n   * Return a linearring geometry given a linearring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linearring.\n   * @return {LinearRing} A linearring geometry.\n   * @private\n   */\n  linearring: function linearring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLinearRing()\n    }\n\n    var points = str.trim().split(',');\n    var components = [];\n    var coords;\n    for (var i = 0, len = points.length; i < len; ++i) {\n      coords = points[i].trim().split(regExes.spaces);\n      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    }\n    return this.geometryFactory.createLinearRing(components)\n  },\n\n  /**\n   * Return a multilinestring geometry given a multilinestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multilinestring.\n   * @return {MultiLineString} A multilinestring geometry.\n   * @private\n   */\n  multilinestring: function multilinestring (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createMultiLineString()\n    }\n\n    var line;\n    var lines = str.trim().split(regExes.parenComma);\n    var components = [];\n    for (var i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i].replace(regExes.trimParens, '$1');\n      components.push(parse$1.linestring.apply(this$1, [line]));\n    }\n    return this.geometryFactory.createMultiLineString(components)\n  },\n\n  /**\n   * Return a polygon geometry given a polygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the polygon.\n   * @return {Polygon} A polygon geometry.\n   * @private\n   */\n  polygon: function polygon (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createPolygon()\n    }\n\n    var ring, linestring, linearring;\n    var rings = str.trim().split(regExes.parenComma);\n    var shell;\n    var holes = [];\n    for (var i = 0, len = rings.length; i < len; ++i) {\n      ring = rings[i].replace(regExes.trimParens, '$1');\n      linestring = parse$1.linestring.apply(this$1, [ring]);\n      linearring = this$1.geometryFactory.createLinearRing(linestring._points);\n      if (i === 0) {\n        shell = linearring;\n      } else {\n        holes.push(linearring);\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Return a multipolygon geometry given a multipolygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipolygon.\n   * @return {MultiPolygon} A multipolygon geometry.\n   * @private\n   */\n  multipolygon: function multipolygon (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPolygon()\n    }\n\n    var polygon;\n    var polygons = str.trim().split(regExes.doubleParenComma);\n    var components = [];\n    for (var i = 0, len = polygons.length; i < len; ++i) {\n      polygon = polygons[i].replace(regExes.trimParens, '$1');\n      components.push(parse$1.polygon.apply(this$1, [polygon]));\n    }\n    return this.geometryFactory.createMultiPolygon(components)\n  },\n\n  /**\n   * Return a geometrycollection given a geometrycollection WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the geometrycollection.\n   * @return {GeometryCollection}\n   * @private\n   */\n  geometrycollection: function geometrycollection (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createGeometryCollection()\n    }\n\n    // separate components of the collection with |\n    str = str.replace(/,\\s*([A-Za-z])/g, '|$1');\n    var wktArray = str.trim().split('|');\n    var components = [];\n    for (var i = 0, len = wktArray.length; i < len; ++i) {\n      components.push(this$1.read(wktArray[i]));\n    }\n    return this.geometryFactory.createGeometryCollection(components)\n  }\n};\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\n\n/**\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nvar WKTWriter = function WKTWriter (geometryFactory) {\n  this.parser = new WKTParser(geometryFactory);\n};\n\n/**\n * Converts a <code>Geometry</code> to its Well-known Text representation.\n *\n * @param {Geometry} geometry a <code>Geometry</code> to process.\n * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n *       Features Specification).\n * @memberof WKTWriter\n */\nWKTWriter.prototype.write = function write (geometry) {\n  return this.parser.write(geometry)\n};\n/**\n * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n * {@link Coordinate}s.\n *\n * @param p0 the first coordinate.\n * @param p1 the second coordinate.\n *\n * @return the WKT.\n * @private\n */\nWKTWriter.toLineString = function toLineString (p0, p1) {\n  if (arguments.length !== 2) {\n    throw new Error('Not implemented')\n  }\n  return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'\n};\n\nvar RuntimeException = (function (Error) {\n  function RuntimeException (message) {\n    Error.call(this, message);\n    this.name = 'RuntimeException';\n    this.message = message;\n    this.stack = (new Error()).stack;\n  }\n\n  if ( Error ) RuntimeException.__proto__ = Error;\n  RuntimeException.prototype = Object.create( Error && Error.prototype );\n  RuntimeException.prototype.constructor = RuntimeException;\n\n  return RuntimeException;\n}(Error));\n\nvar AssertionFailedException = (function (RuntimeException$$1) {\n  function AssertionFailedException () {\n    RuntimeException$$1.call(this);\n    if (arguments.length === 0) {\n      RuntimeException$$1.call(this);\n    } else if (arguments.length === 1) {\n      var message = arguments[0];\n      RuntimeException$$1.call(this, message);\n    }\n  }\n\n  if ( RuntimeException$$1 ) AssertionFailedException.__proto__ = RuntimeException$$1;\n  AssertionFailedException.prototype = Object.create( RuntimeException$$1 && RuntimeException$$1.prototype );\n  AssertionFailedException.prototype.constructor = AssertionFailedException;\n  AssertionFailedException.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  AssertionFailedException.prototype.getClass = function getClass () {\n    return AssertionFailedException\n  };\n\n  return AssertionFailedException;\n}(RuntimeException));\n\nvar Assert = function Assert () {};\n\nAssert.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nAssert.prototype.getClass = function getClass () {\n  return Assert\n};\nAssert.shouldNeverReachHere = function shouldNeverReachHere () {\n  if (arguments.length === 0) {\n    Assert.shouldNeverReachHere(null);\n  } else if (arguments.length === 1) {\n    var message = arguments[0];\n    throw new AssertionFailedException('Should never reach here' + (message !== null ? ': ' + message : ''))\n  }\n};\nAssert.isTrue = function isTrue () {\n  var assertion;\n  var message;\n  if (arguments.length === 1) {\n    assertion = arguments[0];\n    Assert.isTrue(assertion, null);\n  } else if (arguments.length === 2) {\n    assertion = arguments[0];\n    message = arguments[1];\n    if (!assertion) {\n      if (message === null) {\n        throw new AssertionFailedException()\n      } else {\n        throw new AssertionFailedException(message)\n      }\n    }\n  }\n};\nAssert.equals = function equals () {\n  var expectedValue;\n  var actualValue;\n  var message;\n  if (arguments.length === 2) {\n    expectedValue = arguments[0];\n    actualValue = arguments[1];\n    Assert.equals(expectedValue, actualValue, null);\n  } else if (arguments.length === 3) {\n    expectedValue = arguments[0];\n    actualValue = arguments[1];\n    message = arguments[2];\n    if (!actualValue.equals(expectedValue)) {\n      throw new AssertionFailedException('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''))\n    }\n  }\n};\n\nvar LineIntersector = function LineIntersector () {\n  this._result = null;\n  this._inputLines = Array(2).fill().map(function () { return Array(2); });\n  this._intPt = new Array(2).fill(null);\n  this._intLineIndex = null;\n  this._isProper = null;\n  this._pa = null;\n  this._pb = null;\n  this._precisionModel = null;\n  this._intPt[0] = new Coordinate();\n  this._intPt[1] = new Coordinate();\n  this._pa = this._intPt[0];\n  this._pb = this._intPt[1];\n  this._result = 0;\n};\n\nvar staticAccessors$10 = { DONT_INTERSECT: { configurable: true },DO_INTERSECT: { configurable: true },COLLINEAR: { configurable: true },NO_INTERSECTION: { configurable: true },POINT_INTERSECTION: { configurable: true },COLLINEAR_INTERSECTION: { configurable: true } };\nLineIntersector.prototype.getIndexAlongSegment = function getIndexAlongSegment (segmentIndex, intIndex) {\n  this.computeIntLineIndex();\n  return this._intLineIndex[segmentIndex][intIndex]\n};\nLineIntersector.prototype.getTopologySummary = function getTopologySummary () {\n  var catBuf = new StringBuffer();\n  if (this.isEndPoint()) { catBuf.append(' endpoint'); }\n  if (this._isProper) { catBuf.append(' proper'); }\n  if (this.isCollinear()) { catBuf.append(' collinear'); }\n  return catBuf.toString()\n};\nLineIntersector.prototype.computeIntersection = function computeIntersection (p1, p2, p3, p4) {\n  this._inputLines[0][0] = p1;\n  this._inputLines[0][1] = p2;\n  this._inputLines[1][0] = p3;\n  this._inputLines[1][1] = p4;\n  this._result = this.computeIntersect(p1, p2, p3, p4);\n};\nLineIntersector.prototype.getIntersectionNum = function getIntersectionNum () {\n  return this._result\n};\nLineIntersector.prototype.computeIntLineIndex = function computeIntLineIndex () {\n  if (arguments.length === 0) {\n    if (this._intLineIndex === null) {\n      this._intLineIndex = Array(2).fill().map(function () { return Array(2); });\n      this.computeIntLineIndex(0);\n      this.computeIntLineIndex(1);\n    }\n  } else if (arguments.length === 1) {\n    var segmentIndex = arguments[0];\n    var dist0 = this.getEdgeDistance(segmentIndex, 0);\n    var dist1 = this.getEdgeDistance(segmentIndex, 1);\n    if (dist0 > dist1) {\n      this._intLineIndex[segmentIndex][0] = 0;\n      this._intLineIndex[segmentIndex][1] = 1;\n    } else {\n      this._intLineIndex[segmentIndex][0] = 1;\n      this._intLineIndex[segmentIndex][1] = 0;\n    }\n  }\n};\nLineIntersector.prototype.isProper = function isProper () {\n  return this.hasIntersection() && this._isProper\n};\nLineIntersector.prototype.setPrecisionModel = function setPrecisionModel (precisionModel) {\n  this._precisionModel = precisionModel;\n};\nLineIntersector.prototype.isInteriorIntersection = function isInteriorIntersection () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this.isInteriorIntersection(0)) { return true }\n    if (this.isInteriorIntersection(1)) { return true }\n    return false\n  } else if (arguments.length === 1) {\n    var inputLineIndex = arguments[0];\n    for (var i = 0; i < this._result; i++) {\n      if (!(this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][0]) || this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][1]))) {\n        return true\n      }\n    }\n    return false\n  }\n};\nLineIntersector.prototype.getIntersection = function getIntersection (intIndex) {\n  return this._intPt[intIndex]\n};\nLineIntersector.prototype.isEndPoint = function isEndPoint () {\n  return this.hasIntersection() && !this._isProper\n};\nLineIntersector.prototype.hasIntersection = function hasIntersection () {\n  return this._result !== LineIntersector.NO_INTERSECTION\n};\nLineIntersector.prototype.getEdgeDistance = function getEdgeDistance (segmentIndex, intIndex) {\n  var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n  return dist\n};\nLineIntersector.prototype.isCollinear = function isCollinear () {\n  return this._result === LineIntersector.COLLINEAR_INTERSECTION\n};\nLineIntersector.prototype.toString = function toString () {\n  return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()\n};\nLineIntersector.prototype.getEndpoint = function getEndpoint (segmentIndex, ptIndex) {\n  return this._inputLines[segmentIndex][ptIndex]\n};\nLineIntersector.prototype.isIntersection = function isIntersection (pt) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._result; i++) {\n    if (this$1._intPt[i].equals2D(pt)) {\n      return true\n    }\n  }\n  return false\n};\nLineIntersector.prototype.getIntersectionAlongSegment = function getIntersectionAlongSegment (segmentIndex, intIndex) {\n  this.computeIntLineIndex();\n  return this._intPt[this._intLineIndex[segmentIndex][intIndex]]\n};\nLineIntersector.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineIntersector.prototype.getClass = function getClass () {\n  return LineIntersector\n};\nLineIntersector.computeEdgeDistance = function computeEdgeDistance (p, p0, p1) {\n  var dx = Math.abs(p1.x - p0.x);\n  var dy = Math.abs(p1.y - p0.y);\n  var dist = -1.0;\n  if (p.equals(p0)) {\n    dist = 0.0;\n  } else if (p.equals(p1)) {\n    if (dx > dy) { dist = dx; } else { dist = dy; }\n  } else {\n    var pdx = Math.abs(p.x - p0.x);\n    var pdy = Math.abs(p.y - p0.y);\n    if (dx > dy) { dist = pdx; } else { dist = pdy; }\n    if (dist === 0.0 && !p.equals(p0)) {\n      dist = Math.max(pdx, pdy);\n    }\n  }\n  Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');\n  return dist\n};\nLineIntersector.nonRobustComputeEdgeDistance = function nonRobustComputeEdgeDistance (p, p1, p2) {\n  var dx = p.x - p1.x;\n  var dy = p.y - p1.y;\n  var dist = Math.sqrt(dx * dx + dy * dy);\n  Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');\n  return dist\n};\nstaticAccessors$10.DONT_INTERSECT.get = function () { return 0 };\nstaticAccessors$10.DO_INTERSECT.get = function () { return 1 };\nstaticAccessors$10.COLLINEAR.get = function () { return 2 };\nstaticAccessors$10.NO_INTERSECTION.get = function () { return 0 };\nstaticAccessors$10.POINT_INTERSECTION.get = function () { return 1 };\nstaticAccessors$10.COLLINEAR_INTERSECTION.get = function () { return 2 };\n\nObject.defineProperties( LineIntersector, staticAccessors$10 );\n\nvar RobustLineIntersector = (function (LineIntersector$$1) {\n  function RobustLineIntersector () {\n    LineIntersector$$1.apply(this, arguments);\n  }\n\n  if ( LineIntersector$$1 ) RobustLineIntersector.__proto__ = LineIntersector$$1;\n  RobustLineIntersector.prototype = Object.create( LineIntersector$$1 && LineIntersector$$1.prototype );\n  RobustLineIntersector.prototype.constructor = RobustLineIntersector;\n\n  RobustLineIntersector.prototype.isInSegmentEnvelopes = function isInSegmentEnvelopes (intPt) {\n    var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n    var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n    return env0.contains(intPt) && env1.contains(intPt)\n  };\n  RobustLineIntersector.prototype.computeIntersection = function computeIntersection () {\n    if (arguments.length === 3) {\n      var p = arguments[0];\n      var p1 = arguments[1];\n      var p2 = arguments[2];\n      this._isProper = false;\n      if (Envelope.intersects(p1, p2, p)) {\n        if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {\n          this._isProper = true;\n          if (p.equals(p1) || p.equals(p2)) {\n            this._isProper = false;\n          }\n          this._result = LineIntersector$$1.POINT_INTERSECTION;\n          return null\n        }\n      }\n      this._result = LineIntersector$$1.NO_INTERSECTION;\n    } else { return LineIntersector$$1.prototype.computeIntersection.apply(this, arguments) }\n  };\n  RobustLineIntersector.prototype.normalizeToMinimum = function normalizeToMinimum (n1, n2, n3, n4, normPt) {\n    normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n    normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n    n1.x -= normPt.x;\n    n1.y -= normPt.y;\n    n2.x -= normPt.x;\n    n2.y -= normPt.y;\n    n3.x -= normPt.x;\n    n3.y -= normPt.y;\n    n4.x -= normPt.x;\n    n4.y -= normPt.y;\n  };\n  RobustLineIntersector.prototype.safeHCoordinateIntersection = function safeHCoordinateIntersection (p1, p2, q1, q2) {\n    var intPt = null;\n    try {\n      intPt = HCoordinate.intersection(p1, p2, q1, q2);\n    } catch (e) {\n      if (e instanceof NotRepresentableException) {\n        intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n      } else { throw e }\n    } finally {}\n    return intPt\n  };\n  RobustLineIntersector.prototype.intersection = function intersection (p1, p2, q1, q2) {\n    var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n    if (!this.isInSegmentEnvelopes(intPt)) {\n      intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n    }\n    if (this._precisionModel !== null) {\n      this._precisionModel.makePrecise(intPt);\n    }\n    return intPt\n  };\n  RobustLineIntersector.prototype.smallestInAbsValue = function smallestInAbsValue (x1, x2, x3, x4) {\n    var x = x1;\n    var xabs = Math.abs(x);\n    if (Math.abs(x2) < xabs) {\n      x = x2;\n      xabs = Math.abs(x2);\n    }\n    if (Math.abs(x3) < xabs) {\n      x = x3;\n      xabs = Math.abs(x3);\n    }\n    if (Math.abs(x4) < xabs) {\n      x = x4;\n    }\n    return x\n  };\n  RobustLineIntersector.prototype.checkDD = function checkDD (p1, p2, q1, q2, intPt) {\n    var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n    var isIn = this.isInSegmentEnvelopes(intPtDD);\n    System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);\n    if (intPt.distance(intPtDD) > 0.0001) {\n      System.out.println('Distance = ' + intPt.distance(intPtDD));\n    }\n  };\n  RobustLineIntersector.prototype.intersectionWithNormalization = function intersectionWithNormalization (p1, p2, q1, q2) {\n    var n1 = new Coordinate(p1);\n    var n2 = new Coordinate(p2);\n    var n3 = new Coordinate(q1);\n    var n4 = new Coordinate(q2);\n    var normPt = new Coordinate();\n    this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n    var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n    intPt.x += normPt.x;\n    intPt.y += normPt.y;\n    return intPt\n  };\n  RobustLineIntersector.prototype.computeCollinearIntersection = function computeCollinearIntersection (p1, p2, q1, q2) {\n    var p1q1p2 = Envelope.intersects(p1, p2, q1);\n    var p1q2p2 = Envelope.intersects(p1, p2, q2);\n    var q1p1q2 = Envelope.intersects(q1, q2, p1);\n    var q1p2q2 = Envelope.intersects(q1, q2, p2);\n    if (p1q1p2 && p1q2p2) {\n      this._intPt[0] = q1;\n      this._intPt[1] = q2;\n      return LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (q1p1q2 && q1p2q2) {\n      this._intPt[0] = p1;\n      this._intPt[1] = p2;\n      return LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q1p2 && q1p1q2) {\n      this._intPt[0] = q1;\n      this._intPt[1] = p1;\n      return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q1p2 && q1p2q2) {\n      this._intPt[0] = q1;\n      this._intPt[1] = p2;\n      return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q2p2 && q1p1q2) {\n      this._intPt[0] = q2;\n      this._intPt[1] = p1;\n      return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q2p2 && q1p2q2) {\n      this._intPt[0] = q2;\n      this._intPt[1] = p2;\n      return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    return LineIntersector$$1.NO_INTERSECTION\n  };\n  RobustLineIntersector.prototype.normalizeToEnvCentre = function normalizeToEnvCentre (n00, n01, n10, n11, normPt) {\n    var minX0 = n00.x < n01.x ? n00.x : n01.x;\n    var minY0 = n00.y < n01.y ? n00.y : n01.y;\n    var maxX0 = n00.x > n01.x ? n00.x : n01.x;\n    var maxY0 = n00.y > n01.y ? n00.y : n01.y;\n    var minX1 = n10.x < n11.x ? n10.x : n11.x;\n    var minY1 = n10.y < n11.y ? n10.y : n11.y;\n    var maxX1 = n10.x > n11.x ? n10.x : n11.x;\n    var maxY1 = n10.y > n11.y ? n10.y : n11.y;\n    var intMinX = minX0 > minX1 ? minX0 : minX1;\n    var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n    var intMinY = minY0 > minY1 ? minY0 : minY1;\n    var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n    var intMidX = (intMinX + intMaxX) / 2.0;\n    var intMidY = (intMinY + intMaxY) / 2.0;\n    normPt.x = intMidX;\n    normPt.y = intMidY;\n    n00.x -= normPt.x;\n    n00.y -= normPt.y;\n    n01.x -= normPt.x;\n    n01.y -= normPt.y;\n    n10.x -= normPt.x;\n    n10.y -= normPt.y;\n    n11.x -= normPt.x;\n    n11.y -= normPt.y;\n  };\n  RobustLineIntersector.prototype.computeIntersect = function computeIntersect (p1, p2, q1, q2) {\n    this._isProper = false;\n    if (!Envelope.intersects(p1, p2, q1, q2)) { return LineIntersector$$1.NO_INTERSECTION }\n    var Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);\n    var Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);\n    if ((Pq1 > 0 && Pq2 > 0) || (Pq1 < 0 && Pq2 < 0)) {\n      return LineIntersector$$1.NO_INTERSECTION\n    }\n    var Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);\n    var Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);\n    if ((Qp1 > 0 && Qp2 > 0) || (Qp1 < 0 && Qp2 < 0)) {\n      return LineIntersector$$1.NO_INTERSECTION\n    }\n    var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n    if (collinear) {\n      return this.computeCollinearIntersection(p1, p2, q1, q2)\n    }\n    if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n      this._isProper = false;\n      if (p1.equals2D(q1) || p1.equals2D(q2)) {\n        this._intPt[0] = p1;\n      } else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n        this._intPt[0] = p2;\n      } else if (Pq1 === 0) {\n        this._intPt[0] = new Coordinate(q1);\n      } else if (Pq2 === 0) {\n        this._intPt[0] = new Coordinate(q2);\n      } else if (Qp1 === 0) {\n        this._intPt[0] = new Coordinate(p1);\n      } else if (Qp2 === 0) {\n        this._intPt[0] = new Coordinate(p2);\n      }\n    } else {\n      this._isProper = true;\n      this._intPt[0] = this.intersection(p1, p2, q1, q2);\n    }\n    return LineIntersector$$1.POINT_INTERSECTION\n  };\n  RobustLineIntersector.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  RobustLineIntersector.prototype.getClass = function getClass () {\n    return RobustLineIntersector\n  };\n  RobustLineIntersector.nearestEndpoint = function nearestEndpoint (p1, p2, q1, q2) {\n    var nearestPt = p1;\n    var minDist = CGAlgorithms.distancePointLine(p1, q1, q2);\n    var dist = CGAlgorithms.distancePointLine(p2, q1, q2);\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = p2;\n    }\n    dist = CGAlgorithms.distancePointLine(q1, p1, p2);\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = q1;\n    }\n    dist = CGAlgorithms.distancePointLine(q2, p1, p2);\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = q2;\n    }\n    return nearestPt\n  };\n\n  return RobustLineIntersector;\n}(LineIntersector));\n\nvar RobustDeterminant = function RobustDeterminant () {};\n\nRobustDeterminant.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nRobustDeterminant.prototype.getClass = function getClass () {\n  return RobustDeterminant\n};\nRobustDeterminant.orientationIndex = function orientationIndex (p1, p2, q) {\n  var dx1 = p2.x - p1.x;\n  var dy1 = p2.y - p1.y;\n  var dx2 = q.x - p2.x;\n  var dy2 = q.y - p2.y;\n  return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2)\n};\nRobustDeterminant.signOfDet2x2 = function signOfDet2x2 (x1, y1, x2, y2) {\n  var sign = null;\n  var swap = null;\n  var k = null;\n  sign = 1;\n  if (x1 === 0.0 || y2 === 0.0) {\n    if (y1 === 0.0 || x2 === 0.0) {\n      return 0\n    } else if (y1 > 0) {\n      if (x2 > 0) {\n        return -sign\n      } else {\n        return sign\n      }\n    } else {\n      if (x2 > 0) {\n        return sign\n      } else {\n        return -sign\n      }\n    }\n  }\n  if (y1 === 0.0 || x2 === 0.0) {\n    if (y2 > 0) {\n      if (x1 > 0) {\n        return sign\n      } else {\n        return -sign\n      }\n    } else {\n      if (x1 > 0) {\n        return -sign\n      } else {\n        return sign\n      }\n    }\n  }\n  if (y1 > 0.0) {\n    if (y2 > 0.0) {\n      if (y1 <= y2) {\n        \n      } else {\n        sign = -sign;\n        swap = x1;\n        x1 = x2;\n        x2 = swap;\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n      }\n    } else {\n      if (y1 <= -y2) {\n        sign = -sign;\n        x2 = -x2;\n        y2 = -y2;\n      } else {\n        swap = x1;\n        x1 = -x2;\n        x2 = swap;\n        swap = y1;\n        y1 = -y2;\n        y2 = swap;\n      }\n    }\n  } else {\n    if (y2 > 0.0) {\n      if (-y1 <= y2) {\n        sign = -sign;\n        x1 = -x1;\n        y1 = -y1;\n      } else {\n        swap = -x1;\n        x1 = x2;\n        x2 = swap;\n        swap = -y1;\n        y1 = y2;\n        y2 = swap;\n      }\n    } else {\n      if (y1 >= y2) {\n        x1 = -x1;\n        y1 = -y1;\n        x2 = -x2;\n        y2 = -y2;\n      } else {\n        sign = -sign;\n        swap = -x1;\n        x1 = -x2;\n        x2 = swap;\n        swap = -y1;\n        y1 = -y2;\n        y2 = swap;\n      }\n    }\n  }\n  if (x1 > 0.0) {\n    if (x2 > 0.0) {\n      if (x1 <= x2) {\n        \n      } else {\n        return sign\n      }\n    } else {\n      return sign\n    }\n  } else {\n    if (x2 > 0.0) {\n      return -sign\n    } else {\n      if (x1 >= x2) {\n        sign = -sign;\n        x1 = -x1;\n        x2 = -x2;\n      } else {\n        return -sign\n      }\n    }\n  }\n  while (true) {\n    k = Math.floor(x2 / x1);\n    x2 = x2 - k * x1;\n    y2 = y2 - k * y1;\n    if (y2 < 0.0) {\n      return -sign\n    }\n    if (y2 > y1) {\n      return sign\n    }\n    if (x1 > x2 + x2) {\n      if (y1 < y2 + y2) {\n        return sign\n      }\n    } else {\n      if (y1 > y2 + y2) {\n        return -sign\n      } else {\n        x2 = x1 - x2;\n        y2 = y1 - y2;\n        sign = -sign;\n      }\n    }\n    if (y2 === 0.0) {\n      if (x2 === 0.0) {\n        return 0\n      } else {\n        return -sign\n      }\n    }\n    if (x2 === 0.0) {\n      return sign\n    }\n    k = Math.floor(x1 / x2);\n    x1 = x1 - k * x2;\n    y1 = y1 - k * y2;\n    if (y1 < 0.0) {\n      return sign\n    }\n    if (y1 > y2) {\n      return -sign\n    }\n    if (x2 > x1 + x1) {\n      if (y2 < y1 + y1) {\n        return -sign\n      }\n    } else {\n      if (y2 > y1 + y1) {\n        return sign\n      } else {\n        x1 = x2 - x1;\n        y1 = y2 - y1;\n        sign = -sign;\n      }\n    }\n    if (y1 === 0.0) {\n      if (x1 === 0.0) {\n        return 0\n      } else {\n        return sign\n      }\n    }\n    if (x1 === 0.0) {\n      return -sign\n    }\n  }\n};\n\nvar RayCrossingCounter = function RayCrossingCounter () {\n  this._p = null;\n  this._crossingCount = 0;\n  this._isPointOnSegment = false;\n  var p = arguments[0];\n  this._p = p;\n};\nRayCrossingCounter.prototype.countSegment = function countSegment (p1, p2) {\n  if (p1.x < this._p.x && p2.x < this._p.x) { return null }\n  if (this._p.x === p2.x && this._p.y === p2.y) {\n    this._isPointOnSegment = true;\n    return null\n  }\n  if (p1.y === this._p.y && p2.y === this._p.y) {\n    var minx = p1.x;\n    var maxx = p2.x;\n    if (minx > maxx) {\n      minx = p2.x;\n      maxx = p1.x;\n    }\n    if (this._p.x >= minx && this._p.x <= maxx) {\n      this._isPointOnSegment = true;\n    }\n    return null\n  }\n  if ((p1.y > this._p.y && p2.y <= this._p.y) || (p2.y > this._p.y && p1.y <= this._p.y)) {\n    var x1 = p1.x - this._p.x;\n    var y1 = p1.y - this._p.y;\n    var x2 = p2.x - this._p.x;\n    var y2 = p2.y - this._p.y;\n    var xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);\n    if (xIntSign === 0.0) {\n      this._isPointOnSegment = true;\n      return null\n    }\n    if (y2 < y1) { xIntSign = -xIntSign; }\n    if (xIntSign > 0.0) {\n      this._crossingCount++;\n    }\n  }\n};\nRayCrossingCounter.prototype.isPointInPolygon = function isPointInPolygon () {\n  return this.getLocation() !== Location.EXTERIOR\n};\nRayCrossingCounter.prototype.getLocation = function getLocation () {\n  if (this._isPointOnSegment) { return Location.BOUNDARY }\n  if (this._crossingCount % 2 === 1) {\n    return Location.INTERIOR\n  }\n  return Location.EXTERIOR\n};\nRayCrossingCounter.prototype.isOnSegment = function isOnSegment () {\n  return this._isPointOnSegment\n};\nRayCrossingCounter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nRayCrossingCounter.prototype.getClass = function getClass () {\n  return RayCrossingCounter\n};\nRayCrossingCounter.locatePointInRing = function locatePointInRing () {\n  if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n    var p = arguments[0];\n    var ring = arguments[1];\n    var counter = new RayCrossingCounter(p);\n    var p1 = new Coordinate();\n    var p2 = new Coordinate();\n    for (var i = 1; i < ring.size(); i++) {\n      ring.getCoordinate(i, p1);\n      ring.getCoordinate(i - 1, p2);\n      counter.countSegment(p1, p2);\n      if (counter.isOnSegment()) { return counter.getLocation() }\n    }\n    return counter.getLocation()\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n    var p$1 = arguments[0];\n    var ring$1 = arguments[1];\n    var counter$1 = new RayCrossingCounter(p$1);\n    for (var i$1 = 1; i$1 < ring$1.length; i$1++) {\n      var p1$1 = ring$1[i$1];\n      var p2$1 = ring$1[i$1 - 1];\n      counter$1.countSegment(p1$1, p2$1);\n      if (counter$1.isOnSegment()) { return counter$1.getLocation() }\n    }\n    return counter$1.getLocation()\n  }\n};\n\nvar CGAlgorithms = function CGAlgorithms () {};\n\nvar staticAccessors$3 = { CLOCKWISE: { configurable: true },RIGHT: { configurable: true },COUNTERCLOCKWISE: { configurable: true },LEFT: { configurable: true },COLLINEAR: { configurable: true },STRAIGHT: { configurable: true } };\n\nCGAlgorithms.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCGAlgorithms.prototype.getClass = function getClass () {\n  return CGAlgorithms\n};\nCGAlgorithms.orientationIndex = function orientationIndex (p1, p2, q) {\n  return CGAlgorithmsDD.orientationIndex(p1, p2, q)\n};\nCGAlgorithms.signedArea = function signedArea () {\n  if (arguments[0] instanceof Array) {\n    var ring = arguments[0];\n    if (ring.length < 3) { return 0.0 }\n    var sum = 0.0;\n    var x0 = ring[0].x;\n    for (var i = 1; i < ring.length - 1; i++) {\n      var x = ring[i].x - x0;\n      var y1 = ring[i + 1].y;\n      var y2 = ring[i - 1].y;\n      sum += x * (y2 - y1);\n    }\n    return sum / 2.0\n  } else if (hasInterface(arguments[0], CoordinateSequence)) {\n    var ring$1 = arguments[0];\n    var n = ring$1.size();\n    if (n < 3) { return 0.0 }\n    var p0 = new Coordinate();\n    var p1 = new Coordinate();\n    var p2 = new Coordinate();\n    ring$1.getCoordinate(0, p1);\n    ring$1.getCoordinate(1, p2);\n    var x0$1 = p1.x;\n    p2.x -= x0$1;\n    var sum$1 = 0.0;\n    for (var i$1 = 1; i$1 < n - 1; i$1++) {\n      p0.y = p1.y;\n      p1.x = p2.x;\n      p1.y = p2.y;\n      ring$1.getCoordinate(i$1 + 1, p2);\n      p2.x -= x0$1;\n      sum$1 += p1.x * (p0.y - p2.y);\n    }\n    return sum$1 / 2.0\n  }\n};\nCGAlgorithms.distanceLineLine = function distanceLineLine (A, B, C, D) {\n  if (A.equals(B)) { return CGAlgorithms.distancePointLine(A, C, D) }\n  if (C.equals(D)) { return CGAlgorithms.distancePointLine(D, A, B) }\n  var noIntersection = false;\n  if (!Envelope.intersects(A, B, C, D)) {\n    noIntersection = true;\n  } else {\n    var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n    if (denom === 0) {\n      noIntersection = true;\n    } else {\n      var rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n      var sNum = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n      var s = sNum / denom;\n      var r = rNumb / denom;\n      if (r < 0 || r > 1 || s < 0 || s > 1) {\n        noIntersection = true;\n      }\n    }\n  }\n  if (noIntersection) {\n    return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B))\n  }\n  return 0.0\n};\nCGAlgorithms.isPointInRing = function isPointInRing (p, ring) {\n  return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR\n};\nCGAlgorithms.computeLength = function computeLength (pts) {\n  var n = pts.size();\n  if (n <= 1) { return 0.0 }\n  var len = 0.0;\n  var p = new Coordinate();\n  pts.getCoordinate(0, p);\n  var x0 = p.x;\n  var y0 = p.y;\n  for (var i = 1; i < n; i++) {\n    pts.getCoordinate(i, p);\n    var x1 = p.x;\n    var y1 = p.y;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    len += Math.sqrt(dx * dx + dy * dy);\n    x0 = x1;\n    y0 = y1;\n  }\n  return len\n};\nCGAlgorithms.isCCW = function isCCW (ring) {\n  var nPts = ring.length - 1;\n  if (nPts < 3) { throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined') }\n  var hiPt = ring[0];\n  var hiIndex = 0;\n  for (var i = 1; i <= nPts; i++) {\n    var p = ring[i];\n    if (p.y > hiPt.y) {\n      hiPt = p;\n      hiIndex = i;\n    }\n  }\n  var iPrev = hiIndex;\n  do {\n    iPrev = iPrev - 1;\n    if (iPrev < 0) { iPrev = nPts; }\n  } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex)\n  var iNext = hiIndex;\n  do {\n    iNext = (iNext + 1) % nPts;\n  } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex)\n  var prev = ring[iPrev];\n  var next = ring[iNext];\n  if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) { return false }\n  var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);\n  var isCCW = false;\n  if (disc === 0) {\n    isCCW = prev.x > next.x;\n  } else {\n    isCCW = disc > 0;\n  }\n  return isCCW\n};\nCGAlgorithms.locatePointInRing = function locatePointInRing (p, ring) {\n  return RayCrossingCounter.locatePointInRing(p, ring)\n};\nCGAlgorithms.distancePointLinePerpendicular = function distancePointLinePerpendicular (p, A, B) {\n  var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  return Math.abs(s) * Math.sqrt(len2)\n};\nCGAlgorithms.computeOrientation = function computeOrientation (p1, p2, q) {\n  return CGAlgorithms.orientationIndex(p1, p2, q)\n};\nCGAlgorithms.distancePointLine = function distancePointLine () {\n  if (arguments.length === 2) {\n    var p = arguments[0];\n    var line = arguments[1];\n    if (line.length === 0) { throw new IllegalArgumentException('Line array must contain at least one vertex') }\n    var minDistance = p.distance(line[0]);\n    for (var i = 0; i < line.length - 1; i++) {\n      var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);\n      if (dist < minDistance) {\n        minDistance = dist;\n      }\n    }\n    return minDistance\n  } else if (arguments.length === 3) {\n    var p$1 = arguments[0];\n    var A = arguments[1];\n    var B = arguments[2];\n    if (A.x === B.x && A.y === B.y) { return p$1.distance(A) }\n    var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n    var r = ((p$1.x - A.x) * (B.x - A.x) + (p$1.y - A.y) * (B.y - A.y)) / len2;\n    if (r <= 0.0) { return p$1.distance(A) }\n    if (r >= 1.0) { return p$1.distance(B) }\n    var s = ((A.y - p$1.y) * (B.x - A.x) - (A.x - p$1.x) * (B.y - A.y)) / len2;\n    return Math.abs(s) * Math.sqrt(len2)\n  }\n};\nCGAlgorithms.isOnLine = function isOnLine (p, pt) {\n  var lineIntersector = new RobustLineIntersector();\n  for (var i = 1; i < pt.length; i++) {\n    var p0 = pt[i - 1];\n    var p1 = pt[i];\n    lineIntersector.computeIntersection(p, p0, p1);\n    if (lineIntersector.hasIntersection()) {\n      return true\n    }\n  }\n  return false\n};\nstaticAccessors$3.CLOCKWISE.get = function () { return -1 };\nstaticAccessors$3.RIGHT.get = function () { return CGAlgorithms.CLOCKWISE };\nstaticAccessors$3.COUNTERCLOCKWISE.get = function () { return 1 };\nstaticAccessors$3.LEFT.get = function () { return CGAlgorithms.COUNTERCLOCKWISE };\nstaticAccessors$3.COLLINEAR.get = function () { return 0 };\nstaticAccessors$3.STRAIGHT.get = function () { return CGAlgorithms.COLLINEAR };\n\nObject.defineProperties( CGAlgorithms, staticAccessors$3 );\n\nvar GeometryComponentFilter = function GeometryComponentFilter () {};\n\nGeometryComponentFilter.prototype.filter = function filter (geom) {};\nGeometryComponentFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryComponentFilter.prototype.getClass = function getClass () {\n  return GeometryComponentFilter\n};\n\nvar Geometry = function Geometry () {\n  var factory = arguments[0];\n\n  this._envelope = null;\n  this._factory = null;\n  this._SRID = null;\n  this._userData = null;\n  this._factory = factory;\n  this._SRID = factory.getSRID();\n};\n\nvar staticAccessors$11 = { serialVersionUID: { configurable: true },SORTINDEX_POINT: { configurable: true },SORTINDEX_MULTIPOINT: { configurable: true },SORTINDEX_LINESTRING: { configurable: true },SORTINDEX_LINEARRING: { configurable: true },SORTINDEX_MULTILINESTRING: { configurable: true },SORTINDEX_POLYGON: { configurable: true },SORTINDEX_MULTIPOLYGON: { configurable: true },SORTINDEX_GEOMETRYCOLLECTION: { configurable: true },geometryChangedFilter: { configurable: true } };\nGeometry.prototype.isGeometryCollection = function isGeometryCollection () {\n  return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION\n};\nGeometry.prototype.getFactory = function getFactory () {\n  return this._factory\n};\nGeometry.prototype.getGeometryN = function getGeometryN (n) {\n  return this\n};\nGeometry.prototype.getArea = function getArea () {\n  return 0.0\n};\nGeometry.prototype.isRectangle = function isRectangle () {\n  return false\n};\nGeometry.prototype.equals = function equals () {\n  if (arguments[0] instanceof Geometry) {\n    var g$1 = arguments[0];\n    if (g$1 === null) { return false }\n    return this.equalsTopo(g$1)\n  } else if (arguments[0] instanceof Object) {\n    var o = arguments[0];\n    if (!(o instanceof Geometry)) { return false }\n    var g = o;\n    return this.equalsExact(g)\n  }\n};\nGeometry.prototype.equalsExact = function equalsExact (other) {\n  return this === other || this.equalsExact(other, 0)\n};\nGeometry.prototype.geometryChanged = function geometryChanged () {\n  this.apply(Geometry.geometryChangedFilter);\n};\nGeometry.prototype.geometryChangedAction = function geometryChangedAction () {\n  this._envelope = null;\n};\nGeometry.prototype.equalsNorm = function equalsNorm (g) {\n  if (g === null) { return false }\n  return this.norm().equalsExact(g.norm())\n};\nGeometry.prototype.getLength = function getLength () {\n  return 0.0\n};\nGeometry.prototype.getNumGeometries = function getNumGeometries () {\n  return 1\n};\nGeometry.prototype.compareTo = function compareTo () {\n  if (arguments.length === 1) {\n    var o = arguments[0];\n    var other = o;\n    if (this.getSortIndex() !== other.getSortIndex()) {\n      return this.getSortIndex() - other.getSortIndex()\n    }\n    if (this.isEmpty() && other.isEmpty()) {\n      return 0\n    }\n    if (this.isEmpty()) {\n      return -1\n    }\n    if (other.isEmpty()) {\n      return 1\n    }\n    return this.compareToSameClass(o)\n  } else if (arguments.length === 2) {\n    var other$1 = arguments[0];\n    var comp = arguments[1];\n    if (this.getSortIndex() !== other$1.getSortIndex()) {\n      return this.getSortIndex() - other$1.getSortIndex()\n    }\n    if (this.isEmpty() && other$1.isEmpty()) {\n      return 0\n    }\n    if (this.isEmpty()) {\n      return -1\n    }\n    if (other$1.isEmpty()) {\n      return 1\n    }\n    return this.compareToSameClass(other$1, comp)\n  }\n};\nGeometry.prototype.getUserData = function getUserData () {\n  return this._userData\n};\nGeometry.prototype.getSRID = function getSRID () {\n  return this._SRID\n};\nGeometry.prototype.getEnvelope = function getEnvelope () {\n  return this.getFactory().toGeometry(this.getEnvelopeInternal())\n};\nGeometry.prototype.checkNotGeometryCollection = function checkNotGeometryCollection (g) {\n  if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {\n    throw new IllegalArgumentException('This method does not support GeometryCollection arguments')\n  }\n};\nGeometry.prototype.equal = function equal (a, b, tolerance) {\n  if (tolerance === 0) {\n    return a.equals(b)\n  }\n  return a.distance(b) <= tolerance\n};\nGeometry.prototype.norm = function norm () {\n  var copy = this.copy();\n  copy.normalize();\n  return copy\n};\nGeometry.prototype.getPrecisionModel = function getPrecisionModel () {\n  return this._factory.getPrecisionModel()\n};\nGeometry.prototype.getEnvelopeInternal = function getEnvelopeInternal () {\n  if (this._envelope === null) {\n    this._envelope = this.computeEnvelopeInternal();\n  }\n  return new Envelope(this._envelope)\n};\nGeometry.prototype.setSRID = function setSRID (SRID) {\n  this._SRID = SRID;\n};\nGeometry.prototype.setUserData = function setUserData (userData) {\n  this._userData = userData;\n};\nGeometry.prototype.compare = function compare (a, b) {\n  var i = a.iterator();\n  var j = b.iterator();\n  while (i.hasNext() && j.hasNext()) {\n    var aElement = i.next();\n    var bElement = j.next();\n    var comparison = aElement.compareTo(bElement);\n    if (comparison !== 0) {\n      return comparison\n    }\n  }\n  if (i.hasNext()) {\n    return 1\n  }\n  if (j.hasNext()) {\n    return -1\n  }\n  return 0\n};\nGeometry.prototype.hashCode = function hashCode () {\n  return this.getEnvelopeInternal().hashCode()\n};\nGeometry.prototype.isGeometryCollectionOrDerived = function isGeometryCollectionOrDerived () {\n  if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {\n    return true\n  }\n  return false\n};\nGeometry.prototype.interfaces_ = function interfaces_ () {\n  return [Clonable, Comparable, Serializable]\n};\nGeometry.prototype.getClass = function getClass () {\n  return Geometry\n};\nGeometry.hasNonEmptyElements = function hasNonEmptyElements (geometries) {\n  for (var i = 0; i < geometries.length; i++) {\n    if (!geometries[i].isEmpty()) {\n      return true\n    }\n  }\n  return false\n};\nGeometry.hasNullElements = function hasNullElements (array) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === null) {\n      return true\n    }\n  }\n  return false\n};\nstaticAccessors$11.serialVersionUID.get = function () { return 8763622679187376702 };\nstaticAccessors$11.SORTINDEX_POINT.get = function () { return 0 };\nstaticAccessors$11.SORTINDEX_MULTIPOINT.get = function () { return 1 };\nstaticAccessors$11.SORTINDEX_LINESTRING.get = function () { return 2 };\nstaticAccessors$11.SORTINDEX_LINEARRING.get = function () { return 3 };\nstaticAccessors$11.SORTINDEX_MULTILINESTRING.get = function () { return 4 };\nstaticAccessors$11.SORTINDEX_POLYGON.get = function () { return 5 };\nstaticAccessors$11.SORTINDEX_MULTIPOLYGON.get = function () { return 6 };\nstaticAccessors$11.SORTINDEX_GEOMETRYCOLLECTION.get = function () { return 7 };\nstaticAccessors$11.geometryChangedFilter.get = function () { return geometryChangedFilter };\n\nObject.defineProperties( Geometry, staticAccessors$11 );\n\nvar geometryChangedFilter = function geometryChangedFilter () {};\n\ngeometryChangedFilter.interfaces_ = function interfaces_ () {\n  return [GeometryComponentFilter]\n};\ngeometryChangedFilter.filter = function filter (geom) {\n  geom.geometryChangedAction();\n};\n\nvar CoordinateFilter = function CoordinateFilter () {};\n\nCoordinateFilter.prototype.filter = function filter (coord) {};\nCoordinateFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateFilter.prototype.getClass = function getClass () {\n  return CoordinateFilter\n};\n\nvar BoundaryNodeRule = function BoundaryNodeRule () {};\n\nvar staticAccessors$12 = { Mod2BoundaryNodeRule: { configurable: true },EndPointBoundaryNodeRule: { configurable: true },MultiValentEndPointBoundaryNodeRule: { configurable: true },MonoValentEndPointBoundaryNodeRule: { configurable: true },MOD2_BOUNDARY_RULE: { configurable: true },ENDPOINT_BOUNDARY_RULE: { configurable: true },MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true },MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true },OGC_SFS_BOUNDARY_RULE: { configurable: true } };\n\nBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {};\nBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBoundaryNodeRule.prototype.getClass = function getClass () {\n  return BoundaryNodeRule\n};\nstaticAccessors$12.Mod2BoundaryNodeRule.get = function () { return Mod2BoundaryNodeRule };\nstaticAccessors$12.EndPointBoundaryNodeRule.get = function () { return EndPointBoundaryNodeRule };\nstaticAccessors$12.MultiValentEndPointBoundaryNodeRule.get = function () { return MultiValentEndPointBoundaryNodeRule };\nstaticAccessors$12.MonoValentEndPointBoundaryNodeRule.get = function () { return MonoValentEndPointBoundaryNodeRule };\nstaticAccessors$12.MOD2_BOUNDARY_RULE.get = function () { return new Mod2BoundaryNodeRule() };\nstaticAccessors$12.ENDPOINT_BOUNDARY_RULE.get = function () { return new EndPointBoundaryNodeRule() };\nstaticAccessors$12.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new MultiValentEndPointBoundaryNodeRule() };\nstaticAccessors$12.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new MonoValentEndPointBoundaryNodeRule() };\nstaticAccessors$12.OGC_SFS_BOUNDARY_RULE.get = function () { return BoundaryNodeRule.MOD2_BOUNDARY_RULE };\n\nObject.defineProperties( BoundaryNodeRule, staticAccessors$12 );\n\nvar Mod2BoundaryNodeRule = function Mod2BoundaryNodeRule () {};\n\nMod2BoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount % 2 === 1\n};\nMod2BoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nMod2BoundaryNodeRule.prototype.getClass = function getClass () {\n  return Mod2BoundaryNodeRule\n};\n\nvar EndPointBoundaryNodeRule = function EndPointBoundaryNodeRule () {};\n\nEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount > 0\n};\nEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nEndPointBoundaryNodeRule.prototype.getClass = function getClass () {\n  return EndPointBoundaryNodeRule\n};\n\nvar MultiValentEndPointBoundaryNodeRule = function MultiValentEndPointBoundaryNodeRule () {};\n\nMultiValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount > 1\n};\nMultiValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nMultiValentEndPointBoundaryNodeRule.prototype.getClass = function getClass () {\n  return MultiValentEndPointBoundaryNodeRule\n};\n\nvar MonoValentEndPointBoundaryNodeRule = function MonoValentEndPointBoundaryNodeRule () {};\n\nMonoValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount === 1\n};\nMonoValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nMonoValentEndPointBoundaryNodeRule.prototype.getClass = function getClass () {\n  return MonoValentEndPointBoundaryNodeRule\n};\n\n// import Iterator from './Iterator'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n *\n * @constructor\n * @private\n */\nvar Collection = function Collection () {};\n\nCollection.prototype.add = function add () {};\n\n/**\n * Appends all of the elements in the specified collection to the end of this\n * list, in the order that they are returned by the specified collection's\n * iterator (optional operation).\n * @param {javascript.util.Collection} c\n * @return {boolean}\n */\nCollection.prototype.addAll = function addAll () {};\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nCollection.prototype.isEmpty = function isEmpty () {};\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {javascript.util.Iterator}\n */\nCollection.prototype.iterator = function iterator () {};\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {number}\n */\nCollection.prototype.size = function size () {};\n\n/**\n * Returns an array containing all of the elements in this collection.\n * @return {Array}\n */\nCollection.prototype.toArray = function toArray () {};\n\n/**\n * Removes a single instance of the specified element from this collection if it\n * is present. (optional)\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.remove = function remove () {};\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction IndexOutOfBoundsException (message) {\n  this.message = message || '';\n}\nIndexOutOfBoundsException.prototype = new Error();\n\n/**\n * @type {string}\n */\nIndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nvar Iterator = function Iterator () {};\n\nIterator.prototype.hasNext = function hasNext () {};\n\n/**\n * Returns the next element in the iteration.\n * @return {Object}\n */\nIterator.prototype.next = function next () {};\n\n/**\n * Removes from the underlying collection the last element returned by the\n * iterator (optional operation).\n */\nIterator.prototype.remove = function remove () {};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n *\n * @extends {javascript.util.Collection}\n * @constructor\n * @private\n */\nvar List = (function (Collection$$1) {\n  function List () {\n    Collection$$1.apply(this, arguments);\n  }\n\n  if ( Collection$$1 ) List.__proto__ = Collection$$1;\n  List.prototype = Object.create( Collection$$1 && Collection$$1.prototype );\n  List.prototype.constructor = List;\n\n  List.prototype.get = function get () { };\n\n  /**\n   * Replaces the element at the specified position in this list with the\n   * specified element (optional operation).\n   * @param {number} index\n   * @param {Object} e\n   * @return {Object}\n   */\n  List.prototype.set = function set () { };\n\n  /**\n   * Returns true if this collection contains no elements.\n   * @return {boolean}\n   */\n  List.prototype.isEmpty = function isEmpty () { };\n\n  return List;\n}(Collection));\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction NoSuchElementException (message) {\n  this.message = message || '';\n}\nNoSuchElementException.prototype = new Error();\n\n/**\n * @type {string}\n */\nNoSuchElementException.prototype.name = 'NoSuchElementException';\n\n// import OperationNotSupported from './OperationNotSupported'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n *\n * @extends List\n * @private\n */\nvar ArrayList = (function (List$$1) {\n  function ArrayList () {\n    List$$1.call(this);\n    this.array_ = [];\n\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }\n\n  if ( List$$1 ) ArrayList.__proto__ = List$$1;\n  ArrayList.prototype = Object.create( List$$1 && List$$1.prototype );\n  ArrayList.prototype.constructor = ArrayList;\n\n  ArrayList.prototype.ensureCapacity = function ensureCapacity () {};\n  ArrayList.prototype.interfaces_ = function interfaces_ () { return [List$$1, Collection] };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.add = function add (e) {\n    if (arguments.length === 1) {\n      this.array_.push(e);\n    } else {\n      this.array_.splice(arguments[0], arguments[1]);\n    }\n    return true\n  };\n\n  ArrayList.prototype.clear = function clear () {\n    this.array_ = [];\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.addAll = function addAll (c) {\n    var this$1 = this;\n\n    for (var i = c.iterator(); i.hasNext();) {\n      this$1.add(i.next());\n    }\n    return true\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.set = function set (index, element) {\n    var oldElement = this.array_[index];\n    this.array_[index] = element;\n    return oldElement\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.iterator = function iterator () {\n    return new Iterator_(this)\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.get = function get (index) {\n    if (index < 0 || index >= this.size()) {\n      throw new IndexOutOfBoundsException()\n    }\n\n    return this.array_[index]\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.isEmpty = function isEmpty () {\n    return this.array_.length === 0\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.size = function size () {\n    return this.array_.length\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.toArray = function toArray () {\n    var this$1 = this;\n\n    var array = [];\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this$1.array_[i]);\n    }\n\n    return array\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.remove = function remove (o) {\n    var this$1 = this;\n\n    var found = false;\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      if (this$1.array_[i] === o) {\n        this$1.array_.splice(i, 1);\n        found = true;\n        break\n      }\n    }\n\n    return found\n  };\n\n  return ArrayList;\n}(List));\n\n/**\n * @extends {Iterator}\n * @param {ArrayList} arrayList\n * @constructor\n * @private\n */\nvar Iterator_ = (function (Iterator$$1) {\n  function Iterator_ (arrayList) {\n    Iterator$$1.call(this);\n    /**\n     * @type {ArrayList}\n     * @private\n    */\n    this.arrayList_ = arrayList;\n    /**\n     * @type {number}\n     * @private\n    */\n    this.position_ = 0;\n  }\n\n  if ( Iterator$$1 ) Iterator_.__proto__ = Iterator$$1;\n  Iterator_.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n  Iterator_.prototype.constructor = Iterator_;\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.next = function next () {\n    if (this.position_ === this.arrayList_.size()) {\n      throw new NoSuchElementException()\n    }\n    return this.arrayList_.get(this.position_++)\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.hasNext = function hasNext () {\n    if (this.position_ < this.arrayList_.size()) {\n      return true\n    } else {\n      return false\n    }\n  };\n\n  /**\n   * TODO: should be in ListIterator\n   * @override\n   */\n  Iterator_.prototype.set = function set (element) {\n    return this.arrayList_.set(this.position_ - 1, element)\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.remove = function remove () {\n    this.arrayList_.remove(this.arrayList_.get(this.position_));\n  };\n\n  return Iterator_;\n}(Iterator));\n\nvar CoordinateList = (function (ArrayList$$1) {\n  function CoordinateList () {\n    ArrayList$$1.call(this);\n    if (arguments.length === 0) {\n    } else if (arguments.length === 1) {\n      var coord = arguments[0];\n      this.ensureCapacity(coord.length);\n      this.add(coord, true);\n    } else if (arguments.length === 2) {\n      var coord$1 = arguments[0];\n      var allowRepeated = arguments[1];\n      this.ensureCapacity(coord$1.length);\n      this.add(coord$1, allowRepeated);\n    }\n  }\n\n  if ( ArrayList$$1 ) CoordinateList.__proto__ = ArrayList$$1;\n  CoordinateList.prototype = Object.create( ArrayList$$1 && ArrayList$$1.prototype );\n  CoordinateList.prototype.constructor = CoordinateList;\n\n  var staticAccessors = { coordArrayType: { configurable: true } };\n  staticAccessors.coordArrayType.get = function () { return new Array(0).fill(null) };\n  CoordinateList.prototype.getCoordinate = function getCoordinate (i) {\n    return this.get(i)\n  };\n  CoordinateList.prototype.addAll = function addAll () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var coll = arguments[0];\n      var allowRepeated = arguments[1];\n      var isChanged = false;\n      for (var i = coll.iterator(); i.hasNext();) {\n        this$1.add(i.next(), allowRepeated);\n        isChanged = true;\n      }\n      return isChanged\n    } else { return ArrayList$$1.prototype.addAll.apply(this, arguments) }\n  };\n  CoordinateList.prototype.clone = function clone () {\n    var this$1 = this;\n\n    var clone = ArrayList$$1.prototype.clone.call(this);\n    for (var i = 0; i < this.size(); i++) {\n      clone.add(i, this$1.get(i).copy());\n    }\n    return clone\n  };\n  CoordinateList.prototype.toCoordinateArray = function toCoordinateArray () {\n    return this.toArray(CoordinateList.coordArrayType)\n  };\n  CoordinateList.prototype.add = function add () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var coord = arguments[0];\n      ArrayList$$1.prototype.add.call(this, coord);\n    } else if (arguments.length === 2) {\n      if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {\n        var coord$1 = arguments[0];\n        var allowRepeated = arguments[1];\n        this.add(coord$1, allowRepeated, true);\n        return true\n      } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === 'boolean') {\n        var coord$2 = arguments[0];\n        var allowRepeated$1 = arguments[1];\n        if (!allowRepeated$1) {\n          if (this.size() >= 1) {\n            var last = this.get(this.size() - 1);\n            if (last.equals2D(coord$2)) { return null }\n          }\n        }\n        ArrayList$$1.prototype.add.call(this, coord$2);\n      } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {\n        var obj = arguments[0];\n        var allowRepeated$2 = arguments[1];\n        this.add(obj, allowRepeated$2);\n        return true\n      }\n    } else if (arguments.length === 3) {\n      if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Array && typeof arguments[1] === 'boolean')) {\n        var coord$3 = arguments[0];\n        var allowRepeated$3 = arguments[1];\n        var direction = arguments[2];\n        if (direction) {\n          for (var i$1 = 0; i$1 < coord$3.length; i$1++) {\n            this$1.add(coord$3[i$1], allowRepeated$3);\n          }\n        } else {\n          for (var i$2 = coord$3.length - 1; i$2 >= 0; i$2--) {\n            this$1.add(coord$3[i$2], allowRepeated$3);\n          }\n        }\n        return true\n      } else if (typeof arguments[2] === 'boolean' && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {\n        var i$3 = arguments[0];\n        var coord$4 = arguments[1];\n        var allowRepeated$4 = arguments[2];\n        if (!allowRepeated$4) {\n          var size = this.size();\n          if (size > 0) {\n            if (i$3 > 0) {\n              var prev = this.get(i$3 - 1);\n              if (prev.equals2D(coord$4)) { return null }\n            }\n            if (i$3 < size) {\n              var next = this.get(i$3);\n              if (next.equals2D(coord$4)) { return null }\n            }\n          }\n        }\n        ArrayList$$1.prototype.add.call(this, i$3, coord$4);\n      }\n    } else if (arguments.length === 4) {\n      var coord$5 = arguments[0];\n      var allowRepeated$5 = arguments[1];\n      var start = arguments[2];\n      var end = arguments[3];\n      var inc = 1;\n      if (start > end) { inc = -1; }\n      for (var i = start; i !== end; i += inc) {\n        this$1.add(coord$5[i], allowRepeated$5);\n      }\n      return true\n    }\n  };\n  CoordinateList.prototype.closeRing = function closeRing () {\n    if (this.size() > 0) { this.add(new Coordinate(this.get(0)), false); }\n  };\n  CoordinateList.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  CoordinateList.prototype.getClass = function getClass () {\n    return CoordinateList\n  };\n\n  Object.defineProperties( CoordinateList, staticAccessors );\n\n  return CoordinateList;\n}(ArrayList));\n\nvar CoordinateArrays = function CoordinateArrays () {};\n\nvar staticAccessors$13 = { ForwardComparator: { configurable: true },BidirectionalComparator: { configurable: true },coordArrayType: { configurable: true } };\n\nstaticAccessors$13.ForwardComparator.get = function () { return ForwardComparator };\nstaticAccessors$13.BidirectionalComparator.get = function () { return BidirectionalComparator };\nstaticAccessors$13.coordArrayType.get = function () { return new Array(0).fill(null) };\n\nCoordinateArrays.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateArrays.prototype.getClass = function getClass () {\n  return CoordinateArrays\n};\nCoordinateArrays.isRing = function isRing (pts) {\n  if (pts.length < 4) { return false }\n  if (!pts[0].equals2D(pts[pts.length - 1])) { return false }\n  return true\n};\nCoordinateArrays.ptNotInList = function ptNotInList (testPts, pts) {\n  for (var i = 0; i < testPts.length; i++) {\n    var testPt = testPts[i];\n    if (CoordinateArrays.indexOf(testPt, pts) < 0) { return testPt }\n  }\n  return null\n};\nCoordinateArrays.scroll = function scroll (coordinates, firstCoordinate) {\n  var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n  if (i < 0) { return null }\n  var newCoordinates = new Array(coordinates.length).fill(null);\n  System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n  System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n  System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n};\nCoordinateArrays.equals = function equals () {\n  if (arguments.length === 2) {\n    var coord1 = arguments[0];\n    var coord2 = arguments[1];\n    if (coord1 === coord2) { return true }\n    if (coord1 === null || coord2 === null) { return false }\n    if (coord1.length !== coord2.length) { return false }\n    for (var i = 0; i < coord1.length; i++) {\n      if (!coord1[i].equals(coord2[i])) { return false }\n    }\n    return true\n  } else if (arguments.length === 3) {\n    var coord1$1 = arguments[0];\n    var coord2$1 = arguments[1];\n    var coordinateComparator = arguments[2];\n    if (coord1$1 === coord2$1) { return true }\n    if (coord1$1 === null || coord2$1 === null) { return false }\n    if (coord1$1.length !== coord2$1.length) { return false }\n    for (var i$1 = 0; i$1 < coord1$1.length; i$1++) {\n      if (coordinateComparator.compare(coord1$1[i$1], coord2$1[i$1]) !== 0) { return false }\n    }\n    return true\n  }\n};\nCoordinateArrays.intersection = function intersection (coordinates, env) {\n  var coordList = new CoordinateList();\n  for (var i = 0; i < coordinates.length; i++) {\n    if (env.intersects(coordinates[i])) { coordList.add(coordinates[i], true); }\n  }\n  return coordList.toCoordinateArray()\n};\nCoordinateArrays.hasRepeatedPoints = function hasRepeatedPoints (coord) {\n  for (var i = 1; i < coord.length; i++) {\n    if (coord[i - 1].equals(coord[i])) {\n      return true\n    }\n  }\n  return false\n};\nCoordinateArrays.removeRepeatedPoints = function removeRepeatedPoints (coord) {\n  if (!CoordinateArrays.hasRepeatedPoints(coord)) { return coord }\n  var coordList = new CoordinateList(coord, false);\n  return coordList.toCoordinateArray()\n};\nCoordinateArrays.reverse = function reverse (coord) {\n  var last = coord.length - 1;\n  var mid = Math.trunc(last / 2);\n  for (var i = 0; i <= mid; i++) {\n    var tmp = coord[i];\n    coord[i] = coord[last - i];\n    coord[last - i] = tmp;\n  }\n};\nCoordinateArrays.removeNull = function removeNull (coord) {\n  var nonNull = 0;\n  for (var i = 0; i < coord.length; i++) {\n    if (coord[i] !== null) { nonNull++; }\n  }\n  var newCoord = new Array(nonNull).fill(null);\n  if (nonNull === 0) { return newCoord }\n  var j = 0;\n  for (var i$1 = 0; i$1 < coord.length; i$1++) {\n    if (coord[i$1] !== null) { newCoord[j++] = coord[i$1]; }\n  }\n  return newCoord\n};\nCoordinateArrays.copyDeep = function copyDeep () {\n  if (arguments.length === 1) {\n    var coordinates = arguments[0];\n    var copy = new Array(coordinates.length).fill(null);\n    for (var i = 0; i < coordinates.length; i++) {\n      copy[i] = new Coordinate(coordinates[i]);\n    }\n    return copy\n  } else if (arguments.length === 5) {\n    var src = arguments[0];\n    var srcStart = arguments[1];\n    var dest = arguments[2];\n    var destStart = arguments[3];\n    var length = arguments[4];\n    for (var i$1 = 0; i$1 < length; i$1++) {\n      dest[destStart + i$1] = new Coordinate(src[srcStart + i$1]);\n    }\n  }\n};\nCoordinateArrays.isEqualReversed = function isEqualReversed (pts1, pts2) {\n  for (var i = 0; i < pts1.length; i++) {\n    var p1 = pts1[i];\n    var p2 = pts2[pts1.length - i - 1];\n    if (p1.compareTo(p2) !== 0) { return false }\n  }\n  return true\n};\nCoordinateArrays.envelope = function envelope (coordinates) {\n  var env = new Envelope();\n  for (var i = 0; i < coordinates.length; i++) {\n    env.expandToInclude(coordinates[i]);\n  }\n  return env\n};\nCoordinateArrays.toCoordinateArray = function toCoordinateArray (coordList) {\n  return coordList.toArray(CoordinateArrays.coordArrayType)\n};\nCoordinateArrays.atLeastNCoordinatesOrNothing = function atLeastNCoordinatesOrNothing (n, c) {\n  return c.length >= n ? c : []\n};\nCoordinateArrays.indexOf = function indexOf (coordinate, coordinates) {\n  for (var i = 0; i < coordinates.length; i++) {\n    if (coordinate.equals(coordinates[i])) {\n      return i\n    }\n  }\n  return -1\n};\nCoordinateArrays.increasingDirection = function increasingDirection (pts) {\n  for (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n    var j = pts.length - 1 - i;\n    var comp = pts[i].compareTo(pts[j]);\n    if (comp !== 0) { return comp }\n  }\n  return 1\n};\nCoordinateArrays.compare = function compare (pts1, pts2) {\n  var i = 0;\n  while (i < pts1.length && i < pts2.length) {\n    var compare = pts1[i].compareTo(pts2[i]);\n    if (compare !== 0) { return compare }\n    i++;\n  }\n  if (i < pts2.length) { return -1 }\n  if (i < pts1.length) { return 1 }\n  return 0\n};\nCoordinateArrays.minCoordinate = function minCoordinate (coordinates) {\n  var minCoord = null;\n  for (var i = 0; i < coordinates.length; i++) {\n    if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n      minCoord = coordinates[i];\n    }\n  }\n  return minCoord\n};\nCoordinateArrays.extract = function extract (pts, start, end) {\n  start = MathUtil.clamp(start, 0, pts.length);\n  end = MathUtil.clamp(end, -1, pts.length);\n  var npts = end - start + 1;\n  if (end < 0) { npts = 0; }\n  if (start >= pts.length) { npts = 0; }\n  if (end < start) { npts = 0; }\n  var extractPts = new Array(npts).fill(null);\n  if (npts === 0) { return extractPts }\n  var iPts = 0;\n  for (var i = start; i <= end; i++) {\n    extractPts[iPts++] = pts[i];\n  }\n  return extractPts\n};\n\nObject.defineProperties( CoordinateArrays, staticAccessors$13 );\n\nvar ForwardComparator = function ForwardComparator () {};\n\nForwardComparator.prototype.compare = function compare (o1, o2) {\n  var pts1 = o1;\n  var pts2 = o2;\n  return CoordinateArrays.compare(pts1, pts2)\n};\nForwardComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nForwardComparator.prototype.getClass = function getClass () {\n  return ForwardComparator\n};\n\nvar BidirectionalComparator = function BidirectionalComparator () {};\n\nBidirectionalComparator.prototype.compare = function compare (o1, o2) {\n  var pts1 = o1;\n  var pts2 = o2;\n  if (pts1.length < pts2.length) { return -1 }\n  if (pts1.length > pts2.length) { return 1 }\n  if (pts1.length === 0) { return 0 }\n  var forwardComp = CoordinateArrays.compare(pts1, pts2);\n  var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n  if (isEqualRev) { return 0 }\n  return forwardComp\n};\nBidirectionalComparator.prototype.OLDcompare = function OLDcompare (o1, o2) {\n  var pts1 = o1;\n  var pts2 = o2;\n  if (pts1.length < pts2.length) { return -1 }\n  if (pts1.length > pts2.length) { return 1 }\n  if (pts1.length === 0) { return 0 }\n  var dir1 = CoordinateArrays.increasingDirection(pts1);\n  var dir2 = CoordinateArrays.increasingDirection(pts2);\n  var i1 = dir1 > 0 ? 0 : pts1.length - 1;\n  var i2 = dir2 > 0 ? 0 : pts1.length - 1;\n  for (var i = 0; i < pts1.length; i++) {\n    var comparePt = pts1[i1].compareTo(pts2[i2]);\n    if (comparePt !== 0) { return comparePt }\n    i1 += dir1;\n    i2 += dir2;\n  }\n  return 0\n};\nBidirectionalComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nBidirectionalComparator.prototype.getClass = function getClass () {\n  return BidirectionalComparator\n};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n *\n * @constructor\n * @private\n */\nvar Map$1 = function Map () {};\n\nMap$1.prototype.get = function get () {};\n/**\n * Associates the specified value with the specified key in this map (optional\n * operation).\n * @param {Object} key\n * @param {Object} value\n * @return {Object}\n */\nMap$1.prototype.put = function put () {};\n\n/**\n * Returns the number of key-value mappings in this map.\n * @return {number}\n */\nMap$1.prototype.size = function size () {};\n\n/**\n * Returns a Collection view of the values contained in this map.\n * @return {javascript.util.Collection}\n */\nMap$1.prototype.values = function values () {};\n\n/**\n * Returns a {@link Set} view of the mappings contained in this map.\n * The set is backed by the map, so changes to the map are\n * reflected in the set, and vice-versa.If the map is modified\n * while an iteration over the set is in progress (except through\n * the iterator's own <tt>remove</tt> operation, or through the\n * <tt>setValue</tt> operation on a map entry returned by the\n * iterator) the results of the iteration are undefined.The set\n * supports element removal, which removes the corresponding\n * mapping from the map, via the <tt>Iterator.remove</tt>,\n * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n * <tt>clear</tt> operations.It does not support the\n * <tt>add</tt> or <tt>addAll</tt> operations.\n *\n * @return {Set} a set view of the mappings contained in this map\n */\nMap$1.prototype.entrySet = function entrySet () {};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n *\n * @extends {Map}\n * @constructor\n * @private\n */\nvar SortedMap = (function (Map) {\n\tfunction SortedMap () {\n\t\tMap.apply(this, arguments);\n\t}if ( Map ) SortedMap.__proto__ = Map;\n\tSortedMap.prototype = Object.create( Map && Map.prototype );\n\tSortedMap.prototype.constructor = SortedMap;\n\n\t\n\n\treturn SortedMap;\n}(Map$1));\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction OperationNotSupported (message) {\n  this.message = message || '';\n}\nOperationNotSupported.prototype = new Error();\n\n/**\n * @type {string}\n */\nOperationNotSupported.prototype.name = 'OperationNotSupported';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */\nfunction Set() {}\nSet.prototype = new Collection();\n\n\n/**\n * Returns true if this set contains the specified element. More formally,\n * returns true if and only if this set contains an element e such that (o==null ?\n * e==null : o.equals(e)).\n * @param {Object} e\n * @return {boolean}\n */\nSet.prototype.contains = function() {};\n\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n *\n * @extends {javascript.util.Set}\n * @constructor\n * @private\n */\nvar HashSet = (function (Set$$1) {\n  function HashSet () {\n    Set$$1.call(this);\n    this.array_ = [];\n\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }\n\n  if ( Set$$1 ) HashSet.__proto__ = Set$$1;\n  HashSet.prototype = Object.create( Set$$1 && Set$$1.prototype );\n  HashSet.prototype.constructor = HashSet;\n\n  /**\n   * @override\n   */\n  HashSet.prototype.contains = function contains (o) {\n    var this$1 = this;\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this$1.array_[i];\n      if (e === o) {\n        return true\n      }\n    }\n    return false\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.add = function add (o) {\n    if (this.contains(o)) {\n      return false\n    }\n\n    this.array_.push(o);\n\n    return true\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.addAll = function addAll (c) {\n    var this$1 = this;\n\n    for (var i = c.iterator(); i.hasNext();) {\n      this$1.add(i.next());\n    }\n    return true\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.remove = function remove (o) {\n    // throw new javascript.util.OperationNotSupported()\n    throw new Error()\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.size = function size () {\n    return this.array_.length\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.isEmpty = function isEmpty () {\n    return this.array_.length === 0\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.toArray = function toArray () {\n    var this$1 = this;\n\n    var array = [];\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this$1.array_[i]);\n    }\n\n    return array\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.iterator = function iterator () {\n    return new Iterator_$1(this)\n  };\n\n  return HashSet;\n}(Set));\n\n/**\n   * @extends {Iterator}\n   * @param {HashSet} hashSet\n   * @constructor\n   * @private\n   */\nvar Iterator_$1 = (function (Iterator$$1) {\n  function Iterator_ (hashSet) {\n    Iterator$$1.call(this);\n    /**\n     * @type {HashSet}\n     * @private\n     */\n    this.hashSet_ = hashSet;\n    /**\n     * @type {number}\n     * @private\n     */\n    this.position_ = 0;\n  }\n\n  if ( Iterator$$1 ) Iterator_.__proto__ = Iterator$$1;\n  Iterator_.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n  Iterator_.prototype.constructor = Iterator_;\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.next = function next () {\n    if (this.position_ === this.hashSet_.size()) {\n      throw new NoSuchElementException()\n    }\n    return this.hashSet_.array_[this.position_++]\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.hasNext = function hasNext () {\n    if (this.position_ < this.hashSet_.size()) {\n      return true\n    } else {\n      return false\n    }\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.remove = function remove () {\n    throw new OperationNotSupported()\n  };\n\n  return Iterator_;\n}(Iterator));\n\nvar BLACK = 0;\nvar RED = 1;\nfunction colorOf (p) { return (p === null ? BLACK : p.color) }\nfunction parentOf (p) { return (p === null ? null : p.parent) }\nfunction setColor (p, c) { if (p !== null) { p.color = c; } }\nfunction leftOf (p) { return (p === null ? null : p.left) }\nfunction rightOf (p) { return (p === null ? null : p.right) }\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n *\n * @extends {SortedMap}\n * @constructor\n * @private\n */\nfunction TreeMap () {\n  /**\n   * @type {Object}\n   * @private\n   */\n  this.root_ = null;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.size_ = 0;\n}\nTreeMap.prototype = new SortedMap();\n\n/**\n * @override\n */\nTreeMap.prototype.get = function (key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) { p = p.left; }\n    else if (cmp > 0) { p = p.right; }\n    else { return p.value }\n  }\n  return null\n};\n\n/**\n * @override\n */\nTreeMap.prototype.put = function (key, value) {\n  if (this.root_ === null) {\n    this.root_ = {\n      key: key,\n      value: value,\n      left: null,\n      right: null,\n      parent: null,\n      color: BLACK,\n      getValue: function getValue () { return this.value },\n      getKey: function getKey () { return this.key }\n    };\n    this.size_ = 1;\n    return null\n  }\n  var t = this.root_;\n  var parent;\n  var cmp;\n  do {\n    parent = t;\n    cmp = key['compareTo'](t.key);\n    if (cmp < 0) {\n      t = t.left;\n    } else if (cmp > 0) {\n      t = t.right;\n    } else {\n      var oldValue = t.value;\n      t.value = value;\n      return oldValue\n    }\n  } while (t !== null)\n  var e = {\n    key: key,\n    left: null,\n    right: null,\n    value: value,\n    parent: parent,\n    color: BLACK,\n    getValue: function getValue () { return this.value },\n    getKey: function getKey () { return this.key }\n  };\n  if (cmp < 0) {\n    parent.left = e;\n  } else {\n    parent.right = e;\n  }\n  this.fixAfterInsertion(e);\n  this.size_++;\n  return null\n};\n\n/**\n * @param {Object} x\n */\nTreeMap.prototype.fixAfterInsertion = function (x) {\n  var this$1 = this;\n\n  x.color = RED;\n  while (x != null && x !== this.root_ && x.parent.color === RED) {\n    if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {\n      var y = rightOf(parentOf(parentOf(x)));\n      if (colorOf(y) === RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x === rightOf(parentOf(x))) {\n          x = parentOf(x);\n          this$1.rotateLeft(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this$1.rotateRight(parentOf(parentOf(x)));\n      }\n    } else {\n      var y$1 = leftOf(parentOf(parentOf(x)));\n      if (colorOf(y$1) === RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y$1, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x === leftOf(parentOf(x))) {\n          x = parentOf(x);\n          this$1.rotateRight(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this$1.rotateLeft(parentOf(parentOf(x)));\n      }\n    }\n  }\n  this.root_.color = BLACK;\n};\n\n/**\n * @override\n */\nTreeMap.prototype.values = function () {\n  var arrayList = new ArrayList();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    arrayList.add(p.value);\n    while ((p = TreeMap.successor(p)) !== null) {\n      arrayList.add(p.value);\n    }\n  }\n  return arrayList\n};\n\n/**\n * @override\n */\nTreeMap.prototype.entrySet = function () {\n  var hashSet = new HashSet();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    hashSet.add(p);\n    while ((p = TreeMap.successor(p)) !== null) {\n      hashSet.add(p);\n    }\n  }\n  return hashSet\n};\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateLeft = function (p) {\n  if (p != null) {\n    var r = p.right;\n    p.right = r.left;\n    if (r.left != null) { r.left.parent = p; }\n    r.parent = p.parent;\n    if (p.parent === null) { this.root_ = r; } else if (p.parent.left === p) { p.parent.left = r; } else { p.parent.right = r; }\n    r.left = p;\n    p.parent = r;\n  }\n};\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateRight = function (p) {\n  if (p != null) {\n    var l = p.left;\n    p.left = l.right;\n    if (l.right != null) { l.right.parent = p; }\n    l.parent = p.parent;\n    if (p.parent === null) { this.root_ = l; } else if (p.parent.right === p) { p.parent.right = l; } else { p.parent.left = l; }\n    l.right = p;\n    p.parent = l;\n  }\n};\n\n/**\n * @return {Object}\n */\nTreeMap.prototype.getFirstEntry = function () {\n  var p = this.root_;\n  if (p != null) {\n    while (p.left != null) {\n      p = p.left;\n    }\n  }\n  return p\n};\n\n/**\n * @param {Object} t\n * @return {Object}\n * @private\n */\nTreeMap.successor = function (t) {\n  if (t === null) { return null } else if (t.right !== null) {\n    var p = t.right;\n    while (p.left !== null) {\n      p = p.left;\n    }\n    return p\n  } else {\n    var p$1 = t.parent;\n    var ch = t;\n    while (p$1 !== null && ch === p$1.right) {\n      ch = p$1;\n      p$1 = p$1.parent;\n    }\n    return p$1\n  }\n};\n\n/**\n * @override\n */\nTreeMap.prototype.size = function () {\n  return this.size_\n};\n\nvar Lineal = function Lineal () {};\n\nLineal.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineal.prototype.getClass = function getClass () {\n  return Lineal\n};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n *\n * @extends {Set}\n * @constructor\n * @private\n */\nfunction SortedSet () {}\nSortedSet.prototype = new Set();\n\n// import Iterator from './Iterator'\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n *\n * @extends {SortedSet}\n * @constructor\n * @private\n */\nfunction TreeSet () {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n}\nTreeSet.prototype = new SortedSet();\n\n/**\n * @override\n */\nTreeSet.prototype.contains = function (o) {\n  var this$1 = this;\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this$1.array_[i];\n    if (e['compareTo'](o) === 0) {\n      return true\n    }\n  }\n  return false\n};\n\n/**\n * @override\n */\nTreeSet.prototype.add = function (o) {\n  var this$1 = this;\n\n  if (this.contains(o)) {\n    return false\n  }\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this$1.array_[i];\n    if (e['compareTo'](o) === 1) {\n      this$1.array_.splice(i, 0, o);\n      return true\n    }\n  }\n\n  this.array_.push(o);\n\n  return true\n};\n\n/**\n * @override\n */\nTreeSet.prototype.addAll = function (c) {\n  var this$1 = this;\n\n  for (var i = c.iterator(); i.hasNext();) {\n    this$1.add(i.next());\n  }\n  return true\n};\n\n/**\n * @override\n */\nTreeSet.prototype.remove = function (e) {\n  throw new OperationNotSupported()\n};\n\n/**\n * @override\n */\nTreeSet.prototype.size = function () {\n  return this.array_.length\n};\n\n/**\n * @override\n */\nTreeSet.prototype.isEmpty = function () {\n  return this.array_.length === 0\n};\n\n/**\n * @override\n */\nTreeSet.prototype.toArray = function () {\n  var this$1 = this;\n\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this$1.array_[i]);\n  }\n\n  return array\n};\n\n/**\n * @override\n */\nTreeSet.prototype.iterator = function () {\n  return new Iterator_$2(this)\n};\n\n/**\n * @extends {javascript.util.Iterator}\n * @param {javascript.util.TreeSet} treeSet\n * @constructor\n * @private\n */\nvar Iterator_$2 = function (treeSet) {\n  /**\n   * @type {javascript.util.TreeSet}\n   * @private\n   */\n  this.treeSet_ = treeSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.next = function () {\n  if (this.position_ === this.treeSet_.size()) {\n    throw new NoSuchElementException()\n  }\n  return this.treeSet_.array_[this.position_++]\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.hasNext = function () {\n  if (this.position_ < this.treeSet_.size()) {\n    return true\n  } else {\n    return false\n  }\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.remove = function () {\n  throw new OperationNotSupported()\n};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n *\n * @constructor\n * @private\n */\nvar Arrays = function Arrays () {};\n\nArrays.sort = function sort () {\n  var a = arguments[0];\n  var i;\n  var t;\n  var comparator;\n  var compare;\n  if (arguments.length === 1) {\n    compare = function (a, b) {\n      return a.compareTo(b)\n    };\n    a.sort(compare);\n  } else if (arguments.length === 2) {\n    comparator = arguments[1];\n    compare = function (a, b) {\n      return comparator['compare'](a, b)\n    };\n    a.sort(compare);\n  } else if (arguments.length === 3) {\n    t = a.slice(arguments[1], arguments[2]);\n    t.sort();\n    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n  } else if (arguments.length === 4) {\n    t = a.slice(arguments[1], arguments[2]);\n    comparator = arguments[3];\n    compare = function (a, b) {\n      return comparator['compare'](a, b)\n    };\n    t.sort(compare);\n    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n  }\n};\n/**\n * @param {Array} array\n * @return {ArrayList}\n */\nArrays.asList = function asList (array) {\n  var arrayList = new ArrayList();\n  for (var i = 0, len = array.length; i < len; i++) {\n    arrayList.add(array[i]);\n  }\n  return arrayList\n};\n\nvar Dimension = function Dimension () {};\n\nvar staticAccessors$14 = { P: { configurable: true },L: { configurable: true },A: { configurable: true },FALSE: { configurable: true },TRUE: { configurable: true },DONTCARE: { configurable: true },SYM_FALSE: { configurable: true },SYM_TRUE: { configurable: true },SYM_DONTCARE: { configurable: true },SYM_P: { configurable: true },SYM_L: { configurable: true },SYM_A: { configurable: true } };\n\nstaticAccessors$14.P.get = function () { return 0 };\nstaticAccessors$14.L.get = function () { return 1 };\nstaticAccessors$14.A.get = function () { return 2 };\nstaticAccessors$14.FALSE.get = function () { return -1 };\nstaticAccessors$14.TRUE.get = function () { return -2 };\nstaticAccessors$14.DONTCARE.get = function () { return -3 };\nstaticAccessors$14.SYM_FALSE.get = function () { return 'F' };\nstaticAccessors$14.SYM_TRUE.get = function () { return 'T' };\nstaticAccessors$14.SYM_DONTCARE.get = function () { return '*' };\nstaticAccessors$14.SYM_P.get = function () { return '0' };\nstaticAccessors$14.SYM_L.get = function () { return '1' };\nstaticAccessors$14.SYM_A.get = function () { return '2' };\n\nDimension.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDimension.prototype.getClass = function getClass () {\n  return Dimension\n};\nDimension.toDimensionSymbol = function toDimensionSymbol (dimensionValue) {\n  switch (dimensionValue) {\n    case Dimension.FALSE:\n      return Dimension.SYM_FALSE\n    case Dimension.TRUE:\n      return Dimension.SYM_TRUE\n    case Dimension.DONTCARE:\n      return Dimension.SYM_DONTCARE\n    case Dimension.P:\n      return Dimension.SYM_P\n    case Dimension.L:\n      return Dimension.SYM_L\n    case Dimension.A:\n      return Dimension.SYM_A\n    default:\n  }\n  throw new IllegalArgumentException('Unknown dimension value: ' + dimensionValue)\n};\nDimension.toDimensionValue = function toDimensionValue (dimensionSymbol) {\n  switch (Character.toUpperCase(dimensionSymbol)) {\n    case Dimension.SYM_FALSE:\n      return Dimension.FALSE\n    case Dimension.SYM_TRUE:\n      return Dimension.TRUE\n    case Dimension.SYM_DONTCARE:\n      return Dimension.DONTCARE\n    case Dimension.SYM_P:\n      return Dimension.P\n    case Dimension.SYM_L:\n      return Dimension.L\n    case Dimension.SYM_A:\n      return Dimension.A\n    default:\n  }\n  throw new IllegalArgumentException('Unknown dimension symbol: ' + dimensionSymbol)\n};\n\nObject.defineProperties( Dimension, staticAccessors$14 );\n\nvar GeometryFilter = function GeometryFilter () {};\n\nGeometryFilter.prototype.filter = function filter (geom) {};\nGeometryFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryFilter.prototype.getClass = function getClass () {\n  return GeometryFilter\n};\n\nvar CoordinateSequenceFilter = function CoordinateSequenceFilter () {};\n\nCoordinateSequenceFilter.prototype.filter = function filter (seq, i) {};\nCoordinateSequenceFilter.prototype.isDone = function isDone () {};\nCoordinateSequenceFilter.prototype.isGeometryChanged = function isGeometryChanged () {};\nCoordinateSequenceFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateSequenceFilter.prototype.getClass = function getClass () {\n  return CoordinateSequenceFilter\n};\n\nvar GeometryCollection = (function (Geometry$$1) {\n  function GeometryCollection (geometries, factory) {\n    Geometry$$1.call(this, factory);\n    this._geometries = geometries || [];\n\n    if (Geometry$$1.hasNullElements(this._geometries)) {\n      throw new IllegalArgumentException('geometries must not contain null elements')\n    }\n  }\n\n  if ( Geometry$$1 ) GeometryCollection.__proto__ = Geometry$$1;\n  GeometryCollection.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  GeometryCollection.prototype.constructor = GeometryCollection;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  GeometryCollection.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    var this$1 = this;\n\n    var envelope = new Envelope();\n    for (var i = 0; i < this._geometries.length; i++) {\n      envelope.expandToInclude(this$1._geometries[i].getEnvelopeInternal());\n    }\n    return envelope\n  };\n  GeometryCollection.prototype.getGeometryN = function getGeometryN (n) {\n    return this._geometries[n]\n  };\n  GeometryCollection.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_GEOMETRYCOLLECTION\n  };\n  GeometryCollection.prototype.getCoordinates = function getCoordinates () {\n    var this$1 = this;\n\n    var coordinates = new Array(this.getNumPoints()).fill(null);\n    var k = -1;\n    for (var i = 0; i < this._geometries.length; i++) {\n      var childCoordinates = this$1._geometries[i].getCoordinates();\n      for (var j = 0; j < childCoordinates.length; j++) {\n        k++;\n        coordinates[k] = childCoordinates[j];\n      }\n    }\n    return coordinates\n  };\n  GeometryCollection.prototype.getArea = function getArea () {\n    var this$1 = this;\n\n    var area = 0.0;\n    for (var i = 0; i < this._geometries.length; i++) {\n      area += this$1._geometries[i].getArea();\n    }\n    return area\n  };\n  GeometryCollection.prototype.equalsExact = function equalsExact () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      var otherCollection = other;\n      if (this._geometries.length !== otherCollection._geometries.length) {\n        return false\n      }\n      for (var i = 0; i < this._geometries.length; i++) {\n        if (!this$1._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n          return false\n        }\n      }\n      return true\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  GeometryCollection.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n    for (var i = 0; i < this._geometries.length; i++) {\n      this$1._geometries[i].normalize();\n    }\n    Arrays.sort(this._geometries);\n  };\n  GeometryCollection.prototype.getCoordinate = function getCoordinate () {\n    if (this.isEmpty()) { return null }\n    return this._geometries[0].getCoordinate()\n  };\n  GeometryCollection.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    var this$1 = this;\n\n    var dimension = Dimension.FALSE;\n    for (var i = 0; i < this._geometries.length; i++) {\n      dimension = Math.max(dimension, this$1._geometries[i].getBoundaryDimension());\n    }\n    return dimension\n  };\n  GeometryCollection.prototype.getDimension = function getDimension () {\n    var this$1 = this;\n\n    var dimension = Dimension.FALSE;\n    for (var i = 0; i < this._geometries.length; i++) {\n      dimension = Math.max(dimension, this$1._geometries[i].getDimension());\n    }\n    return dimension\n  };\n  GeometryCollection.prototype.getLength = function getLength () {\n    var this$1 = this;\n\n    var sum = 0.0;\n    for (var i = 0; i < this._geometries.length; i++) {\n      sum += this$1._geometries[i].getLength();\n    }\n    return sum\n  };\n  GeometryCollection.prototype.getNumPoints = function getNumPoints () {\n    var this$1 = this;\n\n    var numPoints = 0;\n    for (var i = 0; i < this._geometries.length; i++) {\n      numPoints += this$1._geometries[i].getNumPoints();\n    }\n    return numPoints\n  };\n  GeometryCollection.prototype.getNumGeometries = function getNumGeometries () {\n    return this._geometries.length\n  };\n  GeometryCollection.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var n = this._geometries.length;\n    var revGeoms = new Array(n).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      revGeoms[i] = this$1._geometries[i].reverse();\n    }\n    return this.getFactory().createGeometryCollection(revGeoms)\n  };\n  GeometryCollection.prototype.compareToSameClass = function compareToSameClass () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var o = arguments[0];\n      var theseElements = new TreeSet(Arrays.asList(this._geometries));\n      var otherElements = new TreeSet(Arrays.asList(o._geometries));\n      return this.compare(theseElements, otherElements)\n    } else if (arguments.length === 2) {\n      var o$1 = arguments[0];\n      var comp = arguments[1];\n      var gc = o$1;\n      var n1 = this.getNumGeometries();\n      var n2 = gc.getNumGeometries();\n      var i = 0;\n      while (i < n1 && i < n2) {\n        var thisGeom = this$1.getGeometryN(i);\n        var otherGeom = gc.getGeometryN(i);\n        var holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n        if (holeComp !== 0) { return holeComp }\n        i++;\n      }\n      if (i < n1) { return 1 }\n      if (i < n2) { return -1 }\n      return 0\n    }\n  };\n  GeometryCollection.prototype.apply = function apply () {\n    var this$1 = this;\n\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      var filter = arguments[0];\n      for (var i = 0; i < this._geometries.length; i++) {\n        this$1._geometries[i].apply(filter);\n      }\n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      var filter$1 = arguments[0];\n      if (this._geometries.length === 0) { return null }\n      for (var i$1 = 0; i$1 < this._geometries.length; i$1++) {\n        this$1._geometries[i$1].apply(filter$1);\n        if (filter$1.isDone()) {\n          break\n        }\n      }\n      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      var filter$2 = arguments[0];\n      filter$2.filter(this);\n      for (var i$2 = 0; i$2 < this._geometries.length; i$2++) {\n        this$1._geometries[i$2].apply(filter$2);\n      }\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      var filter$3 = arguments[0];\n      filter$3.filter(this);\n      for (var i$3 = 0; i$3 < this._geometries.length; i$3++) {\n        this$1._geometries[i$3].apply(filter$3);\n      }\n    }\n  };\n  GeometryCollection.prototype.getBoundary = function getBoundary () {\n    this.checkNotGeometryCollection(this);\n    Assert.shouldNeverReachHere();\n    return null\n  };\n  GeometryCollection.prototype.clone = function clone () {\n    var this$1 = this;\n\n    var gc = Geometry$$1.prototype.clone.call(this);\n    gc._geometries = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      gc._geometries[i] = this$1._geometries[i].clone();\n    }\n    return gc\n  };\n  GeometryCollection.prototype.getGeometryType = function getGeometryType () {\n    return 'GeometryCollection'\n  };\n  GeometryCollection.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var geometries = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < geometries.length; i++) {\n      geometries[i] = this$1._geometries[i].copy();\n    }\n    return new GeometryCollection(geometries, this._factory)\n  };\n  GeometryCollection.prototype.isEmpty = function isEmpty () {\n    var this$1 = this;\n\n    for (var i = 0; i < this._geometries.length; i++) {\n      if (!this$1._geometries[i].isEmpty()) {\n        return false\n      }\n    }\n    return true\n  };\n  GeometryCollection.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  GeometryCollection.prototype.getClass = function getClass () {\n    return GeometryCollection\n  };\n  staticAccessors.serialVersionUID.get = function () { return -5694727726395021467 };\n\n  Object.defineProperties( GeometryCollection, staticAccessors );\n\n  return GeometryCollection;\n}(Geometry));\n\nvar MultiLineString = (function (GeometryCollection$$1) {\n  function MultiLineString () {\n    GeometryCollection$$1.apply(this, arguments);\n  }\n\n  if ( GeometryCollection$$1 ) MultiLineString.__proto__ = GeometryCollection$$1;\n  MultiLineString.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );\n  MultiLineString.prototype.constructor = MultiLineString;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n\n  MultiLineString.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_MULTILINESTRING\n  };\n  MultiLineString.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)\n    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  MultiLineString.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    if (this.isClosed()) {\n      return Dimension.FALSE\n    }\n    return 0\n  };\n  MultiLineString.prototype.isClosed = function isClosed () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return false\n    }\n    for (var i = 0; i < this._geometries.length; i++) {\n      if (!this$1._geometries[i].isClosed()) {\n        return false\n      }\n    }\n    return true\n  };\n  MultiLineString.prototype.getDimension = function getDimension () {\n    return 1\n  };\n  MultiLineString.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var nLines = this._geometries.length;\n    var revLines = new Array(nLines).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      revLines[nLines - 1 - i] = this$1._geometries[i].reverse();\n    }\n    return this.getFactory().createMultiLineString(revLines)\n  };\n  MultiLineString.prototype.getBoundary = function getBoundary () {\n    return new BoundaryOp(this).getBoundary()\n  };\n  MultiLineString.prototype.getGeometryType = function getGeometryType () {\n    return 'MultiLineString'\n  };\n  MultiLineString.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var lineStrings = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < lineStrings.length; i++) {\n      lineStrings[i] = this$1._geometries[i].copy();\n    }\n    return new MultiLineString(lineStrings, this._factory)\n  };\n  MultiLineString.prototype.interfaces_ = function interfaces_ () {\n    return [Lineal]\n  };\n  MultiLineString.prototype.getClass = function getClass () {\n    return MultiLineString\n  };\n  staticAccessors.serialVersionUID.get = function () { return 8166665132445433741 };\n\n  Object.defineProperties( MultiLineString, staticAccessors );\n\n  return MultiLineString;\n}(GeometryCollection));\n\nvar BoundaryOp = function BoundaryOp () {\n  this._geom = null;\n  this._geomFact = null;\n  this._bnRule = null;\n  this._endpointMap = null;\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    var bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n    this._geom = geom;\n    this._geomFact = geom.getFactory();\n    this._bnRule = bnRule;\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var bnRule$1 = arguments[1];\n    this._geom = geom$1;\n    this._geomFact = geom$1.getFactory();\n    this._bnRule = bnRule$1;\n  }\n};\nBoundaryOp.prototype.boundaryMultiLineString = function boundaryMultiLineString (mLine) {\n  if (this._geom.isEmpty()) {\n    return this.getEmptyMultiPoint()\n  }\n  var bdyPts = this.computeBoundaryCoordinates(mLine);\n  if (bdyPts.length === 1) {\n    return this._geomFact.createPoint(bdyPts[0])\n  }\n  return this._geomFact.createMultiPointFromCoords(bdyPts)\n};\nBoundaryOp.prototype.getBoundary = function getBoundary () {\n  if (this._geom instanceof LineString) { return this.boundaryLineString(this._geom) }\n  if (this._geom instanceof MultiLineString) { return this.boundaryMultiLineString(this._geom) }\n  return this._geom.getBoundary()\n};\nBoundaryOp.prototype.boundaryLineString = function boundaryLineString (line) {\n  if (this._geom.isEmpty()) {\n    return this.getEmptyMultiPoint()\n  }\n  if (line.isClosed()) {\n    var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n    if (closedEndpointOnBoundary) {\n      return line.getStartPoint()\n    } else {\n      return this._geomFact.createMultiPoint()\n    }\n  }\n  return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()])\n};\nBoundaryOp.prototype.getEmptyMultiPoint = function getEmptyMultiPoint () {\n  return this._geomFact.createMultiPoint()\n};\nBoundaryOp.prototype.computeBoundaryCoordinates = function computeBoundaryCoordinates (mLine) {\n    var this$1 = this;\n\n  var bdyPts = new ArrayList();\n  this._endpointMap = new TreeMap();\n  for (var i = 0; i < mLine.getNumGeometries(); i++) {\n    var line = mLine.getGeometryN(i);\n    if (line.getNumPoints() === 0) { continue }\n    this$1.addEndpoint(line.getCoordinateN(0));\n    this$1.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n  }\n  for (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {\n    var entry = it.next();\n    var counter = entry.getValue();\n    var valence = counter.count;\n    if (this$1._bnRule.isInBoundary(valence)) {\n      bdyPts.add(entry.getKey());\n    }\n  }\n  return CoordinateArrays.toCoordinateArray(bdyPts)\n};\nBoundaryOp.prototype.addEndpoint = function addEndpoint (pt) {\n  var counter = this._endpointMap.get(pt);\n  if (counter === null) {\n    counter = new Counter();\n    this._endpointMap.put(pt, counter);\n  }\n  counter.count++;\n};\nBoundaryOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBoundaryOp.prototype.getClass = function getClass () {\n  return BoundaryOp\n};\nBoundaryOp.getBoundary = function getBoundary () {\n  if (arguments.length === 1) {\n    var g = arguments[0];\n    var bop = new BoundaryOp(g);\n    return bop.getBoundary()\n  } else if (arguments.length === 2) {\n    var g$1 = arguments[0];\n    var bnRule = arguments[1];\n    var bop$1 = new BoundaryOp(g$1, bnRule);\n    return bop$1.getBoundary()\n  }\n};\n\nvar Counter = function Counter () {\n  this.count = null;\n};\nCounter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCounter.prototype.getClass = function getClass () {\n  return Counter\n};\n\n// boundary\n\nfunction PrintStream () {}\n\nfunction StringReader () {}\n\nvar DecimalFormat = function DecimalFormat () {};\n\nfunction ByteArrayOutputStream () {}\n\nfunction IOException () {}\n\nfunction LineNumberReader () {}\n\nvar StringUtil = function StringUtil () {};\n\nvar staticAccessors$15 = { NEWLINE: { configurable: true },SIMPLE_ORDINATE_FORMAT: { configurable: true } };\n\nStringUtil.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nStringUtil.prototype.getClass = function getClass () {\n  return StringUtil\n};\nStringUtil.chars = function chars (c, n) {\n  var ch = new Array(n).fill(null);\n  for (var i = 0; i < n; i++) {\n    ch[i] = c;\n  }\n  return String(ch)\n};\nStringUtil.getStackTrace = function getStackTrace () {\n  if (arguments.length === 1) {\n    var t = arguments[0];\n    var os = new ByteArrayOutputStream();\n    var ps = new PrintStream(os);\n    t.printStackTrace(ps);\n    return os.toString()\n  } else if (arguments.length === 2) {\n    var t$1 = arguments[0];\n    var depth = arguments[1];\n    var stackTrace = '';\n    var stringReader = new StringReader(StringUtil.getStackTrace(t$1));\n    var lineNumberReader = new LineNumberReader(stringReader);\n    for (var i = 0; i < depth; i++) {\n      try {\n        stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n      } catch (e) {\n        if (e instanceof IOException) {\n          Assert.shouldNeverReachHere();\n        } else { throw e }\n      } finally {}\n    }\n    return stackTrace\n  }\n};\nStringUtil.split = function split (s, separator) {\n  var separatorlen = separator.length;\n  var tokenList = new ArrayList();\n  var tmpString = '' + s;\n  var pos = tmpString.indexOf(separator);\n  while (pos >= 0) {\n    var token = tmpString.substring(0, pos);\n    tokenList.add(token);\n    tmpString = tmpString.substring(pos + separatorlen);\n    pos = tmpString.indexOf(separator);\n  }\n  if (tmpString.length > 0) { tokenList.add(tmpString); }\n  var res = new Array(tokenList.size()).fill(null);\n  for (var i = 0; i < res.length; i++) {\n    res[i] = tokenList.get(i);\n  }\n  return res\n};\nStringUtil.toString = function toString () {\n  if (arguments.length === 1) {\n    var d = arguments[0];\n    return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d)\n  }\n};\nStringUtil.spaces = function spaces (n) {\n  return StringUtil.chars(' ', n)\n};\nstaticAccessors$15.NEWLINE.get = function () { return System.getProperty('line.separator') };\nstaticAccessors$15.SIMPLE_ORDINATE_FORMAT.get = function () { return new DecimalFormat('0.#') };\n\nObject.defineProperties( StringUtil, staticAccessors$15 );\n\nvar CoordinateSequences = function CoordinateSequences () {};\n\nCoordinateSequences.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateSequences.prototype.getClass = function getClass () {\n  return CoordinateSequences\n};\nCoordinateSequences.copyCoord = function copyCoord (src, srcPos, dest, destPos) {\n  var minDim = Math.min(src.getDimension(), dest.getDimension());\n  for (var dim = 0; dim < minDim; dim++) {\n    dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n  }\n};\nCoordinateSequences.isRing = function isRing (seq) {\n  var n = seq.size();\n  if (n === 0) { return true }\n  if (n <= 3) { return false }\n  return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y)\n};\nCoordinateSequences.isEqual = function isEqual (cs1, cs2) {\n  var cs1Size = cs1.size();\n  var cs2Size = cs2.size();\n  if (cs1Size !== cs2Size) { return false }\n  var dim = Math.min(cs1.getDimension(), cs2.getDimension());\n  for (var i = 0; i < cs1Size; i++) {\n    for (var d = 0; d < dim; d++) {\n      var v1 = cs1.getOrdinate(i, d);\n      var v2 = cs2.getOrdinate(i, d);\n      if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) { continue }\n      if (Double.isNaN(v1) && Double.isNaN(v2)) { continue }\n      return false\n    }\n  }\n  return true\n};\nCoordinateSequences.extend = function extend (fact, seq, size) {\n  var newseq = fact.create(size, seq.getDimension());\n  var n = seq.size();\n  CoordinateSequences.copy(seq, 0, newseq, 0, n);\n  if (n > 0) {\n    for (var i = n; i < size; i++) { CoordinateSequences.copy(seq, n - 1, newseq, i, 1); }\n  }\n  return newseq\n};\nCoordinateSequences.reverse = function reverse (seq) {\n  var last = seq.size() - 1;\n  var mid = Math.trunc(last / 2);\n  for (var i = 0; i <= mid; i++) {\n    CoordinateSequences.swap(seq, i, last - i);\n  }\n};\nCoordinateSequences.swap = function swap (seq, i, j) {\n  if (i === j) { return null }\n  for (var dim = 0; dim < seq.getDimension(); dim++) {\n    var tmp = seq.getOrdinate(i, dim);\n    seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n    seq.setOrdinate(j, dim, tmp);\n  }\n};\nCoordinateSequences.copy = function copy (src, srcPos, dest, destPos, length) {\n  for (var i = 0; i < length; i++) {\n    CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n  }\n};\nCoordinateSequences.toString = function toString () {\n  if (arguments.length === 1) {\n    var cs = arguments[0];\n    var size = cs.size();\n    if (size === 0) { return '()' }\n    var dim = cs.getDimension();\n    var buf = new StringBuffer();\n    buf.append('(');\n    for (var i = 0; i < size; i++) {\n      if (i > 0) { buf.append(' '); }\n      for (var d = 0; d < dim; d++) {\n        if (d > 0) { buf.append(','); }\n        buf.append(StringUtil.toString(cs.getOrdinate(i, d)));\n      }\n    }\n    buf.append(')');\n    return buf.toString()\n  }\n};\nCoordinateSequences.ensureValidRing = function ensureValidRing (fact, seq) {\n  var n = seq.size();\n  if (n === 0) { return seq }\n  if (n <= 3) { return CoordinateSequences.createClosedRing(fact, seq, 4) }\n  var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n  if (isClosed) { return seq }\n  return CoordinateSequences.createClosedRing(fact, seq, n + 1)\n};\nCoordinateSequences.createClosedRing = function createClosedRing (fact, seq, size) {\n  var newseq = fact.create(size, seq.getDimension());\n  var n = seq.size();\n  CoordinateSequences.copy(seq, 0, newseq, 0, n);\n  for (var i = n; i < size; i++) { CoordinateSequences.copy(seq, 0, newseq, i, 1); }\n  return newseq\n};\n\nvar LineString = (function (Geometry$$1) {\n  function LineString (points, factory) {\n    Geometry$$1.call(this, factory);\n    this._points = null;\n    this.init(points);\n  }\n\n  if ( Geometry$$1 ) LineString.__proto__ = Geometry$$1;\n  LineString.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  LineString.prototype.constructor = LineString;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  LineString.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    if (this.isEmpty()) {\n      return new Envelope()\n    }\n    return this._points.expandEnvelope(new Envelope())\n  };\n  LineString.prototype.isRing = function isRing () {\n    return this.isClosed() && this.isSimple()\n  };\n  LineString.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_LINESTRING\n  };\n  LineString.prototype.getCoordinates = function getCoordinates () {\n    return this._points.toCoordinateArray()\n  };\n  LineString.prototype.equalsExact = function equalsExact () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      var otherLineString = other;\n      if (this._points.size() !== otherLineString._points.size()) {\n        return false\n      }\n      for (var i = 0; i < this._points.size(); i++) {\n        if (!this$1.equal(this$1._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n          return false\n        }\n      }\n      return true\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  LineString.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n    for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n      var j = this$1._points.size() - 1 - i;\n      if (!this$1._points.getCoordinate(i).equals(this$1._points.getCoordinate(j))) {\n        if (this$1._points.getCoordinate(i).compareTo(this$1._points.getCoordinate(j)) > 0) {\n          CoordinateSequences.reverse(this$1._points);\n        }\n        return null\n      }\n    }\n  };\n  LineString.prototype.getCoordinate = function getCoordinate () {\n    if (this.isEmpty()) { return null }\n    return this._points.getCoordinate(0)\n  };\n  LineString.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    if (this.isClosed()) {\n      return Dimension.FALSE\n    }\n    return 0\n  };\n  LineString.prototype.isClosed = function isClosed () {\n    if (this.isEmpty()) {\n      return false\n    }\n    return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))\n  };\n  LineString.prototype.getEndPoint = function getEndPoint () {\n    if (this.isEmpty()) {\n      return null\n    }\n    return this.getPointN(this.getNumPoints() - 1)\n  };\n  LineString.prototype.getDimension = function getDimension () {\n    return 1\n  };\n  LineString.prototype.getLength = function getLength () {\n    return CGAlgorithms.computeLength(this._points)\n  };\n  LineString.prototype.getNumPoints = function getNumPoints () {\n    return this._points.size()\n  };\n  LineString.prototype.reverse = function reverse () {\n    var seq = this._points.copy();\n    CoordinateSequences.reverse(seq);\n    var revLine = this.getFactory().createLineString(seq);\n    return revLine\n  };\n  LineString.prototype.compareToSameClass = function compareToSameClass () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var o = arguments[0];\n      var line = o;\n      var i = 0;\n      var j = 0;\n      while (i < this._points.size() && j < line._points.size()) {\n        var comparison = this$1._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n        if (comparison !== 0) {\n          return comparison\n        }\n        i++;\n        j++;\n      }\n      if (i < this._points.size()) {\n        return 1\n      }\n      if (j < line._points.size()) {\n        return -1\n      }\n      return 0\n    } else if (arguments.length === 2) {\n      var o$1 = arguments[0];\n      var comp = arguments[1];\n      var line$1 = o$1;\n      return comp.compare(this._points, line$1._points)\n    }\n  };\n  LineString.prototype.apply = function apply () {\n    var this$1 = this;\n\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      var filter = arguments[0];\n      for (var i = 0; i < this._points.size(); i++) {\n        filter.filter(this$1._points.getCoordinate(i));\n      }\n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      var filter$1 = arguments[0];\n      if (this._points.size() === 0) { return null }\n      for (var i$1 = 0; i$1 < this._points.size(); i$1++) {\n        filter$1.filter(this$1._points, i$1);\n        if (filter$1.isDone()) { break }\n      }\n      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      var filter$2 = arguments[0];\n      filter$2.filter(this);\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      var filter$3 = arguments[0];\n      filter$3.filter(this);\n    }\n  };\n  LineString.prototype.getBoundary = function getBoundary () {\n    return new BoundaryOp(this).getBoundary()\n  };\n  LineString.prototype.isEquivalentClass = function isEquivalentClass (other) {\n    return other instanceof LineString\n  };\n  LineString.prototype.clone = function clone () {\n    var ls = Geometry$$1.prototype.clone.call(this);\n    ls._points = this._points.clone();\n    return ls\n  };\n  LineString.prototype.getCoordinateN = function getCoordinateN (n) {\n    return this._points.getCoordinate(n)\n  };\n  LineString.prototype.getGeometryType = function getGeometryType () {\n    return 'LineString'\n  };\n  LineString.prototype.copy = function copy () {\n    return new LineString(this._points.copy(), this._factory)\n  };\n  LineString.prototype.getCoordinateSequence = function getCoordinateSequence () {\n    return this._points\n  };\n  LineString.prototype.isEmpty = function isEmpty () {\n    return this._points.size() === 0\n  };\n  LineString.prototype.init = function init (points) {\n    if (points === null) {\n      points = this.getFactory().getCoordinateSequenceFactory().create([]);\n    }\n    if (points.size() === 1) {\n      throw new IllegalArgumentException('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)')\n    }\n    this._points = points;\n  };\n  LineString.prototype.isCoordinate = function isCoordinate (pt) {\n    var this$1 = this;\n\n    for (var i = 0; i < this._points.size(); i++) {\n      if (this$1._points.getCoordinate(i).equals(pt)) {\n        return true\n      }\n    }\n    return false\n  };\n  LineString.prototype.getStartPoint = function getStartPoint () {\n    if (this.isEmpty()) {\n      return null\n    }\n    return this.getPointN(0)\n  };\n  LineString.prototype.getPointN = function getPointN (n) {\n    return this.getFactory().createPoint(this._points.getCoordinate(n))\n  };\n  LineString.prototype.interfaces_ = function interfaces_ () {\n    return [Lineal]\n  };\n  LineString.prototype.getClass = function getClass () {\n    return LineString\n  };\n  staticAccessors.serialVersionUID.get = function () { return 3110669828065365560 };\n\n  Object.defineProperties( LineString, staticAccessors );\n\n  return LineString;\n}(Geometry));\n\nvar Puntal = function Puntal () {};\n\nPuntal.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPuntal.prototype.getClass = function getClass () {\n  return Puntal\n};\n\nvar Point = (function (Geometry$$1) {\n  function Point (coordinates, factory) {\n    Geometry$$1.call(this, factory);\n    this._coordinates = coordinates || null;\n    this.init(this._coordinates);\n  }\n\n  if ( Geometry$$1 ) Point.__proto__ = Geometry$$1;\n  Point.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  Point.prototype.constructor = Point;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  Point.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    if (this.isEmpty()) {\n      return new Envelope()\n    }\n    var env = new Envelope();\n    env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n    return env\n  };\n  Point.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_POINT\n  };\n  Point.prototype.getCoordinates = function getCoordinates () {\n    return this.isEmpty() ? [] : [this.getCoordinate()]\n  };\n  Point.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      if (this.isEmpty() && other.isEmpty()) {\n        return true\n      }\n      if (this.isEmpty() !== other.isEmpty()) {\n        return false\n      }\n      return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance)\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  Point.prototype.normalize = function normalize () {};\n  Point.prototype.getCoordinate = function getCoordinate () {\n    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null\n  };\n  Point.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return Dimension.FALSE\n  };\n  Point.prototype.getDimension = function getDimension () {\n    return 0\n  };\n  Point.prototype.getNumPoints = function getNumPoints () {\n    return this.isEmpty() ? 0 : 1\n  };\n  Point.prototype.reverse = function reverse () {\n    return this.copy()\n  };\n  Point.prototype.getX = function getX () {\n    if (this.getCoordinate() === null) {\n      throw new Error('getX called on empty Point')\n    }\n    return this.getCoordinate().x\n  };\n  Point.prototype.compareToSameClass = function compareToSameClass () {\n    if (arguments.length === 1) {\n      var other = arguments[0];\n      var point$1 = other;\n      return this.getCoordinate().compareTo(point$1.getCoordinate())\n    } else if (arguments.length === 2) {\n      var other$1 = arguments[0];\n      var comp = arguments[1];\n      var point = other$1;\n      return comp.compare(this._coordinates, point._coordinates)\n    }\n  };\n  Point.prototype.apply = function apply () {\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      var filter = arguments[0];\n      if (this.isEmpty()) {\n        return null\n      }\n      filter.filter(this.getCoordinate());\n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      var filter$1 = arguments[0];\n      if (this.isEmpty()) { return null }\n      filter$1.filter(this._coordinates, 0);\n      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      var filter$2 = arguments[0];\n      filter$2.filter(this);\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      var filter$3 = arguments[0];\n      filter$3.filter(this);\n    }\n  };\n  Point.prototype.getBoundary = function getBoundary () {\n    return this.getFactory().createGeometryCollection(null)\n  };\n  Point.prototype.clone = function clone () {\n    var p = Geometry$$1.prototype.clone.call(this);\n    p._coordinates = this._coordinates.clone();\n    return p\n  };\n  Point.prototype.getGeometryType = function getGeometryType () {\n    return 'Point'\n  };\n  Point.prototype.copy = function copy () {\n    return new Point(this._coordinates.copy(), this._factory)\n  };\n  Point.prototype.getCoordinateSequence = function getCoordinateSequence () {\n    return this._coordinates\n  };\n  Point.prototype.getY = function getY () {\n    if (this.getCoordinate() === null) {\n      throw new Error('getY called on empty Point')\n    }\n    return this.getCoordinate().y\n  };\n  Point.prototype.isEmpty = function isEmpty () {\n    return this._coordinates.size() === 0\n  };\n  Point.prototype.init = function init (coordinates) {\n    if (coordinates === null) {\n      coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n    }\n    Assert.isTrue(coordinates.size() <= 1);\n    this._coordinates = coordinates;\n  };\n  Point.prototype.isSimple = function isSimple () {\n    return true\n  };\n  Point.prototype.interfaces_ = function interfaces_ () {\n    return [Puntal]\n  };\n  Point.prototype.getClass = function getClass () {\n    return Point\n  };\n  staticAccessors.serialVersionUID.get = function () { return 4902022702746614570 };\n\n  Object.defineProperties( Point, staticAccessors );\n\n  return Point;\n}(Geometry));\n\nvar Polygonal = function Polygonal () {};\n\nPolygonal.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPolygonal.prototype.getClass = function getClass () {\n  return Polygonal\n};\n\nvar Polygon = (function (Geometry$$1) {\n  function Polygon (shell, holes, factory) {\n    Geometry$$1.call(this, factory);\n    this._shell = null;\n    this._holes = null;\n    if (shell === null) {\n      shell = this.getFactory().createLinearRing();\n    }\n    if (holes === null) {\n      holes = [];\n    }\n    if (Geometry$$1.hasNullElements(holes)) {\n      throw new IllegalArgumentException('holes must not contain null elements')\n    }\n    if (shell.isEmpty() && Geometry$$1.hasNonEmptyElements(holes)) {\n      throw new IllegalArgumentException('shell is empty but holes are not')\n    }\n    this._shell = shell;\n    this._holes = holes;\n  }\n\n  if ( Geometry$$1 ) Polygon.__proto__ = Geometry$$1;\n  Polygon.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  Polygon.prototype.constructor = Polygon;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  Polygon.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    return this._shell.getEnvelopeInternal()\n  };\n  Polygon.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_POLYGON\n  };\n  Polygon.prototype.getCoordinates = function getCoordinates () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return []\n    }\n    var coordinates = new Array(this.getNumPoints()).fill(null);\n    var k = -1;\n    var shellCoordinates = this._shell.getCoordinates();\n    for (var x = 0; x < shellCoordinates.length; x++) {\n      k++;\n      coordinates[k] = shellCoordinates[x];\n    }\n    for (var i = 0; i < this._holes.length; i++) {\n      var childCoordinates = this$1._holes[i].getCoordinates();\n      for (var j = 0; j < childCoordinates.length; j++) {\n        k++;\n        coordinates[k] = childCoordinates[j];\n      }\n    }\n    return coordinates\n  };\n  Polygon.prototype.getArea = function getArea () {\n    var this$1 = this;\n\n    var area = 0.0;\n    area += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));\n    for (var i = 0; i < this._holes.length; i++) {\n      area -= Math.abs(CGAlgorithms.signedArea(this$1._holes[i].getCoordinateSequence()));\n    }\n    return area\n  };\n  Polygon.prototype.isRectangle = function isRectangle () {\n    if (this.getNumInteriorRing() !== 0) { return false }\n    if (this._shell === null) { return false }\n    if (this._shell.getNumPoints() !== 5) { return false }\n    var seq = this._shell.getCoordinateSequence();\n    var env = this.getEnvelopeInternal();\n    for (var i = 0; i < 5; i++) {\n      var x = seq.getX(i);\n      if (!(x === env.getMinX() || x === env.getMaxX())) { return false }\n      var y = seq.getY(i);\n      if (!(y === env.getMinY() || y === env.getMaxY())) { return false }\n    }\n    var prevX = seq.getX(0);\n    var prevY = seq.getY(0);\n    for (var i$1 = 1; i$1 <= 4; i$1++) {\n      var x$1 = seq.getX(i$1);\n      var y$1 = seq.getY(i$1);\n      var xChanged = x$1 !== prevX;\n      var yChanged = y$1 !== prevY;\n      if (xChanged === yChanged) { return false }\n      prevX = x$1;\n      prevY = y$1;\n    }\n    return true\n  };\n  Polygon.prototype.equalsExact = function equalsExact () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      var otherPolygon = other;\n      var thisShell = this._shell;\n      var otherPolygonShell = otherPolygon._shell;\n      if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n        return false\n      }\n      if (this._holes.length !== otherPolygon._holes.length) {\n        return false\n      }\n      for (var i = 0; i < this._holes.length; i++) {\n        if (!this$1._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n          return false\n        }\n      }\n      return true\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  Polygon.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n    if (arguments.length === 0) {\n      this.normalize(this._shell, true);\n      for (var i = 0; i < this._holes.length; i++) {\n        this$1.normalize(this$1._holes[i], false);\n      }\n      Arrays.sort(this._holes);\n    } else if (arguments.length === 2) {\n      var ring = arguments[0];\n      var clockwise = arguments[1];\n      if (ring.isEmpty()) {\n        return null\n      }\n      var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n      System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n      var minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n      CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n      System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n      ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n      if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {\n        CoordinateArrays.reverse(ring.getCoordinates());\n      }\n    }\n  };\n  Polygon.prototype.getCoordinate = function getCoordinate () {\n    return this._shell.getCoordinate()\n  };\n  Polygon.prototype.getNumInteriorRing = function getNumInteriorRing () {\n    return this._holes.length\n  };\n  Polygon.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return 1\n  };\n  Polygon.prototype.getDimension = function getDimension () {\n    return 2\n  };\n  Polygon.prototype.getLength = function getLength () {\n    var this$1 = this;\n\n    var len = 0.0;\n    len += this._shell.getLength();\n    for (var i = 0; i < this._holes.length; i++) {\n      len += this$1._holes[i].getLength();\n    }\n    return len\n  };\n  Polygon.prototype.getNumPoints = function getNumPoints () {\n    var this$1 = this;\n\n    var numPoints = this._shell.getNumPoints();\n    for (var i = 0; i < this._holes.length; i++) {\n      numPoints += this$1._holes[i].getNumPoints();\n    }\n    return numPoints\n  };\n  Polygon.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var poly = this.copy();\n    poly._shell = this._shell.copy().reverse();\n    poly._holes = new Array(this._holes.length).fill(null);\n    for (var i = 0; i < this._holes.length; i++) {\n      poly._holes[i] = this$1._holes[i].copy().reverse();\n    }\n    return poly\n  };\n  Polygon.prototype.convexHull = function convexHull () {\n    return this.getExteriorRing().convexHull()\n  };\n  Polygon.prototype.compareToSameClass = function compareToSameClass () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var o = arguments[0];\n      var thisShell = this._shell;\n      var otherShell = o._shell;\n      return thisShell.compareToSameClass(otherShell)\n    } else if (arguments.length === 2) {\n      var o$1 = arguments[0];\n      var comp = arguments[1];\n      var poly = o$1;\n      var thisShell$1 = this._shell;\n      var otherShell$1 = poly._shell;\n      var shellComp = thisShell$1.compareToSameClass(otherShell$1, comp);\n      if (shellComp !== 0) { return shellComp }\n      var nHole1 = this.getNumInteriorRing();\n      var nHole2 = poly.getNumInteriorRing();\n      var i = 0;\n      while (i < nHole1 && i < nHole2) {\n        var thisHole = this$1.getInteriorRingN(i);\n        var otherHole = poly.getInteriorRingN(i);\n        var holeComp = thisHole.compareToSameClass(otherHole, comp);\n        if (holeComp !== 0) { return holeComp }\n        i++;\n      }\n      if (i < nHole1) { return 1 }\n      if (i < nHole2) { return -1 }\n      return 0\n    }\n  };\n  Polygon.prototype.apply = function apply (filter) {\n    var this$1 = this;\n\n    if (hasInterface(filter, CoordinateFilter)) {\n      this._shell.apply(filter);\n      for (var i$1 = 0; i$1 < this._holes.length; i$1++) {\n        this$1._holes[i$1].apply(filter);\n      }\n    } else if (hasInterface(filter, CoordinateSequenceFilter)) {\n      this._shell.apply(filter);\n      if (!filter.isDone()) {\n        for (var i$2 = 0; i$2 < this._holes.length; i$2++) {\n          this$1._holes[i$2].apply(filter);\n          if (filter.isDone()) { break }\n        }\n      }\n      if (filter.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(filter, GeometryFilter)) {\n      filter.filter(this);\n    } else if (hasInterface(filter, GeometryComponentFilter)) {\n      filter.filter(this);\n      this._shell.apply(filter);\n      for (var i = 0; i < this._holes.length; i++) {\n        this$1._holes[i].apply(filter);\n      }\n    }\n  };\n  Polygon.prototype.getBoundary = function getBoundary () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return this.getFactory().createMultiLineString()\n    }\n    var rings = new Array(this._holes.length + 1).fill(null);\n    rings[0] = this._shell;\n    for (var i = 0; i < this._holes.length; i++) {\n      rings[i + 1] = this$1._holes[i];\n    }\n    if (rings.length <= 1) { return this.getFactory().createLinearRing(rings[0].getCoordinateSequence()) }\n    return this.getFactory().createMultiLineString(rings)\n  };\n  Polygon.prototype.clone = function clone () {\n    var this$1 = this;\n\n    var poly = Geometry$$1.prototype.clone.call(this);\n    poly._shell = this._shell.clone();\n    poly._holes = new Array(this._holes.length).fill(null);\n    for (var i = 0; i < this._holes.length; i++) {\n      poly._holes[i] = this$1._holes[i].clone();\n    }\n    return poly\n  };\n  Polygon.prototype.getGeometryType = function getGeometryType () {\n    return 'Polygon'\n  };\n  Polygon.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var shell = this._shell.copy();\n    var holes = new Array(this._holes.length).fill(null);\n    for (var i = 0; i < holes.length; i++) {\n      holes[i] = this$1._holes[i].copy();\n    }\n    return new Polygon(shell, holes, this._factory)\n  };\n  Polygon.prototype.getExteriorRing = function getExteriorRing () {\n    return this._shell\n  };\n  Polygon.prototype.isEmpty = function isEmpty () {\n    return this._shell.isEmpty()\n  };\n  Polygon.prototype.getInteriorRingN = function getInteriorRingN (n) {\n    return this._holes[n]\n  };\n  Polygon.prototype.interfaces_ = function interfaces_ () {\n    return [Polygonal]\n  };\n  Polygon.prototype.getClass = function getClass () {\n    return Polygon\n  };\n  staticAccessors.serialVersionUID.get = function () { return -3494792200821764533 };\n\n  Object.defineProperties( Polygon, staticAccessors );\n\n  return Polygon;\n}(Geometry));\n\nvar MultiPoint = (function (GeometryCollection$$1) {\n  function MultiPoint () {\n    GeometryCollection$$1.apply(this, arguments);\n  }\n\n  if ( GeometryCollection$$1 ) MultiPoint.__proto__ = GeometryCollection$$1;\n  MultiPoint.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );\n  MultiPoint.prototype.constructor = MultiPoint;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n\n  MultiPoint.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_MULTIPOINT\n  };\n  MultiPoint.prototype.isValid = function isValid () {\n    return true\n  };\n  MultiPoint.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)\n    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  MultiPoint.prototype.getCoordinate = function getCoordinate () {\n    if (arguments.length === 1) {\n      var n = arguments[0];\n      return this._geometries[n].getCoordinate()\n    } else { return GeometryCollection$$1.prototype.getCoordinate.apply(this, arguments) }\n  };\n  MultiPoint.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return Dimension.FALSE\n  };\n  MultiPoint.prototype.getDimension = function getDimension () {\n    return 0\n  };\n  MultiPoint.prototype.getBoundary = function getBoundary () {\n    return this.getFactory().createGeometryCollection(null)\n  };\n  MultiPoint.prototype.getGeometryType = function getGeometryType () {\n    return 'MultiPoint'\n  };\n  MultiPoint.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var points = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < points.length; i++) {\n      points[i] = this$1._geometries[i].copy();\n    }\n    return new MultiPoint(points, this._factory)\n  };\n  MultiPoint.prototype.interfaces_ = function interfaces_ () {\n    return [Puntal]\n  };\n  MultiPoint.prototype.getClass = function getClass () {\n    return MultiPoint\n  };\n  staticAccessors.serialVersionUID.get = function () { return -8048474874175355449 };\n\n  Object.defineProperties( MultiPoint, staticAccessors );\n\n  return MultiPoint;\n}(GeometryCollection));\n\nvar LinearRing = (function (LineString$$1) {\n  function LinearRing (points, factory) {\n    if (points instanceof Coordinate && factory instanceof GeometryFactory) {\n      points = factory.getCoordinateSequenceFactory().create(points);\n    }\n    LineString$$1.call(this, points, factory);\n    this.validateConstruction();\n  }\n\n  if ( LineString$$1 ) LinearRing.__proto__ = LineString$$1;\n  LinearRing.prototype = Object.create( LineString$$1 && LineString$$1.prototype );\n  LinearRing.prototype.constructor = LinearRing;\n\n  var staticAccessors = { MINIMUM_VALID_SIZE: { configurable: true },serialVersionUID: { configurable: true } };\n  LinearRing.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_LINEARRING\n  };\n  LinearRing.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return Dimension.FALSE\n  };\n  LinearRing.prototype.isClosed = function isClosed () {\n    if (this.isEmpty()) {\n      return true\n    }\n    return LineString$$1.prototype.isClosed.call(this)\n  };\n  LinearRing.prototype.reverse = function reverse () {\n    var seq = this._points.copy();\n    CoordinateSequences.reverse(seq);\n    var rev = this.getFactory().createLinearRing(seq);\n    return rev\n  };\n  LinearRing.prototype.validateConstruction = function validateConstruction () {\n    if (!this.isEmpty() && !LineString$$1.prototype.isClosed.call(this)) {\n      throw new IllegalArgumentException('Points of LinearRing do not form a closed linestring')\n    }\n    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n      throw new IllegalArgumentException('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)')\n    }\n  };\n  LinearRing.prototype.getGeometryType = function getGeometryType () {\n    return 'LinearRing'\n  };\n  LinearRing.prototype.copy = function copy () {\n    return new LinearRing(this._points.copy(), this._factory)\n  };\n  LinearRing.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  LinearRing.prototype.getClass = function getClass () {\n    return LinearRing\n  };\n  staticAccessors.MINIMUM_VALID_SIZE.get = function () { return 4 };\n  staticAccessors.serialVersionUID.get = function () { return -4261142084085851829 };\n\n  Object.defineProperties( LinearRing, staticAccessors );\n\n  return LinearRing;\n}(LineString));\n\nvar MultiPolygon = (function (GeometryCollection$$1) {\n  function MultiPolygon () {\n    GeometryCollection$$1.apply(this, arguments);\n  }\n\n  if ( GeometryCollection$$1 ) MultiPolygon.__proto__ = GeometryCollection$$1;\n  MultiPolygon.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );\n  MultiPolygon.prototype.constructor = MultiPolygon;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n\n  MultiPolygon.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_MULTIPOLYGON\n  };\n  MultiPolygon.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)\n    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  MultiPolygon.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return 1\n  };\n  MultiPolygon.prototype.getDimension = function getDimension () {\n    return 2\n  };\n  MultiPolygon.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var n = this._geometries.length;\n    var revGeoms = new Array(n).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      revGeoms[i] = this$1._geometries[i].reverse();\n    }\n    return this.getFactory().createMultiPolygon(revGeoms)\n  };\n  MultiPolygon.prototype.getBoundary = function getBoundary () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return this.getFactory().createMultiLineString()\n    }\n    var allRings = new ArrayList();\n    for (var i = 0; i < this._geometries.length; i++) {\n      var polygon = this$1._geometries[i];\n      var rings = polygon.getBoundary();\n      for (var j = 0; j < rings.getNumGeometries(); j++) {\n        allRings.add(rings.getGeometryN(j));\n      }\n    }\n    var allRingsArray = new Array(allRings.size()).fill(null);\n    return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray))\n  };\n  MultiPolygon.prototype.getGeometryType = function getGeometryType () {\n    return 'MultiPolygon'\n  };\n  MultiPolygon.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var polygons = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < polygons.length; i++) {\n      polygons[i] = this$1._geometries[i].copy();\n    }\n    return new MultiPolygon(polygons, this._factory)\n  };\n  MultiPolygon.prototype.interfaces_ = function interfaces_ () {\n    return [Polygonal]\n  };\n  MultiPolygon.prototype.getClass = function getClass () {\n    return MultiPolygon\n  };\n  staticAccessors.serialVersionUID.get = function () { return -551033529766975875 };\n\n  Object.defineProperties( MultiPolygon, staticAccessors );\n\n  return MultiPolygon;\n}(GeometryCollection));\n\nvar GeometryEditor = function GeometryEditor (factory) {\n  this._factory = factory || null;\n  this._isUserDataCopied = false;\n};\n\nvar staticAccessors$16 = { NoOpGeometryOperation: { configurable: true },CoordinateOperation: { configurable: true },CoordinateSequenceOperation: { configurable: true } };\nGeometryEditor.prototype.setCopyUserData = function setCopyUserData (isUserDataCopied) {\n  this._isUserDataCopied = isUserDataCopied;\n};\nGeometryEditor.prototype.edit = function edit (geometry, operation) {\n  if (geometry === null) { return null }\n  var result = this.editInternal(geometry, operation);\n  if (this._isUserDataCopied) {\n    result.setUserData(geometry.getUserData());\n  }\n  return result\n};\nGeometryEditor.prototype.editInternal = function editInternal (geometry, operation) {\n  if (this._factory === null) { this._factory = geometry.getFactory(); }\n  if (geometry instanceof GeometryCollection) {\n    return this.editGeometryCollection(geometry, operation)\n  }\n  if (geometry instanceof Polygon) {\n    return this.editPolygon(geometry, operation)\n  }\n  if (geometry instanceof Point) {\n    return operation.edit(geometry, this._factory)\n  }\n  if (geometry instanceof LineString) {\n    return operation.edit(geometry, this._factory)\n  }\n  Assert.shouldNeverReachHere('Unsupported Geometry class: ' + geometry.getClass().getName());\n  return null\n};\nGeometryEditor.prototype.editGeometryCollection = function editGeometryCollection (collection, operation) {\n    var this$1 = this;\n\n  var collectionForType = operation.edit(collection, this._factory);\n  var geometries = new ArrayList();\n  for (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n    var geometry = this$1.edit(collectionForType.getGeometryN(i), operation);\n    if (geometry === null || geometry.isEmpty()) {\n      continue\n    }\n    geometries.add(geometry);\n  }\n  if (collectionForType.getClass() === MultiPoint) {\n    return this._factory.createMultiPoint(geometries.toArray([]))\n  }\n  if (collectionForType.getClass() === MultiLineString) {\n    return this._factory.createMultiLineString(geometries.toArray([]))\n  }\n  if (collectionForType.getClass() === MultiPolygon) {\n    return this._factory.createMultiPolygon(geometries.toArray([]))\n  }\n  return this._factory.createGeometryCollection(geometries.toArray([]))\n};\nGeometryEditor.prototype.editPolygon = function editPolygon (polygon, operation) {\n    var this$1 = this;\n\n  var newPolygon = operation.edit(polygon, this._factory);\n  if (newPolygon === null) { newPolygon = this._factory.createPolygon(null); }\n  if (newPolygon.isEmpty()) {\n    return newPolygon\n  }\n  var shell = this.edit(newPolygon.getExteriorRing(), operation);\n  if (shell === null || shell.isEmpty()) {\n    return this._factory.createPolygon()\n  }\n  var holes = new ArrayList();\n  for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n    var hole = this$1.edit(newPolygon.getInteriorRingN(i), operation);\n    if (hole === null || hole.isEmpty()) {\n      continue\n    }\n    holes.add(hole);\n  }\n  return this._factory.createPolygon(shell, holes.toArray([]))\n};\nGeometryEditor.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryEditor.prototype.getClass = function getClass () {\n  return GeometryEditor\n};\nGeometryEditor.GeometryEditorOperation = function GeometryEditorOperation () {};\nstaticAccessors$16.NoOpGeometryOperation.get = function () { return NoOpGeometryOperation };\nstaticAccessors$16.CoordinateOperation.get = function () { return CoordinateOperation };\nstaticAccessors$16.CoordinateSequenceOperation.get = function () { return CoordinateSequenceOperation };\n\nObject.defineProperties( GeometryEditor, staticAccessors$16 );\n\nvar NoOpGeometryOperation = function NoOpGeometryOperation () {};\n\nNoOpGeometryOperation.prototype.edit = function edit (geometry, factory) {\n  return geometry\n};\nNoOpGeometryOperation.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryEditor.GeometryEditorOperation]\n};\nNoOpGeometryOperation.prototype.getClass = function getClass () {\n  return NoOpGeometryOperation\n};\n\nvar CoordinateOperation = function CoordinateOperation () {};\n\nCoordinateOperation.prototype.edit = function edit (geometry, factory) {\n  var coords = this.editCoordinates(geometry.getCoordinates(), geometry);\n  if (coords === null) { return geometry }\n  if (geometry instanceof LinearRing) {\n    return factory.createLinearRing(coords)\n  }\n  if (geometry instanceof LineString) {\n    return factory.createLineString(coords)\n  }\n  if (geometry instanceof Point) {\n    if (coords.length > 0) {\n      return factory.createPoint(coords[0])\n    } else {\n      return factory.createPoint()\n    }\n  }\n  return geometry\n};\nCoordinateOperation.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryEditor.GeometryEditorOperation]\n};\nCoordinateOperation.prototype.getClass = function getClass () {\n  return CoordinateOperation\n};\n\nvar CoordinateSequenceOperation = function CoordinateSequenceOperation () {};\n\nCoordinateSequenceOperation.prototype.edit = function edit (geometry, factory) {\n  if (geometry instanceof LinearRing) {\n    return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry))\n  }\n  if (geometry instanceof LineString) {\n    return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry))\n  }\n  if (geometry instanceof Point) {\n    return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry))\n  }\n  return geometry\n};\nCoordinateSequenceOperation.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryEditor.GeometryEditorOperation]\n};\nCoordinateSequenceOperation.prototype.getClass = function getClass () {\n  return CoordinateSequenceOperation\n};\n\nvar CoordinateArraySequence = function CoordinateArraySequence () {\n  var this$1 = this;\n\n  this._dimension = 3;\n  this._coordinates = null;\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      this._coordinates = arguments[0];\n      this._dimension = 3;\n    } else if (Number.isInteger(arguments[0])) {\n      var size = arguments[0];\n      this._coordinates = new Array(size).fill(null);\n      for (var i = 0; i < size; i++) {\n        this$1._coordinates[i] = new Coordinate();\n      }\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordSeq = arguments[0];\n      if (coordSeq === null) {\n        this._coordinates = new Array(0).fill(null);\n        return null\n      }\n      this._dimension = coordSeq.getDimension();\n      this._coordinates = new Array(coordSeq.size()).fill(null);\n      for (var i$1 = 0; i$1 < this._coordinates.length; i$1++) {\n        this$1._coordinates[i$1] = coordSeq.getCoordinateCopy(i$1);\n      }\n    }\n  } else if (arguments.length === 2) {\n    if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n      var coordinates = arguments[0];\n      var dimension = arguments[1];\n      this._coordinates = coordinates;\n      this._dimension = dimension;\n      if (coordinates === null) { this._coordinates = new Array(0).fill(null); }\n    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n      var size$1 = arguments[0];\n      var dimension$1 = arguments[1];\n      this._coordinates = new Array(size$1).fill(null);\n      this._dimension = dimension$1;\n      for (var i$2 = 0; i$2 < size$1; i$2++) {\n        this$1._coordinates[i$2] = new Coordinate();\n      }\n    }\n  }\n};\n\nvar staticAccessors$18 = { serialVersionUID: { configurable: true } };\nCoordinateArraySequence.prototype.setOrdinate = function setOrdinate (index, ordinateIndex, value) {\n  switch (ordinateIndex) {\n    case CoordinateSequence.X:\n      this._coordinates[index].x = value;\n      break\n    case CoordinateSequence.Y:\n      this._coordinates[index].y = value;\n      break\n    case CoordinateSequence.Z:\n      this._coordinates[index].z = value;\n      break\n    default:\n      throw new IllegalArgumentException('invalid ordinateIndex')\n  }\n};\nCoordinateArraySequence.prototype.size = function size () {\n  return this._coordinates.length\n};\nCoordinateArraySequence.prototype.getOrdinate = function getOrdinate (index, ordinateIndex) {\n  switch (ordinateIndex) {\n    case CoordinateSequence.X:\n      return this._coordinates[index].x\n    case CoordinateSequence.Y:\n      return this._coordinates[index].y\n    case CoordinateSequence.Z:\n      return this._coordinates[index].z\n    default:\n  }\n  return Double.NaN\n};\nCoordinateArraySequence.prototype.getCoordinate = function getCoordinate () {\n  if (arguments.length === 1) {\n    var i = arguments[0];\n    return this._coordinates[i]\n  } else if (arguments.length === 2) {\n    var index = arguments[0];\n    var coord = arguments[1];\n    coord.x = this._coordinates[index].x;\n    coord.y = this._coordinates[index].y;\n    coord.z = this._coordinates[index].z;\n  }\n};\nCoordinateArraySequence.prototype.getCoordinateCopy = function getCoordinateCopy (i) {\n  return new Coordinate(this._coordinates[i])\n};\nCoordinateArraySequence.prototype.getDimension = function getDimension () {\n  return this._dimension\n};\nCoordinateArraySequence.prototype.getX = function getX (index) {\n  return this._coordinates[index].x\n};\nCoordinateArraySequence.prototype.clone = function clone () {\n    var this$1 = this;\n\n  var cloneCoordinates = new Array(this.size()).fill(null);\n  for (var i = 0; i < this._coordinates.length; i++) {\n    cloneCoordinates[i] = this$1._coordinates[i].clone();\n  }\n  return new CoordinateArraySequence(cloneCoordinates, this._dimension)\n};\nCoordinateArraySequence.prototype.expandEnvelope = function expandEnvelope (env) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._coordinates.length; i++) {\n    env.expandToInclude(this$1._coordinates[i]);\n  }\n  return env\n};\nCoordinateArraySequence.prototype.copy = function copy () {\n    var this$1 = this;\n\n  var cloneCoordinates = new Array(this.size()).fill(null);\n  for (var i = 0; i < this._coordinates.length; i++) {\n    cloneCoordinates[i] = this$1._coordinates[i].copy();\n  }\n  return new CoordinateArraySequence(cloneCoordinates, this._dimension)\n};\nCoordinateArraySequence.prototype.toString = function toString () {\n    var this$1 = this;\n\n  if (this._coordinates.length > 0) {\n    var strBuf = new StringBuffer(17 * this._coordinates.length);\n    strBuf.append('(');\n    strBuf.append(this._coordinates[0]);\n    for (var i = 1; i < this._coordinates.length; i++) {\n      strBuf.append(', ');\n      strBuf.append(this$1._coordinates[i]);\n    }\n    strBuf.append(')');\n    return strBuf.toString()\n  } else {\n    return '()'\n  }\n};\nCoordinateArraySequence.prototype.getY = function getY (index) {\n  return this._coordinates[index].y\n};\nCoordinateArraySequence.prototype.toCoordinateArray = function toCoordinateArray () {\n  return this._coordinates\n};\nCoordinateArraySequence.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequence, Serializable]\n};\nCoordinateArraySequence.prototype.getClass = function getClass () {\n  return CoordinateArraySequence\n};\nstaticAccessors$18.serialVersionUID.get = function () { return -915438501601840650 };\n\nObject.defineProperties( CoordinateArraySequence, staticAccessors$18 );\n\nvar CoordinateArraySequenceFactory = function CoordinateArraySequenceFactory () {};\n\nvar staticAccessors$17 = { serialVersionUID: { configurable: true },instanceObject: { configurable: true } };\n\nCoordinateArraySequenceFactory.prototype.readResolve = function readResolve () {\n  return CoordinateArraySequenceFactory.instance()\n};\nCoordinateArraySequenceFactory.prototype.create = function create () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var coordinates = arguments[0];\n      return new CoordinateArraySequence(coordinates)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordSeq = arguments[0];\n      return new CoordinateArraySequence(coordSeq)\n    }\n  } else if (arguments.length === 2) {\n    var size = arguments[0];\n    var dimension = arguments[1];\n    if (dimension > 3) { dimension = 3; }\n    if (dimension < 2) { return new CoordinateArraySequence(size) }\n    return new CoordinateArraySequence(size, dimension)\n  }\n};\nCoordinateArraySequenceFactory.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFactory, Serializable]\n};\nCoordinateArraySequenceFactory.prototype.getClass = function getClass () {\n  return CoordinateArraySequenceFactory\n};\nCoordinateArraySequenceFactory.instance = function instance () {\n  return CoordinateArraySequenceFactory.instanceObject\n};\n\nstaticAccessors$17.serialVersionUID.get = function () { return -4099577099607551657 };\nstaticAccessors$17.instanceObject.get = function () { return new CoordinateArraySequenceFactory() };\n\nObject.defineProperties( CoordinateArraySequenceFactory, staticAccessors$17 );\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n *\n * @extends {javascript.util.Map}\n * @constructor\n * @private\n */\nvar HashMap = (function (MapInterface) {\n  function HashMap () {\n    MapInterface.call(this);\n    this.map_ = new Map();\n  }\n\n  if ( MapInterface ) HashMap.__proto__ = MapInterface;\n  HashMap.prototype = Object.create( MapInterface && MapInterface.prototype );\n  HashMap.prototype.constructor = HashMap;\n  /**\n   * @override\n   */\n  HashMap.prototype.get = function get (key) {\n    return this.map_.get(key) || null\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.put = function put (key, value) {\n    this.map_.set(key, value);\n    return value\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.values = function values () {\n    var arrayList = new ArrayList();\n    var it = this.map_.values();\n    var o = it.next();\n    while (!o.done) {\n      arrayList.add(o.value);\n      o = it.next();\n    }\n    return arrayList\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.entrySet = function entrySet () {\n    var hashSet = new HashSet();\n    this.map_.entries().forEach(function (entry) { return hashSet.add(entry); });\n    return hashSet\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.size = function size () {\n    return this.map_.size()\n  };\n\n  return HashMap;\n}(Map$1));\n\nvar PrecisionModel = function PrecisionModel () {\n  this._modelType = null;\n  this._scale = null;\n  if (arguments.length === 0) {\n    this._modelType = PrecisionModel.FLOATING;\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Type) {\n      var modelType = arguments[0];\n      this._modelType = modelType;\n      if (modelType === PrecisionModel.FIXED) {\n        this.setScale(1.0);\n      }\n    } else if (typeof arguments[0] === 'number') {\n      var scale = arguments[0];\n      this._modelType = PrecisionModel.FIXED;\n      this.setScale(scale);\n    } else if (arguments[0] instanceof PrecisionModel) {\n      var pm = arguments[0];\n      this._modelType = pm._modelType;\n      this._scale = pm._scale;\n    }\n  }\n};\n\nvar staticAccessors$19 = { serialVersionUID: { configurable: true },maximumPreciseValue: { configurable: true } };\nPrecisionModel.prototype.equals = function equals (other) {\n  if (!(other instanceof PrecisionModel)) {\n    return false\n  }\n  var otherPrecisionModel = other;\n  return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale\n};\nPrecisionModel.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  var sigDigits = this.getMaximumSignificantDigits();\n  var otherSigDigits = other.getMaximumSignificantDigits();\n  return new Integer(sigDigits).compareTo(new Integer(otherSigDigits))\n};\nPrecisionModel.prototype.getScale = function getScale () {\n  return this._scale\n};\nPrecisionModel.prototype.isFloating = function isFloating () {\n  return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE\n};\nPrecisionModel.prototype.getType = function getType () {\n  return this._modelType\n};\nPrecisionModel.prototype.toString = function toString () {\n  var description = 'UNKNOWN';\n  if (this._modelType === PrecisionModel.FLOATING) {\n    description = 'Floating';\n  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n    description = 'Floating-Single';\n  } else if (this._modelType === PrecisionModel.FIXED) {\n    description = 'Fixed (Scale=' + this.getScale() + ')';\n  }\n  return description\n};\nPrecisionModel.prototype.makePrecise = function makePrecise () {\n  if (typeof arguments[0] === 'number') {\n    var val = arguments[0];\n    if (Double.isNaN(val)) { return val }\n    if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n      var floatSingleVal = val;\n      return floatSingleVal\n    }\n    if (this._modelType === PrecisionModel.FIXED) {\n      return Math.round(val * this._scale) / this._scale\n    }\n    return val\n  } else if (arguments[0] instanceof Coordinate) {\n    var coord = arguments[0];\n    if (this._modelType === PrecisionModel.FLOATING) { return null }\n    coord.x = this.makePrecise(coord.x);\n    coord.y = this.makePrecise(coord.y);\n  }\n};\nPrecisionModel.prototype.getMaximumSignificantDigits = function getMaximumSignificantDigits () {\n  var maxSigDigits = 16;\n  if (this._modelType === PrecisionModel.FLOATING) {\n    maxSigDigits = 16;\n  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n    maxSigDigits = 6;\n  } else if (this._modelType === PrecisionModel.FIXED) {\n    maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n  }\n  return maxSigDigits\n};\nPrecisionModel.prototype.setScale = function setScale (scale) {\n  this._scale = Math.abs(scale);\n};\nPrecisionModel.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable, Comparable]\n};\nPrecisionModel.prototype.getClass = function getClass () {\n  return PrecisionModel\n};\nPrecisionModel.mostPrecise = function mostPrecise (pm1, pm2) {\n  if (pm1.compareTo(pm2) >= 0) { return pm1 }\n  return pm2\n};\nstaticAccessors$19.serialVersionUID.get = function () { return 7777263578777803835 };\nstaticAccessors$19.maximumPreciseValue.get = function () { return 9007199254740992.0 };\n\nObject.defineProperties( PrecisionModel, staticAccessors$19 );\n\nvar Type = function Type (name) {\n  this._name = name || null;\n  Type.nameToTypeMap.put(name, this);\n};\n\nvar staticAccessors$1$1 = { serialVersionUID: { configurable: true },nameToTypeMap: { configurable: true } };\nType.prototype.readResolve = function readResolve () {\n  return Type.nameToTypeMap.get(this._name)\n};\nType.prototype.toString = function toString () {\n  return this._name\n};\nType.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable]\n};\nType.prototype.getClass = function getClass () {\n  return Type\n};\nstaticAccessors$1$1.serialVersionUID.get = function () { return -5528602631731589822 };\nstaticAccessors$1$1.nameToTypeMap.get = function () { return new HashMap() };\n\nObject.defineProperties( Type, staticAccessors$1$1 );\n\nPrecisionModel.Type = Type;\nPrecisionModel.FIXED = new Type('FIXED');\nPrecisionModel.FLOATING = new Type('FLOATING');\nPrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');\n\nvar GeometryFactory = function GeometryFactory () {\n  this._precisionModel = new PrecisionModel();\n  this._SRID = 0;\n  this._coordinateSequenceFactory = GeometryFactory.getDefaultCoordinateSequenceFactory();\n\n  if (arguments.length === 0) {\n  } else if (arguments.length === 1) {\n    if (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n      this._coordinateSequenceFactory = arguments[0];\n    } else if (arguments[0] instanceof PrecisionModel) {\n      this._precisionModel = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    this._precisionModel = arguments[0];\n    this._SRID = arguments[1];\n  } else if (arguments.length === 3) {\n    this._precisionModel = arguments[0];\n    this._SRID = arguments[1];\n    this._coordinateSequenceFactory = arguments[2];\n  }\n};\n\nvar staticAccessors$2 = { serialVersionUID: { configurable: true } };\nGeometryFactory.prototype.toGeometry = function toGeometry (envelope) {\n  if (envelope.isNull()) {\n    return this.createPoint(null)\n  }\n  if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n    return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()))\n  }\n  if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n    return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())])\n  }\n  return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null)\n};\nGeometryFactory.prototype.createLineString = function createLineString (coordinates) {\n  if (!coordinates) { return new LineString(this.getCoordinateSequenceFactory().create([]), this) }\n  else if (coordinates instanceof Array) { return new LineString(this.getCoordinateSequenceFactory().create(coordinates), this) }\n  else if (hasInterface(coordinates, CoordinateSequence)) { return new LineString(coordinates, this) }\n};\nGeometryFactory.prototype.createMultiLineString = function createMultiLineString () {\n  if (arguments.length === 0) {\n    return new MultiLineString(null, this)\n  } else if (arguments.length === 1) {\n    var lineStrings = arguments[0];\n    return new MultiLineString(lineStrings, this)\n  }\n};\nGeometryFactory.prototype.buildGeometry = function buildGeometry (geomList) {\n  var geomClass = null;\n  var isHeterogeneous = false;\n  var hasGeometryCollection = false;\n  for (var i = geomList.iterator(); i.hasNext();) {\n    var geom = i.next();\n    var partClass = geom.getClass();\n    if (geomClass === null) {\n      geomClass = partClass;\n    }\n    if (partClass !== geomClass) {\n      isHeterogeneous = true;\n    }\n    if (geom.isGeometryCollectionOrDerived()) { hasGeometryCollection = true; }\n  }\n  if (geomClass === null) {\n    return this.createGeometryCollection()\n  }\n  if (isHeterogeneous || hasGeometryCollection) {\n    return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList))\n  }\n  var geom0 = geomList.iterator().next();\n  var isCollection = geomList.size() > 1;\n  if (isCollection) {\n    if (geom0 instanceof Polygon) {\n      return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList))\n    } else if (geom0 instanceof LineString) {\n      return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList))\n    } else if (geom0 instanceof Point) {\n      return this.createMultiPoint(GeometryFactory.toPointArray(geomList))\n    }\n    Assert.shouldNeverReachHere('Unhandled class: ' + geom0.getClass().getName());\n  }\n  return geom0\n};\nGeometryFactory.prototype.createMultiPointFromCoords = function createMultiPointFromCoords (coordinates) {\n  return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n};\nGeometryFactory.prototype.createPoint = function createPoint () {\n  if (arguments.length === 0) {\n    return this.createPoint(this.getCoordinateSequenceFactory().create([]))\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var coordinate = arguments[0];\n      return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates = arguments[0];\n      return new Point(coordinates, this)\n    }\n  }\n};\nGeometryFactory.prototype.getCoordinateSequenceFactory = function getCoordinateSequenceFactory () {\n  return this._coordinateSequenceFactory\n};\nGeometryFactory.prototype.createPolygon = function createPolygon () {\n  if (arguments.length === 0) {\n    return new Polygon(null, null, this)\n  } else if (arguments.length === 1) {\n    if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates = arguments[0];\n      return this.createPolygon(this.createLinearRing(coordinates))\n    } else if (arguments[0] instanceof Array) {\n      var coordinates$1 = arguments[0];\n      return this.createPolygon(this.createLinearRing(coordinates$1))\n    } else if (arguments[0] instanceof LinearRing) {\n      var shell = arguments[0];\n      return this.createPolygon(shell, null)\n    }\n  } else if (arguments.length === 2) {\n    var shell$1 = arguments[0];\n    var holes = arguments[1];\n    return new Polygon(shell$1, holes, this)\n  }\n};\nGeometryFactory.prototype.getSRID = function getSRID () {\n  return this._SRID\n};\nGeometryFactory.prototype.createGeometryCollection = function createGeometryCollection () {\n  if (arguments.length === 0) {\n    return new GeometryCollection(null, this)\n  } else if (arguments.length === 1) {\n    var geometries = arguments[0];\n    return new GeometryCollection(geometries, this)\n  }\n};\nGeometryFactory.prototype.createGeometry = function createGeometry (g) {\n  var editor = new GeometryEditor(this);\n  return editor.edit(g, {\n    edit: function () {\n      if (arguments.length === 2) {\n        var coordSeq = arguments[0];\n        // const geometry = arguments[1]\n        return this._coordinateSequenceFactory.create(coordSeq)\n      }\n    }\n  })\n};\nGeometryFactory.prototype.getPrecisionModel = function getPrecisionModel () {\n  return this._precisionModel\n};\nGeometryFactory.prototype.createLinearRing = function createLinearRing () {\n  if (arguments.length === 0) {\n    return this.createLinearRing(this.getCoordinateSequenceFactory().create([]))\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var coordinates = arguments[0];\n      return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates$1 = arguments[0];\n      return new LinearRing(coordinates$1, this)\n    }\n  }\n};\nGeometryFactory.prototype.createMultiPolygon = function createMultiPolygon () {\n  if (arguments.length === 0) {\n    return new MultiPolygon(null, this)\n  } else if (arguments.length === 1) {\n    var polygons = arguments[0];\n    return new MultiPolygon(polygons, this)\n  }\n};\nGeometryFactory.prototype.createMultiPoint = function createMultiPoint () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    return new MultiPoint(null, this)\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var point = arguments[0];\n      return new MultiPoint(point, this)\n    } else if (arguments[0] instanceof Array) {\n      var coordinates = arguments[0];\n      return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates$1 = arguments[0];\n      if (coordinates$1 === null) {\n        return this.createMultiPoint(new Array(0).fill(null))\n      }\n      var points = new Array(coordinates$1.size()).fill(null);\n      for (var i = 0; i < coordinates$1.size(); i++) {\n        var ptSeq = this$1.getCoordinateSequenceFactory().create(1, coordinates$1.getDimension());\n        CoordinateSequences.copy(coordinates$1, i, ptSeq, 0, 1);\n        points[i] = this$1.createPoint(ptSeq);\n      }\n      return this.createMultiPoint(points)\n    }\n  }\n};\nGeometryFactory.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable]\n};\nGeometryFactory.prototype.getClass = function getClass () {\n  return GeometryFactory\n};\nGeometryFactory.toMultiPolygonArray = function toMultiPolygonArray (multiPolygons) {\n  var multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n  return multiPolygons.toArray(multiPolygonArray)\n};\nGeometryFactory.toGeometryArray = function toGeometryArray (geometries) {\n  if (geometries === null) { return null }\n  var geometryArray = new Array(geometries.size()).fill(null);\n  return geometries.toArray(geometryArray)\n};\nGeometryFactory.getDefaultCoordinateSequenceFactory = function getDefaultCoordinateSequenceFactory () {\n  return CoordinateArraySequenceFactory.instance()\n};\nGeometryFactory.toMultiLineStringArray = function toMultiLineStringArray (multiLineStrings) {\n  var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n  return multiLineStrings.toArray(multiLineStringArray)\n};\nGeometryFactory.toLineStringArray = function toLineStringArray (lineStrings) {\n  var lineStringArray = new Array(lineStrings.size()).fill(null);\n  return lineStrings.toArray(lineStringArray)\n};\nGeometryFactory.toMultiPointArray = function toMultiPointArray (multiPoints) {\n  var multiPointArray = new Array(multiPoints.size()).fill(null);\n  return multiPoints.toArray(multiPointArray)\n};\nGeometryFactory.toLinearRingArray = function toLinearRingArray (linearRings) {\n  var linearRingArray = new Array(linearRings.size()).fill(null);\n  return linearRings.toArray(linearRingArray)\n};\nGeometryFactory.toPointArray = function toPointArray (points) {\n  var pointArray = new Array(points.size()).fill(null);\n  return points.toArray(pointArray)\n};\nGeometryFactory.toPolygonArray = function toPolygonArray (polygons) {\n  var polygonArray = new Array(polygons.size()).fill(null);\n  return polygons.toArray(polygonArray)\n};\nGeometryFactory.createPointFromInternalCoord = function createPointFromInternalCoord (coord, exemplar) {\n  exemplar.getPrecisionModel().makePrecise(coord);\n  return exemplar.getFactory().createPoint(coord)\n};\nstaticAccessors$2.serialVersionUID.get = function () { return -6820524753094095635 };\n\nObject.defineProperties( GeometryFactory, staticAccessors$2 );\n\nvar geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];\n\n/**\n * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/**\n * Create a new parser for GeoJSON\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of GeoJsonParser.\n * @constructor\n * @private\n */\nvar GeoJSONParser = function GeoJSONParser (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n};\n/**\n * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n *\n * @param {}\n *        A GeoJSON object.\n * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n * @private\n */\nGeoJSONParser.prototype.read = function read (json) {\n  var obj;\n  if (typeof json === 'string') {\n    obj = JSON.parse(json);\n  } else {\n    obj = json;\n  }\n\n  var type = obj.type;\n\n  if (!parse[type]) {\n    throw new Error('Unknown GeoJSON type: ' + obj.type)\n  }\n\n  if (geometryTypes.indexOf(type) !== -1) {\n    return parse[type].apply(this, [obj.coordinates])\n  } else if (type === 'GeometryCollection') {\n    return parse[type].apply(this, [obj.geometries])\n  }\n\n  // feature or feature collection\n  return parse[type].apply(this, [obj])\n};\n\n/**\n * Serialize a Geometry object into GeoJSON\n *\n * @param {Geometry}\n *        geometry A Geometry or array of Geometries.\n * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n * @private\n */\nGeoJSONParser.prototype.write = function write (geometry) {\n  var type = geometry.getGeometryType();\n\n  if (!extract[type]) {\n    throw new Error('Geometry is not supported')\n  }\n\n  return extract[type].apply(this, [geometry])\n};\n\nvar parse = {\n  /**\n   * Parse a GeoJSON Feature object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n   */\n  Feature: function (obj) {\n    var feature = {};\n\n    // copy features\n    for (var key in obj) {\n      feature[key] = obj[key];\n    }\n\n    // parse geometry\n    if (obj.geometry) {\n      var type = obj.geometry.type;\n      if (!parse[type]) {\n        throw new Error('Unknown GeoJSON type: ' + obj.type)\n      }\n      feature.geometry = this.read(obj.geometry);\n    }\n\n    // bbox\n    if (obj.bbox) {\n      feature.bbox = parse.bbox.apply(this, [obj.bbox]);\n    }\n\n    return feature\n  },\n\n  /**\n   * Parse a GeoJSON FeatureCollection object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n   */\n  FeatureCollection: function (obj) {\n    var this$1 = this;\n\n    var featureCollection = {};\n\n    if (obj.features) {\n      featureCollection.features = [];\n\n      for (var i = 0; i < obj.features.length; ++i) {\n        featureCollection.features.push(this$1.read(obj.features[i]));\n      }\n    }\n\n    if (obj.bbox) {\n      featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);\n    }\n\n    return featureCollection\n  },\n\n  /**\n   * Convert the ordinates in an array to an array of Coordinates\n   *\n   * @param {Array}\n   *          array Array with {Number}s.\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  coordinates: function (array) {\n    var coordinates = [];\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i];\n      coordinates.push(new Coordinate(sub[0], sub[1]));\n    }\n    return coordinates\n  },\n\n  /**\n   * Convert the bbox to a LinearRing\n   *\n   * @param {Array}\n   *          array Array with [xMin, yMin, xMax, yMax].\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  bbox: function (array) {\n    return this.geometryFactory.createLinearRing([\n      new Coordinate(array[0], array[1]),\n      new Coordinate(array[2], array[1]),\n      new Coordinate(array[2], array[3]),\n      new Coordinate(array[0], array[3]),\n      new Coordinate(array[0], array[1])\n    ])\n  },\n\n  /**\n   * Convert an Array with ordinates to a Point\n   *\n   * @param {Array}\n   *          array Array with ordinates.\n   *\n   * @return {Point} Point.\n   */\n  Point: function (array) {\n    var coordinate = new Coordinate(array[0], array[1]);\n    return this.geometryFactory.createPoint(coordinate)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiPoint\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiPoint} MultiPoint.\n   */\n  MultiPoint: function (array) {\n    var this$1 = this;\n\n    var points = [];\n    for (var i = 0; i < array.length; ++i) {\n      points.push(parse.Point.apply(this$1, [array[i]]));\n    }\n    return this.geometryFactory.createMultiPoint(points)\n  },\n\n  /**\n   * Convert an Array with coordinates to a LineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {LineString} LineString.\n   */\n  LineString: function (array) {\n    var coordinates = parse.coordinates.apply(this, [array]);\n    return this.geometryFactory.createLineString(coordinates)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiLineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiLineString} MultiLineString.\n   */\n  MultiLineString: function (array) {\n    var this$1 = this;\n\n    var lineStrings = [];\n    for (var i = 0; i < array.length; ++i) {\n      lineStrings.push(parse.LineString.apply(this$1, [array[i]]));\n    }\n    return this.geometryFactory.createMultiLineString(lineStrings)\n  },\n\n  /**\n   * Convert an Array to a Polygon\n   *\n   * @param {Array}\n   *          array Array with shell and holes.\n   *\n   * @return {Polygon} Polygon.\n   */\n  Polygon: function (array) {\n    var this$1 = this;\n\n    var shellCoordinates = parse.coordinates.apply(this, [array[0]]);\n    var shell = this.geometryFactory.createLinearRing(shellCoordinates);\n    var holes = [];\n    for (var i = 1; i < array.length; ++i) {\n      var hole = array[i];\n      var coordinates = parse.coordinates.apply(this$1, [hole]);\n      var linearRing = this$1.geometryFactory.createLinearRing(coordinates);\n      holes.push(linearRing);\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Convert an Array to a MultiPolygon\n   *\n   * @param {Array}\n   *          array Array of arrays with shell and rings.\n   *\n   * @return {MultiPolygon} MultiPolygon.\n   */\n  MultiPolygon: function (array) {\n    var this$1 = this;\n\n    var polygons = [];\n    for (var i = 0; i < array.length; ++i) {\n      var polygon = array[i];\n      polygons.push(parse.Polygon.apply(this$1, [polygon]));\n    }\n    return this.geometryFactory.createMultiPolygon(polygons)\n  },\n\n  /**\n   * Convert an Array to a GeometryCollection\n   *\n   * @param {Array}\n   *          array Array of GeoJSON geometries.\n   *\n   * @return {GeometryCollection} GeometryCollection.\n   */\n  GeometryCollection: function (array) {\n    var this$1 = this;\n\n    var geometries = [];\n    for (var i = 0; i < array.length; ++i) {\n      var geometry = array[i];\n      geometries.push(this$1.read(geometry));\n    }\n    return this.geometryFactory.createGeometryCollection(geometries)\n  }\n};\n\nvar extract = {\n  /**\n   * Convert a Coordinate to an Array\n   *\n   * @param {Coordinate}\n   *          coordinate Coordinate to convert.\n   *\n   * @return {Array} Array of ordinates.\n   */\n  coordinate: function (coordinate) {\n    return [coordinate.x, coordinate.y]\n  },\n\n  /**\n   * Convert a Point to a GeoJSON object\n   *\n   * @param {Point}\n   *          point Point to convert.\n   *\n   * @return {Array} Array of 2 ordinates (paired to a coordinate).\n   */\n  Point: function (point) {\n    var array = extract.coordinate.apply(this, [point.getCoordinate()]);\n    return {\n      type: 'Point',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPoint to a GeoJSON object\n   *\n   * @param {MultiPoint}\n   *          multipoint MultiPoint to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  MultiPoint: function (multipoint) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < multipoint._geometries.length; ++i) {\n      var point = multipoint._geometries[i];\n      var geoJson = extract.Point.apply(this$1, [point]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiPoint',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a LineString to a GeoJSON object\n   *\n   * @param {LineString}\n   *          linestring LineString to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  LineString: function (linestring) {\n    var this$1 = this;\n\n    var array = [];\n    var coordinates = linestring.getCoordinates();\n    for (var i = 0; i < coordinates.length; ++i) {\n      var coordinate = coordinates[i];\n      array.push(extract.coordinate.apply(this$1, [coordinate]));\n    }\n    return {\n      type: 'LineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiLineString to a GeoJSON object\n   *\n   * @param {MultiLineString}\n   *          multilinestring MultiLineString to convert.\n   *\n   * @return {Array} Array of Array of coordinates.\n   */\n  MultiLineString: function (multilinestring) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < multilinestring._geometries.length; ++i) {\n      var linestring = multilinestring._geometries[i];\n      var geoJson = extract.LineString.apply(this$1, [linestring]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiLineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a Polygon to a GeoJSON object\n   *\n   * @param {Polygon}\n   *          polygon Polygon to convert.\n   *\n   * @return {Array} Array with shell, holes.\n   */\n  Polygon: function (polygon) {\n    var this$1 = this;\n\n    var array = [];\n    var shellGeoJson = extract.LineString.apply(this, [polygon._shell]);\n    array.push(shellGeoJson.coordinates);\n    for (var i = 0; i < polygon._holes.length; ++i) {\n      var hole = polygon._holes[i];\n      var holeGeoJson = extract.LineString.apply(this$1, [hole]);\n      array.push(holeGeoJson.coordinates);\n    }\n    return {\n      type: 'Polygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPolygon to a GeoJSON object\n   *\n   * @param {MultiPolygon}\n   *          multipolygon MultiPolygon to convert.\n   *\n   * @return {Array} Array of polygons.\n   */\n  MultiPolygon: function (multipolygon) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < multipolygon._geometries.length; ++i) {\n      var polygon = multipolygon._geometries[i];\n      var geoJson = extract.Polygon.apply(this$1, [polygon]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiPolygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a GeometryCollection to a GeoJSON object\n   *\n   * @param {GeometryCollection}\n   *          collection GeometryCollection to convert.\n   *\n   * @return {Array} Array of geometries.\n   */\n  GeometryCollection: function (collection) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < collection._geometries.length; ++i) {\n      var geometry = collection._geometries[i];\n      var type = geometry.getGeometryType();\n      array.push(extract[type].apply(this$1, [geometry]));\n    }\n    return {\n      type: 'GeometryCollection',\n      geometries: array\n    }\n  }\n};\n\n/**\n * Converts a geometry in GeoJSON to a {@link Geometry}.\n */\n\n/**\n * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n * to allow it to create <code>Geometry</code> objects of the appropriate\n * implementation. In particular, the <code>GeometryFactory</code> determines\n * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nvar GeoJSONReader = function GeoJSONReader (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n  this.precisionModel = this.geometryFactory.getPrecisionModel();\n  this.parser = new GeoJSONParser(this.geometryFactory);\n};\n/**\n * Reads a GeoJSON representation of a {@link Geometry}\n *\n * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n *\n * @param {Object|String} geoJson a GeoJSON Object or String.\n * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n * @memberof GeoJSONReader\n */\nGeoJSONReader.prototype.read = function read (geoJson) {\n  var geometry = this.parser.read(geoJson);\n\n  if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n    this.reducePrecision(geometry);\n  }\n\n  return geometry\n};\n\n// NOTE: this is a hack\nGeoJSONReader.prototype.reducePrecision = function reducePrecision (geometry) {\n    var this$1 = this;\n\n  var i, len;\n\n  if (geometry.coordinate) {\n    this.precisionModel.makePrecise(geometry.coordinate);\n  } else if (geometry.points) {\n    for (i = 0, len = geometry.points.length; i < len; i++) {\n      this$1.precisionModel.makePrecise(geometry.points[i]);\n    }\n  } else if (geometry.geometries) {\n    for (i = 0, len = geometry.geometries.length; i < len; i++) {\n      this$1.reducePrecision(geometry.geometries[i]);\n    }\n  }\n};\n\n/**\n * @module GeoJSONWriter\n */\n\n/**\n * Writes the GeoJSON representation of a {@link Geometry}. The\n * The GeoJSON format is defined <A\n * HREF=\"http://geojson.org/geojson-spec.html\">here</A>.\n */\n\n/**\n * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nvar GeoJSONWriter = function GeoJSONWriter () {\n  this.parser = new GeoJSONParser(this.geometryFactory);\n};\n/**\n * Converts a <code>Geometry</code> to its GeoJSON representation.\n *\n * @param {Geometry}\n *        geometry a <code>Geometry</code> to process.\n * @return {Object} The GeoJSON representation of the Geometry.\n * @memberof GeoJSONWriter\n */\nGeoJSONWriter.prototype.write = function write (geometry) {\n  return this.parser.write(geometry)\n};\n\n/* eslint-disable no-undef */\n\n// io\n\nvar Position = function Position () {};\n\nvar staticAccessors$20 = { ON: { configurable: true },LEFT: { configurable: true },RIGHT: { configurable: true } };\n\nPosition.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPosition.prototype.getClass = function getClass () {\n  return Position\n};\nPosition.opposite = function opposite (position) {\n  if (position === Position.LEFT) { return Position.RIGHT }\n  if (position === Position.RIGHT) { return Position.LEFT }\n  return position\n};\nstaticAccessors$20.ON.get = function () { return 0 };\nstaticAccessors$20.LEFT.get = function () { return 1 };\nstaticAccessors$20.RIGHT.get = function () { return 2 };\n\nObject.defineProperties( Position, staticAccessors$20 );\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction EmptyStackException (message) {\n  this.message = message || '';\n}\nEmptyStackException.prototype = new Error();\n\n/**\n * @type {string}\n */\nEmptyStackException.prototype.name = 'EmptyStackException';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n *\n * @extends {List}\n * @constructor\n * @private\n */\nfunction Stack () {\n  /**\n   * @type {Array}\n   * @private\n   */\n  this.array_ = [];\n}\nStack.prototype = new List();\n\n/**\n * @override\n */\nStack.prototype.add = function (e) {\n  this.array_.push(e);\n  return true\n};\n\n/**\n * @override\n */\nStack.prototype.get = function (index) {\n  if (index < 0 || index >= this.size()) {\n    throw new Error()\n  }\n\n  return this.array_[index]\n};\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack.prototype.push = function (e) {\n  this.array_.push(e);\n  return e\n};\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack.prototype.pop = function (e) {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException()\n  }\n\n  return this.array_.pop()\n};\n\n/**\n * Looks at the object at the top of this stack without removing it from the\n * stack.\n * @return {Object}\n */\nStack.prototype.peek = function () {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException()\n  }\n\n  return this.array_[this.array_.length - 1]\n};\n\n/**\n * Tests if this stack is empty.\n * @return {boolean} true if and only if this stack contains no items; false\n *         otherwise.\n */\nStack.prototype.empty = function () {\n  if (this.array_.length === 0) {\n    return true\n  } else {\n    return false\n  }\n};\n\n/**\n * @return {boolean}\n */\nStack.prototype.isEmpty = function () {\n  return this.empty()\n};\n\n/**\n * Returns the 1-based position where an object is on this stack. If the object\n * o occurs as an item in this stack, this method returns the distance from the\n * top of the stack of the occurrence nearest the top of the stack; the topmost\n * item on the stack is considered to be at distance 1. The equals method is\n * used to compare o to the items in this stack.\n *\n * NOTE: does not currently actually use equals. (=== is used)\n *\n * @param {Object} o\n * @return {number} the 1-based position from the top of the stack where the\n *         object is located; the return value -1 indicates that the object is\n *         not on the stack.\n */\nStack.prototype.search = function (o) {\n  return this.array_.indexOf(o)\n};\n\n/**\n * @return {number}\n * @export\n */\nStack.prototype.size = function () {\n  return this.array_.length\n};\n\n/**\n * @return {Array}\n */\nStack.prototype.toArray = function () {\n  var this$1 = this;\n\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this$1.array_[i]);\n  }\n\n  return array\n};\n\nvar RightmostEdgeFinder = function RightmostEdgeFinder () {\n  this._minIndex = -1;\n  this._minCoord = null;\n  this._minDe = null;\n  this._orientedDe = null;\n};\nRightmostEdgeFinder.prototype.getCoordinate = function getCoordinate () {\n  return this._minCoord\n};\nRightmostEdgeFinder.prototype.getRightmostSide = function getRightmostSide (de, index) {\n  var side = this.getRightmostSideOfSegment(de, index);\n  if (side < 0) { side = this.getRightmostSideOfSegment(de, index - 1); }\n  if (side < 0) {\n    this._minCoord = null;\n    this.checkForRightmostCoordinate(de);\n  }\n  return side\n};\nRightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function findRightmostEdgeAtVertex () {\n  var pts = this._minDe.getEdge().getCoordinates();\n  Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');\n  var pPrev = pts[this._minIndex - 1];\n  var pNext = pts[this._minIndex + 1];\n  var orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);\n  var usePrev = false;\n  if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {\n    usePrev = true;\n  } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {\n    usePrev = true;\n  }\n  if (usePrev) {\n    this._minIndex = this._minIndex - 1;\n  }\n};\nRightmostEdgeFinder.prototype.getRightmostSideOfSegment = function getRightmostSideOfSegment (de, i) {\n  var e = de.getEdge();\n  var coord = e.getCoordinates();\n  if (i < 0 || i + 1 >= coord.length) { return -1 }\n  if (coord[i].y === coord[i + 1].y) { return -1 }\n  var pos = Position.LEFT;\n  if (coord[i].y < coord[i + 1].y) { pos = Position.RIGHT; }\n  return pos\n};\nRightmostEdgeFinder.prototype.getEdge = function getEdge () {\n  return this._orientedDe\n};\nRightmostEdgeFinder.prototype.checkForRightmostCoordinate = function checkForRightmostCoordinate (de) {\n    var this$1 = this;\n\n  var coord = de.getEdge().getCoordinates();\n  for (var i = 0; i < coord.length - 1; i++) {\n    if (this$1._minCoord === null || coord[i].x > this$1._minCoord.x) {\n      this$1._minDe = de;\n      this$1._minIndex = i;\n      this$1._minCoord = coord[i];\n    }\n  }\n};\nRightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function findRightmostEdgeAtNode () {\n  var node = this._minDe.getNode();\n  var star = node.getEdges();\n  this._minDe = star.getRightmostEdge();\n  if (!this._minDe.isForward()) {\n    this._minDe = this._minDe.getSym();\n    this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;\n  }\n};\nRightmostEdgeFinder.prototype.findEdge = function findEdge (dirEdgeList) {\n    var this$1 = this;\n\n  for (var i = dirEdgeList.iterator(); i.hasNext();) {\n    var de = i.next();\n    if (!de.isForward()) { continue }\n    this$1.checkForRightmostCoordinate(de);\n  }\n  Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');\n  if (this._minIndex === 0) {\n    this.findRightmostEdgeAtNode();\n  } else {\n    this.findRightmostEdgeAtVertex();\n  }\n  this._orientedDe = this._minDe;\n  var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);\n  if (rightmostSide === Position.LEFT) {\n    this._orientedDe = this._minDe.getSym();\n  }\n};\nRightmostEdgeFinder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nRightmostEdgeFinder.prototype.getClass = function getClass () {\n  return RightmostEdgeFinder\n};\n\nvar TopologyException = (function (RuntimeException$$1) {\n  function TopologyException (msg, pt) {\n    RuntimeException$$1.call(this, TopologyException.msgWithCoord(msg, pt));\n    this.pt = pt ? new Coordinate(pt) : null;\n    this.name = 'TopologyException';\n  }\n\n  if ( RuntimeException$$1 ) TopologyException.__proto__ = RuntimeException$$1;\n  TopologyException.prototype = Object.create( RuntimeException$$1 && RuntimeException$$1.prototype );\n  TopologyException.prototype.constructor = TopologyException;\n  TopologyException.prototype.getCoordinate = function getCoordinate () {\n    return this.pt\n  };\n  TopologyException.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  TopologyException.prototype.getClass = function getClass () {\n    return TopologyException\n  };\n  TopologyException.msgWithCoord = function msgWithCoord (msg, pt) {\n    if (!pt) { return msg + ' [ ' + pt + ' ]' }\n    return msg\n  };\n\n  return TopologyException;\n}(RuntimeException));\n\nvar LinkedList = function LinkedList () {\n  this.array_ = [];\n};\nLinkedList.prototype.addLast = function addLast (e) {\n  this.array_.push(e);\n};\nLinkedList.prototype.removeFirst = function removeFirst () {\n  return this.array_.shift()\n};\nLinkedList.prototype.isEmpty = function isEmpty () {\n  return this.array_.length === 0\n};\n\nvar BufferSubgraph = function BufferSubgraph () {\n  this._finder = null;\n  this._dirEdgeList = new ArrayList();\n  this._nodes = new ArrayList();\n  this._rightMostCoord = null;\n  this._env = null;\n  this._finder = new RightmostEdgeFinder();\n};\nBufferSubgraph.prototype.clearVisitedEdges = function clearVisitedEdges () {\n  for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n    var de = it.next();\n    de.setVisited(false);\n  }\n};\nBufferSubgraph.prototype.getRightmostCoordinate = function getRightmostCoordinate () {\n  return this._rightMostCoord\n};\nBufferSubgraph.prototype.computeNodeDepth = function computeNodeDepth (n) {\n    var this$1 = this;\n\n  var startEdge = null;\n  for (var i = n.getEdges().iterator(); i.hasNext();) {\n    var de = i.next();\n    if (de.isVisited() || de.getSym().isVisited()) {\n      startEdge = de;\n      break\n    }\n  }\n  if (startEdge === null) { throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate()) }\n  n.getEdges().computeDepths(startEdge);\n  for (var i$1 = n.getEdges().iterator(); i$1.hasNext();) {\n    var de$1 = i$1.next();\n    de$1.setVisited(true);\n    this$1.copySymDepths(de$1);\n  }\n};\nBufferSubgraph.prototype.computeDepth = function computeDepth (outsideDepth) {\n  this.clearVisitedEdges();\n  var de = this._finder.getEdge();\n  // const n = de.getNode()\n  // const label = de.getLabel()\n  de.setEdgeDepths(Position.RIGHT, outsideDepth);\n  this.copySymDepths(de);\n  this.computeDepths(de);\n};\nBufferSubgraph.prototype.create = function create (node) {\n  this.addReachable(node);\n  this._finder.findEdge(this._dirEdgeList);\n  this._rightMostCoord = this._finder.getCoordinate();\n};\nBufferSubgraph.prototype.findResultEdges = function findResultEdges () {\n  for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n    var de = it.next();\n    if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {\n      de.setInResult(true);\n    }\n  }\n};\nBufferSubgraph.prototype.computeDepths = function computeDepths (startEdge) {\n    var this$1 = this;\n\n  var nodesVisited = new HashSet();\n  var nodeQueue = new LinkedList();\n  var startNode = startEdge.getNode();\n  nodeQueue.addLast(startNode);\n  nodesVisited.add(startNode);\n  startEdge.setVisited(true);\n  while (!nodeQueue.isEmpty()) {\n    var n = nodeQueue.removeFirst();\n    nodesVisited.add(n);\n    this$1.computeNodeDepth(n);\n    for (var i = n.getEdges().iterator(); i.hasNext();) {\n      var de = i.next();\n      var sym = de.getSym();\n      if (sym.isVisited()) { continue }\n      var adjNode = sym.getNode();\n      if (!nodesVisited.contains(adjNode)) {\n        nodeQueue.addLast(adjNode);\n        nodesVisited.add(adjNode);\n      }\n    }\n  }\n};\nBufferSubgraph.prototype.compareTo = function compareTo (o) {\n  var graph = o;\n  if (this._rightMostCoord.x < graph._rightMostCoord.x) {\n    return -1\n  }\n  if (this._rightMostCoord.x > graph._rightMostCoord.x) {\n    return 1\n  }\n  return 0\n};\nBufferSubgraph.prototype.getEnvelope = function getEnvelope () {\n  if (this._env === null) {\n    var edgeEnv = new Envelope();\n    for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n      var dirEdge = it.next();\n      var pts = dirEdge.getEdge().getCoordinates();\n      for (var i = 0; i < pts.length - 1; i++) {\n        edgeEnv.expandToInclude(pts[i]);\n      }\n    }\n    this._env = edgeEnv;\n  }\n  return this._env\n};\nBufferSubgraph.prototype.addReachable = function addReachable (startNode) {\n    var this$1 = this;\n\n  var nodeStack = new Stack();\n  nodeStack.add(startNode);\n  while (!nodeStack.empty()) {\n    var node = nodeStack.pop();\n    this$1.add(node, nodeStack);\n  }\n};\nBufferSubgraph.prototype.copySymDepths = function copySymDepths (de) {\n  var sym = de.getSym();\n  sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n  sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n};\nBufferSubgraph.prototype.add = function add (node, nodeStack) {\n    var this$1 = this;\n\n  node.setVisited(true);\n  this._nodes.add(node);\n  for (var i = node.getEdges().iterator(); i.hasNext();) {\n    var de = i.next();\n    this$1._dirEdgeList.add(de);\n    var sym = de.getSym();\n    var symNode = sym.getNode();\n    if (!symNode.isVisited()) { nodeStack.push(symNode); }\n  }\n};\nBufferSubgraph.prototype.getNodes = function getNodes () {\n  return this._nodes\n};\nBufferSubgraph.prototype.getDirectedEdges = function getDirectedEdges () {\n  return this._dirEdgeList\n};\nBufferSubgraph.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nBufferSubgraph.prototype.getClass = function getClass () {\n  return BufferSubgraph\n};\n\nvar TopologyLocation = function TopologyLocation () {\n  var this$1 = this;\n\n  this.location = null;\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var location = arguments[0];\n      this.init(location.length);\n    } else if (Number.isInteger(arguments[0])) {\n      var on = arguments[0];\n      this.init(1);\n      this.location[Position.ON] = on;\n    } else if (arguments[0] instanceof TopologyLocation) {\n      var gl = arguments[0];\n      this.init(gl.location.length);\n      if (gl !== null) {\n        for (var i = 0; i < this.location.length; i++) {\n          this$1.location[i] = gl.location[i];\n        }\n      }\n    }\n  } else if (arguments.length === 3) {\n    var on$1 = arguments[0];\n    var left = arguments[1];\n    var right = arguments[2];\n    this.init(3);\n    this.location[Position.ON] = on$1;\n    this.location[Position.LEFT] = left;\n    this.location[Position.RIGHT] = right;\n  }\n};\nTopologyLocation.prototype.setAllLocations = function setAllLocations (locValue) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    this$1.location[i] = locValue;\n  }\n};\nTopologyLocation.prototype.isNull = function isNull () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] !== Location.NONE) { return false }\n  }\n  return true\n};\nTopologyLocation.prototype.setAllLocationsIfNull = function setAllLocationsIfNull (locValue) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] === Location.NONE) { this$1.location[i] = locValue; }\n  }\n};\nTopologyLocation.prototype.isLine = function isLine () {\n  return this.location.length === 1\n};\nTopologyLocation.prototype.merge = function merge (gl) {\n    var this$1 = this;\n\n  if (gl.location.length > this.location.length) {\n    var newLoc = new Array(3).fill(null);\n    newLoc[Position.ON] = this.location[Position.ON];\n    newLoc[Position.LEFT] = Location.NONE;\n    newLoc[Position.RIGHT] = Location.NONE;\n    this.location = newLoc;\n  }\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] === Location.NONE && i < gl.location.length) { this$1.location[i] = gl.location[i]; }\n  }\n};\nTopologyLocation.prototype.getLocations = function getLocations () {\n  return this.location\n};\nTopologyLocation.prototype.flip = function flip () {\n  if (this.location.length <= 1) { return null }\n  var temp = this.location[Position.LEFT];\n  this.location[Position.LEFT] = this.location[Position.RIGHT];\n  this.location[Position.RIGHT] = temp;\n};\nTopologyLocation.prototype.toString = function toString () {\n  var buf = new StringBuffer();\n  if (this.location.length > 1) { buf.append(Location.toLocationSymbol(this.location[Position.LEFT])); }\n  buf.append(Location.toLocationSymbol(this.location[Position.ON]));\n  if (this.location.length > 1) { buf.append(Location.toLocationSymbol(this.location[Position.RIGHT])); }\n  return buf.toString()\n};\nTopologyLocation.prototype.setLocations = function setLocations (on, left, right) {\n  this.location[Position.ON] = on;\n  this.location[Position.LEFT] = left;\n  this.location[Position.RIGHT] = right;\n};\nTopologyLocation.prototype.get = function get (posIndex) {\n  if (posIndex < this.location.length) { return this.location[posIndex] }\n  return Location.NONE\n};\nTopologyLocation.prototype.isArea = function isArea () {\n  return this.location.length > 1\n};\nTopologyLocation.prototype.isAnyNull = function isAnyNull () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] === Location.NONE) { return true }\n  }\n  return false\n};\nTopologyLocation.prototype.setLocation = function setLocation () {\n  if (arguments.length === 1) {\n    var locValue = arguments[0];\n    this.setLocation(Position.ON, locValue);\n  } else if (arguments.length === 2) {\n    var locIndex = arguments[0];\n    var locValue$1 = arguments[1];\n    this.location[locIndex] = locValue$1;\n  }\n};\nTopologyLocation.prototype.init = function init (size) {\n  this.location = new Array(size).fill(null);\n  this.setAllLocations(Location.NONE);\n};\nTopologyLocation.prototype.isEqualOnSide = function isEqualOnSide (le, locIndex) {\n  return this.location[locIndex] === le.location[locIndex]\n};\nTopologyLocation.prototype.allPositionsEqual = function allPositionsEqual (loc) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] !== loc) { return false }\n  }\n  return true\n};\nTopologyLocation.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nTopologyLocation.prototype.getClass = function getClass () {\n  return TopologyLocation\n};\n\nvar Label = function Label () {\n  this.elt = new Array(2).fill(null);\n  if (arguments.length === 1) {\n    if (Number.isInteger(arguments[0])) {\n      var onLoc = arguments[0];\n      this.elt[0] = new TopologyLocation(onLoc);\n      this.elt[1] = new TopologyLocation(onLoc);\n    } else if (arguments[0] instanceof Label) {\n      var lbl = arguments[0];\n      this.elt[0] = new TopologyLocation(lbl.elt[0]);\n      this.elt[1] = new TopologyLocation(lbl.elt[1]);\n    }\n  } else if (arguments.length === 2) {\n    var geomIndex = arguments[0];\n    var onLoc$1 = arguments[1];\n    this.elt[0] = new TopologyLocation(Location.NONE);\n    this.elt[1] = new TopologyLocation(Location.NONE);\n    this.elt[geomIndex].setLocation(onLoc$1);\n  } else if (arguments.length === 3) {\n    var onLoc$2 = arguments[0];\n    var leftLoc = arguments[1];\n    var rightLoc = arguments[2];\n    this.elt[0] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);\n    this.elt[1] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);\n  } else if (arguments.length === 4) {\n    var geomIndex$1 = arguments[0];\n    var onLoc$3 = arguments[1];\n    var leftLoc$1 = arguments[2];\n    var rightLoc$1 = arguments[3];\n    this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n    this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n    this.elt[geomIndex$1].setLocations(onLoc$3, leftLoc$1, rightLoc$1);\n  }\n};\nLabel.prototype.getGeometryCount = function getGeometryCount () {\n  var count = 0;\n  if (!this.elt[0].isNull()) { count++; }\n  if (!this.elt[1].isNull()) { count++; }\n  return count\n};\nLabel.prototype.setAllLocations = function setAllLocations (geomIndex, location) {\n  this.elt[geomIndex].setAllLocations(location);\n};\nLabel.prototype.isNull = function isNull (geomIndex) {\n  return this.elt[geomIndex].isNull()\n};\nLabel.prototype.setAllLocationsIfNull = function setAllLocationsIfNull () {\n  if (arguments.length === 1) {\n    var location = arguments[0];\n    this.setAllLocationsIfNull(0, location);\n    this.setAllLocationsIfNull(1, location);\n  } else if (arguments.length === 2) {\n    var geomIndex = arguments[0];\n    var location$1 = arguments[1];\n    this.elt[geomIndex].setAllLocationsIfNull(location$1);\n  }\n};\nLabel.prototype.isLine = function isLine (geomIndex) {\n  return this.elt[geomIndex].isLine()\n};\nLabel.prototype.merge = function merge (lbl) {\n    var this$1 = this;\n\n  for (var i = 0; i < 2; i++) {\n    if (this$1.elt[i] === null && lbl.elt[i] !== null) {\n      this$1.elt[i] = new TopologyLocation(lbl.elt[i]);\n    } else {\n      this$1.elt[i].merge(lbl.elt[i]);\n    }\n  }\n};\nLabel.prototype.flip = function flip () {\n  this.elt[0].flip();\n  this.elt[1].flip();\n};\nLabel.prototype.getLocation = function getLocation () {\n  if (arguments.length === 1) {\n    var geomIndex = arguments[0];\n    return this.elt[geomIndex].get(Position.ON)\n  } else if (arguments.length === 2) {\n    var geomIndex$1 = arguments[0];\n    var posIndex = arguments[1];\n    return this.elt[geomIndex$1].get(posIndex)\n  }\n};\nLabel.prototype.toString = function toString () {\n  var buf = new StringBuffer();\n  if (this.elt[0] !== null) {\n    buf.append('A:');\n    buf.append(this.elt[0].toString());\n  }\n  if (this.elt[1] !== null) {\n    buf.append(' B:');\n    buf.append(this.elt[1].toString());\n  }\n  return buf.toString()\n};\nLabel.prototype.isArea = function isArea () {\n  if (arguments.length === 0) {\n    return this.elt[0].isArea() || this.elt[1].isArea()\n  } else if (arguments.length === 1) {\n    var geomIndex = arguments[0];\n    return this.elt[geomIndex].isArea()\n  }\n};\nLabel.prototype.isAnyNull = function isAnyNull (geomIndex) {\n  return this.elt[geomIndex].isAnyNull()\n};\nLabel.prototype.setLocation = function setLocation () {\n  if (arguments.length === 2) {\n    var geomIndex = arguments[0];\n    var location = arguments[1];\n    this.elt[geomIndex].setLocation(Position.ON, location);\n  } else if (arguments.length === 3) {\n    var geomIndex$1 = arguments[0];\n    var posIndex = arguments[1];\n    var location$1 = arguments[2];\n    this.elt[geomIndex$1].setLocation(posIndex, location$1);\n  }\n};\nLabel.prototype.isEqualOnSide = function isEqualOnSide (lbl, side) {\n  return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side)\n};\nLabel.prototype.allPositionsEqual = function allPositionsEqual (geomIndex, loc) {\n  return this.elt[geomIndex].allPositionsEqual(loc)\n};\nLabel.prototype.toLine = function toLine (geomIndex) {\n  if (this.elt[geomIndex].isArea()) { this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]); }\n};\nLabel.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLabel.prototype.getClass = function getClass () {\n  return Label\n};\nLabel.toLineLabel = function toLineLabel (label) {\n  var lineLabel = new Label(Location.NONE);\n  for (var i = 0; i < 2; i++) {\n    lineLabel.setLocation(i, label.getLocation(i));\n  }\n  return lineLabel\n};\n\nvar EdgeRing = function EdgeRing () {\n  this._startDe = null;\n  this._maxNodeDegree = -1;\n  this._edges = new ArrayList();\n  this._pts = new ArrayList();\n  this._label = new Label(Location.NONE);\n  this._ring = null;\n  this._isHole = null;\n  this._shell = null;\n  this._holes = new ArrayList();\n  this._geometryFactory = null;\n  var start = arguments[0];\n  var geometryFactory = arguments[1];\n  this._geometryFactory = geometryFactory;\n  this.computePoints(start);\n  this.computeRing();\n};\nEdgeRing.prototype.computeRing = function computeRing () {\n    var this$1 = this;\n\n  if (this._ring !== null) { return null }\n  var coord = new Array(this._pts.size()).fill(null);\n  for (var i = 0; i < this._pts.size(); i++) {\n    coord[i] = this$1._pts.get(i);\n  }\n  this._ring = this._geometryFactory.createLinearRing(coord);\n  this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());\n};\nEdgeRing.prototype.isIsolated = function isIsolated () {\n  return this._label.getGeometryCount() === 1\n};\nEdgeRing.prototype.computePoints = function computePoints (start) {\n    var this$1 = this;\n\n  this._startDe = start;\n  var de = start;\n  var isFirstEdge = true;\n  do {\n    if (de === null) { throw new TopologyException('Found null DirectedEdge') }\n    if (de.getEdgeRing() === this$1) { throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate()) }\n    this$1._edges.add(de);\n    var label = de.getLabel();\n    Assert.isTrue(label.isArea());\n    this$1.mergeLabel(label);\n    this$1.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n    isFirstEdge = false;\n    this$1.setEdgeRing(de, this$1);\n    de = this$1.getNext(de);\n  } while (de !== this._startDe)\n};\nEdgeRing.prototype.getLinearRing = function getLinearRing () {\n  return this._ring\n};\nEdgeRing.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pts.get(i)\n};\nEdgeRing.prototype.computeMaxNodeDegree = function computeMaxNodeDegree () {\n    var this$1 = this;\n\n  this._maxNodeDegree = 0;\n  var de = this._startDe;\n  do {\n    var node = de.getNode();\n    var degree = node.getEdges().getOutgoingDegree(this$1);\n    if (degree > this$1._maxNodeDegree) { this$1._maxNodeDegree = degree; }\n    de = this$1.getNext(de);\n  } while (de !== this._startDe)\n  this._maxNodeDegree *= 2;\n};\nEdgeRing.prototype.addPoints = function addPoints (edge, isForward, isFirstEdge) {\n    var this$1 = this;\n\n  var edgePts = edge.getCoordinates();\n  if (isForward) {\n    var startIndex = 1;\n    if (isFirstEdge) { startIndex = 0; }\n    for (var i = startIndex; i < edgePts.length; i++) {\n      this$1._pts.add(edgePts[i]);\n    }\n  } else {\n    var startIndex$1 = edgePts.length - 2;\n    if (isFirstEdge) { startIndex$1 = edgePts.length - 1; }\n    for (var i$1 = startIndex$1; i$1 >= 0; i$1--) {\n      this$1._pts.add(edgePts[i$1]);\n    }\n  }\n};\nEdgeRing.prototype.isHole = function isHole () {\n  return this._isHole\n};\nEdgeRing.prototype.setInResult = function setInResult () {\n  var de = this._startDe;\n  do {\n    de.getEdge().setInResult(true);\n    de = de.getNext();\n  } while (de !== this._startDe)\n};\nEdgeRing.prototype.containsPoint = function containsPoint (p) {\n  var shell = this.getLinearRing();\n  var env = shell.getEnvelopeInternal();\n  if (!env.contains(p)) { return false }\n  if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) { return false }\n  for (var i = this._holes.iterator(); i.hasNext();) {\n    var hole = i.next();\n    if (hole.containsPoint(p)) { return false }\n  }\n  return true\n};\nEdgeRing.prototype.addHole = function addHole (ring) {\n  this._holes.add(ring);\n};\nEdgeRing.prototype.isShell = function isShell () {\n  return this._shell === null\n};\nEdgeRing.prototype.getLabel = function getLabel () {\n  return this._label\n};\nEdgeRing.prototype.getEdges = function getEdges () {\n  return this._edges\n};\nEdgeRing.prototype.getMaxNodeDegree = function getMaxNodeDegree () {\n  if (this._maxNodeDegree < 0) { this.computeMaxNodeDegree(); }\n  return this._maxNodeDegree\n};\nEdgeRing.prototype.getShell = function getShell () {\n  return this._shell\n};\nEdgeRing.prototype.mergeLabel = function mergeLabel () {\n  if (arguments.length === 1) {\n    var deLabel = arguments[0];\n    this.mergeLabel(deLabel, 0);\n    this.mergeLabel(deLabel, 1);\n  } else if (arguments.length === 2) {\n    var deLabel$1 = arguments[0];\n    var geomIndex = arguments[1];\n    var loc = deLabel$1.getLocation(geomIndex, Position.RIGHT);\n    if (loc === Location.NONE) { return null }\n    if (this._label.getLocation(geomIndex) === Location.NONE) {\n      this._label.setLocation(geomIndex, loc);\n      return null\n    }\n  }\n};\nEdgeRing.prototype.setShell = function setShell (shell) {\n  this._shell = shell;\n  if (shell !== null) { shell.addHole(this); }\n};\nEdgeRing.prototype.toPolygon = function toPolygon (geometryFactory) {\n    var this$1 = this;\n\n  var holeLR = new Array(this._holes.size()).fill(null);\n  for (var i = 0; i < this._holes.size(); i++) {\n    holeLR[i] = this$1._holes.get(i).getLinearRing();\n  }\n  var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n  return poly\n};\nEdgeRing.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeRing.prototype.getClass = function getClass () {\n  return EdgeRing\n};\n\nvar MinimalEdgeRing = (function (EdgeRing$$1) {\n  function MinimalEdgeRing () {\n    var start = arguments[0];\n    var geometryFactory = arguments[1];\n    EdgeRing$$1.call(this, start, geometryFactory);\n  }\n\n  if ( EdgeRing$$1 ) MinimalEdgeRing.__proto__ = EdgeRing$$1;\n  MinimalEdgeRing.prototype = Object.create( EdgeRing$$1 && EdgeRing$$1.prototype );\n  MinimalEdgeRing.prototype.constructor = MinimalEdgeRing;\n  MinimalEdgeRing.prototype.setEdgeRing = function setEdgeRing (de, er) {\n    de.setMinEdgeRing(er);\n  };\n  MinimalEdgeRing.prototype.getNext = function getNext (de) {\n    return de.getNextMin()\n  };\n  MinimalEdgeRing.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  MinimalEdgeRing.prototype.getClass = function getClass () {\n    return MinimalEdgeRing\n  };\n\n  return MinimalEdgeRing;\n}(EdgeRing));\n\nvar MaximalEdgeRing = (function (EdgeRing$$1) {\n  function MaximalEdgeRing () {\n    var start = arguments[0];\n    var geometryFactory = arguments[1];\n    EdgeRing$$1.call(this, start, geometryFactory);\n  }\n\n  if ( EdgeRing$$1 ) MaximalEdgeRing.__proto__ = EdgeRing$$1;\n  MaximalEdgeRing.prototype = Object.create( EdgeRing$$1 && EdgeRing$$1.prototype );\n  MaximalEdgeRing.prototype.constructor = MaximalEdgeRing;\n  MaximalEdgeRing.prototype.buildMinimalRings = function buildMinimalRings () {\n    var this$1 = this;\n\n    var minEdgeRings = new ArrayList();\n    var de = this._startDe;\n    do {\n      if (de.getMinEdgeRing() === null) {\n        var minEr = new MinimalEdgeRing(de, this$1._geometryFactory);\n        minEdgeRings.add(minEr);\n      }\n      de = de.getNext();\n    } while (de !== this._startDe)\n    return minEdgeRings\n  };\n  MaximalEdgeRing.prototype.setEdgeRing = function setEdgeRing (de, er) {\n    de.setEdgeRing(er);\n  };\n  MaximalEdgeRing.prototype.linkDirectedEdgesForMinimalEdgeRings = function linkDirectedEdgesForMinimalEdgeRings () {\n    var this$1 = this;\n\n    var de = this._startDe;\n    do {\n      var node = de.getNode();\n      node.getEdges().linkMinimalDirectedEdges(this$1);\n      de = de.getNext();\n    } while (de !== this._startDe)\n  };\n  MaximalEdgeRing.prototype.getNext = function getNext (de) {\n    return de.getNext()\n  };\n  MaximalEdgeRing.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  MaximalEdgeRing.prototype.getClass = function getClass () {\n    return MaximalEdgeRing\n  };\n\n  return MaximalEdgeRing;\n}(EdgeRing));\n\nvar GraphComponent = function GraphComponent () {\n  this._label = null;\n  this._isInResult = false;\n  this._isCovered = false;\n  this._isCoveredSet = false;\n  this._isVisited = false;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var label = arguments[0];\n    this._label = label;\n  }\n};\nGraphComponent.prototype.setVisited = function setVisited (isVisited) {\n  this._isVisited = isVisited;\n};\nGraphComponent.prototype.setInResult = function setInResult (isInResult) {\n  this._isInResult = isInResult;\n};\nGraphComponent.prototype.isCovered = function isCovered () {\n  return this._isCovered\n};\nGraphComponent.prototype.isCoveredSet = function isCoveredSet () {\n  return this._isCoveredSet\n};\nGraphComponent.prototype.setLabel = function setLabel (label) {\n  this._label = label;\n};\nGraphComponent.prototype.getLabel = function getLabel () {\n  return this._label\n};\nGraphComponent.prototype.setCovered = function setCovered (isCovered) {\n  this._isCovered = isCovered;\n  this._isCoveredSet = true;\n};\nGraphComponent.prototype.updateIM = function updateIM (im) {\n  Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label');\n  this.computeIM(im);\n};\nGraphComponent.prototype.isInResult = function isInResult () {\n  return this._isInResult\n};\nGraphComponent.prototype.isVisited = function isVisited () {\n  return this._isVisited\n};\nGraphComponent.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGraphComponent.prototype.getClass = function getClass () {\n  return GraphComponent\n};\n\nvar Node = (function (GraphComponent$$1) {\n  function Node () {\n    GraphComponent$$1.call(this);\n    this._coord = null;\n    this._edges = null;\n    var coord = arguments[0];\n    var edges = arguments[1];\n    this._coord = coord;\n    this._edges = edges;\n    this._label = new Label(0, Location.NONE);\n  }\n\n  if ( GraphComponent$$1 ) Node.__proto__ = GraphComponent$$1;\n  Node.prototype = Object.create( GraphComponent$$1 && GraphComponent$$1.prototype );\n  Node.prototype.constructor = Node;\n  Node.prototype.isIncidentEdgeInResult = function isIncidentEdgeInResult () {\n    for (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {\n      var de = it.next();\n      if (de.getEdge().isInResult()) { return true }\n    }\n    return false\n  };\n  Node.prototype.isIsolated = function isIsolated () {\n    return this._label.getGeometryCount() === 1\n  };\n  Node.prototype.getCoordinate = function getCoordinate () {\n    return this._coord\n  };\n  Node.prototype.print = function print (out) {\n    out.println('node ' + this._coord + ' lbl: ' + this._label);\n  };\n  Node.prototype.computeIM = function computeIM (im) {};\n  Node.prototype.computeMergedLocation = function computeMergedLocation (label2, eltIndex) {\n    var loc = Location.NONE;\n    loc = this._label.getLocation(eltIndex);\n    if (!label2.isNull(eltIndex)) {\n      var nLoc = label2.getLocation(eltIndex);\n      if (loc !== Location.BOUNDARY) { loc = nLoc; }\n    }\n    return loc\n  };\n  Node.prototype.setLabel = function setLabel () {\n    if (arguments.length === 2) {\n      var argIndex = arguments[0];\n      var onLocation = arguments[1];\n      if (this._label === null) {\n        this._label = new Label(argIndex, onLocation);\n      } else { this._label.setLocation(argIndex, onLocation); }\n    } else { return GraphComponent$$1.prototype.setLabel.apply(this, arguments) }\n  };\n  Node.prototype.getEdges = function getEdges () {\n    return this._edges\n  };\n  Node.prototype.mergeLabel = function mergeLabel () {\n    var this$1 = this;\n\n    if (arguments[0] instanceof Node) {\n      var n = arguments[0];\n      this.mergeLabel(n._label);\n    } else if (arguments[0] instanceof Label) {\n      var label2 = arguments[0];\n      for (var i = 0; i < 2; i++) {\n        var loc = this$1.computeMergedLocation(label2, i);\n        var thisLoc = this$1._label.getLocation(i);\n        if (thisLoc === Location.NONE) { this$1._label.setLocation(i, loc); }\n      }\n    }\n  };\n  Node.prototype.add = function add (e) {\n    this._edges.insert(e);\n    e.setNode(this);\n  };\n  Node.prototype.setLabelBoundary = function setLabelBoundary (argIndex) {\n    if (this._label === null) { return null }\n    var loc = Location.NONE;\n    if (this._label !== null) { loc = this._label.getLocation(argIndex); }\n    var newLoc = null;\n    switch (loc) {\n      case Location.BOUNDARY:\n        newLoc = Location.INTERIOR;\n        break\n      case Location.INTERIOR:\n        newLoc = Location.BOUNDARY;\n        break\n      default:\n        newLoc = Location.BOUNDARY;\n        break\n    }\n    this._label.setLocation(argIndex, newLoc);\n  };\n  Node.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  Node.prototype.getClass = function getClass () {\n    return Node\n  };\n\n  return Node;\n}(GraphComponent));\n\nvar NodeMap = function NodeMap () {\n  this.nodeMap = new TreeMap();\n  this.nodeFact = null;\n  var nodeFact = arguments[0];\n  this.nodeFact = nodeFact;\n};\nNodeMap.prototype.find = function find (coord) {\n  return this.nodeMap.get(coord)\n};\nNodeMap.prototype.addNode = function addNode () {\n  if (arguments[0] instanceof Coordinate) {\n    var coord = arguments[0];\n    var node = this.nodeMap.get(coord);\n    if (node === null) {\n      node = this.nodeFact.createNode(coord);\n      this.nodeMap.put(coord, node);\n    }\n    return node\n  } else if (arguments[0] instanceof Node) {\n    var n = arguments[0];\n    var node$1 = this.nodeMap.get(n.getCoordinate());\n    if (node$1 === null) {\n      this.nodeMap.put(n.getCoordinate(), n);\n      return n\n    }\n    node$1.mergeLabel(n);\n    return node$1\n  }\n};\nNodeMap.prototype.print = function print (out) {\n  for (var it = this.iterator(); it.hasNext();) {\n    var n = it.next();\n    n.print(out);\n  }\n};\nNodeMap.prototype.iterator = function iterator () {\n  return this.nodeMap.values().iterator()\n};\nNodeMap.prototype.values = function values () {\n  return this.nodeMap.values()\n};\nNodeMap.prototype.getBoundaryNodes = function getBoundaryNodes (geomIndex) {\n  var bdyNodes = new ArrayList();\n  for (var i = this.iterator(); i.hasNext();) {\n    var node = i.next();\n    if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) { bdyNodes.add(node); }\n  }\n  return bdyNodes\n};\nNodeMap.prototype.add = function add (e) {\n  var p = e.getCoordinate();\n  var n = this.addNode(p);\n  n.add(e);\n};\nNodeMap.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNodeMap.prototype.getClass = function getClass () {\n  return NodeMap\n};\n\nvar Quadrant = function Quadrant () {};\n\nvar staticAccessors$21 = { NE: { configurable: true },NW: { configurable: true },SW: { configurable: true },SE: { configurable: true } };\n\nQuadrant.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nQuadrant.prototype.getClass = function getClass () {\n  return Quadrant\n};\nQuadrant.isNorthern = function isNorthern (quad) {\n  return quad === Quadrant.NE || quad === Quadrant.NW\n};\nQuadrant.isOpposite = function isOpposite (quad1, quad2) {\n  if (quad1 === quad2) { return false }\n  var diff = (quad1 - quad2 + 4) % 4;\n  if (diff === 2) { return true }\n  return false\n};\nQuadrant.commonHalfPlane = function commonHalfPlane (quad1, quad2) {\n  if (quad1 === quad2) { return quad1 }\n  var diff = (quad1 - quad2 + 4) % 4;\n  if (diff === 2) { return -1 }\n  var min = quad1 < quad2 ? quad1 : quad2;\n  var max = quad1 > quad2 ? quad1 : quad2;\n  if (min === 0 && max === 3) { return 3 }\n  return min\n};\nQuadrant.isInHalfPlane = function isInHalfPlane (quad, halfPlane) {\n  if (halfPlane === Quadrant.SE) {\n    return quad === Quadrant.SE || quad === Quadrant.SW\n  }\n  return quad === halfPlane || quad === halfPlane + 1\n};\nQuadrant.quadrant = function quadrant () {\n  if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n    var dx = arguments[0];\n    var dy = arguments[1];\n    if (dx === 0.0 && dy === 0.0) { throw new IllegalArgumentException('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )') }\n    if (dx >= 0.0) {\n      if (dy >= 0.0) { return Quadrant.NE; } else { return Quadrant.SE }\n    } else {\n      if (dy >= 0.0) { return Quadrant.NW; } else { return Quadrant.SW }\n    }\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (p1.x === p0.x && p1.y === p0.y) { throw new IllegalArgumentException('Cannot compute the quadrant for two identical points ' + p0) }\n    if (p1.x >= p0.x) {\n      if (p1.y >= p0.y) { return Quadrant.NE; } else { return Quadrant.SE }\n    } else {\n      if (p1.y >= p0.y) { return Quadrant.NW; } else { return Quadrant.SW }\n    }\n  }\n};\nstaticAccessors$21.NE.get = function () { return 0 };\nstaticAccessors$21.NW.get = function () { return 1 };\nstaticAccessors$21.SW.get = function () { return 2 };\nstaticAccessors$21.SE.get = function () { return 3 };\n\nObject.defineProperties( Quadrant, staticAccessors$21 );\n\nvar EdgeEnd = function EdgeEnd () {\n  this._edge = null;\n  this._label = null;\n  this._node = null;\n  this._p0 = null;\n  this._p1 = null;\n  this._dx = null;\n  this._dy = null;\n  this._quadrant = null;\n  if (arguments.length === 1) {\n    var edge = arguments[0];\n    this._edge = edge;\n  } else if (arguments.length === 3) {\n    var edge$1 = arguments[0];\n    var p0 = arguments[1];\n    var p1 = arguments[2];\n    var label = null;\n    this._edge = edge$1;\n    this.init(p0, p1);\n    this._label = label;\n  } else if (arguments.length === 4) {\n    var edge$2 = arguments[0];\n    var p0$1 = arguments[1];\n    var p1$1 = arguments[2];\n    var label$1 = arguments[3];\n    this._edge = edge$2;\n    this.init(p0$1, p1$1);\n    this._label = label$1;\n  }\n};\nEdgeEnd.prototype.compareDirection = function compareDirection (e) {\n  if (this._dx === e._dx && this._dy === e._dy) { return 0 }\n  if (this._quadrant > e._quadrant) { return 1 }\n  if (this._quadrant < e._quadrant) { return -1 }\n  return CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1)\n};\nEdgeEnd.prototype.getDy = function getDy () {\n  return this._dy\n};\nEdgeEnd.prototype.getCoordinate = function getCoordinate () {\n  return this._p0\n};\nEdgeEnd.prototype.setNode = function setNode (node) {\n  this._node = node;\n};\nEdgeEnd.prototype.print = function print (out) {\n  var angle = Math.atan2(this._dy, this._dx);\n  var className = this.getClass().getName();\n  var lastDotPos = className.lastIndexOf('.');\n  var name = className.substring(lastDotPos + 1);\n  out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);\n};\nEdgeEnd.prototype.compareTo = function compareTo (obj) {\n  var e = obj;\n  return this.compareDirection(e)\n};\nEdgeEnd.prototype.getDirectedCoordinate = function getDirectedCoordinate () {\n  return this._p1\n};\nEdgeEnd.prototype.getDx = function getDx () {\n  return this._dx\n};\nEdgeEnd.prototype.getLabel = function getLabel () {\n  return this._label\n};\nEdgeEnd.prototype.getEdge = function getEdge () {\n  return this._edge\n};\nEdgeEnd.prototype.getQuadrant = function getQuadrant () {\n  return this._quadrant\n};\nEdgeEnd.prototype.getNode = function getNode () {\n  return this._node\n};\nEdgeEnd.prototype.toString = function toString () {\n  var angle = Math.atan2(this._dy, this._dx);\n  var className = this.getClass().getName();\n  var lastDotPos = className.lastIndexOf('.');\n  var name = className.substring(lastDotPos + 1);\n  return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label\n};\nEdgeEnd.prototype.computeLabel = function computeLabel (boundaryNodeRule) {};\nEdgeEnd.prototype.init = function init (p0, p1) {\n  this._p0 = p0;\n  this._p1 = p1;\n  this._dx = p1.x - p0.x;\n  this._dy = p1.y - p0.y;\n  this._quadrant = Quadrant.quadrant(this._dx, this._dy);\n  Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');\n};\nEdgeEnd.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nEdgeEnd.prototype.getClass = function getClass () {\n  return EdgeEnd\n};\n\nvar DirectedEdge = (function (EdgeEnd$$1) {\n  function DirectedEdge () {\n    var edge = arguments[0];\n    var isForward = arguments[1];\n    EdgeEnd$$1.call(this, edge);\n    this._isForward = null;\n    this._isInResult = false;\n    this._isVisited = false;\n    this._sym = null;\n    this._next = null;\n    this._nextMin = null;\n    this._edgeRing = null;\n    this._minEdgeRing = null;\n    this._depth = [0, -999, -999];\n    this._isForward = isForward;\n    if (isForward) {\n      this.init(edge.getCoordinate(0), edge.getCoordinate(1));\n    } else {\n      var n = edge.getNumPoints() - 1;\n      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n    }\n    this.computeDirectedLabel();\n  }\n\n  if ( EdgeEnd$$1 ) DirectedEdge.__proto__ = EdgeEnd$$1;\n  DirectedEdge.prototype = Object.create( EdgeEnd$$1 && EdgeEnd$$1.prototype );\n  DirectedEdge.prototype.constructor = DirectedEdge;\n  DirectedEdge.prototype.getNextMin = function getNextMin () {\n    return this._nextMin\n  };\n  DirectedEdge.prototype.getDepth = function getDepth (position) {\n    return this._depth[position]\n  };\n  DirectedEdge.prototype.setVisited = function setVisited (isVisited) {\n    this._isVisited = isVisited;\n  };\n  DirectedEdge.prototype.computeDirectedLabel = function computeDirectedLabel () {\n    this._label = new Label(this._edge.getLabel());\n    if (!this._isForward) { this._label.flip(); }\n  };\n  DirectedEdge.prototype.getNext = function getNext () {\n    return this._next\n  };\n  DirectedEdge.prototype.setDepth = function setDepth (position, depthVal) {\n    if (this._depth[position] !== -999) {\n      if (this._depth[position] !== depthVal) { throw new TopologyException('assigned depths do not match', this.getCoordinate()) }\n    }\n    this._depth[position] = depthVal;\n  };\n  DirectedEdge.prototype.isInteriorAreaEdge = function isInteriorAreaEdge () {\n    var this$1 = this;\n\n    var isInteriorAreaEdge = true;\n    for (var i = 0; i < 2; i++) {\n      if (!(this$1._label.isArea(i) && this$1._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this$1._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n        isInteriorAreaEdge = false;\n      }\n    }\n    return isInteriorAreaEdge\n  };\n  DirectedEdge.prototype.setNextMin = function setNextMin (nextMin) {\n    this._nextMin = nextMin;\n  };\n  DirectedEdge.prototype.print = function print (out) {\n    EdgeEnd$$1.prototype.print.call(this, out);\n    out.print(' ' + this._depth[Position.LEFT] + '/' + this._depth[Position.RIGHT]);\n    out.print(' (' + this.getDepthDelta() + ')');\n    if (this._isInResult) { out.print(' inResult'); }\n  };\n  DirectedEdge.prototype.setMinEdgeRing = function setMinEdgeRing (minEdgeRing) {\n    this._minEdgeRing = minEdgeRing;\n  };\n  DirectedEdge.prototype.isLineEdge = function isLineEdge () {\n    var isLine = this._label.isLine(0) || this._label.isLine(1);\n    var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n    var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n    return isLine && isExteriorIfArea0 && isExteriorIfArea1\n  };\n  DirectedEdge.prototype.setEdgeRing = function setEdgeRing (edgeRing) {\n    this._edgeRing = edgeRing;\n  };\n  DirectedEdge.prototype.getMinEdgeRing = function getMinEdgeRing () {\n    return this._minEdgeRing\n  };\n  DirectedEdge.prototype.getDepthDelta = function getDepthDelta () {\n    var depthDelta = this._edge.getDepthDelta();\n    if (!this._isForward) { depthDelta = -depthDelta; }\n    return depthDelta\n  };\n  DirectedEdge.prototype.setInResult = function setInResult (isInResult) {\n    this._isInResult = isInResult;\n  };\n  DirectedEdge.prototype.getSym = function getSym () {\n    return this._sym\n  };\n  DirectedEdge.prototype.isForward = function isForward () {\n    return this._isForward\n  };\n  DirectedEdge.prototype.getEdge = function getEdge () {\n    return this._edge\n  };\n  DirectedEdge.prototype.printEdge = function printEdge (out) {\n    this.print(out);\n    out.print(' ');\n    if (this._isForward) { this._edge.print(out); } else { this._edge.printReverse(out); }\n  };\n  DirectedEdge.prototype.setSym = function setSym (de) {\n    this._sym = de;\n  };\n  DirectedEdge.prototype.setVisitedEdge = function setVisitedEdge (isVisited) {\n    this.setVisited(isVisited);\n    this._sym.setVisited(isVisited);\n  };\n  DirectedEdge.prototype.setEdgeDepths = function setEdgeDepths (position, depth) {\n    var depthDelta = this.getEdge().getDepthDelta();\n    if (!this._isForward) { depthDelta = -depthDelta; }\n    var directionFactor = 1;\n    if (position === Position.LEFT) { directionFactor = -1; }\n    var oppositePos = Position.opposite(position);\n    var delta = depthDelta * directionFactor;\n    var oppositeDepth = depth + delta;\n    this.setDepth(position, depth);\n    this.setDepth(oppositePos, oppositeDepth);\n  };\n  DirectedEdge.prototype.getEdgeRing = function getEdgeRing () {\n    return this._edgeRing\n  };\n  DirectedEdge.prototype.isInResult = function isInResult () {\n    return this._isInResult\n  };\n  DirectedEdge.prototype.setNext = function setNext (next) {\n    this._next = next;\n  };\n  DirectedEdge.prototype.isVisited = function isVisited () {\n    return this._isVisited\n  };\n  DirectedEdge.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  DirectedEdge.prototype.getClass = function getClass () {\n    return DirectedEdge\n  };\n  DirectedEdge.depthFactor = function depthFactor (currLocation, nextLocation) {\n    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) { return 1; } else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) { return -1 }\n    return 0\n  };\n\n  return DirectedEdge;\n}(EdgeEnd));\n\nvar NodeFactory = function NodeFactory () {};\n\nNodeFactory.prototype.createNode = function createNode (coord) {\n  return new Node(coord, null)\n};\nNodeFactory.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNodeFactory.prototype.getClass = function getClass () {\n  return NodeFactory\n};\n\nvar PlanarGraph = function PlanarGraph () {\n  this._edges = new ArrayList();\n  this._nodes = null;\n  this._edgeEndList = new ArrayList();\n  if (arguments.length === 0) {\n    this._nodes = new NodeMap(new NodeFactory());\n  } else if (arguments.length === 1) {\n    var nodeFact = arguments[0];\n    this._nodes = new NodeMap(nodeFact);\n  }\n};\nPlanarGraph.prototype.printEdges = function printEdges (out) {\n    var this$1 = this;\n\n  out.println('Edges:');\n  for (var i = 0; i < this._edges.size(); i++) {\n    out.println('edge ' + i + ':');\n    var e = this$1._edges.get(i);\n    e.print(out);\n    e.eiList.print(out);\n  }\n};\nPlanarGraph.prototype.find = function find (coord) {\n  return this._nodes.find(coord)\n};\nPlanarGraph.prototype.addNode = function addNode () {\n  if (arguments[0] instanceof Node) {\n    var node = arguments[0];\n    return this._nodes.addNode(node)\n  } else if (arguments[0] instanceof Coordinate) {\n    var coord = arguments[0];\n    return this._nodes.addNode(coord)\n  }\n};\nPlanarGraph.prototype.getNodeIterator = function getNodeIterator () {\n  return this._nodes.iterator()\n};\nPlanarGraph.prototype.linkResultDirectedEdges = function linkResultDirectedEdges () {\n  for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().linkResultDirectedEdges();\n  }\n};\nPlanarGraph.prototype.debugPrintln = function debugPrintln (o) {\n  System.out.println(o);\n};\nPlanarGraph.prototype.isBoundaryNode = function isBoundaryNode (geomIndex, coord) {\n  var node = this._nodes.find(coord);\n  if (node === null) { return false }\n  var label = node.getLabel();\n  if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) { return true }\n  return false\n};\nPlanarGraph.prototype.linkAllDirectedEdges = function linkAllDirectedEdges () {\n  for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().linkAllDirectedEdges();\n  }\n};\nPlanarGraph.prototype.matchInSameDirection = function matchInSameDirection (p0, p1, ep0, ep1) {\n  if (!p0.equals(ep0)) { return false }\n  if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) { return true }\n  return false\n};\nPlanarGraph.prototype.getEdgeEnds = function getEdgeEnds () {\n  return this._edgeEndList\n};\nPlanarGraph.prototype.debugPrint = function debugPrint (o) {\n  System.out.print(o);\n};\nPlanarGraph.prototype.getEdgeIterator = function getEdgeIterator () {\n  return this._edges.iterator()\n};\nPlanarGraph.prototype.findEdgeInSameDirection = function findEdgeInSameDirection (p0, p1) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edges.size(); i++) {\n    var e = this$1._edges.get(i);\n    var eCoord = e.getCoordinates();\n    if (this$1.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) { return e }\n    if (this$1.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) { return e }\n  }\n  return null\n};\nPlanarGraph.prototype.insertEdge = function insertEdge (e) {\n  this._edges.add(e);\n};\nPlanarGraph.prototype.findEdgeEnd = function findEdgeEnd (e) {\n  for (var i = this.getEdgeEnds().iterator(); i.hasNext();) {\n    var ee = i.next();\n    if (ee.getEdge() === e) { return ee }\n  }\n  return null\n};\nPlanarGraph.prototype.addEdges = function addEdges (edgesToAdd) {\n    var this$1 = this;\n\n  for (var it = edgesToAdd.iterator(); it.hasNext();) {\n    var e = it.next();\n    this$1._edges.add(e);\n    var de1 = new DirectedEdge(e, true);\n    var de2 = new DirectedEdge(e, false);\n    de1.setSym(de2);\n    de2.setSym(de1);\n    this$1.add(de1);\n    this$1.add(de2);\n  }\n};\nPlanarGraph.prototype.add = function add (e) {\n  this._nodes.add(e);\n  this._edgeEndList.add(e);\n};\nPlanarGraph.prototype.getNodes = function getNodes () {\n  return this._nodes.values()\n};\nPlanarGraph.prototype.findEdge = function findEdge (p0, p1) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edges.size(); i++) {\n    var e = this$1._edges.get(i);\n    var eCoord = e.getCoordinates();\n    if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) { return e }\n  }\n  return null\n};\nPlanarGraph.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPlanarGraph.prototype.getClass = function getClass () {\n  return PlanarGraph\n};\nPlanarGraph.linkResultDirectedEdges = function linkResultDirectedEdges (nodes) {\n  for (var nodeit = nodes.iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().linkResultDirectedEdges();\n  }\n};\n\nvar PolygonBuilder = function PolygonBuilder () {\n  this._geometryFactory = null;\n  this._shellList = new ArrayList();\n  var geometryFactory = arguments[0];\n  this._geometryFactory = geometryFactory;\n};\nPolygonBuilder.prototype.sortShellsAndHoles = function sortShellsAndHoles (edgeRings, shellList, freeHoleList) {\n  for (var it = edgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.isHole()) {\n      freeHoleList.add(er);\n    } else {\n      shellList.add(er);\n    }\n  }\n};\nPolygonBuilder.prototype.computePolygons = function computePolygons (shellList) {\n    var this$1 = this;\n\n  var resultPolyList = new ArrayList();\n  for (var it = shellList.iterator(); it.hasNext();) {\n    var er = it.next();\n    var poly = er.toPolygon(this$1._geometryFactory);\n    resultPolyList.add(poly);\n  }\n  return resultPolyList\n};\nPolygonBuilder.prototype.placeFreeHoles = function placeFreeHoles (shellList, freeHoleList) {\n    var this$1 = this;\n\n  for (var it = freeHoleList.iterator(); it.hasNext();) {\n    var hole = it.next();\n    if (hole.getShell() === null) {\n      var shell = this$1.findEdgeRingContaining(hole, shellList);\n      if (shell === null) { throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0)) }\n      hole.setShell(shell);\n    }\n  }\n};\nPolygonBuilder.prototype.buildMinimalEdgeRings = function buildMinimalEdgeRings (maxEdgeRings, shellList, freeHoleList) {\n    var this$1 = this;\n\n  var edgeRings = new ArrayList();\n  for (var it = maxEdgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.getMaxNodeDegree() > 2) {\n      er.linkDirectedEdgesForMinimalEdgeRings();\n      var minEdgeRings = er.buildMinimalRings();\n      var shell = this$1.findShell(minEdgeRings);\n      if (shell !== null) {\n        this$1.placePolygonHoles(shell, minEdgeRings);\n        shellList.add(shell);\n      } else {\n        freeHoleList.addAll(minEdgeRings);\n      }\n    } else {\n      edgeRings.add(er);\n    }\n  }\n  return edgeRings\n};\nPolygonBuilder.prototype.containsPoint = function containsPoint (p) {\n  for (var it = this._shellList.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.containsPoint(p)) { return true }\n  }\n  return false\n};\nPolygonBuilder.prototype.buildMaximalEdgeRings = function buildMaximalEdgeRings (dirEdges) {\n    var this$1 = this;\n\n  var maxEdgeRings = new ArrayList();\n  for (var it = dirEdges.iterator(); it.hasNext();) {\n    var de = it.next();\n    if (de.isInResult() && de.getLabel().isArea()) {\n      if (de.getEdgeRing() === null) {\n        var er = new MaximalEdgeRing(de, this$1._geometryFactory);\n        maxEdgeRings.add(er);\n        er.setInResult();\n      }\n    }\n  }\n  return maxEdgeRings\n};\nPolygonBuilder.prototype.placePolygonHoles = function placePolygonHoles (shell, minEdgeRings) {\n  for (var it = minEdgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.isHole()) {\n      er.setShell(shell);\n    }\n  }\n};\nPolygonBuilder.prototype.getPolygons = function getPolygons () {\n  var resultPolyList = this.computePolygons(this._shellList);\n  return resultPolyList\n};\nPolygonBuilder.prototype.findEdgeRingContaining = function findEdgeRingContaining (testEr, shellList) {\n  var testRing = testEr.getLinearRing();\n  var testEnv = testRing.getEnvelopeInternal();\n  var testPt = testRing.getCoordinateN(0);\n  var minShell = null;\n  var minEnv = null;\n  for (var it = shellList.iterator(); it.hasNext();) {\n    var tryShell = it.next();\n    var tryRing = tryShell.getLinearRing();\n    var tryEnv = tryRing.getEnvelopeInternal();\n    if (minShell !== null) { minEnv = minShell.getLinearRing().getEnvelopeInternal(); }\n    var isContained = false;\n    if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) { isContained = true; }\n    if (isContained) {\n      if (minShell === null || minEnv.contains(tryEnv)) {\n        minShell = tryShell;\n      }\n    }\n  }\n  return minShell\n};\nPolygonBuilder.prototype.findShell = function findShell (minEdgeRings) {\n  var shellCount = 0;\n  var shell = null;\n  for (var it = minEdgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (!er.isHole()) {\n      shell = er;\n      shellCount++;\n    }\n  }\n  Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');\n  return shell\n};\nPolygonBuilder.prototype.add = function add () {\n  if (arguments.length === 1) {\n    var graph = arguments[0];\n    this.add(graph.getEdgeEnds(), graph.getNodes());\n  } else if (arguments.length === 2) {\n    var dirEdges = arguments[0];\n    var nodes = arguments[1];\n    PlanarGraph.linkResultDirectedEdges(nodes);\n    var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n    var freeHoleList = new ArrayList();\n    var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);\n    this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);\n    this.placeFreeHoles(this._shellList, freeHoleList);\n  }\n};\nPolygonBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPolygonBuilder.prototype.getClass = function getClass () {\n  return PolygonBuilder\n};\n\nvar Boundable = function Boundable () {};\n\nBoundable.prototype.getBounds = function getBounds () {};\nBoundable.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBoundable.prototype.getClass = function getClass () {\n  return Boundable\n};\n\nvar ItemBoundable = function ItemBoundable () {\n  this._bounds = null;\n  this._item = null;\n  var bounds = arguments[0];\n  var item = arguments[1];\n  this._bounds = bounds;\n  this._item = item;\n};\nItemBoundable.prototype.getItem = function getItem () {\n  return this._item\n};\nItemBoundable.prototype.getBounds = function getBounds () {\n  return this._bounds\n};\nItemBoundable.prototype.interfaces_ = function interfaces_ () {\n  return [Boundable, Serializable]\n};\nItemBoundable.prototype.getClass = function getClass () {\n  return ItemBoundable\n};\n\nvar PriorityQueue = function PriorityQueue () {\n  this._size = null;\n  this._items = null;\n  this._size = 0;\n  this._items = new ArrayList();\n  this._items.add(null);\n};\nPriorityQueue.prototype.poll = function poll () {\n  if (this.isEmpty()) { return null }\n  var minItem = this._items.get(1);\n  this._items.set(1, this._items.get(this._size));\n  this._size -= 1;\n  this.reorder(1);\n  return minItem\n};\nPriorityQueue.prototype.size = function size () {\n  return this._size\n};\nPriorityQueue.prototype.reorder = function reorder (hole) {\n    var this$1 = this;\n\n  var child = null;\n  var tmp = this._items.get(hole);\n  for (; hole * 2 <= this._size; hole = child) {\n    child = hole * 2;\n    if (child !== this$1._size && this$1._items.get(child + 1).compareTo(this$1._items.get(child)) < 0) { child++; }\n    if (this$1._items.get(child).compareTo(tmp) < 0) { this$1._items.set(hole, this$1._items.get(child)); } else { break }\n  }\n  this._items.set(hole, tmp);\n};\nPriorityQueue.prototype.clear = function clear () {\n  this._size = 0;\n  this._items.clear();\n};\nPriorityQueue.prototype.isEmpty = function isEmpty () {\n  return this._size === 0\n};\nPriorityQueue.prototype.add = function add (x) {\n    var this$1 = this;\n\n  this._items.add(null);\n  this._size += 1;\n  var hole = this._size;\n  this._items.set(0, x);\n  for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {\n    this$1._items.set(hole, this$1._items.get(Math.trunc(hole / 2)));\n  }\n  this._items.set(hole, x);\n};\nPriorityQueue.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPriorityQueue.prototype.getClass = function getClass () {\n  return PriorityQueue\n};\n\nvar ItemVisitor = function ItemVisitor () {};\n\nItemVisitor.prototype.visitItem = function visitItem (item) {};\nItemVisitor.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nItemVisitor.prototype.getClass = function getClass () {\n  return ItemVisitor\n};\n\nvar SpatialIndex = function SpatialIndex () {};\n\nSpatialIndex.prototype.insert = function insert (itemEnv, item) {};\nSpatialIndex.prototype.remove = function remove (itemEnv, item) {};\nSpatialIndex.prototype.query = function query () {\n  // if (arguments.length === 1) {\n  // const searchEnv = arguments[0]\n  // } else if (arguments.length === 2) {\n  // const searchEnv = arguments[0]\n  // const visitor = arguments[1]\n  // }\n};\nSpatialIndex.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSpatialIndex.prototype.getClass = function getClass () {\n  return SpatialIndex\n};\n\nvar AbstractNode = function AbstractNode () {\n  this._childBoundables = new ArrayList();\n  this._bounds = null;\n  this._level = null;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var level = arguments[0];\n    this._level = level;\n  }\n};\n\nvar staticAccessors$22 = { serialVersionUID: { configurable: true } };\nAbstractNode.prototype.getLevel = function getLevel () {\n  return this._level\n};\nAbstractNode.prototype.size = function size () {\n  return this._childBoundables.size()\n};\nAbstractNode.prototype.getChildBoundables = function getChildBoundables () {\n  return this._childBoundables\n};\nAbstractNode.prototype.addChildBoundable = function addChildBoundable (childBoundable) {\n  Assert.isTrue(this._bounds === null);\n  this._childBoundables.add(childBoundable);\n};\nAbstractNode.prototype.isEmpty = function isEmpty () {\n  return this._childBoundables.isEmpty()\n};\nAbstractNode.prototype.getBounds = function getBounds () {\n  if (this._bounds === null) {\n    this._bounds = this.computeBounds();\n  }\n  return this._bounds\n};\nAbstractNode.prototype.interfaces_ = function interfaces_ () {\n  return [Boundable, Serializable]\n};\nAbstractNode.prototype.getClass = function getClass () {\n  return AbstractNode\n};\nstaticAccessors$22.serialVersionUID.get = function () { return 6493722185909573708 };\n\nObject.defineProperties( AbstractNode, staticAccessors$22 );\n\nvar Collections = function Collections () {};\n\nCollections.reverseOrder = function reverseOrder () {\n  return {\n    compare: function compare (a, b) {\n      return b.compareTo(a)\n    }\n  }\n};\nCollections.min = function min (l) {\n  Collections.sort(l);\n  return l.get(0)\n};\nCollections.sort = function sort (l, c) {\n  var a = l.toArray();\n  if (c) {\n    Arrays.sort(a, c);\n  } else {\n    Arrays.sort(a);\n  }\n  var i = l.iterator();\n  for (var pos = 0, alen = a.length; pos < alen; pos++) {\n    i.next();\n    i.set(a[pos]);\n  }\n};\nCollections.singletonList = function singletonList (o) {\n  var arrayList = new ArrayList();\n  arrayList.add(o);\n  return arrayList\n};\n\nvar BoundablePair = function BoundablePair () {\n  this._boundable1 = null;\n  this._boundable2 = null;\n  this._distance = null;\n  this._itemDistance = null;\n  var boundable1 = arguments[0];\n  var boundable2 = arguments[1];\n  var itemDistance = arguments[2];\n  this._boundable1 = boundable1;\n  this._boundable2 = boundable2;\n  this._itemDistance = itemDistance;\n  this._distance = this.distance();\n};\nBoundablePair.prototype.expandToQueue = function expandToQueue (priQ, minDistance) {\n  var isComp1 = BoundablePair.isComposite(this._boundable1);\n  var isComp2 = BoundablePair.isComposite(this._boundable2);\n  if (isComp1 && isComp2) {\n    if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n      this.expand(this._boundable1, this._boundable2, priQ, minDistance);\n      return null\n    } else {\n      this.expand(this._boundable2, this._boundable1, priQ, minDistance);\n      return null\n    }\n  } else if (isComp1) {\n    this.expand(this._boundable1, this._boundable2, priQ, minDistance);\n    return null\n  } else if (isComp2) {\n    this.expand(this._boundable2, this._boundable1, priQ, minDistance);\n    return null\n  }\n  throw new IllegalArgumentException('neither boundable is composite')\n};\nBoundablePair.prototype.isLeaves = function isLeaves () {\n  return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2))\n};\nBoundablePair.prototype.compareTo = function compareTo (o) {\n  var nd = o;\n  if (this._distance < nd._distance) { return -1 }\n  if (this._distance > nd._distance) { return 1 }\n  return 0\n};\nBoundablePair.prototype.expand = function expand (bndComposite, bndOther, priQ, minDistance) {\n    var this$1 = this;\n\n  var children = bndComposite.getChildBoundables();\n  for (var i = children.iterator(); i.hasNext();) {\n    var child = i.next();\n    var bp = new BoundablePair(child, bndOther, this$1._itemDistance);\n    if (bp.getDistance() < minDistance) {\n      priQ.add(bp);\n    }\n  }\n};\nBoundablePair.prototype.getBoundable = function getBoundable (i) {\n  if (i === 0) { return this._boundable1 }\n  return this._boundable2\n};\nBoundablePair.prototype.getDistance = function getDistance () {\n  return this._distance\n};\nBoundablePair.prototype.distance = function distance () {\n  if (this.isLeaves()) {\n    return this._itemDistance.distance(this._boundable1, this._boundable2)\n  }\n  return this._boundable1.getBounds().distance(this._boundable2.getBounds())\n};\nBoundablePair.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nBoundablePair.prototype.getClass = function getClass () {\n  return BoundablePair\n};\nBoundablePair.area = function area (b) {\n  return b.getBounds().getArea()\n};\nBoundablePair.isComposite = function isComposite (item) {\n  return item instanceof AbstractNode\n};\n\nvar AbstractSTRtree = function AbstractSTRtree () {\n  this._root = null;\n  this._built = false;\n  this._itemBoundables = new ArrayList();\n  this._nodeCapacity = null;\n  if (arguments.length === 0) {\n    var nodeCapacity = AbstractSTRtree.DEFAULT_NODE_CAPACITY;\n    this._nodeCapacity = nodeCapacity;\n  } else if (arguments.length === 1) {\n    var nodeCapacity$1 = arguments[0];\n    Assert.isTrue(nodeCapacity$1 > 1, 'Node capacity must be greater than 1');\n    this._nodeCapacity = nodeCapacity$1;\n  }\n};\n\nvar staticAccessors$23 = { IntersectsOp: { configurable: true },serialVersionUID: { configurable: true },DEFAULT_NODE_CAPACITY: { configurable: true } };\nAbstractSTRtree.prototype.getNodeCapacity = function getNodeCapacity () {\n  return this._nodeCapacity\n};\nAbstractSTRtree.prototype.lastNode = function lastNode (nodes) {\n  return nodes.get(nodes.size() - 1)\n};\nAbstractSTRtree.prototype.size = function size () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this.isEmpty()) {\n      return 0\n    }\n    this.build();\n    return this.size(this._root)\n  } else if (arguments.length === 1) {\n    var node = arguments[0];\n    var size = 0;\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (childBoundable instanceof AbstractNode) {\n        size += this$1.size(childBoundable);\n      } else if (childBoundable instanceof ItemBoundable) {\n        size += 1;\n      }\n    }\n    return size\n  }\n};\nAbstractSTRtree.prototype.removeItem = function removeItem (node, item) {\n  var childToRemove = null;\n  for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n    var childBoundable = i.next();\n    if (childBoundable instanceof ItemBoundable) {\n      if (childBoundable.getItem() === item) { childToRemove = childBoundable; }\n    }\n  }\n  if (childToRemove !== null) {\n    node.getChildBoundables().remove(childToRemove);\n    return true\n  }\n  return false\n};\nAbstractSTRtree.prototype.itemsTree = function itemsTree () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    this.build();\n    var valuesTree = this.itemsTree(this._root);\n    if (valuesTree === null) { return new ArrayList() }\n    return valuesTree\n  } else if (arguments.length === 1) {\n    var node = arguments[0];\n    var valuesTreeForNode = new ArrayList();\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (childBoundable instanceof AbstractNode) {\n        var valuesTreeForChild = this$1.itemsTree(childBoundable);\n        if (valuesTreeForChild !== null) { valuesTreeForNode.add(valuesTreeForChild); }\n      } else if (childBoundable instanceof ItemBoundable) {\n        valuesTreeForNode.add(childBoundable.getItem());\n      } else {\n        Assert.shouldNeverReachHere();\n      }\n    }\n    if (valuesTreeForNode.size() <= 0) { return null }\n    return valuesTreeForNode\n  }\n};\nAbstractSTRtree.prototype.insert = function insert (bounds, item) {\n  Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');\n  this._itemBoundables.add(new ItemBoundable(bounds, item));\n};\nAbstractSTRtree.prototype.boundablesAtLevel = function boundablesAtLevel () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var level = arguments[0];\n    var boundables = new ArrayList();\n    this.boundablesAtLevel(level, this._root, boundables);\n    return boundables\n  } else if (arguments.length === 3) {\n    var level$1 = arguments[0];\n    var top = arguments[1];\n    var boundables$1 = arguments[2];\n    Assert.isTrue(level$1 > -2);\n    if (top.getLevel() === level$1) {\n      boundables$1.add(top);\n      return null\n    }\n    for (var i = top.getChildBoundables().iterator(); i.hasNext();) {\n      var boundable = i.next();\n      if (boundable instanceof AbstractNode) {\n        this$1.boundablesAtLevel(level$1, boundable, boundables$1);\n      } else {\n        Assert.isTrue(boundable instanceof ItemBoundable);\n        if (level$1 === -1) {\n          boundables$1.add(boundable);\n        }\n      }\n    }\n    return null\n  }\n};\nAbstractSTRtree.prototype.query = function query () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var searchBounds = arguments[0];\n    this.build();\n    var matches = new ArrayList();\n    if (this.isEmpty()) {\n      return matches\n    }\n    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n      this.query(searchBounds, this._root, matches);\n    }\n    return matches\n  } else if (arguments.length === 2) {\n    var searchBounds$1 = arguments[0];\n    var visitor = arguments[1];\n    this.build();\n    if (this.isEmpty()) {\n      return null\n    }\n    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds$1)) {\n      this.query(searchBounds$1, this._root, visitor);\n    }\n  } else if (arguments.length === 3) {\n    if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n      var searchBounds$2 = arguments[0];\n      var node = arguments[1];\n      var visitor$1 = arguments[2];\n      var childBoundables = node.getChildBoundables();\n      for (var i = 0; i < childBoundables.size(); i++) {\n        var childBoundable = childBoundables.get(i);\n        if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$2)) {\n          continue\n        }\n        if (childBoundable instanceof AbstractNode) {\n          this$1.query(searchBounds$2, childBoundable, visitor$1);\n        } else if (childBoundable instanceof ItemBoundable) {\n          visitor$1.visitItem(childBoundable.getItem());\n        } else {\n          Assert.shouldNeverReachHere();\n        }\n      }\n    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n      var searchBounds$3 = arguments[0];\n      var node$1 = arguments[1];\n      var matches$1 = arguments[2];\n      var childBoundables$1 = node$1.getChildBoundables();\n      for (var i$1 = 0; i$1 < childBoundables$1.size(); i$1++) {\n        var childBoundable$1 = childBoundables$1.get(i$1);\n        if (!this$1.getIntersectsOp().intersects(childBoundable$1.getBounds(), searchBounds$3)) {\n          continue\n        }\n        if (childBoundable$1 instanceof AbstractNode) {\n          this$1.query(searchBounds$3, childBoundable$1, matches$1);\n        } else if (childBoundable$1 instanceof ItemBoundable) {\n          matches$1.add(childBoundable$1.getItem());\n        } else {\n          Assert.shouldNeverReachHere();\n        }\n      }\n    }\n  }\n};\nAbstractSTRtree.prototype.build = function build () {\n  if (this._built) { return null }\n  this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);\n  this._itemBoundables = null;\n  this._built = true;\n};\nAbstractSTRtree.prototype.getRoot = function getRoot () {\n  this.build();\n  return this._root\n};\nAbstractSTRtree.prototype.remove = function remove () {\n    var this$1 = this;\n\n  if (arguments.length === 2) {\n    var searchBounds = arguments[0];\n    var item = arguments[1];\n    this.build();\n    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n      return this.remove(searchBounds, this._root, item)\n    }\n    return false\n  } else if (arguments.length === 3) {\n    var searchBounds$1 = arguments[0];\n    var node = arguments[1];\n    var item$1 = arguments[2];\n    var found = this.removeItem(node, item$1);\n    if (found) { return true }\n    var childToPrune = null;\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$1)) {\n        continue\n      }\n      if (childBoundable instanceof AbstractNode) {\n        found = this$1.remove(searchBounds$1, childBoundable, item$1);\n        if (found) {\n          childToPrune = childBoundable;\n          break\n        }\n      }\n    }\n    if (childToPrune !== null) {\n      if (childToPrune.getChildBoundables().isEmpty()) {\n        node.getChildBoundables().remove(childToPrune);\n      }\n    }\n    return found\n  }\n};\nAbstractSTRtree.prototype.createHigherLevels = function createHigherLevels (boundablesOfALevel, level) {\n  Assert.isTrue(!boundablesOfALevel.isEmpty());\n  var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n  if (parentBoundables.size() === 1) {\n    return parentBoundables.get(0)\n  }\n  return this.createHigherLevels(parentBoundables, level + 1)\n};\nAbstractSTRtree.prototype.depth = function depth () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this.isEmpty()) {\n      return 0\n    }\n    this.build();\n    return this.depth(this._root)\n  } else if (arguments.length === 1) {\n    var node = arguments[0];\n    var maxChildDepth = 0;\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (childBoundable instanceof AbstractNode) {\n        var childDepth = this$1.depth(childBoundable);\n        if (childDepth > maxChildDepth) { maxChildDepth = childDepth; }\n      }\n    }\n    return maxChildDepth + 1\n  }\n};\nAbstractSTRtree.prototype.createParentBoundables = function createParentBoundables (childBoundables, newLevel) {\n    var this$1 = this;\n\n  Assert.isTrue(!childBoundables.isEmpty());\n  var parentBoundables = new ArrayList();\n  parentBoundables.add(this.createNode(newLevel));\n  var sortedChildBoundables = new ArrayList(childBoundables);\n  Collections.sort(sortedChildBoundables, this.getComparator());\n  for (var i = sortedChildBoundables.iterator(); i.hasNext();) {\n    var childBoundable = i.next();\n    if (this$1.lastNode(parentBoundables).getChildBoundables().size() === this$1.getNodeCapacity()) {\n      parentBoundables.add(this$1.createNode(newLevel));\n    }\n    this$1.lastNode(parentBoundables).addChildBoundable(childBoundable);\n  }\n  return parentBoundables\n};\nAbstractSTRtree.prototype.isEmpty = function isEmpty () {\n  if (!this._built) { return this._itemBoundables.isEmpty() }\n  return this._root.isEmpty()\n};\nAbstractSTRtree.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable]\n};\nAbstractSTRtree.prototype.getClass = function getClass () {\n  return AbstractSTRtree\n};\nAbstractSTRtree.compareDoubles = function compareDoubles (a, b) {\n  return a > b ? 1 : a < b ? -1 : 0\n};\nstaticAccessors$23.IntersectsOp.get = function () { return IntersectsOp };\nstaticAccessors$23.serialVersionUID.get = function () { return -3886435814360241337 };\nstaticAccessors$23.DEFAULT_NODE_CAPACITY.get = function () { return 10 };\n\nObject.defineProperties( AbstractSTRtree, staticAccessors$23 );\n\nvar IntersectsOp = function IntersectsOp () {};\n\nvar ItemDistance = function ItemDistance () {};\n\nItemDistance.prototype.distance = function distance (item1, item2) {};\nItemDistance.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nItemDistance.prototype.getClass = function getClass () {\n  return ItemDistance\n};\n\nvar STRtree = (function (AbstractSTRtree$$1) {\n  function STRtree (nodeCapacity) {\n    nodeCapacity = nodeCapacity || STRtree.DEFAULT_NODE_CAPACITY;\n    AbstractSTRtree$$1.call(this, nodeCapacity);\n  }\n\n  if ( AbstractSTRtree$$1 ) STRtree.__proto__ = AbstractSTRtree$$1;\n  STRtree.prototype = Object.create( AbstractSTRtree$$1 && AbstractSTRtree$$1.prototype );\n  STRtree.prototype.constructor = STRtree;\n\n  var staticAccessors = { STRtreeNode: { configurable: true },serialVersionUID: { configurable: true },xComparator: { configurable: true },yComparator: { configurable: true },intersectsOp: { configurable: true },DEFAULT_NODE_CAPACITY: { configurable: true } };\n  STRtree.prototype.createParentBoundablesFromVerticalSlices = function createParentBoundablesFromVerticalSlices (verticalSlices, newLevel) {\n    var this$1 = this;\n\n    Assert.isTrue(verticalSlices.length > 0);\n    var parentBoundables = new ArrayList();\n    for (var i = 0; i < verticalSlices.length; i++) {\n      parentBoundables.addAll(this$1.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n    }\n    return parentBoundables\n  };\n  STRtree.prototype.createNode = function createNode (level) {\n    return new STRtreeNode(level)\n  };\n  STRtree.prototype.size = function size () {\n    if (arguments.length === 0) {\n      return AbstractSTRtree$$1.prototype.size.call(this)\n    } else { return AbstractSTRtree$$1.prototype.size.apply(this, arguments) }\n  };\n  STRtree.prototype.insert = function insert () {\n    if (arguments.length === 2) {\n      var itemEnv = arguments[0];\n      var item = arguments[1];\n      if (itemEnv.isNull()) {\n        return null\n      }\n      AbstractSTRtree$$1.prototype.insert.call(this, itemEnv, item);\n    } else { return AbstractSTRtree$$1.prototype.insert.apply(this, arguments) }\n  };\n  STRtree.prototype.getIntersectsOp = function getIntersectsOp () {\n    return STRtree.intersectsOp\n  };\n  STRtree.prototype.verticalSlices = function verticalSlices (childBoundables, sliceCount) {\n    var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n    var slices = new Array(sliceCount).fill(null);\n    var i = childBoundables.iterator();\n    for (var j = 0; j < sliceCount; j++) {\n      slices[j] = new ArrayList();\n      var boundablesAddedToSlice = 0;\n      while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n        var childBoundable = i.next();\n        slices[j].add(childBoundable);\n        boundablesAddedToSlice++;\n      }\n    }\n    return slices\n  };\n  STRtree.prototype.query = function query () {\n    if (arguments.length === 1) {\n      var searchEnv = arguments[0];\n      return AbstractSTRtree$$1.prototype.query.call(this, searchEnv)\n    } else if (arguments.length === 2) {\n      var searchEnv$1 = arguments[0];\n      var visitor = arguments[1];\n      AbstractSTRtree$$1.prototype.query.call(this, searchEnv$1, visitor);\n    } else if (arguments.length === 3) {\n      if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n        var searchBounds = arguments[0];\n        var node = arguments[1];\n        var visitor$1 = arguments[2];\n        AbstractSTRtree$$1.prototype.query.call(this, searchBounds, node, visitor$1);\n      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n        var searchBounds$1 = arguments[0];\n        var node$1 = arguments[1];\n        var matches = arguments[2];\n        AbstractSTRtree$$1.prototype.query.call(this, searchBounds$1, node$1, matches);\n      }\n    }\n  };\n  STRtree.prototype.getComparator = function getComparator () {\n    return STRtree.yComparator\n  };\n  STRtree.prototype.createParentBoundablesFromVerticalSlice = function createParentBoundablesFromVerticalSlice (childBoundables, newLevel) {\n    return AbstractSTRtree$$1.prototype.createParentBoundables.call(this, childBoundables, newLevel)\n  };\n  STRtree.prototype.remove = function remove () {\n    if (arguments.length === 2) {\n      var itemEnv = arguments[0];\n      var item = arguments[1];\n      return AbstractSTRtree$$1.prototype.remove.call(this, itemEnv, item)\n    } else { return AbstractSTRtree$$1.prototype.remove.apply(this, arguments) }\n  };\n  STRtree.prototype.depth = function depth () {\n    if (arguments.length === 0) {\n      return AbstractSTRtree$$1.prototype.depth.call(this)\n    } else { return AbstractSTRtree$$1.prototype.depth.apply(this, arguments) }\n  };\n  STRtree.prototype.createParentBoundables = function createParentBoundables (childBoundables, newLevel) {\n    Assert.isTrue(!childBoundables.isEmpty());\n    var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n    var sortedChildBoundables = new ArrayList(childBoundables);\n    Collections.sort(sortedChildBoundables, STRtree.xComparator);\n    var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n    return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel)\n  };\n  STRtree.prototype.nearestNeighbour = function nearestNeighbour () {\n    if (arguments.length === 1) {\n      if (hasInterface(arguments[0], ItemDistance)) {\n        var itemDist = arguments[0];\n        var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n        return this.nearestNeighbour(bp)\n      } else if (arguments[0] instanceof BoundablePair) {\n        var initBndPair = arguments[0];\n        return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY)\n      }\n    } else if (arguments.length === 2) {\n      if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {\n        var tree = arguments[0];\n        var itemDist$1 = arguments[1];\n        var bp$1 = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist$1);\n        return this.nearestNeighbour(bp$1)\n      } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === 'number') {\n        var initBndPair$1 = arguments[0];\n        var maxDistance = arguments[1];\n        var distanceLowerBound = maxDistance;\n        var minPair = null;\n        var priQ = new PriorityQueue();\n        priQ.add(initBndPair$1);\n        while (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n          var bndPair = priQ.poll();\n          var currentDistance = bndPair.getDistance();\n          if (currentDistance >= distanceLowerBound) { break }\n          if (bndPair.isLeaves()) {\n            distanceLowerBound = currentDistance;\n            minPair = bndPair;\n          } else {\n            bndPair.expandToQueue(priQ, distanceLowerBound);\n          }\n        }\n        return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()]\n      }\n    } else if (arguments.length === 3) {\n      var env = arguments[0];\n      var item = arguments[1];\n      var itemDist$2 = arguments[2];\n      var bnd = new ItemBoundable(env, item);\n      var bp$2 = new BoundablePair(this.getRoot(), bnd, itemDist$2);\n      return this.nearestNeighbour(bp$2)[0]\n    }\n  };\n  STRtree.prototype.interfaces_ = function interfaces_ () {\n    return [SpatialIndex, Serializable]\n  };\n  STRtree.prototype.getClass = function getClass () {\n    return STRtree\n  };\n  STRtree.centreX = function centreX (e) {\n    return STRtree.avg(e.getMinX(), e.getMaxX())\n  };\n  STRtree.avg = function avg (a, b) {\n    return (a + b) / 2\n  };\n  STRtree.centreY = function centreY (e) {\n    return STRtree.avg(e.getMinY(), e.getMaxY())\n  };\n  staticAccessors.STRtreeNode.get = function () { return STRtreeNode };\n  staticAccessors.serialVersionUID.get = function () { return 259274702368956900 };\n  staticAccessors.xComparator.get = function () {\n    return {\n      interfaces_: function () {\n        return [Comparator]\n      },\n      compare: function (o1, o2) {\n        return AbstractSTRtree$$1.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()))\n      }\n    }\n  };\n  staticAccessors.yComparator.get = function () {\n    return {\n      interfaces_: function () {\n        return [Comparator]\n      },\n      compare: function (o1, o2) {\n        return AbstractSTRtree$$1.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()))\n      }\n    }\n  };\n  staticAccessors.intersectsOp.get = function () {\n    return {\n      interfaces_: function () {\n        return [AbstractSTRtree$$1.IntersectsOp]\n      },\n      intersects: function (aBounds, bBounds) {\n        return aBounds.intersects(bBounds)\n      }\n    }\n  };\n  staticAccessors.DEFAULT_NODE_CAPACITY.get = function () { return 10 };\n\n  Object.defineProperties( STRtree, staticAccessors );\n\n  return STRtree;\n}(AbstractSTRtree));\n\nvar STRtreeNode = (function (AbstractNode$$1) {\n  function STRtreeNode () {\n    var level = arguments[0];\n    AbstractNode$$1.call(this, level);\n  }\n\n  if ( AbstractNode$$1 ) STRtreeNode.__proto__ = AbstractNode$$1;\n  STRtreeNode.prototype = Object.create( AbstractNode$$1 && AbstractNode$$1.prototype );\n  STRtreeNode.prototype.constructor = STRtreeNode;\n  STRtreeNode.prototype.computeBounds = function computeBounds () {\n    var bounds = null;\n    for (var i = this.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (bounds === null) {\n        bounds = new Envelope(childBoundable.getBounds());\n      } else {\n        bounds.expandToInclude(childBoundable.getBounds());\n      }\n    }\n    return bounds\n  };\n  STRtreeNode.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  STRtreeNode.prototype.getClass = function getClass () {\n    return STRtreeNode\n  };\n\n  return STRtreeNode;\n}(AbstractNode));\n\nvar SegmentPointComparator = function SegmentPointComparator () {};\n\nSegmentPointComparator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentPointComparator.prototype.getClass = function getClass () {\n  return SegmentPointComparator\n};\nSegmentPointComparator.relativeSign = function relativeSign (x0, x1) {\n  if (x0 < x1) { return -1 }\n  if (x0 > x1) { return 1 }\n  return 0\n};\nSegmentPointComparator.compare = function compare (octant, p0, p1) {\n  if (p0.equals2D(p1)) { return 0 }\n  var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n  var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n  switch (octant) {\n    case 0:\n      return SegmentPointComparator.compareValue(xSign, ySign)\n    case 1:\n      return SegmentPointComparator.compareValue(ySign, xSign)\n    case 2:\n      return SegmentPointComparator.compareValue(ySign, -xSign)\n    case 3:\n      return SegmentPointComparator.compareValue(-xSign, ySign)\n    case 4:\n      return SegmentPointComparator.compareValue(-xSign, -ySign)\n    case 5:\n      return SegmentPointComparator.compareValue(-ySign, -xSign)\n    case 6:\n      return SegmentPointComparator.compareValue(-ySign, xSign)\n    case 7:\n      return SegmentPointComparator.compareValue(xSign, -ySign)\n    default:\n  }\n  Assert.shouldNeverReachHere('invalid octant value');\n  return 0\n};\nSegmentPointComparator.compareValue = function compareValue (compareSign0, compareSign1) {\n  if (compareSign0 < 0) { return -1 }\n  if (compareSign0 > 0) { return 1 }\n  if (compareSign1 < 0) { return -1 }\n  if (compareSign1 > 0) { return 1 }\n  return 0\n};\n\nvar SegmentNode = function SegmentNode () {\n  this._segString = null;\n  this.coord = null;\n  this.segmentIndex = null;\n  this._segmentOctant = null;\n  this._isInterior = null;\n  var segString = arguments[0];\n  var coord = arguments[1];\n  var segmentIndex = arguments[2];\n  var segmentOctant = arguments[3];\n  this._segString = segString;\n  this.coord = new Coordinate(coord);\n  this.segmentIndex = segmentIndex;\n  this._segmentOctant = segmentOctant;\n  this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n};\nSegmentNode.prototype.getCoordinate = function getCoordinate () {\n  return this.coord\n};\nSegmentNode.prototype.print = function print (out) {\n  out.print(this.coord);\n  out.print(' seg # = ' + this.segmentIndex);\n};\nSegmentNode.prototype.compareTo = function compareTo (obj) {\n  var other = obj;\n  if (this.segmentIndex < other.segmentIndex) { return -1 }\n  if (this.segmentIndex > other.segmentIndex) { return 1 }\n  if (this.coord.equals2D(other.coord)) { return 0 }\n  return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord)\n};\nSegmentNode.prototype.isEndPoint = function isEndPoint (maxSegmentIndex) {\n  if (this.segmentIndex === 0 && !this._isInterior) { return true }\n  if (this.segmentIndex === maxSegmentIndex) { return true }\n  return false\n};\nSegmentNode.prototype.isInterior = function isInterior () {\n  return this._isInterior\n};\nSegmentNode.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nSegmentNode.prototype.getClass = function getClass () {\n  return SegmentNode\n};\n\n// import Iterator from '../../../../java/util/Iterator'\nvar SegmentNodeList = function SegmentNodeList () {\n  this._nodeMap = new TreeMap();\n  this._edge = null;\n  var edge = arguments[0];\n  this._edge = edge;\n};\nSegmentNodeList.prototype.getSplitCoordinates = function getSplitCoordinates () {\n    var this$1 = this;\n\n  var coordList = new CoordinateList();\n  this.addEndpoints();\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    this$1.addEdgeCoordinates(eiPrev, ei, coordList);\n    eiPrev = ei;\n  }\n  return coordList.toCoordinateArray()\n};\nSegmentNodeList.prototype.addCollapsedNodes = function addCollapsedNodes () {\n    var this$1 = this;\n\n  var collapsedVertexIndexes = new ArrayList();\n  this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n  this.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n  for (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {\n    var vertexIndex = it.next().intValue();\n    this$1.add(this$1._edge.getCoordinate(vertexIndex), vertexIndex);\n  }\n};\nSegmentNodeList.prototype.print = function print (out) {\n  out.println('Intersections:');\n  for (var it = this.iterator(); it.hasNext();) {\n    var ei = it.next();\n    ei.print(out);\n  }\n};\nSegmentNodeList.prototype.findCollapsesFromExistingVertices = function findCollapsesFromExistingVertices (collapsedVertexIndexes) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edge.size() - 2; i++) {\n    var p0 = this$1._edge.getCoordinate(i);\n    // const p1 = this._edge.getCoordinate(i + 1)\n    var p2 = this$1._edge.getCoordinate(i + 2);\n    if (p0.equals2D(p2)) {\n      collapsedVertexIndexes.add(new Integer(i + 1));\n    }\n  }\n};\nSegmentNodeList.prototype.addEdgeCoordinates = function addEdgeCoordinates (ei0, ei1, coordList) {\n    var this$1 = this;\n\n  // let npts = ei1.segmentIndex - ei0.segmentIndex + 2\n  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n  // if (!useIntPt1) {\n  // npts--\n  // }\n  // const ipt = 0\n  coordList.add(new Coordinate(ei0.coord), false);\n  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n    coordList.add(this$1._edge.getCoordinate(i));\n  }\n  if (useIntPt1) {\n    coordList.add(new Coordinate(ei1.coord));\n  }\n};\nSegmentNodeList.prototype.iterator = function iterator () {\n  return this._nodeMap.values().iterator()\n};\nSegmentNodeList.prototype.addSplitEdges = function addSplitEdges (edgeList) {\n    var this$1 = this;\n\n  this.addEndpoints();\n  this.addCollapsedNodes();\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    var newEdge = this$1.createSplitEdge(eiPrev, ei);\n    edgeList.add(newEdge);\n    eiPrev = ei;\n  }\n};\nSegmentNodeList.prototype.findCollapseIndex = function findCollapseIndex (ei0, ei1, collapsedVertexIndex) {\n  if (!ei0.coord.equals2D(ei1.coord)) { return false }\n  var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n  if (!ei1.isInterior()) {\n    numVerticesBetween--;\n  }\n  if (numVerticesBetween === 1) {\n    collapsedVertexIndex[0] = ei0.segmentIndex + 1;\n    return true\n  }\n  return false\n};\nSegmentNodeList.prototype.findCollapsesFromInsertedNodes = function findCollapsesFromInsertedNodes (collapsedVertexIndexes) {\n    var this$1 = this;\n\n  var collapsedVertexIndex = new Array(1).fill(null);\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    var isCollapsed = this$1.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n    if (isCollapsed) { collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0])); }\n    eiPrev = ei;\n  }\n};\nSegmentNodeList.prototype.getEdge = function getEdge () {\n  return this._edge\n};\nSegmentNodeList.prototype.addEndpoints = function addEndpoints () {\n  var maxSegIndex = this._edge.size() - 1;\n  this.add(this._edge.getCoordinate(0), 0);\n  this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);\n};\nSegmentNodeList.prototype.createSplitEdge = function createSplitEdge (ei0, ei1) {\n    var this$1 = this;\n\n  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n  if (!useIntPt1) {\n    npts--;\n  }\n  var pts = new Array(npts).fill(null);\n  var ipt = 0;\n  pts[ipt++] = new Coordinate(ei0.coord);\n  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n    pts[ipt++] = this$1._edge.getCoordinate(i);\n  }\n  if (useIntPt1) { pts[ipt] = new Coordinate(ei1.coord); }\n  return new NodedSegmentString(pts, this._edge.getData())\n};\nSegmentNodeList.prototype.add = function add (intPt, segmentIndex) {\n  var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));\n  var ei = this._nodeMap.get(eiNew);\n  if (ei !== null) {\n    Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');\n    return ei\n  }\n  this._nodeMap.put(eiNew, eiNew);\n  return eiNew\n};\nSegmentNodeList.prototype.checkSplitEdgesCorrectness = function checkSplitEdgesCorrectness (splitEdges) {\n  var edgePts = this._edge.getCoordinates();\n  var split0 = splitEdges.get(0);\n  var pt0 = split0.getCoordinate(0);\n  if (!pt0.equals2D(edgePts[0])) { throw new RuntimeException('bad split edge start point at ' + pt0) }\n  var splitn = splitEdges.get(splitEdges.size() - 1);\n  var splitnPts = splitn.getCoordinates();\n  var ptn = splitnPts[splitnPts.length - 1];\n  if (!ptn.equals2D(edgePts[edgePts.length - 1])) { throw new RuntimeException('bad split edge end point at ' + ptn) }\n};\nSegmentNodeList.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentNodeList.prototype.getClass = function getClass () {\n  return SegmentNodeList\n};\n\n\n\n// class NodeVertexIterator {\n//   constructor () {\n//     this._nodeList = null\n//     this._edge = null\n//     this._nodeIt = null\n//     this._currNode = null\n//     this._nextNode = null\n//     this._currSegIndex = 0\n//     let nodeList = arguments[0]\n//     this._nodeList = nodeList\n//     this._edge = nodeList.getEdge()\n//     this._nodeIt = nodeList.iterator()\n//     this.readNextNode()\n//   }\n//   next () {\n//     if (this._currNode === null) {\n//       this._currNode = this._nextNode\n//       this._currSegIndex = this._currNode.segmentIndex\n//       this.readNextNode()\n//       return this._currNode\n//     }\n//     if (this._nextNode === null) return null\n//     if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n//       this._currNode = this._nextNode\n//       this._currSegIndex = this._currNode.segmentIndex\n//       this.readNextNode()\n//       return this._currNode\n//     }\n//     if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}\n//     return null\n//   }\n//   remove () {\n//     // throw new UnsupportedOperationException(this.getClass().getName())\n//   }\n//   hasNext () {\n//     if (this._nextNode === null) return false\n//     return true\n//   }\n//   readNextNode () {\n//     if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null\n//   }\n//   interfaces_ () {\n//     return [Iterator]\n//   }\n//   getClass () {\n//     return NodeVertexIterator\n//   }\n// }\n\nvar Octant = function Octant () {};\n\nOctant.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOctant.prototype.getClass = function getClass () {\n  return Octant\n};\nOctant.octant = function octant () {\n  if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n    var dx = arguments[0];\n    var dy = arguments[1];\n    if (dx === 0.0 && dy === 0.0) { throw new IllegalArgumentException('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )') }\n    var adx = Math.abs(dx);\n    var ady = Math.abs(dy);\n    if (dx >= 0) {\n      if (dy >= 0) {\n        if (adx >= ady) { return 0; } else { return 1 }\n      } else {\n        if (adx >= ady) { return 7; } else { return 6 }\n      }\n    } else {\n      if (dy >= 0) {\n        if (adx >= ady) { return 3; } else { return 2 }\n      } else {\n        if (adx >= ady) { return 4; } else { return 5 }\n      }\n    }\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    var dx$1 = p1.x - p0.x;\n    var dy$1 = p1.y - p0.y;\n    if (dx$1 === 0.0 && dy$1 === 0.0) { throw new IllegalArgumentException('Cannot compute the octant for two identical points ' + p0) }\n    return Octant.octant(dx$1, dy$1)\n  }\n};\n\nvar SegmentString = function SegmentString () {};\n\nSegmentString.prototype.getCoordinates = function getCoordinates () {};\nSegmentString.prototype.size = function size () {};\nSegmentString.prototype.getCoordinate = function getCoordinate (i) {};\nSegmentString.prototype.isClosed = function isClosed () {};\nSegmentString.prototype.setData = function setData (data) {};\nSegmentString.prototype.getData = function getData () {};\nSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentString.prototype.getClass = function getClass () {\n  return SegmentString\n};\n\nvar NodableSegmentString = function NodableSegmentString () {};\n\nNodableSegmentString.prototype.addIntersection = function addIntersection (intPt, segmentIndex) {};\nNodableSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentString]\n};\nNodableSegmentString.prototype.getClass = function getClass () {\n  return NodableSegmentString\n};\n\nvar NodedSegmentString = function NodedSegmentString () {\n  this._nodeList = new SegmentNodeList(this);\n  this._pts = null;\n  this._data = null;\n  var pts = arguments[0];\n  var data = arguments[1];\n  this._pts = pts;\n  this._data = data;\n};\nNodedSegmentString.prototype.getCoordinates = function getCoordinates () {\n  return this._pts\n};\nNodedSegmentString.prototype.size = function size () {\n  return this._pts.length\n};\nNodedSegmentString.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pts[i]\n};\nNodedSegmentString.prototype.isClosed = function isClosed () {\n  return this._pts[0].equals(this._pts[this._pts.length - 1])\n};\nNodedSegmentString.prototype.getSegmentOctant = function getSegmentOctant (index) {\n  if (index === this._pts.length - 1) { return -1 }\n  return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1))\n};\nNodedSegmentString.prototype.setData = function setData (data) {\n  this._data = data;\n};\nNodedSegmentString.prototype.safeOctant = function safeOctant (p0, p1) {\n  if (p0.equals2D(p1)) { return 0 }\n  return Octant.octant(p0, p1)\n};\nNodedSegmentString.prototype.getData = function getData () {\n  return this._data\n};\nNodedSegmentString.prototype.addIntersection = function addIntersection () {\n  if (arguments.length === 2) {\n    var intPt$1 = arguments[0];\n    var segmentIndex = arguments[1];\n    this.addIntersectionNode(intPt$1, segmentIndex);\n  } else if (arguments.length === 4) {\n    var li = arguments[0];\n    var segmentIndex$1 = arguments[1];\n    // const geomIndex = arguments[2]\n    var intIndex = arguments[3];\n    var intPt = new Coordinate(li.getIntersection(intIndex));\n    this.addIntersection(intPt, segmentIndex$1);\n  }\n};\nNodedSegmentString.prototype.toString = function toString () {\n  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))\n};\nNodedSegmentString.prototype.getNodeList = function getNodeList () {\n  return this._nodeList\n};\nNodedSegmentString.prototype.addIntersectionNode = function addIntersectionNode (intPt, segmentIndex) {\n  var normalizedSegmentIndex = segmentIndex;\n  var nextSegIndex = normalizedSegmentIndex + 1;\n  if (nextSegIndex < this._pts.length) {\n    var nextPt = this._pts[nextSegIndex];\n    if (intPt.equals2D(nextPt)) {\n      normalizedSegmentIndex = nextSegIndex;\n    }\n  }\n  var ei = this._nodeList.add(intPt, normalizedSegmentIndex);\n  return ei\n};\nNodedSegmentString.prototype.addIntersections = function addIntersections (li, segmentIndex, geomIndex) {\n    var this$1 = this;\n\n  for (var i = 0; i < li.getIntersectionNum(); i++) {\n    this$1.addIntersection(li, segmentIndex, geomIndex, i);\n  }\n};\nNodedSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return [NodableSegmentString]\n};\nNodedSegmentString.prototype.getClass = function getClass () {\n  return NodedSegmentString\n};\nNodedSegmentString.getNodedSubstrings = function getNodedSubstrings () {\n  if (arguments.length === 1) {\n    var segStrings = arguments[0];\n    var resultEdgelist = new ArrayList();\n    NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n    return resultEdgelist\n  } else if (arguments.length === 2) {\n    var segStrings$1 = arguments[0];\n    var resultEdgelist$1 = arguments[1];\n    for (var i = segStrings$1.iterator(); i.hasNext();) {\n      var ss = i.next();\n      ss.getNodeList().addSplitEdges(resultEdgelist$1);\n    }\n  }\n};\n\nvar LineSegment = function LineSegment () {\n  this.p0 = null;\n  this.p1 = null;\n  if (arguments.length === 0) {\n    this.p0 = new Coordinate();\n    this.p1 = new Coordinate();\n  } else if (arguments.length === 1) {\n    var ls = arguments[0];\n    this.p0 = new Coordinate(ls.p0);\n    this.p1 = new Coordinate(ls.p1);\n  } else if (arguments.length === 2) {\n    this.p0 = arguments[0];\n    this.p1 = arguments[1];\n  } else if (arguments.length === 4) {\n    var x0 = arguments[0];\n    var y0 = arguments[1];\n    var x1 = arguments[2];\n    var y1 = arguments[3];\n    this.p0 = new Coordinate(x0, y0);\n    this.p1 = new Coordinate(x1, y1);\n  }\n};\n\nvar staticAccessors$24 = { serialVersionUID: { configurable: true } };\nLineSegment.prototype.minX = function minX () {\n  return Math.min(this.p0.x, this.p1.x)\n};\nLineSegment.prototype.orientationIndex = function orientationIndex () {\n  if (arguments[0] instanceof LineSegment) {\n    var seg = arguments[0];\n    var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);\n    var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);\n    if (orient0 >= 0 && orient1 >= 0) { return Math.max(orient0, orient1) }\n    if (orient0 <= 0 && orient1 <= 0) { return Math.max(orient0, orient1) }\n    return 0\n  } else if (arguments[0] instanceof Coordinate) {\n    var p = arguments[0];\n    return CGAlgorithms.orientationIndex(this.p0, this.p1, p)\n  }\n};\nLineSegment.prototype.toGeometry = function toGeometry (geomFactory) {\n  return geomFactory.createLineString([this.p0, this.p1])\n};\nLineSegment.prototype.isVertical = function isVertical () {\n  return this.p0.x === this.p1.x\n};\nLineSegment.prototype.equals = function equals (o) {\n  if (!(o instanceof LineSegment)) {\n    return false\n  }\n  var other = o;\n  return this.p0.equals(other.p0) && this.p1.equals(other.p1)\n};\nLineSegment.prototype.intersection = function intersection (line) {\n  var li = new RobustLineIntersector();\n  li.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n  if (li.hasIntersection()) { return li.getIntersection(0) }\n  return null\n};\nLineSegment.prototype.project = function project () {\n  if (arguments[0] instanceof Coordinate) {\n    var p = arguments[0];\n    if (p.equals(this.p0) || p.equals(this.p1)) { return new Coordinate(p) }\n    var r = this.projectionFactor(p);\n    var coord = new Coordinate();\n    coord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n    coord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n    return coord\n  } else if (arguments[0] instanceof LineSegment) {\n    var seg = arguments[0];\n    var pf0 = this.projectionFactor(seg.p0);\n    var pf1 = this.projectionFactor(seg.p1);\n    if (pf0 >= 1.0 && pf1 >= 1.0) { return null }\n    if (pf0 <= 0.0 && pf1 <= 0.0) { return null }\n    var newp0 = this.project(seg.p0);\n    if (pf0 < 0.0) { newp0 = this.p0; }\n    if (pf0 > 1.0) { newp0 = this.p1; }\n    var newp1 = this.project(seg.p1);\n    if (pf1 < 0.0) { newp1 = this.p0; }\n    if (pf1 > 1.0) { newp1 = this.p1; }\n    return new LineSegment(newp0, newp1)\n  }\n};\nLineSegment.prototype.normalize = function normalize () {\n  if (this.p1.compareTo(this.p0) < 0) { this.reverse(); }\n};\nLineSegment.prototype.angle = function angle () {\n  return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)\n};\nLineSegment.prototype.getCoordinate = function getCoordinate (i) {\n  if (i === 0) { return this.p0 }\n  return this.p1\n};\nLineSegment.prototype.distancePerpendicular = function distancePerpendicular (p) {\n  return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1)\n};\nLineSegment.prototype.minY = function minY () {\n  return Math.min(this.p0.y, this.p1.y)\n};\nLineSegment.prototype.midPoint = function midPoint () {\n  return LineSegment.midPoint(this.p0, this.p1)\n};\nLineSegment.prototype.projectionFactor = function projectionFactor (p) {\n  if (p.equals(this.p0)) { return 0.0 }\n  if (p.equals(this.p1)) { return 1.0 }\n  var dx = this.p1.x - this.p0.x;\n  var dy = this.p1.y - this.p0.y;\n  var len = dx * dx + dy * dy;\n  if (len <= 0.0) { return Double.NaN }\n  var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n  return r\n};\nLineSegment.prototype.closestPoints = function closestPoints (line) {\n  var intPt = this.intersection(line);\n  if (intPt !== null) {\n    return [intPt, intPt]\n  }\n  var closestPt = new Array(2).fill(null);\n  var minDistance = Double.MAX_VALUE;\n  var dist = null;\n  var close00 = this.closestPoint(line.p0);\n  minDistance = close00.distance(line.p0);\n  closestPt[0] = close00;\n  closestPt[1] = line.p0;\n  var close01 = this.closestPoint(line.p1);\n  dist = close01.distance(line.p1);\n  if (dist < minDistance) {\n    minDistance = dist;\n    closestPt[0] = close01;\n    closestPt[1] = line.p1;\n  }\n  var close10 = line.closestPoint(this.p0);\n  dist = close10.distance(this.p0);\n  if (dist < minDistance) {\n    minDistance = dist;\n    closestPt[0] = this.p0;\n    closestPt[1] = close10;\n  }\n  var close11 = line.closestPoint(this.p1);\n  dist = close11.distance(this.p1);\n  if (dist < minDistance) {\n    minDistance = dist;\n    closestPt[0] = this.p1;\n    closestPt[1] = close11;\n  }\n  return closestPt\n};\nLineSegment.prototype.closestPoint = function closestPoint (p) {\n  var factor = this.projectionFactor(p);\n  if (factor > 0 && factor < 1) {\n    return this.project(p)\n  }\n  var dist0 = this.p0.distance(p);\n  var dist1 = this.p1.distance(p);\n  if (dist0 < dist1) { return this.p0 }\n  return this.p1\n};\nLineSegment.prototype.maxX = function maxX () {\n  return Math.max(this.p0.x, this.p1.x)\n};\nLineSegment.prototype.getLength = function getLength () {\n  return this.p0.distance(this.p1)\n};\nLineSegment.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  var comp0 = this.p0.compareTo(other.p0);\n  if (comp0 !== 0) { return comp0 }\n  return this.p1.compareTo(other.p1)\n};\nLineSegment.prototype.reverse = function reverse () {\n  var temp = this.p0;\n  this.p0 = this.p1;\n  this.p1 = temp;\n};\nLineSegment.prototype.equalsTopo = function equalsTopo (other) {\n  return this.p0.equals(other.p0) &&\n        (this.p1.equals(other.p1) || this.p0.equals(other.p1)) &&\n         this.p1.equals(other.p0)\n};\nLineSegment.prototype.lineIntersection = function lineIntersection (line) {\n  try {\n    var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n    return intPt\n  } catch (ex) {\n    if (ex instanceof NotRepresentableException) {} else { throw ex }\n  } finally {}\n  return null\n};\nLineSegment.prototype.maxY = function maxY () {\n  return Math.max(this.p0.y, this.p1.y)\n};\nLineSegment.prototype.pointAlongOffset = function pointAlongOffset (segmentLengthFraction, offsetDistance) {\n  var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n  var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n  var dx = this.p1.x - this.p0.x;\n  var dy = this.p1.y - this.p0.y;\n  var len = Math.sqrt(dx * dx + dy * dy);\n  var ux = 0.0;\n  var uy = 0.0;\n  if (offsetDistance !== 0.0) {\n    if (len <= 0.0) { throw new Error('Cannot compute offset from zero-length line segment') }\n    ux = offsetDistance * dx / len;\n    uy = offsetDistance * dy / len;\n  }\n  var offsetx = segx - uy;\n  var offsety = segy + ux;\n  var coord = new Coordinate(offsetx, offsety);\n  return coord\n};\nLineSegment.prototype.setCoordinates = function setCoordinates () {\n  if (arguments.length === 1) {\n    var ls = arguments[0];\n    this.setCoordinates(ls.p0, ls.p1);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    this.p0.x = p0.x;\n    this.p0.y = p0.y;\n    this.p1.x = p1.x;\n    this.p1.y = p1.y;\n  }\n};\nLineSegment.prototype.segmentFraction = function segmentFraction (inputPt) {\n  var segFrac = this.projectionFactor(inputPt);\n  if (segFrac < 0.0) { segFrac = 0.0; } else if (segFrac > 1.0 || Double.isNaN(segFrac)) { segFrac = 1.0; }\n  return segFrac\n};\nLineSegment.prototype.toString = function toString () {\n  return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')'\n};\nLineSegment.prototype.isHorizontal = function isHorizontal () {\n  return this.p0.y === this.p1.y\n};\nLineSegment.prototype.distance = function distance () {\n  if (arguments[0] instanceof LineSegment) {\n    var ls = arguments[0];\n    return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1)\n  } else if (arguments[0] instanceof Coordinate) {\n    var p = arguments[0];\n    return CGAlgorithms.distancePointLine(p, this.p0, this.p1)\n  }\n};\nLineSegment.prototype.pointAlong = function pointAlong (segmentLengthFraction) {\n  var coord = new Coordinate();\n  coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n  coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n  return coord\n};\nLineSegment.prototype.hashCode = function hashCode () {\n  var bits0 = Double.doubleToLongBits(this.p0.x);\n  bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;\n  var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n  var bits1 = Double.doubleToLongBits(this.p1.x);\n  bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;\n  var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n  return hash0 ^ hash1\n};\nLineSegment.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable, Serializable]\n};\nLineSegment.prototype.getClass = function getClass () {\n  return LineSegment\n};\nLineSegment.midPoint = function midPoint (p0, p1) {\n  return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2)\n};\nstaticAccessors$24.serialVersionUID.get = function () { return 3252005833466256227 };\n\nObject.defineProperties( LineSegment, staticAccessors$24 );\n\nvar MonotoneChainOverlapAction = function MonotoneChainOverlapAction () {\n  this.tempEnv1 = new Envelope();\n  this.tempEnv2 = new Envelope();\n  this._overlapSeg1 = new LineSegment();\n  this._overlapSeg2 = new LineSegment();\n};\nMonotoneChainOverlapAction.prototype.overlap = function overlap () {\n  if (arguments.length === 2) {\n    // const seg1 = arguments[0]\n    // const seg2 = arguments[1]\n  } else if (arguments.length === 4) {\n    var mc1 = arguments[0];\n    var start1 = arguments[1];\n    var mc2 = arguments[2];\n    var start2 = arguments[3];\n    mc1.getLineSegment(start1, this._overlapSeg1);\n    mc2.getLineSegment(start2, this._overlapSeg2);\n    this.overlap(this._overlapSeg1, this._overlapSeg2);\n  }\n};\nMonotoneChainOverlapAction.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainOverlapAction.prototype.getClass = function getClass () {\n  return MonotoneChainOverlapAction\n};\n\nvar MonotoneChain = function MonotoneChain () {\n  this._pts = null;\n  this._start = null;\n  this._end = null;\n  this._env = null;\n  this._context = null;\n  this._id = null;\n  var pts = arguments[0];\n  var start = arguments[1];\n  var end = arguments[2];\n  var context = arguments[3];\n  this._pts = pts;\n  this._start = start;\n  this._end = end;\n  this._context = context;\n};\nMonotoneChain.prototype.getLineSegment = function getLineSegment (index, ls) {\n  ls.p0 = this._pts[index];\n  ls.p1 = this._pts[index + 1];\n};\nMonotoneChain.prototype.computeSelect = function computeSelect (searchEnv, start0, end0, mcs) {\n  var p0 = this._pts[start0];\n  var p1 = this._pts[end0];\n  mcs.tempEnv1.init(p0, p1);\n  if (end0 - start0 === 1) {\n    mcs.select(this, start0);\n    return null\n  }\n  if (!searchEnv.intersects(mcs.tempEnv1)) { return null }\n  var mid = Math.trunc((start0 + end0) / 2);\n  if (start0 < mid) {\n    this.computeSelect(searchEnv, start0, mid, mcs);\n  }\n  if (mid < end0) {\n    this.computeSelect(searchEnv, mid, end0, mcs);\n  }\n};\nMonotoneChain.prototype.getCoordinates = function getCoordinates () {\n    var this$1 = this;\n\n  var coord = new Array(this._end - this._start + 1).fill(null);\n  var index = 0;\n  for (var i = this._start; i <= this._end; i++) {\n    coord[index++] = this$1._pts[i];\n  }\n  return coord\n};\nMonotoneChain.prototype.computeOverlaps = function computeOverlaps (mc, mco) {\n  this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);\n};\nMonotoneChain.prototype.setId = function setId (id) {\n  this._id = id;\n};\nMonotoneChain.prototype.select = function select (searchEnv, mcs) {\n  this.computeSelect(searchEnv, this._start, this._end, mcs);\n};\nMonotoneChain.prototype.getEnvelope = function getEnvelope () {\n  if (this._env === null) {\n    var p0 = this._pts[this._start];\n    var p1 = this._pts[this._end];\n    this._env = new Envelope(p0, p1);\n  }\n  return this._env\n};\nMonotoneChain.prototype.getEndIndex = function getEndIndex () {\n  return this._end\n};\nMonotoneChain.prototype.getStartIndex = function getStartIndex () {\n  return this._start\n};\nMonotoneChain.prototype.getContext = function getContext () {\n  return this._context\n};\nMonotoneChain.prototype.getId = function getId () {\n  return this._id\n};\nMonotoneChain.prototype.computeOverlapsInternal = function computeOverlapsInternal (start0, end0, mc, start1, end1, mco) {\n  var p00 = this._pts[start0];\n  var p01 = this._pts[end0];\n  var p10 = mc._pts[start1];\n  var p11 = mc._pts[end1];\n  if (end0 - start0 === 1 && end1 - start1 === 1) {\n    mco.overlap(this, start0, mc, start1);\n    return null\n  }\n  mco.tempEnv1.init(p00, p01);\n  mco.tempEnv2.init(p10, p11);\n  if (!mco.tempEnv1.intersects(mco.tempEnv2)) { return null }\n  var mid0 = Math.trunc((start0 + end0) / 2);\n  var mid1 = Math.trunc((start1 + end1) / 2);\n  if (start0 < mid0) {\n    if (start1 < mid1) { this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco); }\n    if (mid1 < end1) { this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco); }\n  }\n  if (mid0 < end0) {\n    if (start1 < mid1) { this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco); }\n    if (mid1 < end1) { this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco); }\n  }\n};\nMonotoneChain.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChain.prototype.getClass = function getClass () {\n  return MonotoneChain\n};\n\nvar MonotoneChainBuilder = function MonotoneChainBuilder () {};\n\nMonotoneChainBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainBuilder.prototype.getClass = function getClass () {\n  return MonotoneChainBuilder\n};\nMonotoneChainBuilder.getChainStartIndices = function getChainStartIndices (pts) {\n  var start = 0;\n  var startIndexList = new ArrayList();\n  startIndexList.add(new Integer(start));\n  do {\n    var last = MonotoneChainBuilder.findChainEnd(pts, start);\n    startIndexList.add(new Integer(last));\n    start = last;\n  } while (start < pts.length - 1)\n  var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);\n  return startIndex\n};\nMonotoneChainBuilder.findChainEnd = function findChainEnd (pts, start) {\n  var safeStart = start;\n  while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {\n    safeStart++;\n  }\n  if (safeStart >= pts.length - 1) {\n    return pts.length - 1\n  }\n  var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n  var last = start + 1;\n  while (last < pts.length) {\n    if (!pts[last - 1].equals2D(pts[last])) {\n      var quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n      if (quad !== chainQuad) { break }\n    }\n    last++;\n  }\n  return last - 1\n};\nMonotoneChainBuilder.getChains = function getChains () {\n  if (arguments.length === 1) {\n    var pts = arguments[0];\n    return MonotoneChainBuilder.getChains(pts, null)\n  } else if (arguments.length === 2) {\n    var pts$1 = arguments[0];\n    var context = arguments[1];\n    var mcList = new ArrayList();\n    var startIndex = MonotoneChainBuilder.getChainStartIndices(pts$1);\n    for (var i = 0; i < startIndex.length - 1; i++) {\n      var mc = new MonotoneChain(pts$1, startIndex[i], startIndex[i + 1], context);\n      mcList.add(mc);\n    }\n    return mcList\n  }\n};\nMonotoneChainBuilder.toIntArray = function toIntArray (list) {\n  var array = new Array(list.size()).fill(null);\n  for (var i = 0; i < array.length; i++) {\n    array[i] = list.get(i).intValue();\n  }\n  return array\n};\n\nvar Noder = function Noder () {};\n\nNoder.prototype.computeNodes = function computeNodes (segStrings) {};\nNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {};\nNoder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNoder.prototype.getClass = function getClass () {\n  return Noder\n};\n\nvar SinglePassNoder = function SinglePassNoder () {\n  this._segInt = null;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var segInt = arguments[0];\n    this.setSegmentIntersector(segInt);\n  }\n};\nSinglePassNoder.prototype.setSegmentIntersector = function setSegmentIntersector (segInt) {\n  this._segInt = segInt;\n};\nSinglePassNoder.prototype.interfaces_ = function interfaces_ () {\n  return [Noder]\n};\nSinglePassNoder.prototype.getClass = function getClass () {\n  return SinglePassNoder\n};\n\nvar MCIndexNoder = (function (SinglePassNoder$$1) {\n  function MCIndexNoder (si) {\n    if (si) { SinglePassNoder$$1.call(this, si); }\n    else { SinglePassNoder$$1.call(this); }\n    this._monoChains = new ArrayList();\n    this._index = new STRtree();\n    this._idCounter = 0;\n    this._nodedSegStrings = null;\n    this._nOverlaps = 0;\n  }\n\n  if ( SinglePassNoder$$1 ) MCIndexNoder.__proto__ = SinglePassNoder$$1;\n  MCIndexNoder.prototype = Object.create( SinglePassNoder$$1 && SinglePassNoder$$1.prototype );\n  MCIndexNoder.prototype.constructor = MCIndexNoder;\n\n  var staticAccessors = { SegmentOverlapAction: { configurable: true } };\n  MCIndexNoder.prototype.getMonotoneChains = function getMonotoneChains () {\n    return this._monoChains\n  };\n  MCIndexNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {\n    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)\n  };\n  MCIndexNoder.prototype.getIndex = function getIndex () {\n    return this._index\n  };\n  MCIndexNoder.prototype.add = function add (segStr) {\n    var this$1 = this;\n\n    var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n    for (var i = segChains.iterator(); i.hasNext();) {\n      var mc = i.next();\n      mc.setId(this$1._idCounter++);\n      this$1._index.insert(mc.getEnvelope(), mc);\n      this$1._monoChains.add(mc);\n    }\n  };\n  MCIndexNoder.prototype.computeNodes = function computeNodes (inputSegStrings) {\n    var this$1 = this;\n\n    this._nodedSegStrings = inputSegStrings;\n    for (var i = inputSegStrings.iterator(); i.hasNext();) {\n      this$1.add(i.next());\n    }\n    this.intersectChains();\n  };\n  MCIndexNoder.prototype.intersectChains = function intersectChains () {\n    var this$1 = this;\n\n    var overlapAction = new SegmentOverlapAction(this._segInt);\n    for (var i = this._monoChains.iterator(); i.hasNext();) {\n      var queryChain = i.next();\n      var overlapChains = this$1._index.query(queryChain.getEnvelope());\n      for (var j = overlapChains.iterator(); j.hasNext();) {\n        var testChain = j.next();\n        if (testChain.getId() > queryChain.getId()) {\n          queryChain.computeOverlaps(testChain, overlapAction);\n          this$1._nOverlaps++;\n        }\n        if (this$1._segInt.isDone()) { return null }\n      }\n    }\n  };\n  MCIndexNoder.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  MCIndexNoder.prototype.getClass = function getClass () {\n    return MCIndexNoder\n  };\n  staticAccessors.SegmentOverlapAction.get = function () { return SegmentOverlapAction };\n\n  Object.defineProperties( MCIndexNoder, staticAccessors );\n\n  return MCIndexNoder;\n}(SinglePassNoder));\n\nvar SegmentOverlapAction = (function (MonotoneChainOverlapAction$$1) {\n  function SegmentOverlapAction () {\n    MonotoneChainOverlapAction$$1.call(this);\n    this._si = null;\n    var si = arguments[0];\n    this._si = si;\n  }\n\n  if ( MonotoneChainOverlapAction$$1 ) SegmentOverlapAction.__proto__ = MonotoneChainOverlapAction$$1;\n  SegmentOverlapAction.prototype = Object.create( MonotoneChainOverlapAction$$1 && MonotoneChainOverlapAction$$1.prototype );\n  SegmentOverlapAction.prototype.constructor = SegmentOverlapAction;\n  SegmentOverlapAction.prototype.overlap = function overlap () {\n    if (arguments.length === 4) {\n      var mc1 = arguments[0];\n      var start1 = arguments[1];\n      var mc2 = arguments[2];\n      var start2 = arguments[3];\n      var ss1 = mc1.getContext();\n      var ss2 = mc2.getContext();\n      this._si.processIntersections(ss1, start1, ss2, start2);\n    } else { return MonotoneChainOverlapAction$$1.prototype.overlap.apply(this, arguments) }\n  };\n  SegmentOverlapAction.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  SegmentOverlapAction.prototype.getClass = function getClass () {\n    return SegmentOverlapAction\n  };\n\n  return SegmentOverlapAction;\n}(MonotoneChainOverlapAction));\n\nvar BufferParameters = function BufferParameters () {\n  this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n  this._endCapStyle = BufferParameters.CAP_ROUND;\n  this._joinStyle = BufferParameters.JOIN_ROUND;\n  this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n  this._isSingleSided = false;\n  this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var quadrantSegments = arguments[0];\n    this.setQuadrantSegments(quadrantSegments);\n  } else if (arguments.length === 2) {\n    var quadrantSegments$1 = arguments[0];\n    var endCapStyle = arguments[1];\n    this.setQuadrantSegments(quadrantSegments$1);\n    this.setEndCapStyle(endCapStyle);\n  } else if (arguments.length === 4) {\n    var quadrantSegments$2 = arguments[0];\n    var endCapStyle$1 = arguments[1];\n    var joinStyle = arguments[2];\n    var mitreLimit = arguments[3];\n    this.setQuadrantSegments(quadrantSegments$2);\n    this.setEndCapStyle(endCapStyle$1);\n    this.setJoinStyle(joinStyle);\n    this.setMitreLimit(mitreLimit);\n  }\n};\n\nvar staticAccessors$25 = { CAP_ROUND: { configurable: true },CAP_FLAT: { configurable: true },CAP_SQUARE: { configurable: true },JOIN_ROUND: { configurable: true },JOIN_MITRE: { configurable: true },JOIN_BEVEL: { configurable: true },DEFAULT_QUADRANT_SEGMENTS: { configurable: true },DEFAULT_MITRE_LIMIT: { configurable: true },DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };\nBufferParameters.prototype.getEndCapStyle = function getEndCapStyle () {\n  return this._endCapStyle\n};\nBufferParameters.prototype.isSingleSided = function isSingleSided () {\n  return this._isSingleSided\n};\nBufferParameters.prototype.setQuadrantSegments = function setQuadrantSegments (quadSegs) {\n  this._quadrantSegments = quadSegs;\n  if (this._quadrantSegments === 0) { this._joinStyle = BufferParameters.JOIN_BEVEL; }\n  if (this._quadrantSegments < 0) {\n    this._joinStyle = BufferParameters.JOIN_MITRE;\n    this._mitreLimit = Math.abs(this._quadrantSegments);\n  }\n  if (quadSegs <= 0) {\n    this._quadrantSegments = 1;\n  }\n  if (this._joinStyle !== BufferParameters.JOIN_ROUND) {\n    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n  }\n};\nBufferParameters.prototype.getJoinStyle = function getJoinStyle () {\n  return this._joinStyle\n};\nBufferParameters.prototype.setJoinStyle = function setJoinStyle (joinStyle) {\n  this._joinStyle = joinStyle;\n};\nBufferParameters.prototype.setSimplifyFactor = function setSimplifyFactor (simplifyFactor) {\n  this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n};\nBufferParameters.prototype.getSimplifyFactor = function getSimplifyFactor () {\n  return this._simplifyFactor\n};\nBufferParameters.prototype.getQuadrantSegments = function getQuadrantSegments () {\n  return this._quadrantSegments\n};\nBufferParameters.prototype.setEndCapStyle = function setEndCapStyle (endCapStyle) {\n  this._endCapStyle = endCapStyle;\n};\nBufferParameters.prototype.getMitreLimit = function getMitreLimit () {\n  return this._mitreLimit\n};\nBufferParameters.prototype.setMitreLimit = function setMitreLimit (mitreLimit) {\n  this._mitreLimit = mitreLimit;\n};\nBufferParameters.prototype.setSingleSided = function setSingleSided (isSingleSided) {\n  this._isSingleSided = isSingleSided;\n};\nBufferParameters.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferParameters.prototype.getClass = function getClass () {\n  return BufferParameters\n};\nBufferParameters.bufferDistanceError = function bufferDistanceError (quadSegs) {\n  var alpha = Math.PI / 2.0 / quadSegs;\n  return 1 - Math.cos(alpha / 2.0)\n};\nstaticAccessors$25.CAP_ROUND.get = function () { return 1 };\nstaticAccessors$25.CAP_FLAT.get = function () { return 2 };\nstaticAccessors$25.CAP_SQUARE.get = function () { return 3 };\nstaticAccessors$25.JOIN_ROUND.get = function () { return 1 };\nstaticAccessors$25.JOIN_MITRE.get = function () { return 2 };\nstaticAccessors$25.JOIN_BEVEL.get = function () { return 3 };\nstaticAccessors$25.DEFAULT_QUADRANT_SEGMENTS.get = function () { return 8 };\nstaticAccessors$25.DEFAULT_MITRE_LIMIT.get = function () { return 5.0 };\nstaticAccessors$25.DEFAULT_SIMPLIFY_FACTOR.get = function () { return 0.01 };\n\nObject.defineProperties( BufferParameters, staticAccessors$25 );\n\nvar BufferInputLineSimplifier = function BufferInputLineSimplifier (inputLine) {\n  this._distanceTol = null;\n  this._isDeleted = null;\n  this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;\n  this._inputLine = inputLine || null;\n};\n\nvar staticAccessors$26 = { INIT: { configurable: true },DELETE: { configurable: true },KEEP: { configurable: true },NUM_PTS_TO_CHECK: { configurable: true } };\nBufferInputLineSimplifier.prototype.isDeletable = function isDeletable (i0, i1, i2, distanceTol) {\n  var p0 = this._inputLine[i0];\n  var p1 = this._inputLine[i1];\n  var p2 = this._inputLine[i2];\n  if (!this.isConcave(p0, p1, p2)) { return false }\n  if (!this.isShallow(p0, p1, p2, distanceTol)) { return false }\n  return this.isShallowSampled(p0, p1, i0, i2, distanceTol)\n};\nBufferInputLineSimplifier.prototype.deleteShallowConcavities = function deleteShallowConcavities () {\n    var this$1 = this;\n\n  var index = 1;\n  // const maxIndex = this._inputLine.length - 1\n  var midIndex = this.findNextNonDeletedIndex(index);\n  var lastIndex = this.findNextNonDeletedIndex(midIndex);\n  var isChanged = false;\n  while (lastIndex < this._inputLine.length) {\n    var isMiddleVertexDeleted = false;\n    if (this$1.isDeletable(index, midIndex, lastIndex, this$1._distanceTol)) {\n      this$1._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n      isMiddleVertexDeleted = true;\n      isChanged = true;\n    }\n    if (isMiddleVertexDeleted) { index = lastIndex; } else { index = midIndex; }\n    midIndex = this$1.findNextNonDeletedIndex(index);\n    lastIndex = this$1.findNextNonDeletedIndex(midIndex);\n  }\n  return isChanged\n};\nBufferInputLineSimplifier.prototype.isShallowConcavity = function isShallowConcavity (p0, p1, p2, distanceTol) {\n  var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n  var isAngleToSimplify = orientation === this._angleOrientation;\n  if (!isAngleToSimplify) { return false }\n  var dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n  return dist < distanceTol\n};\nBufferInputLineSimplifier.prototype.isShallowSampled = function isShallowSampled (p0, p2, i0, i2, distanceTol) {\n    var this$1 = this;\n\n  var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n  if (inc <= 0) { inc = 1; }\n  for (var i = i0; i < i2; i += inc) {\n    if (!this$1.isShallow(p0, p2, this$1._inputLine[i], distanceTol)) { return false }\n  }\n  return true\n};\nBufferInputLineSimplifier.prototype.isConcave = function isConcave (p0, p1, p2) {\n  var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n  var isConcave = orientation === this._angleOrientation;\n  return isConcave\n};\nBufferInputLineSimplifier.prototype.simplify = function simplify (distanceTol) {\n    var this$1 = this;\n\n  this._distanceTol = Math.abs(distanceTol);\n  if (distanceTol < 0) { this._angleOrientation = CGAlgorithms.CLOCKWISE; }\n  this._isDeleted = new Array(this._inputLine.length).fill(null);\n  var isChanged = false;\n  do {\n    isChanged = this$1.deleteShallowConcavities();\n  } while (isChanged)\n  return this.collapseLine()\n};\nBufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function findNextNonDeletedIndex (index) {\n  var next = index + 1;\n  while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) { next++; }\n  return next\n};\nBufferInputLineSimplifier.prototype.isShallow = function isShallow (p0, p1, p2, distanceTol) {\n  var dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n  return dist < distanceTol\n};\nBufferInputLineSimplifier.prototype.collapseLine = function collapseLine () {\n    var this$1 = this;\n\n  var coordList = new CoordinateList();\n  for (var i = 0; i < this._inputLine.length; i++) {\n    if (this$1._isDeleted[i] !== BufferInputLineSimplifier.DELETE) { coordList.add(this$1._inputLine[i]); }\n  }\n  return coordList.toCoordinateArray()\n};\nBufferInputLineSimplifier.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferInputLineSimplifier.prototype.getClass = function getClass () {\n  return BufferInputLineSimplifier\n};\nBufferInputLineSimplifier.simplify = function simplify (inputLine, distanceTol) {\n  var simp = new BufferInputLineSimplifier(inputLine);\n  return simp.simplify(distanceTol)\n};\nstaticAccessors$26.INIT.get = function () { return 0 };\nstaticAccessors$26.DELETE.get = function () { return 1 };\nstaticAccessors$26.KEEP.get = function () { return 1 };\nstaticAccessors$26.NUM_PTS_TO_CHECK.get = function () { return 10 };\n\nObject.defineProperties( BufferInputLineSimplifier, staticAccessors$26 );\n\nvar OffsetSegmentString = function OffsetSegmentString () {\n  this._ptList = null;\n  this._precisionModel = null;\n  this._minimimVertexDistance = 0.0;\n  this._ptList = new ArrayList();\n};\n\nvar staticAccessors$28 = { COORDINATE_ARRAY_TYPE: { configurable: true } };\nOffsetSegmentString.prototype.getCoordinates = function getCoordinates () {\n  var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n  return coord\n};\nOffsetSegmentString.prototype.setPrecisionModel = function setPrecisionModel (precisionModel) {\n  this._precisionModel = precisionModel;\n};\nOffsetSegmentString.prototype.addPt = function addPt (pt) {\n  var bufPt = new Coordinate(pt);\n  this._precisionModel.makePrecise(bufPt);\n  if (this.isRedundant(bufPt)) { return null }\n  this._ptList.add(bufPt);\n};\nOffsetSegmentString.prototype.revere = function revere () {};\nOffsetSegmentString.prototype.addPts = function addPts (pt, isForward) {\n    var this$1 = this;\n\n  if (isForward) {\n    for (var i = 0; i < pt.length; i++) {\n      this$1.addPt(pt[i]);\n    }\n  } else {\n    for (var i$1 = pt.length - 1; i$1 >= 0; i$1--) {\n      this$1.addPt(pt[i$1]);\n    }\n  }\n};\nOffsetSegmentString.prototype.isRedundant = function isRedundant (pt) {\n  if (this._ptList.size() < 1) { return false }\n  var lastPt = this._ptList.get(this._ptList.size() - 1);\n  var ptDist = pt.distance(lastPt);\n  if (ptDist < this._minimimVertexDistance) { return true }\n  return false\n};\nOffsetSegmentString.prototype.toString = function toString () {\n  var fact = new GeometryFactory();\n  var line = fact.createLineString(this.getCoordinates());\n  return line.toString()\n};\nOffsetSegmentString.prototype.closeRing = function closeRing () {\n  if (this._ptList.size() < 1) { return null }\n  var startPt = new Coordinate(this._ptList.get(0));\n  var lastPt = this._ptList.get(this._ptList.size() - 1);\n  // const last2Pt = null\n  // if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2)\n  if (startPt.equals(lastPt)) { return null }\n  this._ptList.add(startPt);\n};\nOffsetSegmentString.prototype.setMinimumVertexDistance = function setMinimumVertexDistance (minimimVertexDistance) {\n  this._minimimVertexDistance = minimimVertexDistance;\n};\nOffsetSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetSegmentString.prototype.getClass = function getClass () {\n  return OffsetSegmentString\n};\nstaticAccessors$28.COORDINATE_ARRAY_TYPE.get = function () { return new Array(0).fill(null) };\n\nObject.defineProperties( OffsetSegmentString, staticAccessors$28 );\n\nvar Angle = function Angle () {};\n\nvar staticAccessors$29 = { PI_TIMES_2: { configurable: true },PI_OVER_2: { configurable: true },PI_OVER_4: { configurable: true },COUNTERCLOCKWISE: { configurable: true },CLOCKWISE: { configurable: true },NONE: { configurable: true } };\n\nAngle.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nAngle.prototype.getClass = function getClass () {\n  return Angle\n};\nAngle.toDegrees = function toDegrees (radians) {\n  return radians * 180 / Math.PI\n};\nAngle.normalize = function normalize (angle) {\n  while (angle > Math.PI) { angle -= Angle.PI_TIMES_2; }\n  while (angle <= -Math.PI) { angle += Angle.PI_TIMES_2; }\n  return angle\n};\nAngle.angle = function angle () {\n  if (arguments.length === 1) {\n    var p = arguments[0];\n    return Math.atan2(p.y, p.x)\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    var dx = p1.x - p0.x;\n    var dy = p1.y - p0.y;\n    return Math.atan2(dy, dx)\n  }\n};\nAngle.isAcute = function isAcute (p0, p1, p2) {\n  var dx0 = p0.x - p1.x;\n  var dy0 = p0.y - p1.y;\n  var dx1 = p2.x - p1.x;\n  var dy1 = p2.y - p1.y;\n  var dotprod = dx0 * dx1 + dy0 * dy1;\n  return dotprod > 0\n};\nAngle.isObtuse = function isObtuse (p0, p1, p2) {\n  var dx0 = p0.x - p1.x;\n  var dy0 = p0.y - p1.y;\n  var dx1 = p2.x - p1.x;\n  var dy1 = p2.y - p1.y;\n  var dotprod = dx0 * dx1 + dy0 * dy1;\n  return dotprod < 0\n};\nAngle.interiorAngle = function interiorAngle (p0, p1, p2) {\n  var anglePrev = Angle.angle(p1, p0);\n  var angleNext = Angle.angle(p1, p2);\n  return Math.abs(angleNext - anglePrev)\n};\nAngle.normalizePositive = function normalizePositive (angle) {\n  if (angle < 0.0) {\n    while (angle < 0.0) { angle += Angle.PI_TIMES_2; }\n    if (angle >= Angle.PI_TIMES_2) { angle = 0.0; }\n  } else {\n    while (angle >= Angle.PI_TIMES_2) { angle -= Angle.PI_TIMES_2; }\n    if (angle < 0.0) { angle = 0.0; }\n  }\n  return angle\n};\nAngle.angleBetween = function angleBetween (tip1, tail, tip2) {\n  var a1 = Angle.angle(tail, tip1);\n  var a2 = Angle.angle(tail, tip2);\n  return Angle.diff(a1, a2)\n};\nAngle.diff = function diff (ang1, ang2) {\n  var delAngle = null;\n  if (ang1 < ang2) {\n    delAngle = ang2 - ang1;\n  } else {\n    delAngle = ang1 - ang2;\n  }\n  if (delAngle > Math.PI) {\n    delAngle = 2 * Math.PI - delAngle;\n  }\n  return delAngle\n};\nAngle.toRadians = function toRadians (angleDegrees) {\n  return angleDegrees * Math.PI / 180.0\n};\nAngle.getTurn = function getTurn (ang1, ang2) {\n  var crossproduct = Math.sin(ang2 - ang1);\n  if (crossproduct > 0) {\n    return Angle.COUNTERCLOCKWISE\n  }\n  if (crossproduct < 0) {\n    return Angle.CLOCKWISE\n  }\n  return Angle.NONE\n};\nAngle.angleBetweenOriented = function angleBetweenOriented (tip1, tail, tip2) {\n  var a1 = Angle.angle(tail, tip1);\n  var a2 = Angle.angle(tail, tip2);\n  var angDel = a2 - a1;\n  if (angDel <= -Math.PI) { return angDel + Angle.PI_TIMES_2 }\n  if (angDel > Math.PI) { return angDel - Angle.PI_TIMES_2 }\n  return angDel\n};\nstaticAccessors$29.PI_TIMES_2.get = function () { return 2.0 * Math.PI };\nstaticAccessors$29.PI_OVER_2.get = function () { return Math.PI / 2.0 };\nstaticAccessors$29.PI_OVER_4.get = function () { return Math.PI / 4.0 };\nstaticAccessors$29.COUNTERCLOCKWISE.get = function () { return CGAlgorithms.COUNTERCLOCKWISE };\nstaticAccessors$29.CLOCKWISE.get = function () { return CGAlgorithms.CLOCKWISE };\nstaticAccessors$29.NONE.get = function () { return CGAlgorithms.COLLINEAR };\n\nObject.defineProperties( Angle, staticAccessors$29 );\n\nvar OffsetSegmentGenerator = function OffsetSegmentGenerator () {\n  this._maxCurveSegmentError = 0.0;\n  this._filletAngleQuantum = null;\n  this._closingSegLengthFactor = 1;\n  this._segList = null;\n  this._distance = 0.0;\n  this._precisionModel = null;\n  this._bufParams = null;\n  this._li = null;\n  this._s0 = null;\n  this._s1 = null;\n  this._s2 = null;\n  this._seg0 = new LineSegment();\n  this._seg1 = new LineSegment();\n  this._offset0 = new LineSegment();\n  this._offset1 = new LineSegment();\n  this._side = 0;\n  this._hasNarrowConcaveAngle = false;\n  var precisionModel = arguments[0];\n  var bufParams = arguments[1];\n  var distance = arguments[2];\n  this._precisionModel = precisionModel;\n  this._bufParams = bufParams;\n  this._li = new RobustLineIntersector();\n  this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n  if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) { this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR; }\n  this.init(distance);\n};\n\nvar staticAccessors$27 = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true },INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true },CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true },MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };\nOffsetSegmentGenerator.prototype.addNextSegment = function addNextSegment (p, addStartPoint) {\n  this._s0 = this._s1;\n  this._s1 = this._s2;\n  this._s2 = p;\n  this._seg0.setCoordinates(this._s0, this._s1);\n  this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);\n  this._seg1.setCoordinates(this._s1, this._s2);\n  this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);\n  if (this._s1.equals(this._s2)) { return null }\n  var orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);\n  var outsideTurn = (orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT) || (orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT);\n  if (orientation === 0) {\n    this.addCollinear(addStartPoint);\n  } else if (outsideTurn) {\n    this.addOutsideTurn(orientation, addStartPoint);\n  } else {\n    this.addInsideTurn(orientation, addStartPoint);\n  }\n};\nOffsetSegmentGenerator.prototype.addLineEndCap = function addLineEndCap (p0, p1) {\n  var seg = new LineSegment(p0, p1);\n  var offsetL = new LineSegment();\n  this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);\n  var offsetR = new LineSegment();\n  this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);\n  var dx = p1.x - p0.x;\n  var dy = p1.y - p0.y;\n  var angle = Math.atan2(dy, dx);\n  switch (this._bufParams.getEndCapStyle()) {\n    case BufferParameters.CAP_ROUND:\n      this._segList.addPt(offsetL.p1);\n      this.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);\n      this._segList.addPt(offsetR.p1);\n      break\n    case BufferParameters.CAP_FLAT:\n      this._segList.addPt(offsetL.p1);\n      this._segList.addPt(offsetR.p1);\n      break\n    case BufferParameters.CAP_SQUARE:\n      var squareCapSideOffset = new Coordinate();\n      squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);\n      squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);\n      var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n      var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n      this._segList.addPt(squareCapLOffset);\n      this._segList.addPt(squareCapROffset);\n      break\n    default:\n  }\n};\nOffsetSegmentGenerator.prototype.getCoordinates = function getCoordinates () {\n  var pts = this._segList.getCoordinates();\n  return pts\n};\nOffsetSegmentGenerator.prototype.addMitreJoin = function addMitreJoin (p, offset0, offset1, distance) {\n  var isMitreWithinLimit = true;\n  var intPt = null;\n  try {\n    intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n    var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n    if (mitreRatio > this._bufParams.getMitreLimit()) { isMitreWithinLimit = false; }\n  } catch (ex) {\n    if (ex instanceof NotRepresentableException) {\n      intPt = new Coordinate(0, 0);\n      isMitreWithinLimit = false;\n    } else { throw ex }\n  } finally {}\n  if (isMitreWithinLimit) {\n    this._segList.addPt(intPt);\n  } else {\n    this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());\n  }\n};\nOffsetSegmentGenerator.prototype.addFilletCorner = function addFilletCorner (p, p0, p1, direction, radius) {\n  var dx0 = p0.x - p.x;\n  var dy0 = p0.y - p.y;\n  var startAngle = Math.atan2(dy0, dx0);\n  var dx1 = p1.x - p.x;\n  var dy1 = p1.y - p.y;\n  var endAngle = Math.atan2(dy1, dx1);\n  if (direction === CGAlgorithms.CLOCKWISE) {\n    if (startAngle <= endAngle) { startAngle += 2.0 * Math.PI; }\n  } else {\n    if (startAngle >= endAngle) { startAngle -= 2.0 * Math.PI; }\n  }\n  this._segList.addPt(p0);\n  this.addFilletArc(p, startAngle, endAngle, direction, radius);\n  this._segList.addPt(p1);\n};\nOffsetSegmentGenerator.prototype.addOutsideTurn = function addOutsideTurn (orientation, addStartPoint) {\n  if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n    this._segList.addPt(this._offset0.p1);\n    return null\n  }\n  if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n    this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);\n  } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n    this.addBevelJoin(this._offset0, this._offset1);\n  } else {\n    if (addStartPoint) { this._segList.addPt(this._offset0.p1); }\n    this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);\n    this._segList.addPt(this._offset1.p0);\n  }\n};\nOffsetSegmentGenerator.prototype.createSquare = function createSquare (p) {\n  this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));\n  this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));\n  this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));\n  this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));\n  this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.addSegments = function addSegments (pt, isForward) {\n  this._segList.addPts(pt, isForward);\n};\nOffsetSegmentGenerator.prototype.addFirstSegment = function addFirstSegment () {\n  this._segList.addPt(this._offset1.p0);\n};\nOffsetSegmentGenerator.prototype.addLastSegment = function addLastSegment () {\n  this._segList.addPt(this._offset1.p1);\n};\nOffsetSegmentGenerator.prototype.initSideSegments = function initSideSegments (s1, s2, side) {\n  this._s1 = s1;\n  this._s2 = s2;\n  this._side = side;\n  this._seg1.setCoordinates(s1, s2);\n  this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);\n};\nOffsetSegmentGenerator.prototype.addLimitedMitreJoin = function addLimitedMitreJoin (offset0, offset1, distance, mitreLimit) {\n  var basePt = this._seg0.p1;\n  var ang0 = Angle.angle(basePt, this._seg0.p0);\n  // const ang1 = Angle.angle(basePt, this._seg1.p1)\n  var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);\n  var angDiffHalf = angDiff / 2;\n  var midAng = Angle.normalize(ang0 + angDiffHalf);\n  var mitreMidAng = Angle.normalize(midAng + Math.PI);\n  var mitreDist = mitreLimit * distance;\n  var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n  var bevelHalfLen = distance - bevelDelta;\n  var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n  var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n  var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n  var mitreMidLine = new LineSegment(basePt, bevelMidPt);\n  var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n  var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n  if (this._side === Position.LEFT) {\n    this._segList.addPt(bevelEndLeft);\n    this._segList.addPt(bevelEndRight);\n  } else {\n    this._segList.addPt(bevelEndRight);\n    this._segList.addPt(bevelEndLeft);\n  }\n};\nOffsetSegmentGenerator.prototype.computeOffsetSegment = function computeOffsetSegment (seg, side, distance, offset) {\n  var sideSign = side === Position.LEFT ? 1 : -1;\n  var dx = seg.p1.x - seg.p0.x;\n  var dy = seg.p1.y - seg.p0.y;\n  var len = Math.sqrt(dx * dx + dy * dy);\n  var ux = sideSign * distance * dx / len;\n  var uy = sideSign * distance * dy / len;\n  offset.p0.x = seg.p0.x - uy;\n  offset.p0.y = seg.p0.y + ux;\n  offset.p1.x = seg.p1.x - uy;\n  offset.p1.y = seg.p1.y + ux;\n};\nOffsetSegmentGenerator.prototype.addFilletArc = function addFilletArc (p, startAngle, endAngle, direction, radius) {\n    var this$1 = this;\n\n  var directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;\n  var totalAngle = Math.abs(startAngle - endAngle);\n  var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);\n  if (nSegs < 1) { return null }\n  var initAngle = 0.0;\n  var currAngleInc = totalAngle / nSegs;\n  var currAngle = initAngle;\n  var pt = new Coordinate();\n  while (currAngle < totalAngle) {\n    var angle = startAngle + directionFactor * currAngle;\n    pt.x = p.x + radius * Math.cos(angle);\n    pt.y = p.y + radius * Math.sin(angle);\n    this$1._segList.addPt(pt);\n    currAngle += currAngleInc;\n  }\n};\nOffsetSegmentGenerator.prototype.addInsideTurn = function addInsideTurn (orientation, addStartPoint) {\n  this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);\n  if (this._li.hasIntersection()) {\n    this._segList.addPt(this._li.getIntersection(0));\n  } else {\n    this._hasNarrowConcaveAngle = true;\n    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n      this._segList.addPt(this._offset0.p1);\n    } else {\n      this._segList.addPt(this._offset0.p1);\n      if (this._closingSegLengthFactor > 0) {\n        var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n        this._segList.addPt(mid0);\n        var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n        this._segList.addPt(mid1);\n      } else {\n        this._segList.addPt(this._s1);\n      }\n      this._segList.addPt(this._offset1.p0);\n    }\n  }\n};\nOffsetSegmentGenerator.prototype.createCircle = function createCircle (p) {\n  var pt = new Coordinate(p.x + this._distance, p.y);\n  this._segList.addPt(pt);\n  this.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);\n  this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.addBevelJoin = function addBevelJoin (offset0, offset1) {\n  this._segList.addPt(offset0.p1);\n  this._segList.addPt(offset1.p0);\n};\nOffsetSegmentGenerator.prototype.init = function init (distance) {\n  this._distance = distance;\n  this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));\n  this._segList = new OffsetSegmentString();\n  this._segList.setPrecisionModel(this._precisionModel);\n  this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n};\nOffsetSegmentGenerator.prototype.addCollinear = function addCollinear (addStartPoint) {\n  this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n  var numInt = this._li.getIntersectionNum();\n  if (numInt >= 2) {\n    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n      if (addStartPoint) { this._segList.addPt(this._offset0.p1); }\n      this._segList.addPt(this._offset1.p0);\n    } else {\n      this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);\n    }\n  }\n};\nOffsetSegmentGenerator.prototype.closeRing = function closeRing () {\n  this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function hasNarrowConcaveAngle () {\n  return this._hasNarrowConcaveAngle\n};\nOffsetSegmentGenerator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetSegmentGenerator.prototype.getClass = function getClass () {\n  return OffsetSegmentGenerator\n};\nstaticAccessors$27.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () { return 1.0E-3 };\nstaticAccessors$27.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1.0E-3 };\nstaticAccessors$27.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1.0E-6 };\nstaticAccessors$27.MAX_CLOSING_SEG_LEN_FACTOR.get = function () { return 80 };\n\nObject.defineProperties( OffsetSegmentGenerator, staticAccessors$27 );\n\nvar OffsetCurveBuilder = function OffsetCurveBuilder () {\n  this._distance = 0.0;\n  this._precisionModel = null;\n  this._bufParams = null;\n  var precisionModel = arguments[0];\n  var bufParams = arguments[1];\n  this._precisionModel = precisionModel;\n  this._bufParams = bufParams;\n};\nOffsetCurveBuilder.prototype.getOffsetCurve = function getOffsetCurve (inputPts, distance) {\n  this._distance = distance;\n  if (distance === 0.0) { return null }\n  var isRightSide = distance < 0.0;\n  var posDistance = Math.abs(distance);\n  var segGen = this.getSegGen(posDistance);\n  if (inputPts.length <= 1) {\n    this.computePointCurve(inputPts[0], segGen);\n  } else {\n    this.computeOffsetCurve(inputPts, isRightSide, segGen);\n  }\n  var curvePts = segGen.getCoordinates();\n  if (isRightSide) { CoordinateArrays.reverse(curvePts); }\n  return curvePts\n};\nOffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function computeSingleSidedBufferCurve (inputPts, isRightSide, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  if (isRightSide) {\n    segGen.addSegments(inputPts, true);\n    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n    var n2 = simp2.length - 1;\n    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i = n2 - 2; i >= 0; i--) {\n      segGen.addNextSegment(simp2[i], true);\n    }\n  } else {\n    segGen.addSegments(inputPts, false);\n    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n    var n1 = simp1.length - 1;\n    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i$1 = 2; i$1 <= n1; i$1++) {\n      segGen.addNextSegment(simp1[i$1], true);\n    }\n  }\n  segGen.addLastSegment();\n  segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computeRingBufferCurve = function computeRingBufferCurve (inputPts, side, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  if (side === Position.RIGHT) { distTol = -distTol; }\n  var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  var n = simp.length - 1;\n  segGen.initSideSegments(simp[n - 1], simp[0], side);\n  for (var i = 1; i <= n; i++) {\n    var addStartPoint = i !== 1;\n    segGen.addNextSegment(simp[i], addStartPoint);\n  }\n  segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computeLineBufferCurve = function computeLineBufferCurve (inputPts, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  var n1 = simp1.length - 1;\n  segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n  for (var i = 2; i <= n1; i++) {\n    segGen.addNextSegment(simp1[i], true);\n  }\n  segGen.addLastSegment();\n  segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n  var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n  var n2 = simp2.length - 1;\n  segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n  for (var i$1 = n2 - 2; i$1 >= 0; i$1--) {\n    segGen.addNextSegment(simp2[i$1], true);\n  }\n  segGen.addLastSegment();\n  segGen.addLineEndCap(simp2[1], simp2[0]);\n  segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computePointCurve = function computePointCurve (pt, segGen) {\n  switch (this._bufParams.getEndCapStyle()) {\n    case BufferParameters.CAP_ROUND:\n      segGen.createCircle(pt);\n      break\n    case BufferParameters.CAP_SQUARE:\n      segGen.createSquare(pt);\n      break\n    default:\n  }\n};\nOffsetCurveBuilder.prototype.getLineCurve = function getLineCurve (inputPts, distance) {\n  this._distance = distance;\n  if (distance < 0.0 && !this._bufParams.isSingleSided()) { return null }\n  if (distance === 0.0) { return null }\n  var posDistance = Math.abs(distance);\n  var segGen = this.getSegGen(posDistance);\n  if (inputPts.length <= 1) {\n    this.computePointCurve(inputPts[0], segGen);\n  } else {\n    if (this._bufParams.isSingleSided()) {\n      var isRightSide = distance < 0.0;\n      this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n    } else { this.computeLineBufferCurve(inputPts, segGen); }\n  }\n  var lineCoord = segGen.getCoordinates();\n  return lineCoord\n};\nOffsetCurveBuilder.prototype.getBufferParameters = function getBufferParameters () {\n  return this._bufParams\n};\nOffsetCurveBuilder.prototype.simplifyTolerance = function simplifyTolerance (bufDistance) {\n  return bufDistance * this._bufParams.getSimplifyFactor()\n};\nOffsetCurveBuilder.prototype.getRingCurve = function getRingCurve (inputPts, side, distance) {\n  this._distance = distance;\n  if (inputPts.length <= 2) { return this.getLineCurve(inputPts, distance) }\n  if (distance === 0.0) {\n    return OffsetCurveBuilder.copyCoordinates(inputPts)\n  }\n  var segGen = this.getSegGen(distance);\n  this.computeRingBufferCurve(inputPts, side, segGen);\n  return segGen.getCoordinates()\n};\nOffsetCurveBuilder.prototype.computeOffsetCurve = function computeOffsetCurve (inputPts, isRightSide, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  if (isRightSide) {\n    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n    var n2 = simp2.length - 1;\n    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i = n2 - 2; i >= 0; i--) {\n      segGen.addNextSegment(simp2[i], true);\n    }\n  } else {\n    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n    var n1 = simp1.length - 1;\n    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i$1 = 2; i$1 <= n1; i$1++) {\n      segGen.addNextSegment(simp1[i$1], true);\n    }\n  }\n  segGen.addLastSegment();\n};\nOffsetCurveBuilder.prototype.getSegGen = function getSegGen (distance) {\n  return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance)\n};\nOffsetCurveBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetCurveBuilder.prototype.getClass = function getClass () {\n  return OffsetCurveBuilder\n};\nOffsetCurveBuilder.copyCoordinates = function copyCoordinates (pts) {\n  var copy = new Array(pts.length).fill(null);\n  for (var i = 0; i < copy.length; i++) {\n    copy[i] = new Coordinate(pts[i]);\n  }\n  return copy\n};\n\nvar SubgraphDepthLocater = function SubgraphDepthLocater () {\n  this._subgraphs = null;\n  this._seg = new LineSegment();\n  this._cga = new CGAlgorithms();\n  var subgraphs = arguments[0];\n  this._subgraphs = subgraphs;\n};\n\nvar staticAccessors$30 = { DepthSegment: { configurable: true } };\nSubgraphDepthLocater.prototype.findStabbedSegments = function findStabbedSegments () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var stabbingRayLeftPt = arguments[0];\n    var stabbedSegments = new ArrayList();\n    for (var i = this._subgraphs.iterator(); i.hasNext();) {\n      var bsg = i.next();\n      var env = bsg.getEnvelope();\n      if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) { continue }\n      this$1.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n    }\n    return stabbedSegments\n  } else if (arguments.length === 3) {\n    if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {\n      var stabbingRayLeftPt$1 = arguments[0];\n      var dirEdge = arguments[1];\n      var stabbedSegments$1 = arguments[2];\n      var pts = dirEdge.getEdge().getCoordinates();\n      for (var i$1 = 0; i$1 < pts.length - 1; i$1++) {\n        this$1._seg.p0 = pts[i$1];\n        this$1._seg.p1 = pts[i$1 + 1];\n        if (this$1._seg.p0.y > this$1._seg.p1.y) { this$1._seg.reverse(); }\n        var maxx = Math.max(this$1._seg.p0.x, this$1._seg.p1.x);\n        if (maxx < stabbingRayLeftPt$1.x) { continue }\n        if (this$1._seg.isHorizontal()) { continue }\n        if (stabbingRayLeftPt$1.y < this$1._seg.p0.y || stabbingRayLeftPt$1.y > this$1._seg.p1.y) { continue }\n        if (CGAlgorithms.computeOrientation(this$1._seg.p0, this$1._seg.p1, stabbingRayLeftPt$1) === CGAlgorithms.RIGHT) { continue }\n        var depth = dirEdge.getDepth(Position.LEFT);\n        if (!this$1._seg.p0.equals(pts[i$1])) { depth = dirEdge.getDepth(Position.RIGHT); }\n        var ds = new DepthSegment(this$1._seg, depth);\n        stabbedSegments$1.add(ds);\n      }\n    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {\n      var stabbingRayLeftPt$2 = arguments[0];\n      var dirEdges = arguments[1];\n      var stabbedSegments$2 = arguments[2];\n      for (var i$2 = dirEdges.iterator(); i$2.hasNext();) {\n        var de = i$2.next();\n        if (!de.isForward()) { continue }\n        this$1.findStabbedSegments(stabbingRayLeftPt$2, de, stabbedSegments$2);\n      }\n    }\n  }\n};\nSubgraphDepthLocater.prototype.getDepth = function getDepth (p) {\n  var stabbedSegments = this.findStabbedSegments(p);\n  if (stabbedSegments.size() === 0) { return 0 }\n  var ds = Collections.min(stabbedSegments);\n  return ds._leftDepth\n};\nSubgraphDepthLocater.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSubgraphDepthLocater.prototype.getClass = function getClass () {\n  return SubgraphDepthLocater\n};\nstaticAccessors$30.DepthSegment.get = function () { return DepthSegment };\n\nObject.defineProperties( SubgraphDepthLocater, staticAccessors$30 );\n\nvar DepthSegment = function DepthSegment () {\n  this._upwardSeg = null;\n  this._leftDepth = null;\n  var seg = arguments[0];\n  var depth = arguments[1];\n  this._upwardSeg = new LineSegment(seg);\n  this._leftDepth = depth;\n};\nDepthSegment.prototype.compareTo = function compareTo (obj) {\n  var other = obj;\n  if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) { return 1 }\n  if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) { return -1 }\n  var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);\n  if (orientIndex !== 0) { return orientIndex }\n  orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);\n  if (orientIndex !== 0) { return orientIndex }\n  return this._upwardSeg.compareTo(other._upwardSeg)\n};\nDepthSegment.prototype.compareX = function compareX (seg0, seg1) {\n  var compare0 = seg0.p0.compareTo(seg1.p0);\n  if (compare0 !== 0) { return compare0 }\n  return seg0.p1.compareTo(seg1.p1)\n};\nDepthSegment.prototype.toString = function toString () {\n  return this._upwardSeg.toString()\n};\nDepthSegment.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nDepthSegment.prototype.getClass = function getClass () {\n  return DepthSegment\n};\n\nvar Triangle = function Triangle (p0, p1, p2) {\n  this.p0 = p0 || null;\n  this.p1 = p1 || null;\n  this.p2 = p2 || null;\n};\nTriangle.prototype.area = function area () {\n  return Triangle.area(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.signedArea = function signedArea () {\n  return Triangle.signedArea(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.interpolateZ = function interpolateZ (p) {\n  if (p === null) { throw new IllegalArgumentException('Supplied point is null.') }\n  return Triangle.interpolateZ(p, this.p0, this.p1, this.p2)\n};\nTriangle.prototype.longestSideLength = function longestSideLength () {\n  return Triangle.longestSideLength(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.isAcute = function isAcute () {\n  return Triangle.isAcute(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.circumcentre = function circumcentre () {\n  return Triangle.circumcentre(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.area3D = function area3D () {\n  return Triangle.area3D(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.centroid = function centroid () {\n  return Triangle.centroid(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.inCentre = function inCentre () {\n  return Triangle.inCentre(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nTriangle.prototype.getClass = function getClass () {\n  return Triangle\n};\nTriangle.area = function area (a, b, c) {\n  return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2)\n};\nTriangle.signedArea = function signedArea (a, b, c) {\n  return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2\n};\nTriangle.det = function det (m00, m01, m10, m11) {\n  return m00 * m11 - m01 * m10\n};\nTriangle.interpolateZ = function interpolateZ (p, v0, v1, v2) {\n  var x0 = v0.x;\n  var y0 = v0.y;\n  var a = v1.x - x0;\n  var b = v2.x - x0;\n  var c = v1.y - y0;\n  var d = v2.y - y0;\n  var det = a * d - b * c;\n  var dx = p.x - x0;\n  var dy = p.y - y0;\n  var t = (d * dx - b * dy) / det;\n  var u = (-c * dx + a * dy) / det;\n  var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n  return z\n};\nTriangle.longestSideLength = function longestSideLength (a, b, c) {\n  var lenAB = a.distance(b);\n  var lenBC = b.distance(c);\n  var lenCA = c.distance(a);\n  var maxLen = lenAB;\n  if (lenBC > maxLen) { maxLen = lenBC; }\n  if (lenCA > maxLen) { maxLen = lenCA; }\n  return maxLen\n};\nTriangle.isAcute = function isAcute (a, b, c) {\n  if (!Angle.isAcute(a, b, c)) { return false }\n  if (!Angle.isAcute(b, c, a)) { return false }\n  if (!Angle.isAcute(c, a, b)) { return false }\n  return true\n};\nTriangle.circumcentre = function circumcentre (a, b, c) {\n  var cx = c.x;\n  var cy = c.y;\n  var ax = a.x - cx;\n  var ay = a.y - cy;\n  var bx = b.x - cx;\n  var by = b.y - cy;\n  var denom = 2 * Triangle.det(ax, ay, bx, by);\n  var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n  var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n  var ccx = cx - numx / denom;\n  var ccy = cy + numy / denom;\n  return new Coordinate(ccx, ccy)\n};\nTriangle.perpendicularBisector = function perpendicularBisector (a, b) {\n  var dx = b.x - a.x;\n  var dy = b.y - a.y;\n  var l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n  var l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n  return new HCoordinate(l1, l2)\n};\nTriangle.angleBisector = function angleBisector (a, b, c) {\n  var len0 = b.distance(a);\n  var len2 = b.distance(c);\n  var frac = len0 / (len0 + len2);\n  var dx = c.x - a.x;\n  var dy = c.y - a.y;\n  var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n  return splitPt\n};\nTriangle.area3D = function area3D (a, b, c) {\n  var ux = b.x - a.x;\n  var uy = b.y - a.y;\n  var uz = b.z - a.z;\n  var vx = c.x - a.x;\n  var vy = c.y - a.y;\n  var vz = c.z - a.z;\n  var crossx = uy * vz - uz * vy;\n  var crossy = uz * vx - ux * vz;\n  var crossz = ux * vy - uy * vx;\n  var absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n  var area3D = Math.sqrt(absSq) / 2;\n  return area3D\n};\nTriangle.centroid = function centroid (a, b, c) {\n  var x = (a.x + b.x + c.x) / 3;\n  var y = (a.y + b.y + c.y) / 3;\n  return new Coordinate(x, y)\n};\nTriangle.inCentre = function inCentre (a, b, c) {\n  var len0 = b.distance(c);\n  var len1 = a.distance(c);\n  var len2 = a.distance(b);\n  var circum = len0 + len1 + len2;\n  var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n  var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n  return new Coordinate(inCentreX, inCentreY)\n};\n\nvar OffsetCurveSetBuilder = function OffsetCurveSetBuilder () {\n  this._inputGeom = null;\n  this._distance = null;\n  this._curveBuilder = null;\n  this._curveList = new ArrayList();\n  var inputGeom = arguments[0];\n  var distance = arguments[1];\n  var curveBuilder = arguments[2];\n  this._inputGeom = inputGeom;\n  this._distance = distance;\n  this._curveBuilder = curveBuilder;\n};\nOffsetCurveSetBuilder.prototype.addPoint = function addPoint (p) {\n  if (this._distance <= 0.0) { return null }\n  var coord = p.getCoordinates();\n  var curve = this._curveBuilder.getLineCurve(coord, this._distance);\n  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n};\nOffsetCurveSetBuilder.prototype.addPolygon = function addPolygon (p) {\n    var this$1 = this;\n\n  var offsetDistance = this._distance;\n  var offsetSide = Position.LEFT;\n  if (this._distance < 0.0) {\n    offsetDistance = -this._distance;\n    offsetSide = Position.RIGHT;\n  }\n  var shell = p.getExteriorRing();\n  var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n  if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) { return null }\n  if (this._distance <= 0.0 && shellCoord.length < 3) { return null }\n  this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n  for (var i = 0; i < p.getNumInteriorRing(); i++) {\n    var hole = p.getInteriorRingN(i);\n    var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n    if (this$1._distance > 0.0 && this$1.isErodedCompletely(hole, -this$1._distance)) { continue }\n    this$1.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n  }\n};\nOffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function isTriangleErodedCompletely (triangleCoord, bufferDistance) {\n  var tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n  var inCentre = tri.inCentre();\n  var distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);\n  return distToCentre < Math.abs(bufferDistance)\n};\nOffsetCurveSetBuilder.prototype.addLineString = function addLineString (line) {\n  if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) { return null }\n  var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n  var curve = this._curveBuilder.getLineCurve(coord, this._distance);\n  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n};\nOffsetCurveSetBuilder.prototype.addCurve = function addCurve (coord, leftLoc, rightLoc) {\n  if (coord === null || coord.length < 2) { return null }\n  var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n  this._curveList.add(e);\n};\nOffsetCurveSetBuilder.prototype.getCurves = function getCurves () {\n  this.add(this._inputGeom);\n  return this._curveList\n};\nOffsetCurveSetBuilder.prototype.addPolygonRing = function addPolygonRing (coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n  if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) { return null }\n  var leftLoc = cwLeftLoc;\n  var rightLoc = cwRightLoc;\n  if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {\n    leftLoc = cwRightLoc;\n    rightLoc = cwLeftLoc;\n    side = Position.opposite(side);\n  }\n  var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);\n  this.addCurve(curve, leftLoc, rightLoc);\n};\nOffsetCurveSetBuilder.prototype.add = function add (g) {\n  if (g.isEmpty()) { return null }\n  if (g instanceof Polygon) { this.addPolygon(g); }\n  else if (g instanceof LineString) { this.addLineString(g); }\n  else if (g instanceof Point) { this.addPoint(g); }\n  else if (g instanceof MultiPoint) { this.addCollection(g); }\n  else if (g instanceof MultiLineString) { this.addCollection(g); }\n  else if (g instanceof MultiPolygon) { this.addCollection(g); }\n  else if (g instanceof GeometryCollection) { this.addCollection(g); }\n  // else throw new UnsupportedOperationException(g.getClass().getName())\n};\nOffsetCurveSetBuilder.prototype.isErodedCompletely = function isErodedCompletely (ring, bufferDistance) {\n  var ringCoord = ring.getCoordinates();\n  // const minDiam = 0.0\n  if (ringCoord.length < 4) { return bufferDistance < 0 }\n  if (ringCoord.length === 4) { return this.isTriangleErodedCompletely(ringCoord, bufferDistance) }\n  var env = ring.getEnvelopeInternal();\n  var envMinDimension = Math.min(env.getHeight(), env.getWidth());\n  if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) { return true }\n  return false\n};\nOffsetCurveSetBuilder.prototype.addCollection = function addCollection (gc) {\n    var this$1 = this;\n\n  for (var i = 0; i < gc.getNumGeometries(); i++) {\n    var g = gc.getGeometryN(i);\n    this$1.add(g);\n  }\n};\nOffsetCurveSetBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetCurveSetBuilder.prototype.getClass = function getClass () {\n  return OffsetCurveSetBuilder\n};\n\nvar PointOnGeometryLocator = function PointOnGeometryLocator () {};\n\nPointOnGeometryLocator.prototype.locate = function locate (p) {};\nPointOnGeometryLocator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointOnGeometryLocator.prototype.getClass = function getClass () {\n  return PointOnGeometryLocator\n};\n\nvar GeometryCollectionIterator = function GeometryCollectionIterator () {\n  this._parent = null;\n  this._atStart = null;\n  this._max = null;\n  this._index = null;\n  this._subcollectionIterator = null;\n  var parent = arguments[0];\n  this._parent = parent;\n  this._atStart = true;\n  this._index = 0;\n  this._max = parent.getNumGeometries();\n};\nGeometryCollectionIterator.prototype.next = function next () {\n  if (this._atStart) {\n    this._atStart = false;\n    if (GeometryCollectionIterator.isAtomic(this._parent)) { this._index++; }\n    return this._parent\n  }\n  if (this._subcollectionIterator !== null) {\n    if (this._subcollectionIterator.hasNext()) {\n      return this._subcollectionIterator.next()\n    } else {\n      this._subcollectionIterator = null;\n    }\n  }\n  if (this._index >= this._max) {\n    throw new NoSuchElementException()\n  }\n  var obj = this._parent.getGeometryN(this._index++);\n  if (obj instanceof GeometryCollection) {\n    this._subcollectionIterator = new GeometryCollectionIterator(obj);\n    return this._subcollectionIterator.next()\n  }\n  return obj\n};\nGeometryCollectionIterator.prototype.remove = function remove () {\n  throw new Error(this.getClass().getName())\n};\nGeometryCollectionIterator.prototype.hasNext = function hasNext () {\n  if (this._atStart) {\n    return true\n  }\n  if (this._subcollectionIterator !== null) {\n    if (this._subcollectionIterator.hasNext()) {\n      return true\n    }\n    this._subcollectionIterator = null;\n  }\n  if (this._index >= this._max) {\n    return false\n  }\n  return true\n};\nGeometryCollectionIterator.prototype.interfaces_ = function interfaces_ () {\n  return [Iterator]\n};\nGeometryCollectionIterator.prototype.getClass = function getClass () {\n  return GeometryCollectionIterator\n};\nGeometryCollectionIterator.isAtomic = function isAtomic (geom) {\n  return !(geom instanceof GeometryCollection)\n};\n\nvar SimplePointInAreaLocator = function SimplePointInAreaLocator () {\n  this._geom = null;\n  var geom = arguments[0];\n  this._geom = geom;\n};\nSimplePointInAreaLocator.prototype.locate = function locate (p) {\n  return SimplePointInAreaLocator.locate(p, this._geom)\n};\nSimplePointInAreaLocator.prototype.interfaces_ = function interfaces_ () {\n  return [PointOnGeometryLocator]\n};\nSimplePointInAreaLocator.prototype.getClass = function getClass () {\n  return SimplePointInAreaLocator\n};\nSimplePointInAreaLocator.isPointInRing = function isPointInRing (p, ring) {\n  if (!ring.getEnvelopeInternal().intersects(p)) { return false }\n  return CGAlgorithms.isPointInRing(p, ring.getCoordinates())\n};\nSimplePointInAreaLocator.containsPointInPolygon = function containsPointInPolygon (p, poly) {\n  if (poly.isEmpty()) { return false }\n  var shell = poly.getExteriorRing();\n  if (!SimplePointInAreaLocator.isPointInRing(p, shell)) { return false }\n  for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n    var hole = poly.getInteriorRingN(i);\n    if (SimplePointInAreaLocator.isPointInRing(p, hole)) { return false }\n  }\n  return true\n};\nSimplePointInAreaLocator.containsPoint = function containsPoint (p, geom) {\n  if (geom instanceof Polygon) {\n    return SimplePointInAreaLocator.containsPointInPolygon(p, geom)\n  } else if (geom instanceof GeometryCollection) {\n    var geomi = new GeometryCollectionIterator(geom);\n    while (geomi.hasNext()) {\n      var g2 = geomi.next();\n      if (g2 !== geom) { if (SimplePointInAreaLocator.containsPoint(p, g2)) { return true } }\n    }\n  }\n  return false\n};\nSimplePointInAreaLocator.locate = function locate (p, geom) {\n  if (geom.isEmpty()) { return Location.EXTERIOR }\n  if (SimplePointInAreaLocator.containsPoint(p, geom)) { return Location.INTERIOR }\n  return Location.EXTERIOR\n};\n\nvar EdgeEndStar = function EdgeEndStar () {\n  this._edgeMap = new TreeMap();\n  this._edgeList = null;\n  this._ptInAreaLocation = [Location.NONE, Location.NONE];\n};\nEdgeEndStar.prototype.getNextCW = function getNextCW (ee) {\n  this.getEdges();\n  var i = this._edgeList.indexOf(ee);\n  var iNextCW = i - 1;\n  if (i === 0) { iNextCW = this._edgeList.size() - 1; }\n  return this._edgeList.get(iNextCW)\n};\nEdgeEndStar.prototype.propagateSideLabels = function propagateSideLabels (geomIndex) {\n  var startLoc = Location.NONE;\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) { startLoc = label.getLocation(geomIndex, Position.LEFT); }\n  }\n  if (startLoc === Location.NONE) { return null }\n  var currLoc = startLoc;\n  for (var it$1 = this.iterator(); it$1.hasNext();) {\n    var e$1 = it$1.next();\n    var label$1 = e$1.getLabel();\n    if (label$1.getLocation(geomIndex, Position.ON) === Location.NONE) { label$1.setLocation(geomIndex, Position.ON, currLoc); }\n    if (label$1.isArea(geomIndex)) {\n      var leftLoc = label$1.getLocation(geomIndex, Position.LEFT);\n      var rightLoc = label$1.getLocation(geomIndex, Position.RIGHT);\n      if (rightLoc !== Location.NONE) {\n        if (rightLoc !== currLoc) { throw new TopologyException('side location conflict', e$1.getCoordinate()) }\n        if (leftLoc === Location.NONE) {\n          Assert.shouldNeverReachHere('found single null side (at ' + e$1.getCoordinate() + ')');\n        }\n        currLoc = leftLoc;\n      } else {\n        Assert.isTrue(label$1.getLocation(geomIndex, Position.LEFT) === Location.NONE, 'found single null side');\n        label$1.setLocation(geomIndex, Position.RIGHT, currLoc);\n        label$1.setLocation(geomIndex, Position.LEFT, currLoc);\n      }\n    }\n  }\n};\nEdgeEndStar.prototype.getCoordinate = function getCoordinate () {\n  var it = this.iterator();\n  if (!it.hasNext()) { return null }\n  var e = it.next();\n  return e.getCoordinate()\n};\nEdgeEndStar.prototype.print = function print (out) {\n  System.out.println('EdgeEndStar:   ' + this.getCoordinate());\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    e.print(out);\n  }\n};\nEdgeEndStar.prototype.isAreaLabelsConsistent = function isAreaLabelsConsistent (geomGraph) {\n  this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n  return this.checkAreaLabelsConsistent(0)\n};\nEdgeEndStar.prototype.checkAreaLabelsConsistent = function checkAreaLabelsConsistent (geomIndex) {\n  var edges = this.getEdges();\n  if (edges.size() <= 0) { return true }\n  var lastEdgeIndex = edges.size() - 1;\n  var startLabel = edges.get(lastEdgeIndex).getLabel();\n  var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n  Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge');\n  var currLoc = startLoc;\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge');\n    var leftLoc = label.getLocation(geomIndex, Position.LEFT);\n    var rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n    if (leftLoc === rightLoc) {\n      return false\n    }\n    if (rightLoc !== currLoc) {\n      return false\n    }\n    currLoc = leftLoc;\n  }\n  return true\n};\nEdgeEndStar.prototype.findIndex = function findIndex (eSearch) {\n    var this$1 = this;\n\n  this.iterator();\n  for (var i = 0; i < this._edgeList.size(); i++) {\n    var e = this$1._edgeList.get(i);\n    if (e === eSearch) { return i }\n  }\n  return -1\n};\nEdgeEndStar.prototype.iterator = function iterator () {\n  return this.getEdges().iterator()\n};\nEdgeEndStar.prototype.getEdges = function getEdges () {\n  if (this._edgeList === null) {\n    this._edgeList = new ArrayList(this._edgeMap.values());\n  }\n  return this._edgeList\n};\nEdgeEndStar.prototype.getLocation = function getLocation (geomIndex, p, geom) {\n  if (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n    this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n  }\n  return this._ptInAreaLocation[geomIndex]\n};\nEdgeEndStar.prototype.toString = function toString () {\n  var buf = new StringBuffer();\n  buf.append('EdgeEndStar:   ' + this.getCoordinate());\n  buf.append('\\n');\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    buf.append(e);\n    buf.append('\\n');\n  }\n  return buf.toString()\n};\nEdgeEndStar.prototype.computeEdgeEndLabels = function computeEdgeEndLabels (boundaryNodeRule) {\n  for (var it = this.iterator(); it.hasNext();) {\n    var ee = it.next();\n    ee.computeLabel(boundaryNodeRule);\n  }\n};\nEdgeEndStar.prototype.computeLabelling = function computeLabelling (geomGraph) {\n    var this$1 = this;\n\n  this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n  this.propagateSideLabels(0);\n  this.propagateSideLabels(1);\n  var hasDimensionalCollapseEdge = [false, false];\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    for (var geomi = 0; geomi < 2; geomi++) {\n      if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) { hasDimensionalCollapseEdge[geomi] = true; }\n    }\n  }\n  for (var it$1 = this.iterator(); it$1.hasNext();) {\n    var e$1 = it$1.next();\n    var label$1 = e$1.getLabel();\n    for (var geomi$1 = 0; geomi$1 < 2; geomi$1++) {\n      if (label$1.isAnyNull(geomi$1)) {\n        var loc = Location.NONE;\n        if (hasDimensionalCollapseEdge[geomi$1]) {\n          loc = Location.EXTERIOR;\n        } else {\n          var p = e$1.getCoordinate();\n          loc = this$1.getLocation(geomi$1, p, geomGraph);\n        }\n        label$1.setAllLocationsIfNull(geomi$1, loc);\n      }\n    }\n  }\n};\nEdgeEndStar.prototype.getDegree = function getDegree () {\n  return this._edgeMap.size()\n};\nEdgeEndStar.prototype.insertEdgeEnd = function insertEdgeEnd (e, obj) {\n  this._edgeMap.put(e, obj);\n  this._edgeList = null;\n};\nEdgeEndStar.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeEndStar.prototype.getClass = function getClass () {\n  return EdgeEndStar\n};\n\nvar DirectedEdgeStar = (function (EdgeEndStar$$1) {\n  function DirectedEdgeStar () {\n    EdgeEndStar$$1.call(this);\n    this._resultAreaEdgeList = null;\n    this._label = null;\n    this._SCANNING_FOR_INCOMING = 1;\n    this._LINKING_TO_OUTGOING = 2;\n  }\n\n  if ( EdgeEndStar$$1 ) DirectedEdgeStar.__proto__ = EdgeEndStar$$1;\n  DirectedEdgeStar.prototype = Object.create( EdgeEndStar$$1 && EdgeEndStar$$1.prototype );\n  DirectedEdgeStar.prototype.constructor = DirectedEdgeStar;\n  DirectedEdgeStar.prototype.linkResultDirectedEdges = function linkResultDirectedEdges () {\n    var this$1 = this;\n\n    this.getResultAreaEdges();\n    var firstOut = null;\n    var incoming = null;\n    var state = this._SCANNING_FOR_INCOMING;\n    for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {\n      var nextOut = this$1._resultAreaEdgeList.get(i);\n      var nextIn = nextOut.getSym();\n      if (!nextOut.getLabel().isArea()) { continue }\n      if (firstOut === null && nextOut.isInResult()) { firstOut = nextOut; }\n      switch (state) {\n        case this$1._SCANNING_FOR_INCOMING:\n          if (!nextIn.isInResult()) { continue }\n          incoming = nextIn;\n          state = this$1._LINKING_TO_OUTGOING;\n          break\n        case this$1._LINKING_TO_OUTGOING:\n          if (!nextOut.isInResult()) { continue }\n          incoming.setNext(nextOut);\n          state = this$1._SCANNING_FOR_INCOMING;\n          break\n        default:\n      }\n    }\n    if (state === this._LINKING_TO_OUTGOING) {\n      if (firstOut === null) { throw new TopologyException('no outgoing dirEdge found', this.getCoordinate()) }\n      Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');\n      incoming.setNext(firstOut);\n    }\n  };\n  DirectedEdgeStar.prototype.insert = function insert (ee) {\n    var de = ee;\n    this.insertEdgeEnd(de, de);\n  };\n  DirectedEdgeStar.prototype.getRightmostEdge = function getRightmostEdge () {\n    var edges = this.getEdges();\n    var size = edges.size();\n    if (size < 1) { return null }\n    var de0 = edges.get(0);\n    if (size === 1) { return de0 }\n    var deLast = edges.get(size - 1);\n    var quad0 = de0.getQuadrant();\n    var quad1 = deLast.getQuadrant();\n    if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) { return de0; } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) { return deLast; } else {\n      // const nonHorizontalEdge = null\n      if (de0.getDy() !== 0) { return de0; } else if (deLast.getDy() !== 0) { return deLast }\n    }\n    Assert.shouldNeverReachHere('found two horizontal edges incident on node');\n    return null\n  };\n  DirectedEdgeStar.prototype.print = function print (out) {\n    System.out.println('DirectedEdgeStar: ' + this.getCoordinate());\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      out.print('out ');\n      de.print(out);\n      out.println();\n      out.print('in ');\n      de.getSym().print(out);\n      out.println();\n    }\n  };\n  DirectedEdgeStar.prototype.getResultAreaEdges = function getResultAreaEdges () {\n    var this$1 = this;\n\n    if (this._resultAreaEdgeList !== null) { return this._resultAreaEdgeList }\n    this._resultAreaEdgeList = new ArrayList();\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      if (de.isInResult() || de.getSym().isInResult()) { this$1._resultAreaEdgeList.add(de); }\n    }\n    return this._resultAreaEdgeList\n  };\n  DirectedEdgeStar.prototype.updateLabelling = function updateLabelling (nodeLabel) {\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      var label = de.getLabel();\n      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n    }\n  };\n  DirectedEdgeStar.prototype.linkAllDirectedEdges = function linkAllDirectedEdges () {\n    var this$1 = this;\n\n    this.getEdges();\n    var prevOut = null;\n    var firstIn = null;\n    for (var i = this._edgeList.size() - 1; i >= 0; i--) {\n      var nextOut = this$1._edgeList.get(i);\n      var nextIn = nextOut.getSym();\n      if (firstIn === null) { firstIn = nextIn; }\n      if (prevOut !== null) { nextIn.setNext(prevOut); }\n      prevOut = nextOut;\n    }\n    firstIn.setNext(prevOut);\n  };\n  DirectedEdgeStar.prototype.computeDepths = function computeDepths () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var de = arguments[0];\n      var edgeIndex = this.findIndex(de);\n      // const label = de.getLabel()\n      var startDepth = de.getDepth(Position.LEFT);\n      var targetLastDepth = de.getDepth(Position.RIGHT);\n      var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);\n      var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n      if (lastDepth !== targetLastDepth) { throw new TopologyException('depth mismatch at ' + de.getCoordinate()) }\n    } else if (arguments.length === 3) {\n      var startIndex = arguments[0];\n      var endIndex = arguments[1];\n      var startDepth$1 = arguments[2];\n      var currDepth = startDepth$1;\n      for (var i = startIndex; i < endIndex; i++) {\n        var nextDe = this$1._edgeList.get(i);\n        // const label = nextDe.getLabel()\n        nextDe.setEdgeDepths(Position.RIGHT, currDepth);\n        currDepth = nextDe.getDepth(Position.LEFT);\n      }\n      return currDepth\n    }\n  };\n  DirectedEdgeStar.prototype.mergeSymLabels = function mergeSymLabels () {\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      var label = de.getLabel();\n      label.merge(de.getSym().getLabel());\n    }\n  };\n  DirectedEdgeStar.prototype.linkMinimalDirectedEdges = function linkMinimalDirectedEdges (er) {\n    var this$1 = this;\n\n    var firstOut = null;\n    var incoming = null;\n    var state = this._SCANNING_FOR_INCOMING;\n    for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n      var nextOut = this$1._resultAreaEdgeList.get(i);\n      var nextIn = nextOut.getSym();\n      if (firstOut === null && nextOut.getEdgeRing() === er) { firstOut = nextOut; }\n      switch (state) {\n        case this$1._SCANNING_FOR_INCOMING:\n          if (nextIn.getEdgeRing() !== er) { continue }\n          incoming = nextIn;\n          state = this$1._LINKING_TO_OUTGOING;\n          break\n        case this$1._LINKING_TO_OUTGOING:\n          if (nextOut.getEdgeRing() !== er) { continue }\n          incoming.setNextMin(nextOut);\n          state = this$1._SCANNING_FOR_INCOMING;\n          break\n        default:\n      }\n    }\n    if (state === this._LINKING_TO_OUTGOING) {\n      Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge');\n      Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');\n      incoming.setNextMin(firstOut);\n    }\n  };\n  DirectedEdgeStar.prototype.getOutgoingDegree = function getOutgoingDegree () {\n    if (arguments.length === 0) {\n      var degree = 0;\n      for (var it = this.iterator(); it.hasNext();) {\n        var de = it.next();\n        if (de.isInResult()) { degree++; }\n      }\n      return degree\n    } else if (arguments.length === 1) {\n      var er = arguments[0];\n      var degree$1 = 0;\n      for (var it$1 = this.iterator(); it$1.hasNext();) {\n        var de$1 = it$1.next();\n        if (de$1.getEdgeRing() === er) { degree$1++; }\n      }\n      return degree$1\n    }\n  };\n  DirectedEdgeStar.prototype.getLabel = function getLabel () {\n    return this._label\n  };\n  DirectedEdgeStar.prototype.findCoveredLineEdges = function findCoveredLineEdges () {\n    var startLoc = Location.NONE;\n    for (var it = this.iterator(); it.hasNext();) {\n      var nextOut = it.next();\n      var nextIn = nextOut.getSym();\n      if (!nextOut.isLineEdge()) {\n        if (nextOut.isInResult()) {\n          startLoc = Location.INTERIOR;\n          break\n        }\n        if (nextIn.isInResult()) {\n          startLoc = Location.EXTERIOR;\n          break\n        }\n      }\n    }\n    if (startLoc === Location.NONE) { return null }\n    var currLoc = startLoc;\n    for (var it$1 = this.iterator(); it$1.hasNext();) {\n      var nextOut$1 = it$1.next();\n      var nextIn$1 = nextOut$1.getSym();\n      if (nextOut$1.isLineEdge()) {\n        nextOut$1.getEdge().setCovered(currLoc === Location.INTERIOR);\n      } else {\n        if (nextOut$1.isInResult()) { currLoc = Location.EXTERIOR; }\n        if (nextIn$1.isInResult()) { currLoc = Location.INTERIOR; }\n      }\n    }\n  };\n  DirectedEdgeStar.prototype.computeLabelling = function computeLabelling (geom) {\n    var this$1 = this;\n\n    EdgeEndStar$$1.prototype.computeLabelling.call(this, geom);\n    this._label = new Label(Location.NONE);\n    for (var it = this.iterator(); it.hasNext();) {\n      var ee = it.next();\n      var e = ee.getEdge();\n      var eLabel = e.getLabel();\n      for (var i = 0; i < 2; i++) {\n        var eLoc = eLabel.getLocation(i);\n        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) { this$1._label.setLocation(i, Location.INTERIOR); }\n      }\n    }\n  };\n  DirectedEdgeStar.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  DirectedEdgeStar.prototype.getClass = function getClass () {\n    return DirectedEdgeStar\n  };\n\n  return DirectedEdgeStar;\n}(EdgeEndStar));\n\nvar OverlayNodeFactory = (function (NodeFactory$$1) {\n  function OverlayNodeFactory () {\n    NodeFactory$$1.apply(this, arguments);\n  }\n\n  if ( NodeFactory$$1 ) OverlayNodeFactory.__proto__ = NodeFactory$$1;\n  OverlayNodeFactory.prototype = Object.create( NodeFactory$$1 && NodeFactory$$1.prototype );\n  OverlayNodeFactory.prototype.constructor = OverlayNodeFactory;\n\n  OverlayNodeFactory.prototype.createNode = function createNode (coord) {\n    return new Node(coord, new DirectedEdgeStar())\n  };\n  OverlayNodeFactory.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  OverlayNodeFactory.prototype.getClass = function getClass () {\n    return OverlayNodeFactory\n  };\n\n  return OverlayNodeFactory;\n}(NodeFactory));\n\nvar OrientedCoordinateArray = function OrientedCoordinateArray () {\n  this._pts = null;\n  this._orientation = null;\n  var pts = arguments[0];\n  this._pts = pts;\n  this._orientation = OrientedCoordinateArray.orientation(pts);\n};\nOrientedCoordinateArray.prototype.compareTo = function compareTo (o1) {\n  var oca = o1;\n  var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);\n  return comp\n};\nOrientedCoordinateArray.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nOrientedCoordinateArray.prototype.getClass = function getClass () {\n  return OrientedCoordinateArray\n};\nOrientedCoordinateArray.orientation = function orientation (pts) {\n  return CoordinateArrays.increasingDirection(pts) === 1\n};\nOrientedCoordinateArray.compareOriented = function compareOriented (pts1, orientation1, pts2, orientation2) {\n  var dir1 = orientation1 ? 1 : -1;\n  var dir2 = orientation2 ? 1 : -1;\n  var limit1 = orientation1 ? pts1.length : -1;\n  var limit2 = orientation2 ? pts2.length : -1;\n  var i1 = orientation1 ? 0 : pts1.length - 1;\n  var i2 = orientation2 ? 0 : pts2.length - 1;\n  // const comp = 0\n  while (true) {\n    var compPt = pts1[i1].compareTo(pts2[i2]);\n    if (compPt !== 0) { return compPt }\n    i1 += dir1;\n    i2 += dir2;\n    var done1 = i1 === limit1;\n    var done2 = i2 === limit2;\n    if (done1 && !done2) { return -1 }\n    if (!done1 && done2) { return 1 }\n    if (done1 && done2) { return 0 }\n  }\n};\n\nvar EdgeList = function EdgeList () {\n  this._edges = new ArrayList();\n  this._ocaMap = new TreeMap();\n};\nEdgeList.prototype.print = function print (out) {\n    var this$1 = this;\n\n  out.print('MULTILINESTRING ( ');\n  for (var j = 0; j < this._edges.size(); j++) {\n    var e = this$1._edges.get(j);\n    if (j > 0) { out.print(','); }\n    out.print('(');\n    var pts = e.getCoordinates();\n    for (var i = 0; i < pts.length; i++) {\n      if (i > 0) { out.print(','); }\n      out.print(pts[i].x + ' ' + pts[i].y);\n    }\n    out.println(')');\n  }\n  out.print(')  ');\n};\nEdgeList.prototype.addAll = function addAll (edgeColl) {\n    var this$1 = this;\n\n  for (var i = edgeColl.iterator(); i.hasNext();) {\n    this$1.add(i.next());\n  }\n};\nEdgeList.prototype.findEdgeIndex = function findEdgeIndex (e) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edges.size(); i++) {\n    if (this$1._edges.get(i).equals(e)) { return i }\n  }\n  return -1\n};\nEdgeList.prototype.iterator = function iterator () {\n  return this._edges.iterator()\n};\nEdgeList.prototype.getEdges = function getEdges () {\n  return this._edges\n};\nEdgeList.prototype.get = function get (i) {\n  return this._edges.get(i)\n};\nEdgeList.prototype.findEqualEdge = function findEqualEdge (e) {\n  var oca = new OrientedCoordinateArray(e.getCoordinates());\n  var matchEdge = this._ocaMap.get(oca);\n  return matchEdge\n};\nEdgeList.prototype.add = function add (e) {\n  this._edges.add(e);\n  var oca = new OrientedCoordinateArray(e.getCoordinates());\n  this._ocaMap.put(oca, e);\n};\nEdgeList.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeList.prototype.getClass = function getClass () {\n  return EdgeList\n};\n\nvar SegmentIntersector = function SegmentIntersector () {};\n\nSegmentIntersector.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {};\nSegmentIntersector.prototype.isDone = function isDone () {};\nSegmentIntersector.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentIntersector.prototype.getClass = function getClass () {\n  return SegmentIntersector\n};\n\nvar IntersectionAdder = function IntersectionAdder () {\n  this._hasIntersection = false;\n  this._hasProper = false;\n  this._hasProperInterior = false;\n  this._hasInterior = false;\n  this._properIntersectionPoint = null;\n  this._li = null;\n  this._isSelfIntersection = null;\n  this.numIntersections = 0;\n  this.numInteriorIntersections = 0;\n  this.numProperIntersections = 0;\n  this.numTests = 0;\n  var li = arguments[0];\n  this._li = li;\n};\nIntersectionAdder.prototype.isTrivialIntersection = function isTrivialIntersection (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1) {\n    if (this._li.getIntersectionNum() === 1) {\n      if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) { return true }\n      if (e0.isClosed()) {\n        var maxSegIndex = e0.size() - 1;\n        if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||\n            (segIndex1 === 0 && segIndex0 === maxSegIndex)) {\n          return true\n        }\n      }\n    }\n  }\n  return false\n};\nIntersectionAdder.prototype.getProperIntersectionPoint = function getProperIntersectionPoint () {\n  return this._properIntersectionPoint\n};\nIntersectionAdder.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection () {\n  return this._hasProperInterior\n};\nIntersectionAdder.prototype.getLineIntersector = function getLineIntersector () {\n  return this._li\n};\nIntersectionAdder.prototype.hasProperIntersection = function hasProperIntersection () {\n  return this._hasProper\n};\nIntersectionAdder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  this.numTests++;\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    this.numIntersections++;\n    if (this._li.isInteriorIntersection()) {\n      this.numInteriorIntersections++;\n      this._hasInterior = true;\n    }\n    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n      this._hasIntersection = true;\n      e0.addIntersections(this._li, segIndex0, 0);\n      e1.addIntersections(this._li, segIndex1, 1);\n      if (this._li.isProper()) {\n        this.numProperIntersections++;\n        this._hasProper = true;\n        this._hasProperInterior = true;\n      }\n    }\n  }\n};\nIntersectionAdder.prototype.hasIntersection = function hasIntersection () {\n  return this._hasIntersection\n};\nIntersectionAdder.prototype.isDone = function isDone () {\n  return false\n};\nIntersectionAdder.prototype.hasInteriorIntersection = function hasInteriorIntersection () {\n  return this._hasInterior\n};\nIntersectionAdder.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentIntersector]\n};\nIntersectionAdder.prototype.getClass = function getClass () {\n  return IntersectionAdder\n};\nIntersectionAdder.isAdjacentSegments = function isAdjacentSegments (i1, i2) {\n  return Math.abs(i1 - i2) === 1\n};\n\nvar EdgeIntersection = function EdgeIntersection () {\n  this.coord = null;\n  this.segmentIndex = null;\n  this.dist = null;\n  var coord = arguments[0];\n  var segmentIndex = arguments[1];\n  var dist = arguments[2];\n  this.coord = new Coordinate(coord);\n  this.segmentIndex = segmentIndex;\n  this.dist = dist;\n};\nEdgeIntersection.prototype.getSegmentIndex = function getSegmentIndex () {\n  return this.segmentIndex\n};\nEdgeIntersection.prototype.getCoordinate = function getCoordinate () {\n  return this.coord\n};\nEdgeIntersection.prototype.print = function print (out) {\n  out.print(this.coord);\n  out.print(' seg # = ' + this.segmentIndex);\n  out.println(' dist = ' + this.dist);\n};\nEdgeIntersection.prototype.compareTo = function compareTo (obj) {\n  var other = obj;\n  return this.compare(other.segmentIndex, other.dist)\n};\nEdgeIntersection.prototype.isEndPoint = function isEndPoint (maxSegmentIndex) {\n  if (this.segmentIndex === 0 && this.dist === 0.0) { return true }\n  if (this.segmentIndex === maxSegmentIndex) { return true }\n  return false\n};\nEdgeIntersection.prototype.toString = function toString () {\n  return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist\n};\nEdgeIntersection.prototype.getDistance = function getDistance () {\n  return this.dist\n};\nEdgeIntersection.prototype.compare = function compare (segmentIndex, dist) {\n  if (this.segmentIndex < segmentIndex) { return -1 }\n  if (this.segmentIndex > segmentIndex) { return 1 }\n  if (this.dist < dist) { return -1 }\n  if (this.dist > dist) { return 1 }\n  return 0\n};\nEdgeIntersection.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nEdgeIntersection.prototype.getClass = function getClass () {\n  return EdgeIntersection\n};\n\nvar EdgeIntersectionList = function EdgeIntersectionList () {\n  this._nodeMap = new TreeMap();\n  this.edge = null;\n  var edge = arguments[0];\n  this.edge = edge;\n};\nEdgeIntersectionList.prototype.print = function print (out) {\n  out.println('Intersections:');\n  for (var it = this.iterator(); it.hasNext();) {\n    var ei = it.next();\n    ei.print(out);\n  }\n};\nEdgeIntersectionList.prototype.iterator = function iterator () {\n  return this._nodeMap.values().iterator()\n};\nEdgeIntersectionList.prototype.addSplitEdges = function addSplitEdges (edgeList) {\n    var this$1 = this;\n\n  this.addEndpoints();\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    var newEdge = this$1.createSplitEdge(eiPrev, ei);\n    edgeList.add(newEdge);\n    eiPrev = ei;\n  }\n};\nEdgeIntersectionList.prototype.addEndpoints = function addEndpoints () {\n  var maxSegIndex = this.edge.pts.length - 1;\n  this.add(this.edge.pts[0], 0, 0.0);\n  this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n};\nEdgeIntersectionList.prototype.createSplitEdge = function createSplitEdge (ei0, ei1) {\n    var this$1 = this;\n\n  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  var lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n  var useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n  if (!useIntPt1) {\n    npts--;\n  }\n  var pts = new Array(npts).fill(null);\n  var ipt = 0;\n  pts[ipt++] = new Coordinate(ei0.coord);\n  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n    pts[ipt++] = this$1.edge.pts[i];\n  }\n  if (useIntPt1) { pts[ipt] = ei1.coord; }\n  return new Edge(pts, new Label(this.edge._label))\n};\nEdgeIntersectionList.prototype.add = function add (intPt, segmentIndex, dist) {\n  var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n  var ei = this._nodeMap.get(eiNew);\n  if (ei !== null) {\n    return ei\n  }\n  this._nodeMap.put(eiNew, eiNew);\n  return eiNew\n};\nEdgeIntersectionList.prototype.isIntersection = function isIntersection (pt) {\n  for (var it = this.iterator(); it.hasNext();) {\n    var ei = it.next();\n    if (ei.coord.equals(pt)) { return true }\n  }\n  return false\n};\nEdgeIntersectionList.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeIntersectionList.prototype.getClass = function getClass () {\n  return EdgeIntersectionList\n};\n\nvar MonotoneChainIndexer = function MonotoneChainIndexer () {};\n\nMonotoneChainIndexer.prototype.getChainStartIndices = function getChainStartIndices (pts) {\n    var this$1 = this;\n\n  var start = 0;\n  var startIndexList = new ArrayList();\n  startIndexList.add(new Integer(start));\n  do {\n    var last = this$1.findChainEnd(pts, start);\n    startIndexList.add(new Integer(last));\n    start = last;\n  } while (start < pts.length - 1)\n  var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n  return startIndex\n};\nMonotoneChainIndexer.prototype.findChainEnd = function findChainEnd (pts, start) {\n  var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n  var last = start + 1;\n  while (last < pts.length) {\n    var quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n    if (quad !== chainQuad) { break }\n    last++;\n  }\n  return last - 1\n};\nMonotoneChainIndexer.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainIndexer.prototype.getClass = function getClass () {\n  return MonotoneChainIndexer\n};\nMonotoneChainIndexer.toIntArray = function toIntArray (list) {\n  var array = new Array(list.size()).fill(null);\n  for (var i = 0; i < array.length; i++) {\n    array[i] = list.get(i).intValue();\n  }\n  return array\n};\n\nvar MonotoneChainEdge = function MonotoneChainEdge () {\n  this.e = null;\n  this.pts = null;\n  this.startIndex = null;\n  this.env1 = new Envelope();\n  this.env2 = new Envelope();\n  var e = arguments[0];\n  this.e = e;\n  this.pts = e.getCoordinates();\n  var mcb = new MonotoneChainIndexer();\n  this.startIndex = mcb.getChainStartIndices(this.pts);\n};\nMonotoneChainEdge.prototype.getCoordinates = function getCoordinates () {\n  return this.pts\n};\nMonotoneChainEdge.prototype.getMaxX = function getMaxX (chainIndex) {\n  var x1 = this.pts[this.startIndex[chainIndex]].x;\n  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n  return x1 > x2 ? x1 : x2\n};\nMonotoneChainEdge.prototype.getMinX = function getMinX (chainIndex) {\n  var x1 = this.pts[this.startIndex[chainIndex]].x;\n  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n  return x1 < x2 ? x1 : x2\n};\nMonotoneChainEdge.prototype.computeIntersectsForChain = function computeIntersectsForChain () {\n  if (arguments.length === 4) {\n    var chainIndex0 = arguments[0];\n    var mce = arguments[1];\n    var chainIndex1 = arguments[2];\n    var si = arguments[3];\n    this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n  } else if (arguments.length === 6) {\n    var start0 = arguments[0];\n    var end0 = arguments[1];\n    var mce$1 = arguments[2];\n    var start1 = arguments[3];\n    var end1 = arguments[4];\n    var ei = arguments[5];\n    var p00 = this.pts[start0];\n    var p01 = this.pts[end0];\n    var p10 = mce$1.pts[start1];\n    var p11 = mce$1.pts[end1];\n    if (end0 - start0 === 1 && end1 - start1 === 1) {\n      ei.addIntersections(this.e, start0, mce$1.e, start1);\n      return null\n    }\n    this.env1.init(p00, p01);\n    this.env2.init(p10, p11);\n    if (!this.env1.intersects(this.env2)) { return null }\n    var mid0 = Math.trunc((start0 + end0) / 2);\n    var mid1 = Math.trunc((start1 + end1) / 2);\n    if (start0 < mid0) {\n      if (start1 < mid1) { this.computeIntersectsForChain(start0, mid0, mce$1, start1, mid1, ei); }\n      if (mid1 < end1) { this.computeIntersectsForChain(start0, mid0, mce$1, mid1, end1, ei); }\n    }\n    if (mid0 < end0) {\n      if (start1 < mid1) { this.computeIntersectsForChain(mid0, end0, mce$1, start1, mid1, ei); }\n      if (mid1 < end1) { this.computeIntersectsForChain(mid0, end0, mce$1, mid1, end1, ei); }\n    }\n  }\n};\nMonotoneChainEdge.prototype.getStartIndexes = function getStartIndexes () {\n  return this.startIndex\n};\nMonotoneChainEdge.prototype.computeIntersects = function computeIntersects (mce, si) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.startIndex.length - 1; i++) {\n    for (var j = 0; j < mce.startIndex.length - 1; j++) {\n      this$1.computeIntersectsForChain(i, mce, j, si);\n    }\n  }\n};\nMonotoneChainEdge.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainEdge.prototype.getClass = function getClass () {\n  return MonotoneChainEdge\n};\n\nvar Depth = function Depth () {\n  var this$1 = this;\n\n  this._depth = Array(2).fill().map(function () { return Array(3); });\n  for (var i = 0; i < 2; i++) {\n    for (var j = 0; j < 3; j++) {\n      this$1._depth[i][j] = Depth.NULL_VALUE;\n    }\n  }\n};\n\nvar staticAccessors$31 = { NULL_VALUE: { configurable: true } };\nDepth.prototype.getDepth = function getDepth (geomIndex, posIndex) {\n  return this._depth[geomIndex][posIndex]\n};\nDepth.prototype.setDepth = function setDepth (geomIndex, posIndex, depthValue) {\n  this._depth[geomIndex][posIndex] = depthValue;\n};\nDepth.prototype.isNull = function isNull () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = 0; i < 2; i++) {\n      for (var j = 0; j < 3; j++) {\n        if (this$1._depth[i][j] !== Depth.NULL_VALUE) { return false }\n      }\n    }\n    return true\n  } else if (arguments.length === 1) {\n    var geomIndex = arguments[0];\n    return this._depth[geomIndex][1] === Depth.NULL_VALUE\n  } else if (arguments.length === 2) {\n    var geomIndex$1 = arguments[0];\n    var posIndex = arguments[1];\n    return this._depth[geomIndex$1][posIndex] === Depth.NULL_VALUE\n  }\n};\nDepth.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n  for (var i = 0; i < 2; i++) {\n    if (!this$1.isNull(i)) {\n      var minDepth = this$1._depth[i][1];\n      if (this$1._depth[i][2] < minDepth) { minDepth = this$1._depth[i][2]; }\n      if (minDepth < 0) { minDepth = 0; }\n      for (var j = 1; j < 3; j++) {\n        var newValue = 0;\n        if (this$1._depth[i][j] > minDepth) { newValue = 1; }\n        this$1._depth[i][j] = newValue;\n      }\n    }\n  }\n};\nDepth.prototype.getDelta = function getDelta (geomIndex) {\n  return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT]\n};\nDepth.prototype.getLocation = function getLocation (geomIndex, posIndex) {\n  if (this._depth[geomIndex][posIndex] <= 0) { return Location.EXTERIOR }\n  return Location.INTERIOR\n};\nDepth.prototype.toString = function toString () {\n  return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2]\n};\nDepth.prototype.add = function add () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var lbl = arguments[0];\n    for (var i = 0; i < 2; i++) {\n      for (var j = 1; j < 3; j++) {\n        var loc = lbl.getLocation(i, j);\n        if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n          if (this$1.isNull(i, j)) {\n            this$1._depth[i][j] = Depth.depthAtLocation(loc);\n          } else { this$1._depth[i][j] += Depth.depthAtLocation(loc); }\n        }\n      }\n    }\n  } else if (arguments.length === 3) {\n    var geomIndex = arguments[0];\n    var posIndex = arguments[1];\n    var location = arguments[2];\n    if (location === Location.INTERIOR) { this._depth[geomIndex][posIndex]++; }\n  }\n};\nDepth.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDepth.prototype.getClass = function getClass () {\n  return Depth\n};\nDepth.depthAtLocation = function depthAtLocation (location) {\n  if (location === Location.EXTERIOR) { return 0 }\n  if (location === Location.INTERIOR) { return 1 }\n  return Depth.NULL_VALUE\n};\nstaticAccessors$31.NULL_VALUE.get = function () { return -1 };\n\nObject.defineProperties( Depth, staticAccessors$31 );\n\nvar Edge = (function (GraphComponent$$1) {\n  function Edge () {\n    GraphComponent$$1.call(this);\n    this.pts = null;\n    this._env = null;\n    this.eiList = new EdgeIntersectionList(this);\n    this._name = null;\n    this._mce = null;\n    this._isIsolated = true;\n    this._depth = new Depth();\n    this._depthDelta = 0;\n    if (arguments.length === 1) {\n      var pts = arguments[0];\n      Edge.call(this, pts, null);\n    } else if (arguments.length === 2) {\n      var pts$1 = arguments[0];\n      var label = arguments[1];\n      this.pts = pts$1;\n      this._label = label;\n    }\n  }\n\n  if ( GraphComponent$$1 ) Edge.__proto__ = GraphComponent$$1;\n  Edge.prototype = Object.create( GraphComponent$$1 && GraphComponent$$1.prototype );\n  Edge.prototype.constructor = Edge;\n  Edge.prototype.getDepth = function getDepth () {\n    return this._depth\n  };\n  Edge.prototype.getCollapsedEdge = function getCollapsedEdge () {\n    var newPts = new Array(2).fill(null);\n    newPts[0] = this.pts[0];\n    newPts[1] = this.pts[1];\n    var newe = new Edge(newPts, Label.toLineLabel(this._label));\n    return newe\n  };\n  Edge.prototype.isIsolated = function isIsolated () {\n    return this._isIsolated\n  };\n  Edge.prototype.getCoordinates = function getCoordinates () {\n    return this.pts\n  };\n  Edge.prototype.setIsolated = function setIsolated (isIsolated) {\n    this._isIsolated = isIsolated;\n  };\n  Edge.prototype.setName = function setName (name) {\n    this._name = name;\n  };\n  Edge.prototype.equals = function equals (o) {\n    var this$1 = this;\n\n    if (!(o instanceof Edge)) { return false }\n    var e = o;\n    if (this.pts.length !== e.pts.length) { return false }\n    var isEqualForward = true;\n    var isEqualReverse = true;\n    var iRev = this.pts.length;\n    for (var i = 0; i < this.pts.length; i++) {\n      if (!this$1.pts[i].equals2D(e.pts[i])) {\n        isEqualForward = false;\n      }\n      if (!this$1.pts[i].equals2D(e.pts[--iRev])) {\n        isEqualReverse = false;\n      }\n      if (!isEqualForward && !isEqualReverse) { return false }\n    }\n    return true\n  };\n  Edge.prototype.getCoordinate = function getCoordinate () {\n    if (arguments.length === 0) {\n      if (this.pts.length > 0) { return this.pts[0] }\n      return null\n    } else if (arguments.length === 1) {\n      var i = arguments[0];\n      return this.pts[i]\n    }\n  };\n  Edge.prototype.print = function print (out) {\n    var this$1 = this;\n\n    out.print('edge ' + this._name + ': ');\n    out.print('LINESTRING (');\n    for (var i = 0; i < this.pts.length; i++) {\n      if (i > 0) { out.print(','); }\n      out.print(this$1.pts[i].x + ' ' + this$1.pts[i].y);\n    }\n    out.print(')  ' + this._label + ' ' + this._depthDelta);\n  };\n  Edge.prototype.computeIM = function computeIM (im) {\n    Edge.updateIM(this._label, im);\n  };\n  Edge.prototype.isCollapsed = function isCollapsed () {\n    if (!this._label.isArea()) { return false }\n    if (this.pts.length !== 3) { return false }\n    if (this.pts[0].equals(this.pts[2])) { return true }\n    return false\n  };\n  Edge.prototype.isClosed = function isClosed () {\n    return this.pts[0].equals(this.pts[this.pts.length - 1])\n  };\n  Edge.prototype.getMaximumSegmentIndex = function getMaximumSegmentIndex () {\n    return this.pts.length - 1\n  };\n  Edge.prototype.getDepthDelta = function getDepthDelta () {\n    return this._depthDelta\n  };\n  Edge.prototype.getNumPoints = function getNumPoints () {\n    return this.pts.length\n  };\n  Edge.prototype.printReverse = function printReverse (out) {\n    var this$1 = this;\n\n    out.print('edge ' + this._name + ': ');\n    for (var i = this.pts.length - 1; i >= 0; i--) {\n      out.print(this$1.pts[i] + ' ');\n    }\n    out.println('');\n  };\n  Edge.prototype.getMonotoneChainEdge = function getMonotoneChainEdge () {\n    if (this._mce === null) { this._mce = new MonotoneChainEdge(this); }\n    return this._mce\n  };\n  Edge.prototype.getEnvelope = function getEnvelope () {\n    var this$1 = this;\n\n    if (this._env === null) {\n      this._env = new Envelope();\n      for (var i = 0; i < this.pts.length; i++) {\n        this$1._env.expandToInclude(this$1.pts[i]);\n      }\n    }\n    return this._env\n  };\n  Edge.prototype.addIntersection = function addIntersection (li, segmentIndex, geomIndex, intIndex) {\n    var intPt = new Coordinate(li.getIntersection(intIndex));\n    var normalizedSegmentIndex = segmentIndex;\n    var dist = li.getEdgeDistance(geomIndex, intIndex);\n    var nextSegIndex = normalizedSegmentIndex + 1;\n    if (nextSegIndex < this.pts.length) {\n      var nextPt = this.pts[nextSegIndex];\n      if (intPt.equals2D(nextPt)) {\n        normalizedSegmentIndex = nextSegIndex;\n        dist = 0.0;\n      }\n    }\n    this.eiList.add(intPt, normalizedSegmentIndex, dist);\n  };\n  Edge.prototype.toString = function toString () {\n    var this$1 = this;\n\n    var buf = new StringBuffer();\n    buf.append('edge ' + this._name + ': ');\n    buf.append('LINESTRING (');\n    for (var i = 0; i < this.pts.length; i++) {\n      if (i > 0) { buf.append(','); }\n      buf.append(this$1.pts[i].x + ' ' + this$1.pts[i].y);\n    }\n    buf.append(')  ' + this._label + ' ' + this._depthDelta);\n    return buf.toString()\n  };\n  Edge.prototype.isPointwiseEqual = function isPointwiseEqual (e) {\n    var this$1 = this;\n\n    if (this.pts.length !== e.pts.length) { return false }\n    for (var i = 0; i < this.pts.length; i++) {\n      if (!this$1.pts[i].equals2D(e.pts[i])) {\n        return false\n      }\n    }\n    return true\n  };\n  Edge.prototype.setDepthDelta = function setDepthDelta (depthDelta) {\n    this._depthDelta = depthDelta;\n  };\n  Edge.prototype.getEdgeIntersectionList = function getEdgeIntersectionList () {\n    return this.eiList\n  };\n  Edge.prototype.addIntersections = function addIntersections (li, segmentIndex, geomIndex) {\n    var this$1 = this;\n\n    for (var i = 0; i < li.getIntersectionNum(); i++) {\n      this$1.addIntersection(li, segmentIndex, geomIndex, i);\n    }\n  };\n  Edge.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  Edge.prototype.getClass = function getClass () {\n    return Edge\n  };\n  Edge.updateIM = function updateIM () {\n    if (arguments.length === 2) {\n      var label = arguments[0];\n      var im = arguments[1];\n      im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n      if (label.isArea()) {\n        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n      }\n    } else { return GraphComponent$$1.prototype.updateIM.apply(this, arguments) }\n  };\n\n  return Edge;\n}(GraphComponent));\n\nvar BufferBuilder = function BufferBuilder (bufParams) {\n  this._workingPrecisionModel = null;\n  this._workingNoder = null;\n  this._geomFact = null;\n  this._graph = null;\n  this._edgeList = new EdgeList();\n  this._bufParams = bufParams || null;\n};\nBufferBuilder.prototype.setWorkingPrecisionModel = function setWorkingPrecisionModel (pm) {\n  this._workingPrecisionModel = pm;\n};\nBufferBuilder.prototype.insertUniqueEdge = function insertUniqueEdge (e) {\n  var existingEdge = this._edgeList.findEqualEdge(e);\n  if (existingEdge !== null) {\n    var existingLabel = existingEdge.getLabel();\n    var labelToMerge = e.getLabel();\n    if (!existingEdge.isPointwiseEqual(e)) {\n      labelToMerge = new Label(e.getLabel());\n      labelToMerge.flip();\n    }\n    existingLabel.merge(labelToMerge);\n    var mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n    var existingDelta = existingEdge.getDepthDelta();\n    var newDelta = existingDelta + mergeDelta;\n    existingEdge.setDepthDelta(newDelta);\n  } else {\n    this._edgeList.add(e);\n    e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n  }\n};\nBufferBuilder.prototype.buildSubgraphs = function buildSubgraphs (subgraphList, polyBuilder) {\n  var processedGraphs = new ArrayList();\n  for (var i = subgraphList.iterator(); i.hasNext();) {\n    var subgraph = i.next();\n    var p = subgraph.getRightmostCoordinate();\n    var locater = new SubgraphDepthLocater(processedGraphs);\n    var outsideDepth = locater.getDepth(p);\n    subgraph.computeDepth(outsideDepth);\n    subgraph.findResultEdges();\n    processedGraphs.add(subgraph);\n    polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n  }\n};\nBufferBuilder.prototype.createSubgraphs = function createSubgraphs (graph) {\n  var subgraphList = new ArrayList();\n  for (var i = graph.getNodes().iterator(); i.hasNext();) {\n    var node = i.next();\n    if (!node.isVisited()) {\n      var subgraph = new BufferSubgraph();\n      subgraph.create(node);\n      subgraphList.add(subgraph);\n    }\n  }\n  Collections.sort(subgraphList, Collections.reverseOrder());\n  return subgraphList\n};\nBufferBuilder.prototype.createEmptyResultGeometry = function createEmptyResultGeometry () {\n  var emptyGeom = this._geomFact.createPolygon();\n  return emptyGeom\n};\nBufferBuilder.prototype.getNoder = function getNoder (precisionModel) {\n  if (this._workingNoder !== null) { return this._workingNoder }\n  var noder = new MCIndexNoder();\n  var li = new RobustLineIntersector();\n  li.setPrecisionModel(precisionModel);\n  noder.setSegmentIntersector(new IntersectionAdder(li));\n  return noder\n};\nBufferBuilder.prototype.buffer = function buffer (g, distance) {\n  var precisionModel = this._workingPrecisionModel;\n  if (precisionModel === null) { precisionModel = g.getPrecisionModel(); }\n  this._geomFact = g.getFactory();\n  var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);\n  var curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n  var bufferSegStrList = curveSetBuilder.getCurves();\n  if (bufferSegStrList.size() <= 0) {\n    return this.createEmptyResultGeometry()\n  }\n  this.computeNodedEdges(bufferSegStrList, precisionModel);\n  this._graph = new PlanarGraph(new OverlayNodeFactory());\n  this._graph.addEdges(this._edgeList.getEdges());\n  var subgraphList = this.createSubgraphs(this._graph);\n  var polyBuilder = new PolygonBuilder(this._geomFact);\n  this.buildSubgraphs(subgraphList, polyBuilder);\n  var resultPolyList = polyBuilder.getPolygons();\n  if (resultPolyList.size() <= 0) {\n    return this.createEmptyResultGeometry()\n  }\n  var resultGeom = this._geomFact.buildGeometry(resultPolyList);\n  return resultGeom\n};\nBufferBuilder.prototype.computeNodedEdges = function computeNodedEdges (bufferSegStrList, precisionModel) {\n    var this$1 = this;\n\n  var noder = this.getNoder(precisionModel);\n  noder.computeNodes(bufferSegStrList);\n  var nodedSegStrings = noder.getNodedSubstrings();\n  for (var i = nodedSegStrings.iterator(); i.hasNext();) {\n    var segStr = i.next();\n    var pts = segStr.getCoordinates();\n    if (pts.length === 2 && pts[0].equals2D(pts[1])) { continue }\n    var oldLabel = segStr.getData();\n    var edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n    this$1.insertUniqueEdge(edge);\n  }\n};\nBufferBuilder.prototype.setNoder = function setNoder (noder) {\n  this._workingNoder = noder;\n};\nBufferBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferBuilder.prototype.getClass = function getClass () {\n  return BufferBuilder\n};\nBufferBuilder.depthDelta = function depthDelta (label) {\n  var lLoc = label.getLocation(0, Position.LEFT);\n  var rLoc = label.getLocation(0, Position.RIGHT);\n  if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) { return 1; } else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) { return -1 }\n  return 0\n};\nBufferBuilder.convertSegStrings = function convertSegStrings (it) {\n  var fact = new GeometryFactory();\n  var lines = new ArrayList();\n  while (it.hasNext()) {\n    var ss = it.next();\n    var line = fact.createLineString(ss.getCoordinates());\n    lines.add(line);\n  }\n  return fact.buildGeometry(lines)\n};\n\nvar ScaledNoder = function ScaledNoder () {\n  this._noder = null;\n  this._scaleFactor = null;\n  this._offsetX = null;\n  this._offsetY = null;\n  this._isScaled = false;\n  if (arguments.length === 2) {\n    var noder = arguments[0];\n    var scaleFactor = arguments[1];\n    this._noder = noder;\n    this._scaleFactor = scaleFactor;\n    this._offsetX = 0.0;\n    this._offsetY = 0.0;\n    this._isScaled = !this.isIntegerPrecision();\n  } else if (arguments.length === 4) {\n    var noder$1 = arguments[0];\n    var scaleFactor$1 = arguments[1];\n    var offsetX = arguments[2];\n    var offsetY = arguments[3];\n    this._noder = noder$1;\n    this._scaleFactor = scaleFactor$1;\n    this._offsetX = offsetX;\n    this._offsetY = offsetY;\n    this._isScaled = !this.isIntegerPrecision();\n  }\n};\nScaledNoder.prototype.rescale = function rescale () {\n    var this$1 = this;\n\n  if (hasInterface(arguments[0], Collection)) {\n    var segStrings = arguments[0];\n    for (var i = segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      this$1.rescale(ss.getCoordinates());\n    }\n  } else if (arguments[0] instanceof Array) {\n    var pts = arguments[0];\n    // let p0 = null\n    // let p1 = null\n    // if (pts.length === 2) {\n    // p0 = new Coordinate(pts[0])\n    // p1 = new Coordinate(pts[1])\n    // }\n    for (var i$1 = 0; i$1 < pts.length; i$1++) {\n      pts[i$1].x = pts[i$1].x / this$1._scaleFactor + this$1._offsetX;\n      pts[i$1].y = pts[i$1].y / this$1._scaleFactor + this$1._offsetY;\n    }\n    if (pts.length === 2 && pts[0].equals2D(pts[1])) {\n      System.out.println(pts);\n    }\n  }\n};\nScaledNoder.prototype.scale = function scale () {\n    var this$1 = this;\n\n  if (hasInterface(arguments[0], Collection)) {\n    var segStrings = arguments[0];\n    var nodedSegmentStrings = new ArrayList();\n    for (var i = segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      nodedSegmentStrings.add(new NodedSegmentString(this$1.scale(ss.getCoordinates()), ss.getData()));\n    }\n    return nodedSegmentStrings\n  } else if (arguments[0] instanceof Array) {\n    var pts = arguments[0];\n    var roundPts = new Array(pts.length).fill(null);\n    for (var i$1 = 0; i$1 < pts.length; i$1++) {\n      roundPts[i$1] = new Coordinate(Math.round((pts[i$1].x - this$1._offsetX) * this$1._scaleFactor), Math.round((pts[i$1].y - this$1._offsetY) * this$1._scaleFactor), pts[i$1].z);\n    }\n    var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n    return roundPtsNoDup\n  }\n};\nScaledNoder.prototype.isIntegerPrecision = function isIntegerPrecision () {\n  return this._scaleFactor === 1.0\n};\nScaledNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {\n  var splitSS = this._noder.getNodedSubstrings();\n  if (this._isScaled) { this.rescale(splitSS); }\n  return splitSS\n};\nScaledNoder.prototype.computeNodes = function computeNodes (inputSegStrings) {\n  var intSegStrings = inputSegStrings;\n  if (this._isScaled) { intSegStrings = this.scale(inputSegStrings); }\n  this._noder.computeNodes(intSegStrings);\n};\nScaledNoder.prototype.interfaces_ = function interfaces_ () {\n  return [Noder]\n};\nScaledNoder.prototype.getClass = function getClass () {\n  return ScaledNoder\n};\n\nvar NodingValidator = function NodingValidator () {\n  this._li = new RobustLineIntersector();\n  this._segStrings = null;\n  var segStrings = arguments[0];\n  this._segStrings = segStrings;\n};\n\nvar staticAccessors$33 = { fact: { configurable: true } };\nNodingValidator.prototype.checkEndPtVertexIntersections = function checkEndPtVertexIntersections () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = this._segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      var pts = ss.getCoordinates();\n      this$1.checkEndPtVertexIntersections(pts[0], this$1._segStrings);\n      this$1.checkEndPtVertexIntersections(pts[pts.length - 1], this$1._segStrings);\n    }\n  } else if (arguments.length === 2) {\n    var testPt = arguments[0];\n    var segStrings = arguments[1];\n    for (var i$1 = segStrings.iterator(); i$1.hasNext();) {\n      var ss$1 = i$1.next();\n      var pts$1 = ss$1.getCoordinates();\n      for (var j = 1; j < pts$1.length - 1; j++) {\n        if (pts$1[j].equals(testPt)) { throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt) }\n      }\n    }\n  }\n};\nNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = this._segStrings.iterator(); i.hasNext();) {\n      var ss0 = i.next();\n      for (var j = this._segStrings.iterator(); j.hasNext();) {\n        var ss1 = j.next();\n        this$1.checkInteriorIntersections(ss0, ss1);\n      }\n    }\n  } else if (arguments.length === 2) {\n    var ss0$1 = arguments[0];\n    var ss1$1 = arguments[1];\n    var pts0 = ss0$1.getCoordinates();\n    var pts1 = ss1$1.getCoordinates();\n    for (var i0 = 0; i0 < pts0.length - 1; i0++) {\n      for (var i1 = 0; i1 < pts1.length - 1; i1++) {\n        this$1.checkInteriorIntersections(ss0$1, i0, ss1$1, i1);\n      }\n    }\n  } else if (arguments.length === 4) {\n    var e0 = arguments[0];\n    var segIndex0 = arguments[1];\n    var e1 = arguments[2];\n    var segIndex1 = arguments[3];\n    if (e0 === e1 && segIndex0 === segIndex1) { return null }\n    var p00 = e0.getCoordinates()[segIndex0];\n    var p01 = e0.getCoordinates()[segIndex0 + 1];\n    var p10 = e1.getCoordinates()[segIndex1];\n    var p11 = e1.getCoordinates()[segIndex1 + 1];\n    this._li.computeIntersection(p00, p01, p10, p11);\n    if (this._li.hasIntersection()) {\n      if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {\n        throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11)\n      }\n    }\n  }\n};\nNodingValidator.prototype.checkValid = function checkValid () {\n  this.checkEndPtVertexIntersections();\n  this.checkInteriorIntersections();\n  this.checkCollapses();\n};\nNodingValidator.prototype.checkCollapses = function checkCollapses () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = this._segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      this$1.checkCollapses(ss);\n    }\n  } else if (arguments.length === 1) {\n    var ss$1 = arguments[0];\n    var pts = ss$1.getCoordinates();\n    for (var i$1 = 0; i$1 < pts.length - 2; i$1++) {\n      this$1.checkCollapse(pts[i$1], pts[i$1 + 1], pts[i$1 + 2]);\n    }\n  }\n};\nNodingValidator.prototype.hasInteriorIntersection = function hasInteriorIntersection (li, p0, p1) {\n  for (var i = 0; i < li.getIntersectionNum(); i++) {\n    var intPt = li.getIntersection(i);\n    if (!(intPt.equals(p0) || intPt.equals(p1))) { return true }\n  }\n  return false\n};\nNodingValidator.prototype.checkCollapse = function checkCollapse (p0, p1, p2) {\n  if (p0.equals(p2)) { throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2])) }\n};\nNodingValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNodingValidator.prototype.getClass = function getClass () {\n  return NodingValidator\n};\nstaticAccessors$33.fact.get = function () { return new GeometryFactory() };\n\nObject.defineProperties( NodingValidator, staticAccessors$33 );\n\nvar HotPixel = function HotPixel () {\n  this._li = null;\n  this._pt = null;\n  this._originalPt = null;\n  this._ptScaled = null;\n  this._p0Scaled = null;\n  this._p1Scaled = null;\n  this._scaleFactor = null;\n  this._minx = null;\n  this._maxx = null;\n  this._miny = null;\n  this._maxy = null;\n  this._corner = new Array(4).fill(null);\n  this._safeEnv = null;\n  var pt = arguments[0];\n  var scaleFactor = arguments[1];\n  var li = arguments[2];\n  this._originalPt = pt;\n  this._pt = pt;\n  this._scaleFactor = scaleFactor;\n  this._li = li;\n  if (scaleFactor <= 0) { throw new IllegalArgumentException('Scale factor must be non-zero') }\n  if (scaleFactor !== 1.0) {\n    this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n    this._p0Scaled = new Coordinate();\n    this._p1Scaled = new Coordinate();\n  }\n  this.initCorners(this._pt);\n};\n\nvar staticAccessors$34 = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };\nHotPixel.prototype.intersectsScaled = function intersectsScaled (p0, p1) {\n  var segMinx = Math.min(p0.x, p1.x);\n  var segMaxx = Math.max(p0.x, p1.x);\n  var segMiny = Math.min(p0.y, p1.y);\n  var segMaxy = Math.max(p0.y, p1.y);\n  var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;\n  if (isOutsidePixelEnv) { return false }\n  var intersects = this.intersectsToleranceSquare(p0, p1);\n  Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');\n  return intersects\n};\nHotPixel.prototype.initCorners = function initCorners (pt) {\n  var tolerance = 0.5;\n  this._minx = pt.x - tolerance;\n  this._maxx = pt.x + tolerance;\n  this._miny = pt.y - tolerance;\n  this._maxy = pt.y + tolerance;\n  this._corner[0] = new Coordinate(this._maxx, this._maxy);\n  this._corner[1] = new Coordinate(this._minx, this._maxy);\n  this._corner[2] = new Coordinate(this._minx, this._miny);\n  this._corner[3] = new Coordinate(this._maxx, this._miny);\n};\nHotPixel.prototype.intersects = function intersects (p0, p1) {\n  if (this._scaleFactor === 1.0) { return this.intersectsScaled(p0, p1) }\n  this.copyScaled(p0, this._p0Scaled);\n  this.copyScaled(p1, this._p1Scaled);\n  return this.intersectsScaled(this._p0Scaled, this._p1Scaled)\n};\nHotPixel.prototype.scale = function scale (val) {\n  return Math.round(val * this._scaleFactor)\n};\nHotPixel.prototype.getCoordinate = function getCoordinate () {\n  return this._originalPt\n};\nHotPixel.prototype.copyScaled = function copyScaled (p, pScaled) {\n  pScaled.x = this.scale(p.x);\n  pScaled.y = this.scale(p.y);\n};\nHotPixel.prototype.getSafeEnvelope = function getSafeEnvelope () {\n  if (this._safeEnv === null) {\n    var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n    this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);\n  }\n  return this._safeEnv\n};\nHotPixel.prototype.intersectsPixelClosure = function intersectsPixelClosure (p0, p1) {\n  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n  if (this._li.hasIntersection()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n  if (this._li.hasIntersection()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n  if (this._li.hasIntersection()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n  if (this._li.hasIntersection()) { return true }\n  return false\n};\nHotPixel.prototype.intersectsToleranceSquare = function intersectsToleranceSquare (p0, p1) {\n  var intersectsLeft = false;\n  var intersectsBottom = false;\n  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n  if (this._li.isProper()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n  if (this._li.isProper()) { return true }\n  if (this._li.hasIntersection()) { intersectsLeft = true; }\n  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n  if (this._li.isProper()) { return true }\n  if (this._li.hasIntersection()) { intersectsBottom = true; }\n  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n  if (this._li.isProper()) { return true }\n  if (intersectsLeft && intersectsBottom) { return true }\n  if (p0.equals(this._pt)) { return true }\n  if (p1.equals(this._pt)) { return true }\n  return false\n};\nHotPixel.prototype.addSnappedNode = function addSnappedNode (segStr, segIndex) {\n  var p0 = segStr.getCoordinate(segIndex);\n  var p1 = segStr.getCoordinate(segIndex + 1);\n  if (this.intersects(p0, p1)) {\n    segStr.addIntersection(this.getCoordinate(), segIndex);\n    return true\n  }\n  return false\n};\nHotPixel.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nHotPixel.prototype.getClass = function getClass () {\n  return HotPixel\n};\nstaticAccessors$34.SAFE_ENV_EXPANSION_FACTOR.get = function () { return 0.75 };\n\nObject.defineProperties( HotPixel, staticAccessors$34 );\n\nvar MonotoneChainSelectAction = function MonotoneChainSelectAction () {\n  this.tempEnv1 = new Envelope();\n  this.selectedSegment = new LineSegment();\n};\nMonotoneChainSelectAction.prototype.select = function select () {\n  if (arguments.length === 1) {\n    // const seg = arguments[0]\n  } else if (arguments.length === 2) {\n    var mc = arguments[0];\n    var startIndex = arguments[1];\n    mc.getLineSegment(startIndex, this.selectedSegment);\n    this.select(this.selectedSegment);\n  }\n};\nMonotoneChainSelectAction.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainSelectAction.prototype.getClass = function getClass () {\n  return MonotoneChainSelectAction\n};\n\nvar MCIndexPointSnapper = function MCIndexPointSnapper () {\n  this._index = null;\n  var index = arguments[0];\n  this._index = index;\n};\n\nvar staticAccessors$35 = { HotPixelSnapAction: { configurable: true } };\nMCIndexPointSnapper.prototype.snap = function snap () {\n  if (arguments.length === 1) {\n    var hotPixel = arguments[0];\n    return this.snap(hotPixel, null, -1)\n  } else if (arguments.length === 3) {\n    var hotPixel$1 = arguments[0];\n    var parentEdge = arguments[1];\n    var hotPixelVertexIndex = arguments[2];\n    var pixelEnv = hotPixel$1.getSafeEnvelope();\n    var hotPixelSnapAction = new HotPixelSnapAction(hotPixel$1, parentEdge, hotPixelVertexIndex);\n    this._index.query(pixelEnv, {\n      interfaces_: function () {\n        return [ItemVisitor]\n      },\n      visitItem: function (item) {\n        var testChain = item;\n        testChain.select(pixelEnv, hotPixelSnapAction);\n      }\n    });\n    return hotPixelSnapAction.isNodeAdded()\n  }\n};\nMCIndexPointSnapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMCIndexPointSnapper.prototype.getClass = function getClass () {\n  return MCIndexPointSnapper\n};\nstaticAccessors$35.HotPixelSnapAction.get = function () { return HotPixelSnapAction };\n\nObject.defineProperties( MCIndexPointSnapper, staticAccessors$35 );\n\nvar HotPixelSnapAction = (function (MonotoneChainSelectAction$$1) {\n  function HotPixelSnapAction () {\n    MonotoneChainSelectAction$$1.call(this);\n    this._hotPixel = null;\n    this._parentEdge = null;\n    this._hotPixelVertexIndex = null;\n    this._isNodeAdded = false;\n    var hotPixel = arguments[0];\n    var parentEdge = arguments[1];\n    var hotPixelVertexIndex = arguments[2];\n    this._hotPixel = hotPixel;\n    this._parentEdge = parentEdge;\n    this._hotPixelVertexIndex = hotPixelVertexIndex;\n  }\n\n  if ( MonotoneChainSelectAction$$1 ) HotPixelSnapAction.__proto__ = MonotoneChainSelectAction$$1;\n  HotPixelSnapAction.prototype = Object.create( MonotoneChainSelectAction$$1 && MonotoneChainSelectAction$$1.prototype );\n  HotPixelSnapAction.prototype.constructor = HotPixelSnapAction;\n  HotPixelSnapAction.prototype.isNodeAdded = function isNodeAdded () {\n    return this._isNodeAdded\n  };\n  HotPixelSnapAction.prototype.select = function select () {\n    if (arguments.length === 2) {\n      var mc = arguments[0];\n      var startIndex = arguments[1];\n      var ss = mc.getContext();\n      if (this._parentEdge !== null) {\n        if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) { return null }\n      }\n      this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);\n    } else { return MonotoneChainSelectAction$$1.prototype.select.apply(this, arguments) }\n  };\n  HotPixelSnapAction.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  HotPixelSnapAction.prototype.getClass = function getClass () {\n    return HotPixelSnapAction\n  };\n\n  return HotPixelSnapAction;\n}(MonotoneChainSelectAction));\n\nvar InteriorIntersectionFinderAdder = function InteriorIntersectionFinderAdder () {\n  this._li = null;\n  this._interiorIntersections = null;\n  var li = arguments[0];\n  this._li = li;\n  this._interiorIntersections = new ArrayList();\n};\nInteriorIntersectionFinderAdder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {\n    var this$1 = this;\n\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    if (this._li.isInteriorIntersection()) {\n      for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {\n        this$1._interiorIntersections.add(this$1._li.getIntersection(intIndex));\n      }\n      e0.addIntersections(this._li, segIndex0, 0);\n      e1.addIntersections(this._li, segIndex1, 1);\n    }\n  }\n};\nInteriorIntersectionFinderAdder.prototype.isDone = function isDone () {\n  return false\n};\nInteriorIntersectionFinderAdder.prototype.getInteriorIntersections = function getInteriorIntersections () {\n  return this._interiorIntersections\n};\nInteriorIntersectionFinderAdder.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentIntersector]\n};\nInteriorIntersectionFinderAdder.prototype.getClass = function getClass () {\n  return InteriorIntersectionFinderAdder\n};\n\nvar MCIndexSnapRounder = function MCIndexSnapRounder () {\n  this._pm = null;\n  this._li = null;\n  this._scaleFactor = null;\n  this._noder = null;\n  this._pointSnapper = null;\n  this._nodedSegStrings = null;\n  var pm = arguments[0];\n  this._pm = pm;\n  this._li = new RobustLineIntersector();\n  this._li.setPrecisionModel(pm);\n  this._scaleFactor = pm.getScale();\n};\nMCIndexSnapRounder.prototype.checkCorrectness = function checkCorrectness (inputSegmentStrings) {\n  var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n  var nv = new NodingValidator(resultSegStrings);\n  try {\n    nv.checkValid();\n  } catch (ex) {\n    if (ex instanceof Exception) {\n      ex.printStackTrace();\n    } else { throw ex }\n  } finally {}\n};\nMCIndexSnapRounder.prototype.getNodedSubstrings = function getNodedSubstrings () {\n  return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)\n};\nMCIndexSnapRounder.prototype.snapRound = function snapRound (segStrings, li) {\n  var intersections = this.findInteriorIntersections(segStrings, li);\n  this.computeIntersectionSnaps(intersections);\n  this.computeVertexSnaps(segStrings);\n};\nMCIndexSnapRounder.prototype.findInteriorIntersections = function findInteriorIntersections (segStrings, li) {\n  var intFinderAdder = new InteriorIntersectionFinderAdder(li);\n  this._noder.setSegmentIntersector(intFinderAdder);\n  this._noder.computeNodes(segStrings);\n  return intFinderAdder.getInteriorIntersections()\n};\nMCIndexSnapRounder.prototype.computeVertexSnaps = function computeVertexSnaps () {\n    var this$1 = this;\n\n  if (hasInterface(arguments[0], Collection)) {\n    var edges = arguments[0];\n    for (var i0 = edges.iterator(); i0.hasNext();) {\n      var edge0 = i0.next();\n      this$1.computeVertexSnaps(edge0);\n    }\n  } else if (arguments[0] instanceof NodedSegmentString) {\n    var e = arguments[0];\n    var pts0 = e.getCoordinates();\n    for (var i = 0; i < pts0.length; i++) {\n      var hotPixel = new HotPixel(pts0[i], this$1._scaleFactor, this$1._li);\n      var isNodeAdded = this$1._pointSnapper.snap(hotPixel, e, i);\n      if (isNodeAdded) {\n        e.addIntersection(pts0[i], i);\n      }\n    }\n  }\n};\nMCIndexSnapRounder.prototype.computeNodes = function computeNodes (inputSegmentStrings) {\n  this._nodedSegStrings = inputSegmentStrings;\n  this._noder = new MCIndexNoder();\n  this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());\n  this.snapRound(inputSegmentStrings, this._li);\n};\nMCIndexSnapRounder.prototype.computeIntersectionSnaps = function computeIntersectionSnaps (snapPts) {\n    var this$1 = this;\n\n  for (var it = snapPts.iterator(); it.hasNext();) {\n    var snapPt = it.next();\n    var hotPixel = new HotPixel(snapPt, this$1._scaleFactor, this$1._li);\n    this$1._pointSnapper.snap(hotPixel);\n  }\n};\nMCIndexSnapRounder.prototype.interfaces_ = function interfaces_ () {\n  return [Noder]\n};\nMCIndexSnapRounder.prototype.getClass = function getClass () {\n  return MCIndexSnapRounder\n};\n\nvar BufferOp = function BufferOp () {\n  this._argGeom = null;\n  this._distance = null;\n  this._bufParams = new BufferParameters();\n  this._resultGeometry = null;\n  this._saveException = null;\n  if (arguments.length === 1) {\n    var g = arguments[0];\n    this._argGeom = g;\n  } else if (arguments.length === 2) {\n    var g$1 = arguments[0];\n    var bufParams = arguments[1];\n    this._argGeom = g$1;\n    this._bufParams = bufParams;\n  }\n};\n\nvar staticAccessors$32 = { CAP_ROUND: { configurable: true },CAP_BUTT: { configurable: true },CAP_FLAT: { configurable: true },CAP_SQUARE: { configurable: true },MAX_PRECISION_DIGITS: { configurable: true } };\nBufferOp.prototype.bufferFixedPrecision = function bufferFixedPrecision (fixedPM) {\n  var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n  var bufBuilder = new BufferBuilder(this._bufParams);\n  bufBuilder.setWorkingPrecisionModel(fixedPM);\n  bufBuilder.setNoder(noder);\n  this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n};\nBufferOp.prototype.bufferReducedPrecision = function bufferReducedPrecision () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n      try {\n        this$1.bufferReducedPrecision(precDigits);\n      } catch (ex) {\n        if (ex instanceof TopologyException) {\n          this$1._saveException = ex;\n        } else { throw ex }\n      } finally {}\n      if (this$1._resultGeometry !== null) { return null }\n    }\n    throw this._saveException\n  } else if (arguments.length === 1) {\n    var precisionDigits = arguments[0];\n    var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);\n    var fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n    this.bufferFixedPrecision(fixedPM);\n  }\n};\nBufferOp.prototype.computeGeometry = function computeGeometry () {\n  this.bufferOriginalPrecision();\n  if (this._resultGeometry !== null) { return null }\n  var argPM = this._argGeom.getFactory().getPrecisionModel();\n  if (argPM.getType() === PrecisionModel.FIXED) { this.bufferFixedPrecision(argPM); } else { this.bufferReducedPrecision(); }\n};\nBufferOp.prototype.setQuadrantSegments = function setQuadrantSegments (quadrantSegments) {\n  this._bufParams.setQuadrantSegments(quadrantSegments);\n};\nBufferOp.prototype.bufferOriginalPrecision = function bufferOriginalPrecision () {\n  try {\n    var bufBuilder = new BufferBuilder(this._bufParams);\n    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n  } catch (ex) {\n    if (ex instanceof RuntimeException) {\n      this._saveException = ex;\n    } else { throw ex }\n  } finally {}\n};\nBufferOp.prototype.getResultGeometry = function getResultGeometry (distance) {\n  this._distance = distance;\n  this.computeGeometry();\n  return this._resultGeometry\n};\nBufferOp.prototype.setEndCapStyle = function setEndCapStyle (endCapStyle) {\n  this._bufParams.setEndCapStyle(endCapStyle);\n};\nBufferOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferOp.prototype.getClass = function getClass () {\n  return BufferOp\n};\nBufferOp.bufferOp = function bufferOp () {\n  if (arguments.length === 2) {\n    var g = arguments[0];\n    var distance = arguments[1];\n    var gBuf = new BufferOp(g);\n    var geomBuf = gBuf.getResultGeometry(distance);\n    return geomBuf\n  } else if (arguments.length === 3) {\n    if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {\n      var g$1 = arguments[0];\n      var distance$1 = arguments[1];\n      var quadrantSegments = arguments[2];\n      var bufOp = new BufferOp(g$1);\n      bufOp.setQuadrantSegments(quadrantSegments);\n      var geomBuf$1 = bufOp.getResultGeometry(distance$1);\n      return geomBuf$1\n    } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {\n      var g$2 = arguments[0];\n      var distance$2 = arguments[1];\n      var params = arguments[2];\n      var bufOp$1 = new BufferOp(g$2, params);\n      var geomBuf$2 = bufOp$1.getResultGeometry(distance$2);\n      return geomBuf$2\n    }\n  } else if (arguments.length === 4) {\n    var g$3 = arguments[0];\n    var distance$3 = arguments[1];\n    var quadrantSegments$1 = arguments[2];\n    var endCapStyle = arguments[3];\n    var bufOp$2 = new BufferOp(g$3);\n    bufOp$2.setQuadrantSegments(quadrantSegments$1);\n    bufOp$2.setEndCapStyle(endCapStyle);\n    var geomBuf$3 = bufOp$2.getResultGeometry(distance$3);\n    return geomBuf$3\n  }\n};\nBufferOp.precisionScaleFactor = function precisionScaleFactor (g, distance, maxPrecisionDigits) {\n  var env = g.getEnvelopeInternal();\n  var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n  var expandByDistance = distance > 0.0 ? distance : 0.0;\n  var bufEnvMax = envMax + 2 * expandByDistance;\n  var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n  var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n  var scaleFactor = Math.pow(10.0, minUnitLog10);\n  return scaleFactor\n};\nstaticAccessors$32.CAP_ROUND.get = function () { return BufferParameters.CAP_ROUND };\nstaticAccessors$32.CAP_BUTT.get = function () { return BufferParameters.CAP_FLAT };\nstaticAccessors$32.CAP_FLAT.get = function () { return BufferParameters.CAP_FLAT };\nstaticAccessors$32.CAP_SQUARE.get = function () { return BufferParameters.CAP_SQUARE };\nstaticAccessors$32.MAX_PRECISION_DIGITS.get = function () { return 12 };\n\nObject.defineProperties( BufferOp, staticAccessors$32 );\n\nvar PointPairDistance = function PointPairDistance () {\n  this._pt = [new Coordinate(), new Coordinate()];\n  this._distance = Double.NaN;\n  this._isNull = true;\n};\nPointPairDistance.prototype.getCoordinates = function getCoordinates () {\n  return this._pt\n};\nPointPairDistance.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pt[i]\n};\nPointPairDistance.prototype.setMinimum = function setMinimum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist < this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance.prototype.initialize = function initialize () {\n  if (arguments.length === 0) {\n    this._isNull = true;\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    this._pt[0].setCoordinate(p0);\n    this._pt[1].setCoordinate(p1);\n    this._distance = p0.distance(p1);\n    this._isNull = false;\n  } else if (arguments.length === 3) {\n    var p0$1 = arguments[0];\n    var p1$1 = arguments[1];\n    var distance = arguments[2];\n    this._pt[0].setCoordinate(p0$1);\n    this._pt[1].setCoordinate(p1$1);\n    this._distance = distance;\n    this._isNull = false;\n  }\n};\nPointPairDistance.prototype.getDistance = function getDistance () {\n  return this._distance\n};\nPointPairDistance.prototype.setMaximum = function setMaximum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist > this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointPairDistance.prototype.getClass = function getClass () {\n  return PointPairDistance\n};\n\nvar DistanceToPointFinder = function DistanceToPointFinder () {};\n\nDistanceToPointFinder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDistanceToPointFinder.prototype.getClass = function getClass () {\n  return DistanceToPointFinder\n};\nDistanceToPointFinder.computeDistance = function computeDistance () {\n  if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {\n    var line = arguments[0];\n    var pt = arguments[1];\n    var ptDist = arguments[2];\n    var coords = line.getCoordinates();\n    var tempSegment = new LineSegment();\n    for (var i = 0; i < coords.length - 1; i++) {\n      tempSegment.setCoordinates(coords[i], coords[i + 1]);\n      var closestPt = tempSegment.closestPoint(pt);\n      ptDist.setMinimum(closestPt, pt);\n    }\n  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {\n    var poly = arguments[0];\n    var pt$1 = arguments[1];\n    var ptDist$1 = arguments[2];\n    DistanceToPointFinder.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);\n    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {\n      DistanceToPointFinder.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);\n    }\n  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {\n    var geom = arguments[0];\n    var pt$2 = arguments[1];\n    var ptDist$2 = arguments[2];\n    if (geom instanceof LineString) {\n      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof Polygon) {\n      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof GeometryCollection) {\n      var gc = geom;\n      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {\n        var g = gc.getGeometryN(i$2);\n        DistanceToPointFinder.computeDistance(g, pt$2, ptDist$2);\n      }\n    } else {\n      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);\n    }\n  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {\n    var segment = arguments[0];\n    var pt$3 = arguments[1];\n    var ptDist$3 = arguments[2];\n    var closestPt$1 = segment.closestPoint(pt$3);\n    ptDist$3.setMinimum(closestPt$1, pt$3);\n  }\n};\n\nvar BufferCurveMaximumDistanceFinder = function BufferCurveMaximumDistanceFinder (inputGeom) {\n  this._maxPtDist = new PointPairDistance();\n  this._inputGeom = inputGeom || null;\n};\n\nvar staticAccessors$36 = { MaxPointDistanceFilter: { configurable: true },MaxMidpointDistanceFilter: { configurable: true } };\nBufferCurveMaximumDistanceFinder.prototype.computeMaxMidpointDistance = function computeMaxMidpointDistance (curve) {\n  var distFilter = new MaxMidpointDistanceFilter(this._inputGeom);\n  curve.apply(distFilter);\n  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());\n};\nBufferCurveMaximumDistanceFinder.prototype.computeMaxVertexDistance = function computeMaxVertexDistance (curve) {\n  var distFilter = new MaxPointDistanceFilter(this._inputGeom);\n  curve.apply(distFilter);\n  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());\n};\nBufferCurveMaximumDistanceFinder.prototype.findDistance = function findDistance (bufferCurve) {\n  this.computeMaxVertexDistance(bufferCurve);\n  this.computeMaxMidpointDistance(bufferCurve);\n  return this._maxPtDist.getDistance()\n};\nBufferCurveMaximumDistanceFinder.prototype.getDistancePoints = function getDistancePoints () {\n  return this._maxPtDist\n};\nBufferCurveMaximumDistanceFinder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferCurveMaximumDistanceFinder.prototype.getClass = function getClass () {\n  return BufferCurveMaximumDistanceFinder\n};\nstaticAccessors$36.MaxPointDistanceFilter.get = function () { return MaxPointDistanceFilter };\nstaticAccessors$36.MaxMidpointDistanceFilter.get = function () { return MaxMidpointDistanceFilter };\n\nObject.defineProperties( BufferCurveMaximumDistanceFinder, staticAccessors$36 );\n\nvar MaxPointDistanceFilter = function MaxPointDistanceFilter (geom) {\n  this._maxPtDist = new PointPairDistance();\n  this._minPtDist = new PointPairDistance();\n  this._geom = geom || null;\n};\nMaxPointDistanceFilter.prototype.filter = function filter (pt) {\n  this._minPtDist.initialize();\n  DistanceToPointFinder.computeDistance(this._geom, pt, this._minPtDist);\n  this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxPointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxPointDistanceFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateFilter]\n};\nMaxPointDistanceFilter.prototype.getClass = function getClass () {\n  return MaxPointDistanceFilter\n};\n\nvar MaxMidpointDistanceFilter = function MaxMidpointDistanceFilter (geom) {\n  this._maxPtDist = new PointPairDistance();\n  this._minPtDist = new PointPairDistance();\n  this._geom = geom || null;\n};\nMaxMidpointDistanceFilter.prototype.filter = function filter (seq, index) {\n  if (index === 0) { return null }\n  var p0 = seq.getCoordinate(index - 1);\n  var p1 = seq.getCoordinate(index);\n  var midPt = new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n  this._minPtDist.initialize();\n  DistanceToPointFinder.computeDistance(this._geom, midPt, this._minPtDist);\n  this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxMidpointDistanceFilter.prototype.isDone = function isDone () {\n  return false\n};\nMaxMidpointDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged () {\n  return false\n};\nMaxMidpointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxMidpointDistanceFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFilter]\n};\nMaxMidpointDistanceFilter.prototype.getClass = function getClass () {\n  return MaxMidpointDistanceFilter\n};\n\nvar PolygonExtracter = function PolygonExtracter (comps) {\n  this._comps = comps || null;\n};\nPolygonExtracter.prototype.filter = function filter (geom) {\n  if (geom instanceof Polygon) { this._comps.add(geom); }\n};\nPolygonExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nPolygonExtracter.prototype.getClass = function getClass () {\n  return PolygonExtracter\n};\nPolygonExtracter.getPolygons = function getPolygons () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    return PolygonExtracter.getPolygons(geom, new ArrayList())\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var list = arguments[1];\n    if (geom$1 instanceof Polygon) {\n      list.add(geom$1);\n    } else if (geom$1 instanceof GeometryCollection) {\n      geom$1.apply(new PolygonExtracter(list));\n    }\n    return list\n  }\n};\n\nvar LinearComponentExtracter = function LinearComponentExtracter () {\n  this._lines = null;\n  this._isForcedToLineString = false;\n  if (arguments.length === 1) {\n    var lines = arguments[0];\n    this._lines = lines;\n  } else if (arguments.length === 2) {\n    var lines$1 = arguments[0];\n    var isForcedToLineString = arguments[1];\n    this._lines = lines$1;\n    this._isForcedToLineString = isForcedToLineString;\n  }\n};\nLinearComponentExtracter.prototype.filter = function filter (geom) {\n  if (this._isForcedToLineString && geom instanceof LinearRing) {\n    var line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n    this._lines.add(line);\n    return null\n  }\n  if (geom instanceof LineString) { this._lines.add(geom); }\n};\nLinearComponentExtracter.prototype.setForceToLineString = function setForceToLineString (isForcedToLineString) {\n  this._isForcedToLineString = isForcedToLineString;\n};\nLinearComponentExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryComponentFilter]\n};\nLinearComponentExtracter.prototype.getClass = function getClass () {\n  return LinearComponentExtracter\n};\nLinearComponentExtracter.getGeometry = function getGeometry () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom))\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var forceToLineString = arguments[1];\n    return geom$1.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom$1, forceToLineString))\n  }\n};\nLinearComponentExtracter.getLines = function getLines () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    return LinearComponentExtracter.getLines(geom, false)\n  } else if (arguments.length === 2) {\n    if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n      var geoms = arguments[0];\n      var lines$1 = arguments[1];\n      for (var i = geoms.iterator(); i.hasNext();) {\n        var g = i.next();\n        LinearComponentExtracter.getLines(g, lines$1);\n      }\n      return lines$1\n    } else if (arguments[0] instanceof Geometry && typeof arguments[1] === 'boolean') {\n      var geom$1 = arguments[0];\n      var forceToLineString = arguments[1];\n      var lines = new ArrayList();\n      geom$1.apply(new LinearComponentExtracter(lines, forceToLineString));\n      return lines\n    } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n      var geom$2 = arguments[0];\n      var lines$2 = arguments[1];\n      if (geom$2 instanceof LineString) {\n        lines$2.add(geom$2);\n      } else {\n        geom$2.apply(new LinearComponentExtracter(lines$2));\n      }\n      return lines$2\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {\n      var geoms$1 = arguments[0];\n      var lines$3 = arguments[1];\n      var forceToLineString$1 = arguments[2];\n      for (var i$1 = geoms$1.iterator(); i$1.hasNext();) {\n        var g$1 = i$1.next();\n        LinearComponentExtracter.getLines(g$1, lines$3, forceToLineString$1);\n      }\n      return lines$3\n    } else if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {\n      var geom$3 = arguments[0];\n      var lines$4 = arguments[1];\n      var forceToLineString$2 = arguments[2];\n      geom$3.apply(new LinearComponentExtracter(lines$4, forceToLineString$2));\n      return lines$4\n    }\n  }\n};\n\nvar PointLocator = function PointLocator () {\n  this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n  this._isIn = null;\n  this._numBoundaries = null;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var boundaryRule = arguments[0];\n    if (boundaryRule === null) { throw new IllegalArgumentException('Rule must be non-null') }\n    this._boundaryRule = boundaryRule;\n  }\n};\nPointLocator.prototype.locateInternal = function locateInternal () {\n    var this$1 = this;\n\n  if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {\n    var p = arguments[0];\n    var poly = arguments[1];\n    if (poly.isEmpty()) { return Location.EXTERIOR }\n    var shell = poly.getExteriorRing();\n    var shellLoc = this.locateInPolygonRing(p, shell);\n    if (shellLoc === Location.EXTERIOR) { return Location.EXTERIOR }\n    if (shellLoc === Location.BOUNDARY) { return Location.BOUNDARY }\n    for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n      var hole = poly.getInteriorRingN(i);\n      var holeLoc = this$1.locateInPolygonRing(p, hole);\n      if (holeLoc === Location.INTERIOR) { return Location.EXTERIOR }\n      if (holeLoc === Location.BOUNDARY) { return Location.BOUNDARY }\n    }\n    return Location.INTERIOR\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {\n    var p$1 = arguments[0];\n    var l = arguments[1];\n    if (!l.getEnvelopeInternal().intersects(p$1)) { return Location.EXTERIOR }\n    var pt = l.getCoordinates();\n    if (!l.isClosed()) {\n      if (p$1.equals(pt[0]) || p$1.equals(pt[pt.length - 1])) {\n        return Location.BOUNDARY\n      }\n    }\n    if (CGAlgorithms.isOnLine(p$1, pt)) { return Location.INTERIOR }\n    return Location.EXTERIOR\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {\n    var p$2 = arguments[0];\n    var pt$1 = arguments[1];\n    var ptCoord = pt$1.getCoordinate();\n    if (ptCoord.equals2D(p$2)) { return Location.INTERIOR }\n    return Location.EXTERIOR\n  }\n};\nPointLocator.prototype.locateInPolygonRing = function locateInPolygonRing (p, ring) {\n  if (!ring.getEnvelopeInternal().intersects(p)) { return Location.EXTERIOR }\n  return CGAlgorithms.locatePointInRing(p, ring.getCoordinates())\n};\nPointLocator.prototype.intersects = function intersects (p, geom) {\n  return this.locate(p, geom) !== Location.EXTERIOR\n};\nPointLocator.prototype.updateLocationInfo = function updateLocationInfo (loc) {\n  if (loc === Location.INTERIOR) { this._isIn = true; }\n  if (loc === Location.BOUNDARY) { this._numBoundaries++; }\n};\nPointLocator.prototype.computeLocation = function computeLocation (p, geom) {\n    var this$1 = this;\n\n  if (geom instanceof Point) {\n    this.updateLocationInfo(this.locateInternal(p, geom));\n  }\n  if (geom instanceof LineString) {\n    this.updateLocationInfo(this.locateInternal(p, geom));\n  } else if (geom instanceof Polygon) {\n    this.updateLocationInfo(this.locateInternal(p, geom));\n  } else if (geom instanceof MultiLineString) {\n    var ml = geom;\n    for (var i = 0; i < ml.getNumGeometries(); i++) {\n      var l = ml.getGeometryN(i);\n      this$1.updateLocationInfo(this$1.locateInternal(p, l));\n    }\n  } else if (geom instanceof MultiPolygon) {\n    var mpoly = geom;\n    for (var i$1 = 0; i$1 < mpoly.getNumGeometries(); i$1++) {\n      var poly = mpoly.getGeometryN(i$1);\n      this$1.updateLocationInfo(this$1.locateInternal(p, poly));\n    }\n  } else if (geom instanceof GeometryCollection) {\n    var geomi = new GeometryCollectionIterator(geom);\n    while (geomi.hasNext()) {\n      var g2 = geomi.next();\n      if (g2 !== geom) { this$1.computeLocation(p, g2); }\n    }\n  }\n};\nPointLocator.prototype.locate = function locate (p, geom) {\n  if (geom.isEmpty()) { return Location.EXTERIOR }\n  if (geom instanceof LineString) {\n    return this.locateInternal(p, geom)\n  } else if (geom instanceof Polygon) {\n    return this.locateInternal(p, geom)\n  }\n  this._isIn = false;\n  this._numBoundaries = 0;\n  this.computeLocation(p, geom);\n  if (this._boundaryRule.isInBoundary(this._numBoundaries)) { return Location.BOUNDARY }\n  if (this._numBoundaries > 0 || this._isIn) { return Location.INTERIOR }\n  return Location.EXTERIOR\n};\nPointLocator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointLocator.prototype.getClass = function getClass () {\n  return PointLocator\n};\n\nvar GeometryLocation = function GeometryLocation () {\n  this._component = null;\n  this._segIndex = null;\n  this._pt = null;\n  if (arguments.length === 2) {\n    var component = arguments[0];\n    var pt = arguments[1];\n    GeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);\n  } else if (arguments.length === 3) {\n    var component$1 = arguments[0];\n    var segIndex = arguments[1];\n    var pt$1 = arguments[2];\n    this._component = component$1;\n    this._segIndex = segIndex;\n    this._pt = pt$1;\n  }\n};\n\nvar staticAccessors$38 = { INSIDE_AREA: { configurable: true } };\nGeometryLocation.prototype.isInsideArea = function isInsideArea () {\n  return this._segIndex === GeometryLocation.INSIDE_AREA\n};\nGeometryLocation.prototype.getCoordinate = function getCoordinate () {\n  return this._pt\n};\nGeometryLocation.prototype.getGeometryComponent = function getGeometryComponent () {\n  return this._component\n};\nGeometryLocation.prototype.getSegmentIndex = function getSegmentIndex () {\n  return this._segIndex\n};\nGeometryLocation.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryLocation.prototype.getClass = function getClass () {\n  return GeometryLocation\n};\nstaticAccessors$38.INSIDE_AREA.get = function () { return -1 };\n\nObject.defineProperties( GeometryLocation, staticAccessors$38 );\n\nvar PointExtracter = function PointExtracter (pts) {\n  this._pts = pts || null;\n};\nPointExtracter.prototype.filter = function filter (geom) {\n  if (geom instanceof Point) { this._pts.add(geom); }\n};\nPointExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nPointExtracter.prototype.getClass = function getClass () {\n  return PointExtracter\n};\nPointExtracter.getPoints = function getPoints () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    if (geom instanceof Point) {\n      return Collections.singletonList(geom)\n    }\n    return PointExtracter.getPoints(geom, new ArrayList())\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var list = arguments[1];\n    if (geom$1 instanceof Point) {\n      list.add(geom$1);\n    } else if (geom$1 instanceof GeometryCollection) {\n      geom$1.apply(new PointExtracter(list));\n    }\n    return list\n  }\n};\n\nvar ConnectedElementLocationFilter = function ConnectedElementLocationFilter () {\n  this._locations = null;\n  var locations = arguments[0];\n  this._locations = locations;\n};\nConnectedElementLocationFilter.prototype.filter = function filter (geom) {\n  if (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) { this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate())); }\n};\nConnectedElementLocationFilter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nConnectedElementLocationFilter.prototype.getClass = function getClass () {\n  return ConnectedElementLocationFilter\n};\nConnectedElementLocationFilter.getLocations = function getLocations (geom) {\n  var locations = new ArrayList();\n  geom.apply(new ConnectedElementLocationFilter(locations));\n  return locations\n};\n\nvar DistanceOp = function DistanceOp () {\n  this._geom = null;\n  this._terminateDistance = 0.0;\n  this._ptLocator = new PointLocator();\n  this._minDistanceLocation = null;\n  this._minDistance = Double.MAX_VALUE;\n  if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    this._geom = [g0, g1];\n    this._terminateDistance = 0.0;\n  } else if (arguments.length === 3) {\n    var g0$1 = arguments[0];\n    var g1$1 = arguments[1];\n    var terminateDistance = arguments[2];\n    this._geom = new Array(2).fill(null);\n    this._geom[0] = g0$1;\n    this._geom[1] = g1$1;\n    this._terminateDistance = terminateDistance;\n  }\n};\nDistanceOp.prototype.computeContainmentDistance = function computeContainmentDistance () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    var locPtPoly = new Array(2).fill(null);\n    this.computeContainmentDistance(0, locPtPoly);\n    if (this._minDistance <= this._terminateDistance) { return null }\n    this.computeContainmentDistance(1, locPtPoly);\n  } else if (arguments.length === 2) {\n    var polyGeomIndex = arguments[0];\n    var locPtPoly$1 = arguments[1];\n    var locationsIndex = 1 - polyGeomIndex;\n    var polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);\n    if (polys.size() > 0) {\n      var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);\n      this.computeContainmentDistance(insideLocs, polys, locPtPoly$1);\n      if (this._minDistance <= this._terminateDistance) {\n        this._minDistanceLocation[locationsIndex] = locPtPoly$1[0];\n        this._minDistanceLocation[polyGeomIndex] = locPtPoly$1[1];\n        return null\n      }\n    }\n  } else if (arguments.length === 3) {\n    if (arguments[2] instanceof Array && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n      var locs = arguments[0];\n      var polys$1 = arguments[1];\n      var locPtPoly$2 = arguments[2];\n      for (var i = 0; i < locs.size(); i++) {\n        var loc = locs.get(i);\n        for (var j = 0; j < polys$1.size(); j++) {\n          this$1.computeContainmentDistance(loc, polys$1.get(j), locPtPoly$2);\n          if (this$1._minDistance <= this$1._terminateDistance) { return null }\n        }\n      }\n    } else if (arguments[2] instanceof Array && (arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon)) {\n      var ptLoc = arguments[0];\n      var poly = arguments[1];\n      var locPtPoly$3 = arguments[2];\n      var pt = ptLoc.getCoordinate();\n      if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {\n        this._minDistance = 0.0;\n        locPtPoly$3[0] = ptLoc;\n        locPtPoly$3[1] = new GeometryLocation(poly, pt);\n\n        return null\n      }\n    }\n  }\n};\nDistanceOp.prototype.computeMinDistanceLinesPoints = function computeMinDistanceLinesPoints (lines, points, locGeom) {\n    var this$1 = this;\n\n  for (var i = 0; i < lines.size(); i++) {\n    var line = lines.get(i);\n    for (var j = 0; j < points.size(); j++) {\n      var pt = points.get(j);\n      this$1.computeMinDistance(line, pt, locGeom);\n      if (this$1._minDistance <= this$1._terminateDistance) { return null }\n    }\n  }\n};\nDistanceOp.prototype.computeFacetDistance = function computeFacetDistance () {\n  var locGeom = new Array(2).fill(null);\n  var lines0 = LinearComponentExtracter.getLines(this._geom[0]);\n  var lines1 = LinearComponentExtracter.getLines(this._geom[1]);\n  var pts0 = PointExtracter.getPoints(this._geom[0]);\n  var pts1 = PointExtracter.getPoints(this._geom[1]);\n  this.computeMinDistanceLines(lines0, lines1, locGeom);\n  this.updateMinDistance(locGeom, false);\n  if (this._minDistance <= this._terminateDistance) { return null }\n  locGeom[0] = null;\n  locGeom[1] = null;\n  this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);\n  this.updateMinDistance(locGeom, false);\n  if (this._minDistance <= this._terminateDistance) { return null }\n  locGeom[0] = null;\n  locGeom[1] = null;\n  this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);\n  this.updateMinDistance(locGeom, true);\n  if (this._minDistance <= this._terminateDistance) { return null }\n  locGeom[0] = null;\n  locGeom[1] = null;\n  this.computeMinDistancePoints(pts0, pts1, locGeom);\n  this.updateMinDistance(locGeom, false);\n};\nDistanceOp.prototype.nearestLocations = function nearestLocations () {\n  this.computeMinDistance();\n  return this._minDistanceLocation\n};\nDistanceOp.prototype.updateMinDistance = function updateMinDistance (locGeom, flip) {\n  if (locGeom[0] === null) { return null }\n  if (flip) {\n    this._minDistanceLocation[0] = locGeom[1];\n    this._minDistanceLocation[1] = locGeom[0];\n  } else {\n    this._minDistanceLocation[0] = locGeom[0];\n    this._minDistanceLocation[1] = locGeom[1];\n  }\n};\nDistanceOp.prototype.nearestPoints = function nearestPoints () {\n  this.computeMinDistance();\n  var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];\n  return nearestPts\n};\nDistanceOp.prototype.computeMinDistance = function computeMinDistance () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this._minDistanceLocation !== null) { return null }\n    this._minDistanceLocation = new Array(2).fill(null);\n    this.computeContainmentDistance();\n    if (this._minDistance <= this._terminateDistance) { return null }\n    this.computeFacetDistance();\n  } else if (arguments.length === 3) {\n    if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof Point)) {\n      var line = arguments[0];\n      var pt = arguments[1];\n      var locGeom = arguments[2];\n      if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) { return null }\n      var coord0 = line.getCoordinates();\n      var coord = pt.getCoordinate();\n      for (var i = 0; i < coord0.length - 1; i++) {\n        var dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);\n        if (dist < this$1._minDistance) {\n          this$1._minDistance = dist;\n          var seg = new LineSegment(coord0[i], coord0[i + 1]);\n          var segClosestPoint = seg.closestPoint(coord);\n          locGeom[0] = new GeometryLocation(line, i, segClosestPoint);\n          locGeom[1] = new GeometryLocation(pt, 0, coord);\n        }\n        if (this$1._minDistance <= this$1._terminateDistance) { return null }\n      }\n    } else if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof LineString)) {\n      var line0 = arguments[0];\n      var line1 = arguments[1];\n      var locGeom$1 = arguments[2];\n      if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) { return null }\n      var coord0$1 = line0.getCoordinates();\n      var coord1 = line1.getCoordinates();\n      for (var i$1 = 0; i$1 < coord0$1.length - 1; i$1++) {\n        for (var j = 0; j < coord1.length - 1; j++) {\n          var dist$1 = CGAlgorithms.distanceLineLine(coord0$1[i$1], coord0$1[i$1 + 1], coord1[j], coord1[j + 1]);\n          if (dist$1 < this$1._minDistance) {\n            this$1._minDistance = dist$1;\n            var seg0 = new LineSegment(coord0$1[i$1], coord0$1[i$1 + 1]);\n            var seg1 = new LineSegment(coord1[j], coord1[j + 1]);\n            var closestPt = seg0.closestPoints(seg1);\n            locGeom$1[0] = new GeometryLocation(line0, i$1, closestPt[0]);\n            locGeom$1[1] = new GeometryLocation(line1, j, closestPt[1]);\n          }\n          if (this$1._minDistance <= this$1._terminateDistance) { return null }\n        }\n      }\n    }\n  }\n};\nDistanceOp.prototype.computeMinDistancePoints = function computeMinDistancePoints (points0, points1, locGeom) {\n    var this$1 = this;\n\n  for (var i = 0; i < points0.size(); i++) {\n    var pt0 = points0.get(i);\n    for (var j = 0; j < points1.size(); j++) {\n      var pt1 = points1.get(j);\n      var dist = pt0.getCoordinate().distance(pt1.getCoordinate());\n      if (dist < this$1._minDistance) {\n        this$1._minDistance = dist;\n        locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());\n        locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());\n      }\n      if (this$1._minDistance <= this$1._terminateDistance) { return null }\n    }\n  }\n};\nDistanceOp.prototype.distance = function distance () {\n  if (this._geom[0] === null || this._geom[1] === null) { throw new IllegalArgumentException('null geometries are not supported') }\n  if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) { return 0.0 }\n  this.computeMinDistance();\n  return this._minDistance\n};\nDistanceOp.prototype.computeMinDistanceLines = function computeMinDistanceLines (lines0, lines1, locGeom) {\n    var this$1 = this;\n\n  for (var i = 0; i < lines0.size(); i++) {\n    var line0 = lines0.get(i);\n    for (var j = 0; j < lines1.size(); j++) {\n      var line1 = lines1.get(j);\n      this$1.computeMinDistance(line0, line1, locGeom);\n      if (this$1._minDistance <= this$1._terminateDistance) { return null }\n    }\n  }\n};\nDistanceOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDistanceOp.prototype.getClass = function getClass () {\n  return DistanceOp\n};\nDistanceOp.distance = function distance (g0, g1) {\n  var distOp = new DistanceOp(g0, g1);\n  return distOp.distance()\n};\nDistanceOp.isWithinDistance = function isWithinDistance (g0, g1, distance) {\n  var distOp = new DistanceOp(g0, g1, distance);\n  return distOp.distance() <= distance\n};\nDistanceOp.nearestPoints = function nearestPoints (g0, g1) {\n  var distOp = new DistanceOp(g0, g1);\n  return distOp.nearestPoints()\n};\n\nvar PointPairDistance$2 = function PointPairDistance () {\n  this._pt = [new Coordinate(), new Coordinate()];\n  this._distance = Double.NaN;\n  this._isNull = true;\n};\nPointPairDistance$2.prototype.getCoordinates = function getCoordinates () {\n  return this._pt\n};\nPointPairDistance$2.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pt[i]\n};\nPointPairDistance$2.prototype.setMinimum = function setMinimum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist < this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance$2.prototype.initialize = function initialize () {\n  if (arguments.length === 0) {\n    this._isNull = true;\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    this._pt[0].setCoordinate(p0);\n    this._pt[1].setCoordinate(p1);\n    this._distance = p0.distance(p1);\n    this._isNull = false;\n  } else if (arguments.length === 3) {\n    var p0$1 = arguments[0];\n    var p1$1 = arguments[1];\n    var distance = arguments[2];\n    this._pt[0].setCoordinate(p0$1);\n    this._pt[1].setCoordinate(p1$1);\n    this._distance = distance;\n    this._isNull = false;\n  }\n};\nPointPairDistance$2.prototype.toString = function toString () {\n  return WKTWriter.toLineString(this._pt[0], this._pt[1])\n};\nPointPairDistance$2.prototype.getDistance = function getDistance () {\n  return this._distance\n};\nPointPairDistance$2.prototype.setMaximum = function setMaximum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist > this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance$2.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointPairDistance$2.prototype.getClass = function getClass () {\n  return PointPairDistance$2\n};\n\nvar DistanceToPoint = function DistanceToPoint () {};\n\nDistanceToPoint.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDistanceToPoint.prototype.getClass = function getClass () {\n  return DistanceToPoint\n};\nDistanceToPoint.computeDistance = function computeDistance () {\n  if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {\n    var line = arguments[0];\n    var pt = arguments[1];\n    var ptDist = arguments[2];\n    var tempSegment = new LineSegment();\n    var coords = line.getCoordinates();\n    for (var i = 0; i < coords.length - 1; i++) {\n      tempSegment.setCoordinates(coords[i], coords[i + 1]);\n      var closestPt = tempSegment.closestPoint(pt);\n      ptDist.setMinimum(closestPt, pt);\n    }\n  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {\n    var poly = arguments[0];\n    var pt$1 = arguments[1];\n    var ptDist$1 = arguments[2];\n    DistanceToPoint.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);\n    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {\n      DistanceToPoint.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);\n    }\n  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {\n    var geom = arguments[0];\n    var pt$2 = arguments[1];\n    var ptDist$2 = arguments[2];\n    if (geom instanceof LineString) {\n      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof Polygon) {\n      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof GeometryCollection) {\n      var gc = geom;\n      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {\n        var g = gc.getGeometryN(i$2);\n        DistanceToPoint.computeDistance(g, pt$2, ptDist$2);\n      }\n    } else {\n      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);\n    }\n  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {\n    var segment = arguments[0];\n    var pt$3 = arguments[1];\n    var ptDist$3 = arguments[2];\n    var closestPt$1 = segment.closestPoint(pt$3);\n    ptDist$3.setMinimum(closestPt$1, pt$3);\n  }\n};\n\nvar DiscreteHausdorffDistance = function DiscreteHausdorffDistance () {\n  this._g0 = null;\n  this._g1 = null;\n  this._ptDist = new PointPairDistance$2();\n  this._densifyFrac = 0.0;\n  var g0 = arguments[0];\n  var g1 = arguments[1];\n  this._g0 = g0;\n  this._g1 = g1;\n};\n\nvar staticAccessors$39 = { MaxPointDistanceFilter: { configurable: true },MaxDensifiedByFractionDistanceFilter: { configurable: true } };\nDiscreteHausdorffDistance.prototype.getCoordinates = function getCoordinates () {\n  return this._ptDist.getCoordinates()\n};\nDiscreteHausdorffDistance.prototype.setDensifyFraction = function setDensifyFraction (densifyFrac) {\n  if (densifyFrac > 1.0 || densifyFrac <= 0.0) { throw new IllegalArgumentException('Fraction is not in range (0.0 - 1.0]') }\n  this._densifyFrac = densifyFrac;\n};\nDiscreteHausdorffDistance.prototype.compute = function compute (g0, g1) {\n  this.computeOrientedDistance(g0, g1, this._ptDist);\n  this.computeOrientedDistance(g1, g0, this._ptDist);\n};\nDiscreteHausdorffDistance.prototype.distance = function distance () {\n  this.compute(this._g0, this._g1);\n  return this._ptDist.getDistance()\n};\nDiscreteHausdorffDistance.prototype.computeOrientedDistance = function computeOrientedDistance (discreteGeom, geom, ptDist) {\n  var distFilter = new MaxPointDistanceFilter$1(geom);\n  discreteGeom.apply(distFilter);\n  ptDist.setMaximum(distFilter.getMaxPointDistance());\n  if (this._densifyFrac > 0) {\n    var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);\n    discreteGeom.apply(fracFilter);\n    ptDist.setMaximum(fracFilter.getMaxPointDistance());\n  }\n};\nDiscreteHausdorffDistance.prototype.orientedDistance = function orientedDistance () {\n  this.computeOrientedDistance(this._g0, this._g1, this._ptDist);\n  return this._ptDist.getDistance()\n};\nDiscreteHausdorffDistance.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDiscreteHausdorffDistance.prototype.getClass = function getClass () {\n  return DiscreteHausdorffDistance\n};\nDiscreteHausdorffDistance.distance = function distance () {\n  if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    var dist = new DiscreteHausdorffDistance(g0, g1);\n    return dist.distance()\n  } else if (arguments.length === 3) {\n    var g0$1 = arguments[0];\n    var g1$1 = arguments[1];\n    var densifyFrac = arguments[2];\n    var dist$1 = new DiscreteHausdorffDistance(g0$1, g1$1);\n    dist$1.setDensifyFraction(densifyFrac);\n    return dist$1.distance()\n  }\n};\nstaticAccessors$39.MaxPointDistanceFilter.get = function () { return MaxPointDistanceFilter$1 };\nstaticAccessors$39.MaxDensifiedByFractionDistanceFilter.get = function () { return MaxDensifiedByFractionDistanceFilter };\n\nObject.defineProperties( DiscreteHausdorffDistance, staticAccessors$39 );\n\nvar MaxPointDistanceFilter$1 = function MaxPointDistanceFilter () {\n  this._maxPtDist = new PointPairDistance$2();\n  this._minPtDist = new PointPairDistance$2();\n  this._euclideanDist = new DistanceToPoint();\n  this._geom = null;\n  var geom = arguments[0];\n  this._geom = geom;\n};\nMaxPointDistanceFilter$1.prototype.filter = function filter (pt) {\n  this._minPtDist.initialize();\n  DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);\n  this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxPointDistanceFilter$1.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxPointDistanceFilter$1.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateFilter]\n};\nMaxPointDistanceFilter$1.prototype.getClass = function getClass () {\n  return MaxPointDistanceFilter$1\n};\n\nvar MaxDensifiedByFractionDistanceFilter = function MaxDensifiedByFractionDistanceFilter () {\n  this._maxPtDist = new PointPairDistance$2();\n  this._minPtDist = new PointPairDistance$2();\n  this._geom = null;\n  this._numSubSegs = 0;\n  var geom = arguments[0];\n  var fraction = arguments[1];\n  this._geom = geom;\n  this._numSubSegs = Math.trunc(Math.round(1.0 / fraction));\n};\nMaxDensifiedByFractionDistanceFilter.prototype.filter = function filter (seq, index) {\n    var this$1 = this;\n\n  if (index === 0) { return null }\n  var p0 = seq.getCoordinate(index - 1);\n  var p1 = seq.getCoordinate(index);\n  var delx = (p1.x - p0.x) / this._numSubSegs;\n  var dely = (p1.y - p0.y) / this._numSubSegs;\n  for (var i = 0; i < this._numSubSegs; i++) {\n    var x = p0.x + i * delx;\n    var y = p0.y + i * dely;\n    var pt = new Coordinate(x, y);\n    this$1._minPtDist.initialize();\n    DistanceToPoint.computeDistance(this$1._geom, pt, this$1._minPtDist);\n    this$1._maxPtDist.setMaximum(this$1._minPtDist);\n  }\n};\nMaxDensifiedByFractionDistanceFilter.prototype.isDone = function isDone () {\n  return false\n};\nMaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged () {\n  return false\n};\nMaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxDensifiedByFractionDistanceFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFilter]\n};\nMaxDensifiedByFractionDistanceFilter.prototype.getClass = function getClass () {\n  return MaxDensifiedByFractionDistanceFilter\n};\n\nvar BufferDistanceValidator = function BufferDistanceValidator (input, bufDistance, result) {\n  this._minValidDistance = null;\n  this._maxValidDistance = null;\n  this._minDistanceFound = null;\n  this._maxDistanceFound = null;\n  this._isValid = true;\n  this._errMsg = null;\n  this._errorLocation = null;\n  this._errorIndicator = null;\n  this._input = input || null;\n  this._bufDistance = bufDistance || null;\n  this._result = result || null;\n};\n\nvar staticAccessors$37 = { VERBOSE: { configurable: true },MAX_DISTANCE_DIFF_FRAC: { configurable: true } };\nBufferDistanceValidator.prototype.checkMaximumDistance = function checkMaximumDistance (input, bufCurve, maxDist) {\n  var haus = new DiscreteHausdorffDistance(bufCurve, input);\n  haus.setDensifyFraction(0.25);\n  this._maxDistanceFound = haus.orientedDistance();\n  if (this._maxDistanceFound > maxDist) {\n    this._isValid = false;\n    var pts = haus.getCoordinates();\n    this._errorLocation = pts[1];\n    this._errorIndicator = input.getFactory().createLineString(pts);\n    this._errMsg = 'Distance between buffer curve and input is too large (' + this._maxDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ')';\n  }\n};\nBufferDistanceValidator.prototype.isValid = function isValid () {\n  var posDistance = Math.abs(this._bufDistance);\n  var distDelta = BufferDistanceValidator.MAX_DISTANCE_DIFF_FRAC * posDistance;\n  this._minValidDistance = posDistance - distDelta;\n  this._maxValidDistance = posDistance + distDelta;\n  if (this._input.isEmpty() || this._result.isEmpty()) { return true }\n  if (this._bufDistance > 0.0) {\n    this.checkPositiveValid();\n  } else {\n    this.checkNegativeValid();\n  }\n  if (BufferDistanceValidator.VERBOSE) {\n    System.out.println('Min Dist= ' + this._minDistanceFound + '  err= ' + (1.0 - this._minDistanceFound / this._bufDistance) + '  Max Dist= ' + this._maxDistanceFound + '  err= ' + (this._maxDistanceFound / this._bufDistance - 1.0));\n  }\n  return this._isValid\n};\nBufferDistanceValidator.prototype.checkNegativeValid = function checkNegativeValid () {\n  if (!(this._input instanceof Polygon || this._input instanceof MultiPolygon || this._input instanceof GeometryCollection)) {\n    return null\n  }\n  var inputCurve = this.getPolygonLines(this._input);\n  this.checkMinimumDistance(inputCurve, this._result, this._minValidDistance);\n  if (!this._isValid) { return null }\n  this.checkMaximumDistance(inputCurve, this._result, this._maxValidDistance);\n};\nBufferDistanceValidator.prototype.getErrorIndicator = function getErrorIndicator () {\n  return this._errorIndicator\n};\nBufferDistanceValidator.prototype.checkMinimumDistance = function checkMinimumDistance (g1, g2, minDist) {\n  var distOp = new DistanceOp(g1, g2, minDist);\n  this._minDistanceFound = distOp.distance();\n  if (this._minDistanceFound < minDist) {\n    this._isValid = false;\n    var pts = distOp.nearestPoints();\n    this._errorLocation = distOp.nearestPoints()[1];\n    this._errorIndicator = g1.getFactory().createLineString(pts);\n    this._errMsg = 'Distance between buffer curve and input is too small (' + this._minDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ' )';\n  }\n};\nBufferDistanceValidator.prototype.checkPositiveValid = function checkPositiveValid () {\n  var bufCurve = this._result.getBoundary();\n  this.checkMinimumDistance(this._input, bufCurve, this._minValidDistance);\n  if (!this._isValid) { return null }\n  this.checkMaximumDistance(this._input, bufCurve, this._maxValidDistance);\n};\nBufferDistanceValidator.prototype.getErrorLocation = function getErrorLocation () {\n  return this._errorLocation\n};\nBufferDistanceValidator.prototype.getPolygonLines = function getPolygonLines (g) {\n  var lines = new ArrayList();\n  var lineExtracter = new LinearComponentExtracter(lines);\n  var polys = PolygonExtracter.getPolygons(g);\n  for (var i = polys.iterator(); i.hasNext();) {\n    var poly = i.next();\n    poly.apply(lineExtracter);\n  }\n  return g.getFactory().buildGeometry(lines)\n};\nBufferDistanceValidator.prototype.getErrorMessage = function getErrorMessage () {\n  return this._errMsg\n};\nBufferDistanceValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferDistanceValidator.prototype.getClass = function getClass () {\n  return BufferDistanceValidator\n};\nstaticAccessors$37.VERBOSE.get = function () { return false };\nstaticAccessors$37.MAX_DISTANCE_DIFF_FRAC.get = function () { return 0.012 };\n\nObject.defineProperties( BufferDistanceValidator, staticAccessors$37 );\n\nvar BufferResultValidator = function BufferResultValidator (input, distance, result) {\n  this._isValid = true;\n  this._errorMsg = null;\n  this._errorLocation = null;\n  this._errorIndicator = null;\n  this._input = input || null;\n  this._distance = distance || null;\n  this._result = result || null;\n};\n\nvar staticAccessors$40 = { VERBOSE: { configurable: true },MAX_ENV_DIFF_FRAC: { configurable: true } };\nBufferResultValidator.prototype.isValid = function isValid () {\n  this.checkPolygonal();\n  if (!this._isValid) { return this._isValid }\n  this.checkExpectedEmpty();\n  if (!this._isValid) { return this._isValid }\n  this.checkEnvelope();\n  if (!this._isValid) { return this._isValid }\n  this.checkArea();\n  if (!this._isValid) { return this._isValid }\n  this.checkDistance();\n  return this._isValid\n};\nBufferResultValidator.prototype.checkEnvelope = function checkEnvelope () {\n  if (this._distance < 0.0) { return null }\n  var padding = this._distance * BufferResultValidator.MAX_ENV_DIFF_FRAC;\n  if (padding === 0.0) { padding = 0.001; }\n  var expectedEnv = new Envelope(this._input.getEnvelopeInternal());\n  expectedEnv.expandBy(this._distance);\n  var bufEnv = new Envelope(this._result.getEnvelopeInternal());\n  bufEnv.expandBy(padding);\n  if (!bufEnv.contains(expectedEnv)) {\n    this._isValid = false;\n    this._errorMsg = 'Buffer envelope is incorrect';\n    this._errorIndicator = this._input.getFactory().toGeometry(bufEnv);\n  }\n  this.report('Envelope');\n};\nBufferResultValidator.prototype.checkDistance = function checkDistance () {\n  var distValid = new BufferDistanceValidator(this._input, this._distance, this._result);\n  if (!distValid.isValid()) {\n    this._isValid = false;\n    this._errorMsg = distValid.getErrorMessage();\n    this._errorLocation = distValid.getErrorLocation();\n    this._errorIndicator = distValid.getErrorIndicator();\n  }\n  this.report('Distance');\n};\nBufferResultValidator.prototype.checkArea = function checkArea () {\n  var inputArea = this._input.getArea();\n  var resultArea = this._result.getArea();\n  if (this._distance > 0.0 && inputArea > resultArea) {\n    this._isValid = false;\n    this._errorMsg = 'Area of positive buffer is smaller than input';\n    this._errorIndicator = this._result;\n  }\n  if (this._distance < 0.0 && inputArea < resultArea) {\n    this._isValid = false;\n    this._errorMsg = 'Area of negative buffer is larger than input';\n    this._errorIndicator = this._result;\n  }\n  this.report('Area');\n};\nBufferResultValidator.prototype.checkPolygonal = function checkPolygonal () {\n  if (!(this._result instanceof Polygon || this._result instanceof MultiPolygon)) { this._isValid = false; }\n  this._errorMsg = 'Result is not polygonal';\n  this._errorIndicator = this._result;\n  this.report('Polygonal');\n};\nBufferResultValidator.prototype.getErrorIndicator = function getErrorIndicator () {\n  return this._errorIndicator\n};\nBufferResultValidator.prototype.getErrorLocation = function getErrorLocation () {\n  return this._errorLocation\n};\nBufferResultValidator.prototype.checkExpectedEmpty = function checkExpectedEmpty () {\n  if (this._input.getDimension() >= 2) { return null }\n  if (this._distance > 0.0) { return null }\n  if (!this._result.isEmpty()) {\n    this._isValid = false;\n    this._errorMsg = 'Result is non-empty';\n    this._errorIndicator = this._result;\n  }\n  this.report('ExpectedEmpty');\n};\nBufferResultValidator.prototype.report = function report (checkName) {\n  if (!BufferResultValidator.VERBOSE) { return null }\n  System.out.println('Check ' + checkName + ': ' + (this._isValid ? 'passed' : 'FAILED'));\n};\nBufferResultValidator.prototype.getErrorMessage = function getErrorMessage () {\n  return this._errorMsg\n};\nBufferResultValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferResultValidator.prototype.getClass = function getClass () {\n  return BufferResultValidator\n};\nBufferResultValidator.isValidMsg = function isValidMsg (g, distance, result) {\n  var validator = new BufferResultValidator(g, distance, result);\n  if (!validator.isValid()) { return validator.getErrorMessage() }\n  return null\n};\nBufferResultValidator.isValid = function isValid (g, distance, result) {\n  var validator = new BufferResultValidator(g, distance, result);\n  if (validator.isValid()) { return true }\n  return false\n};\nstaticAccessors$40.VERBOSE.get = function () { return false };\nstaticAccessors$40.MAX_ENV_DIFF_FRAC.get = function () { return 0.012 };\n\nObject.defineProperties( BufferResultValidator, staticAccessors$40 );\n\n// operation.buffer\n\nvar BasicSegmentString = function BasicSegmentString () {\n  this._pts = null;\n  this._data = null;\n  var pts = arguments[0];\n  var data = arguments[1];\n  this._pts = pts;\n  this._data = data;\n};\nBasicSegmentString.prototype.getCoordinates = function getCoordinates () {\n  return this._pts\n};\nBasicSegmentString.prototype.size = function size () {\n  return this._pts.length\n};\nBasicSegmentString.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pts[i]\n};\nBasicSegmentString.prototype.isClosed = function isClosed () {\n  return this._pts[0].equals(this._pts[this._pts.length - 1])\n};\nBasicSegmentString.prototype.getSegmentOctant = function getSegmentOctant (index) {\n  if (index === this._pts.length - 1) { return -1 }\n  return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1))\n};\nBasicSegmentString.prototype.setData = function setData (data) {\n  this._data = data;\n};\nBasicSegmentString.prototype.getData = function getData () {\n  return this._data\n};\nBasicSegmentString.prototype.toString = function toString () {\n  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))\n};\nBasicSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentString]\n};\nBasicSegmentString.prototype.getClass = function getClass () {\n  return BasicSegmentString\n};\n\nvar InteriorIntersectionFinder = function InteriorIntersectionFinder () {\n  this._findAllIntersections = false;\n  this._isCheckEndSegmentsOnly = false;\n  this._li = null;\n  this._interiorIntersection = null;\n  this._intSegments = null;\n  this._intersections = new ArrayList();\n  this._intersectionCount = 0;\n  this._keepIntersections = true;\n  var li = arguments[0];\n  this._li = li;\n  this._interiorIntersection = null;\n};\nInteriorIntersectionFinder.prototype.getInteriorIntersection = function getInteriorIntersection () {\n  return this._interiorIntersection\n};\nInteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function setCheckEndSegmentsOnly (isCheckEndSegmentsOnly) {\n  this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n};\nInteriorIntersectionFinder.prototype.getIntersectionSegments = function getIntersectionSegments () {\n  return this._intSegments\n};\nInteriorIntersectionFinder.prototype.count = function count () {\n  return this._intersectionCount\n};\nInteriorIntersectionFinder.prototype.getIntersections = function getIntersections () {\n  return this._intersections\n};\nInteriorIntersectionFinder.prototype.setFindAllIntersections = function setFindAllIntersections (findAllIntersections) {\n  this._findAllIntersections = findAllIntersections;\n};\nInteriorIntersectionFinder.prototype.setKeepIntersections = function setKeepIntersections (keepIntersections) {\n  this._keepIntersections = keepIntersections;\n};\nInteriorIntersectionFinder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {\n  if (!this._findAllIntersections && this.hasIntersection()) { return null }\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  if (this._isCheckEndSegmentsOnly) {\n    var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);\n    if (!isEndSegPresent) { return null }\n  }\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    if (this._li.isInteriorIntersection()) {\n      this._intSegments = new Array(4).fill(null);\n      this._intSegments[0] = p00;\n      this._intSegments[1] = p01;\n      this._intSegments[2] = p10;\n      this._intSegments[3] = p11;\n      this._interiorIntersection = this._li.getIntersection(0);\n      if (this._keepIntersections) { this._intersections.add(this._interiorIntersection); }\n      this._intersectionCount++;\n    }\n  }\n};\nInteriorIntersectionFinder.prototype.isEndSegment = function isEndSegment (segStr, index) {\n  if (index === 0) { return true }\n  if (index >= segStr.size() - 2) { return true }\n  return false\n};\nInteriorIntersectionFinder.prototype.hasIntersection = function hasIntersection () {\n  return this._interiorIntersection !== null\n};\nInteriorIntersectionFinder.prototype.isDone = function isDone () {\n  if (this._findAllIntersections) { return false }\n  return this._interiorIntersection !== null\n};\nInteriorIntersectionFinder.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentIntersector]\n};\nInteriorIntersectionFinder.prototype.getClass = function getClass () {\n  return InteriorIntersectionFinder\n};\nInteriorIntersectionFinder.createAllIntersectionsFinder = function createAllIntersectionsFinder (li) {\n  var finder = new InteriorIntersectionFinder(li);\n  finder.setFindAllIntersections(true);\n  return finder\n};\nInteriorIntersectionFinder.createAnyIntersectionFinder = function createAnyIntersectionFinder (li) {\n  return new InteriorIntersectionFinder(li)\n};\nInteriorIntersectionFinder.createIntersectionCounter = function createIntersectionCounter (li) {\n  var finder = new InteriorIntersectionFinder(li);\n  finder.setFindAllIntersections(true);\n  finder.setKeepIntersections(false);\n  return finder\n};\n\nvar FastNodingValidator = function FastNodingValidator () {\n  this._li = new RobustLineIntersector();\n  this._segStrings = null;\n  this._findAllIntersections = false;\n  this._segInt = null;\n  this._isValid = true;\n  var segStrings = arguments[0];\n  this._segStrings = segStrings;\n};\nFastNodingValidator.prototype.execute = function execute () {\n  if (this._segInt !== null) { return null }\n  this.checkInteriorIntersections();\n};\nFastNodingValidator.prototype.getIntersections = function getIntersections () {\n  return this._segInt.getIntersections()\n};\nFastNodingValidator.prototype.isValid = function isValid () {\n  this.execute();\n  return this._isValid\n};\nFastNodingValidator.prototype.setFindAllIntersections = function setFindAllIntersections (findAllIntersections) {\n  this._findAllIntersections = findAllIntersections;\n};\nFastNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections () {\n  this._isValid = true;\n  this._segInt = new InteriorIntersectionFinder(this._li);\n  this._segInt.setFindAllIntersections(this._findAllIntersections);\n  var noder = new MCIndexNoder();\n  noder.setSegmentIntersector(this._segInt);\n  noder.computeNodes(this._segStrings);\n  if (this._segInt.hasIntersection()) {\n    this._isValid = false;\n    return null\n  }\n};\nFastNodingValidator.prototype.checkValid = function checkValid () {\n  this.execute();\n  if (!this._isValid) { throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection()) }\n};\nFastNodingValidator.prototype.getErrorMessage = function getErrorMessage () {\n  if (this._isValid) { return 'no intersections found' }\n  var intSegs = this._segInt.getIntersectionSegments();\n  return 'found non-noded intersection between ' + WKTWriter.toLineString(intSegs[0], intSegs[1]) + ' and ' + WKTWriter.toLineString(intSegs[2], intSegs[3])\n};\nFastNodingValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nFastNodingValidator.prototype.getClass = function getClass () {\n  return FastNodingValidator\n};\nFastNodingValidator.computeIntersections = function computeIntersections (segStrings) {\n  var nv = new FastNodingValidator(segStrings);\n  nv.setFindAllIntersections(true);\n  nv.isValid();\n  return nv.getIntersections()\n};\n\nvar EdgeNodingValidator = function EdgeNodingValidator () {\n  this._nv = null;\n  var edges = arguments[0];\n  this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n};\nEdgeNodingValidator.prototype.checkValid = function checkValid () {\n  this._nv.checkValid();\n};\nEdgeNodingValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeNodingValidator.prototype.getClass = function getClass () {\n  return EdgeNodingValidator\n};\nEdgeNodingValidator.toSegmentStrings = function toSegmentStrings (edges) {\n  var segStrings = new ArrayList();\n  for (var i = edges.iterator(); i.hasNext();) {\n    var e = i.next();\n    segStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n  }\n  return segStrings\n};\nEdgeNodingValidator.checkValid = function checkValid (edges) {\n  var validator = new EdgeNodingValidator(edges);\n  validator.checkValid();\n};\n\nvar GeometryCollectionMapper = function GeometryCollectionMapper (mapOp) {\n  this._mapOp = mapOp;\n};\nGeometryCollectionMapper.prototype.map = function map (gc) {\n    var this$1 = this;\n\n  var mapped = new ArrayList();\n  for (var i = 0; i < gc.getNumGeometries(); i++) {\n    var g = this$1._mapOp.map(gc.getGeometryN(i));\n    if (!g.isEmpty()) { mapped.add(g); }\n  }\n  return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped))\n};\nGeometryCollectionMapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryCollectionMapper.prototype.getClass = function getClass () {\n  return GeometryCollectionMapper\n};\nGeometryCollectionMapper.map = function map (gc, op) {\n  var mapper = new GeometryCollectionMapper(op);\n  return mapper.map(gc)\n};\n\nvar LineBuilder = function LineBuilder () {\n  this._op = null;\n  this._geometryFactory = null;\n  this._ptLocator = null;\n  this._lineEdgesList = new ArrayList();\n  this._resultLineList = new ArrayList();\n  var op = arguments[0];\n  var geometryFactory = arguments[1];\n  var ptLocator = arguments[2];\n  this._op = op;\n  this._geometryFactory = geometryFactory;\n  this._ptLocator = ptLocator;\n};\nLineBuilder.prototype.collectLines = function collectLines (opCode) {\n    var this$1 = this;\n\n  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n    var de = it.next();\n    this$1.collectLineEdge(de, opCode, this$1._lineEdgesList);\n    this$1.collectBoundaryTouchEdge(de, opCode, this$1._lineEdgesList);\n  }\n};\nLineBuilder.prototype.labelIsolatedLine = function labelIsolatedLine (e, targetIndex) {\n  var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));\n  e.getLabel().setLocation(targetIndex, loc);\n};\nLineBuilder.prototype.build = function build (opCode) {\n  this.findCoveredLineEdges();\n  this.collectLines(opCode);\n  this.buildLines(opCode);\n  return this._resultLineList\n};\nLineBuilder.prototype.collectLineEdge = function collectLineEdge (de, opCode, edges) {\n  var label = de.getLabel();\n  var e = de.getEdge();\n  if (de.isLineEdge()) {\n    if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n      edges.add(e);\n      de.setVisitedEdge(true);\n    }\n  }\n};\nLineBuilder.prototype.findCoveredLineEdges = function findCoveredLineEdges () {\n    var this$1 = this;\n\n  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().findCoveredLineEdges();\n  }\n  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n    var de = it.next();\n    var e = de.getEdge();\n    if (de.isLineEdge() && !e.isCoveredSet()) {\n      var isCovered = this$1._op.isCoveredByA(de.getCoordinate());\n      e.setCovered(isCovered);\n    }\n  }\n};\nLineBuilder.prototype.labelIsolatedLines = function labelIsolatedLines (edgesList) {\n    var this$1 = this;\n\n  for (var it = edgesList.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    if (e.isIsolated()) {\n      if (label.isNull(0)) { this$1.labelIsolatedLine(e, 0); } else { this$1.labelIsolatedLine(e, 1); }\n    }\n  }\n};\nLineBuilder.prototype.buildLines = function buildLines (opCode) {\n    var this$1 = this;\n\n  for (var it = this._lineEdgesList.iterator(); it.hasNext();) {\n    var e = it.next();\n    // const label = e.getLabel()\n    var line = this$1._geometryFactory.createLineString(e.getCoordinates());\n    this$1._resultLineList.add(line);\n    e.setInResult(true);\n  }\n};\nLineBuilder.prototype.collectBoundaryTouchEdge = function collectBoundaryTouchEdge (de, opCode, edges) {\n  var label = de.getLabel();\n  if (de.isLineEdge()) { return null }\n  if (de.isVisited()) { return null }\n  if (de.isInteriorAreaEdge()) { return null }\n  if (de.getEdge().isInResult()) { return null }\n  Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n  if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n    edges.add(de.getEdge());\n    de.setVisitedEdge(true);\n  }\n};\nLineBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineBuilder.prototype.getClass = function getClass () {\n  return LineBuilder\n};\n\nvar PointBuilder = function PointBuilder () {\n  this._op = null;\n  this._geometryFactory = null;\n  this._resultPointList = new ArrayList();\n  var op = arguments[0];\n  var geometryFactory = arguments[1];\n  // const ptLocator = arguments[2]\n  this._op = op;\n  this._geometryFactory = geometryFactory;\n};\nPointBuilder.prototype.filterCoveredNodeToPoint = function filterCoveredNodeToPoint (n) {\n  var coord = n.getCoordinate();\n  if (!this._op.isCoveredByLA(coord)) {\n    var pt = this._geometryFactory.createPoint(coord);\n    this._resultPointList.add(pt);\n  }\n};\nPointBuilder.prototype.extractNonCoveredResultNodes = function extractNonCoveredResultNodes (opCode) {\n    var this$1 = this;\n\n  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n    var n = nodeit.next();\n    if (n.isInResult()) { continue }\n    if (n.isIncidentEdgeInResult()) { continue }\n    if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n      var label = n.getLabel();\n      if (OverlayOp.isResultOfOp(label, opCode)) {\n        this$1.filterCoveredNodeToPoint(n);\n      }\n    }\n  }\n};\nPointBuilder.prototype.build = function build (opCode) {\n  this.extractNonCoveredResultNodes(opCode);\n  return this._resultPointList\n};\nPointBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointBuilder.prototype.getClass = function getClass () {\n  return PointBuilder\n};\n\nvar GeometryTransformer = function GeometryTransformer () {\n  this._inputGeom = null;\n  this._factory = null;\n  this._pruneEmptyGeometry = true;\n  this._preserveGeometryCollectionType = true;\n  this._preserveCollections = false;\n  this._preserveType = false;\n};\nGeometryTransformer.prototype.transformPoint = function transformPoint (geom, parent) {\n  return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom))\n};\nGeometryTransformer.prototype.transformPolygon = function transformPolygon (geom, parent) {\n    var this$1 = this;\n\n  var isAllValidLinearRings = true;\n  var shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n  if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) { isAllValidLinearRings = false; }\n  var holes = new ArrayList();\n  for (var i = 0; i < geom.getNumInteriorRing(); i++) {\n    var hole = this$1.transformLinearRing(geom.getInteriorRingN(i), geom);\n    if (hole === null || hole.isEmpty()) {\n      continue\n    }\n    if (!(hole instanceof LinearRing)) { isAllValidLinearRings = false; }\n    holes.add(hole);\n  }\n  if (isAllValidLinearRings) { return this._factory.createPolygon(shell, holes.toArray([])); } else {\n    var components = new ArrayList();\n    if (shell !== null) { components.add(shell); }\n    components.addAll(holes);\n    return this._factory.buildGeometry(components)\n  }\n};\nGeometryTransformer.prototype.createCoordinateSequence = function createCoordinateSequence (coords) {\n  return this._factory.getCoordinateSequenceFactory().create(coords)\n};\nGeometryTransformer.prototype.getInputGeometry = function getInputGeometry () {\n  return this._inputGeom\n};\nGeometryTransformer.prototype.transformMultiLineString = function transformMultiLineString (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transformLineString(geom.getGeometryN(i), geom);\n    if (transformGeom === null) { continue }\n    if (transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.transformCoordinates = function transformCoordinates (coords, parent) {\n  return this.copy(coords)\n};\nGeometryTransformer.prototype.transformLineString = function transformLineString (geom, parent) {\n  return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom))\n};\nGeometryTransformer.prototype.transformMultiPoint = function transformMultiPoint (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transformPoint(geom.getGeometryN(i), geom);\n    if (transformGeom === null) { continue }\n    if (transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.transformMultiPolygon = function transformMultiPolygon (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transformPolygon(geom.getGeometryN(i), geom);\n    if (transformGeom === null) { continue }\n    if (transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.copy = function copy (seq) {\n  return seq.copy()\n};\nGeometryTransformer.prototype.transformGeometryCollection = function transformGeometryCollection (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transform(geom.getGeometryN(i));\n    if (transformGeom === null) { continue }\n    if (this$1._pruneEmptyGeometry && transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  if (this._preserveGeometryCollectionType) { return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList)) }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.transform = function transform (inputGeom) {\n  this._inputGeom = inputGeom;\n  this._factory = inputGeom.getFactory();\n  if (inputGeom instanceof Point) { return this.transformPoint(inputGeom, null) }\n  if (inputGeom instanceof MultiPoint) { return this.transformMultiPoint(inputGeom, null) }\n  if (inputGeom instanceof LinearRing) { return this.transformLinearRing(inputGeom, null) }\n  if (inputGeom instanceof LineString) { return this.transformLineString(inputGeom, null) }\n  if (inputGeom instanceof MultiLineString) { return this.transformMultiLineString(inputGeom, null) }\n  if (inputGeom instanceof Polygon) { return this.transformPolygon(inputGeom, null) }\n  if (inputGeom instanceof MultiPolygon) { return this.transformMultiPolygon(inputGeom, null) }\n  if (inputGeom instanceof GeometryCollection) { return this.transformGeometryCollection(inputGeom, null) }\n  throw new IllegalArgumentException('Unknown Geometry subtype: ' + inputGeom.getClass().getName())\n};\nGeometryTransformer.prototype.transformLinearRing = function transformLinearRing (geom, parent) {\n  var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n  if (seq === null) { return this._factory.createLinearRing(null) }\n  var seqSize = seq.size();\n  if (seqSize > 0 && seqSize < 4 && !this._preserveType) { return this._factory.createLineString(seq) }\n  return this._factory.createLinearRing(seq)\n};\nGeometryTransformer.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryTransformer.prototype.getClass = function getClass () {\n  return GeometryTransformer\n};\n\nvar LineStringSnapper = function LineStringSnapper () {\n  this._snapTolerance = 0.0;\n  this._srcPts = null;\n  this._seg = new LineSegment();\n  this._allowSnappingToSourceVertices = false;\n  this._isClosed = false;\n  if (arguments[0] instanceof LineString && typeof arguments[1] === 'number') {\n    var srcLine = arguments[0];\n    var snapTolerance = arguments[1];\n    LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);\n  } else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') {\n    var srcPts = arguments[0];\n    var snapTolerance$1 = arguments[1];\n    this._srcPts = srcPts;\n    this._isClosed = LineStringSnapper.isClosed(srcPts);\n    this._snapTolerance = snapTolerance$1;\n  }\n};\nLineStringSnapper.prototype.snapVertices = function snapVertices (srcCoords, snapPts) {\n    var this$1 = this;\n\n  var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n  for (var i = 0; i < end; i++) {\n    var srcPt = srcCoords.get(i);\n    var snapVert = this$1.findSnapForVertex(srcPt, snapPts);\n    if (snapVert !== null) {\n      srcCoords.set(i, new Coordinate(snapVert));\n      if (i === 0 && this$1._isClosed) { srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert)); }\n    }\n  }\n};\nLineStringSnapper.prototype.findSnapForVertex = function findSnapForVertex (pt, snapPts) {\n    var this$1 = this;\n\n  for (var i = 0; i < snapPts.length; i++) {\n    if (pt.equals2D(snapPts[i])) { return null }\n    if (pt.distance(snapPts[i]) < this$1._snapTolerance) { return snapPts[i] }\n  }\n  return null\n};\nLineStringSnapper.prototype.snapTo = function snapTo (snapPts) {\n  var coordList = new CoordinateList(this._srcPts);\n  this.snapVertices(coordList, snapPts);\n  this.snapSegments(coordList, snapPts);\n  var newPts = coordList.toCoordinateArray();\n  return newPts\n};\nLineStringSnapper.prototype.snapSegments = function snapSegments (srcCoords, snapPts) {\n    var this$1 = this;\n\n  if (snapPts.length === 0) { return null }\n  var distinctPtCount = snapPts.length;\n  if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) { distinctPtCount = snapPts.length - 1; }\n  for (var i = 0; i < distinctPtCount; i++) {\n    var snapPt = snapPts[i];\n    var index = this$1.findSegmentIndexToSnap(snapPt, srcCoords);\n    if (index >= 0) {\n      srcCoords.add(index + 1, new Coordinate(snapPt), false);\n    }\n  }\n};\nLineStringSnapper.prototype.findSegmentIndexToSnap = function findSegmentIndexToSnap (snapPt, srcCoords) {\n    var this$1 = this;\n\n  var minDist = Double.MAX_VALUE;\n  var snapIndex = -1;\n  for (var i = 0; i < srcCoords.size() - 1; i++) {\n    this$1._seg.p0 = srcCoords.get(i);\n    this$1._seg.p1 = srcCoords.get(i + 1);\n    if (this$1._seg.p0.equals2D(snapPt) || this$1._seg.p1.equals2D(snapPt)) {\n      if (this$1._allowSnappingToSourceVertices) { continue; } else { return -1 }\n    }\n    var dist = this$1._seg.distance(snapPt);\n    if (dist < this$1._snapTolerance && dist < minDist) {\n      minDist = dist;\n      snapIndex = i;\n    }\n  }\n  return snapIndex\n};\nLineStringSnapper.prototype.setAllowSnappingToSourceVertices = function setAllowSnappingToSourceVertices (allowSnappingToSourceVertices) {\n  this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n};\nLineStringSnapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineStringSnapper.prototype.getClass = function getClass () {\n  return LineStringSnapper\n};\nLineStringSnapper.isClosed = function isClosed (pts) {\n  if (pts.length <= 1) { return false }\n  return pts[0].equals2D(pts[pts.length - 1])\n};\n\nvar GeometrySnapper = function GeometrySnapper (srcGeom) {\n  this._srcGeom = srcGeom || null;\n};\n\nvar staticAccessors$41 = { SNAP_PRECISION_FACTOR: { configurable: true } };\nGeometrySnapper.prototype.snapTo = function snapTo (snapGeom, snapTolerance) {\n  var snapPts = this.extractTargetCoordinates(snapGeom);\n  var snapTrans = new SnapTransformer(snapTolerance, snapPts);\n  return snapTrans.transform(this._srcGeom)\n};\nGeometrySnapper.prototype.snapToSelf = function snapToSelf (snapTolerance, cleanResult) {\n  var snapPts = this.extractTargetCoordinates(this._srcGeom);\n  var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n  var snappedGeom = snapTrans.transform(this._srcGeom);\n  var result = snappedGeom;\n  if (cleanResult && hasInterface(result, Polygonal)) {\n    result = snappedGeom.buffer(0);\n  }\n  return result\n};\nGeometrySnapper.prototype.computeSnapTolerance = function computeSnapTolerance (ringPts) {\n  var minSegLen = this.computeMinimumSegmentLength(ringPts);\n  var snapTol = minSegLen / 10;\n  return snapTol\n};\nGeometrySnapper.prototype.extractTargetCoordinates = function extractTargetCoordinates (g) {\n  var ptSet = new TreeSet();\n  var pts = g.getCoordinates();\n  for (var i = 0; i < pts.length; i++) {\n    ptSet.add(pts[i]);\n  }\n  return ptSet.toArray(new Array(0).fill(null))\n};\nGeometrySnapper.prototype.computeMinimumSegmentLength = function computeMinimumSegmentLength (pts) {\n  var minSegLen = Double.MAX_VALUE;\n  for (var i = 0; i < pts.length - 1; i++) {\n    var segLen = pts[i].distance(pts[i + 1]);\n    if (segLen < minSegLen) { minSegLen = segLen; }\n  }\n  return minSegLen\n};\nGeometrySnapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometrySnapper.prototype.getClass = function getClass () {\n  return GeometrySnapper\n};\nGeometrySnapper.snap = function snap (g0, g1, snapTolerance) {\n  var snapGeom = new Array(2).fill(null);\n  var snapper0 = new GeometrySnapper(g0);\n  snapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n  var snapper1 = new GeometrySnapper(g1);\n  snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n  return snapGeom\n};\nGeometrySnapper.computeOverlaySnapTolerance = function computeOverlaySnapTolerance () {\n  if (arguments.length === 1) {\n    var g = arguments[0];\n    var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n    var pm = g.getPrecisionModel();\n    if (pm.getType() === PrecisionModel.FIXED) {\n      var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n      if (fixedSnapTol > snapTolerance) { snapTolerance = fixedSnapTol; }\n    }\n    return snapTolerance\n  } else if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1))\n  }\n};\nGeometrySnapper.computeSizeBasedSnapTolerance = function computeSizeBasedSnapTolerance (g) {\n  var env = g.getEnvelopeInternal();\n  var minDimension = Math.min(env.getHeight(), env.getWidth());\n  var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n  return snapTol\n};\nGeometrySnapper.snapToSelf = function snapToSelf (geom, snapTolerance, cleanResult) {\n  var snapper0 = new GeometrySnapper(geom);\n  return snapper0.snapToSelf(snapTolerance, cleanResult)\n};\nstaticAccessors$41.SNAP_PRECISION_FACTOR.get = function () { return 1e-9 };\n\nObject.defineProperties( GeometrySnapper, staticAccessors$41 );\n\nvar SnapTransformer = (function (GeometryTransformer$$1) {\n  function SnapTransformer (snapTolerance, snapPts, isSelfSnap) {\n    GeometryTransformer$$1.call(this);\n    this._snapTolerance = snapTolerance || null;\n    this._snapPts = snapPts || null;\n    this._isSelfSnap = (isSelfSnap !== undefined) ? isSelfSnap : false;\n  }\n\n  if ( GeometryTransformer$$1 ) SnapTransformer.__proto__ = GeometryTransformer$$1;\n  SnapTransformer.prototype = Object.create( GeometryTransformer$$1 && GeometryTransformer$$1.prototype );\n  SnapTransformer.prototype.constructor = SnapTransformer;\n  SnapTransformer.prototype.snapLine = function snapLine (srcPts, snapPts) {\n    var snapper = new LineStringSnapper(srcPts, this._snapTolerance);\n    snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);\n    return snapper.snapTo(snapPts)\n  };\n  SnapTransformer.prototype.transformCoordinates = function transformCoordinates (coords, parent) {\n    var srcPts = coords.toCoordinateArray();\n    var newPts = this.snapLine(srcPts, this._snapPts);\n    return this._factory.getCoordinateSequenceFactory().create(newPts)\n  };\n  SnapTransformer.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  SnapTransformer.prototype.getClass = function getClass () {\n    return SnapTransformer\n  };\n\n  return SnapTransformer;\n}(GeometryTransformer));\n\nvar CommonBits = function CommonBits () {\n  this._isFirst = true;\n  this._commonMantissaBitsCount = 53;\n  this._commonBits = 0;\n  this._commonSignExp = null;\n};\nCommonBits.prototype.getCommon = function getCommon () {\n  return Double.longBitsToDouble(this._commonBits)\n};\nCommonBits.prototype.add = function add (num) {\n  var numBits = Double.doubleToLongBits(num);\n  if (this._isFirst) {\n    this._commonBits = numBits;\n    this._commonSignExp = CommonBits.signExpBits(this._commonBits);\n    this._isFirst = false;\n    return null\n  }\n  var numSignExp = CommonBits.signExpBits(numBits);\n  if (numSignExp !== this._commonSignExp) {\n    this._commonBits = 0;\n    return null\n  }\n  this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);\n  this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n};\nCommonBits.prototype.toString = function toString () {\n  if (arguments.length === 1) {\n    var bits = arguments[0];\n    var x = Double.longBitsToDouble(bits);\n    var numStr = Double.toBinaryString(bits);\n    var padStr = '0000000000000000000000000000000000000000000000000000000000000000' + numStr;\n    var bitStr = padStr.substring(padStr.length - 64);\n    var str = bitStr.substring(0, 1) + '  ' + bitStr.substring(1, 12) + '(exp) ' + bitStr.substring(12) + ' [ ' + x + ' ]';\n    return str\n  }\n};\nCommonBits.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCommonBits.prototype.getClass = function getClass () {\n  return CommonBits\n};\nCommonBits.getBit = function getBit (bits, i) {\n  var mask = 1 << i;\n  return (bits & mask) !== 0 ? 1 : 0\n};\nCommonBits.signExpBits = function signExpBits (num) {\n  return num >> 52\n};\nCommonBits.zeroLowerBits = function zeroLowerBits (bits, nBits) {\n  var invMask = (1 << nBits) - 1;\n  var mask = ~invMask;\n  var zeroed = bits & mask;\n  return zeroed\n};\nCommonBits.numCommonMostSigMantissaBits = function numCommonMostSigMantissaBits (num1, num2) {\n  var count = 0;\n  for (var i = 52; i >= 0; i--) {\n    if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) { return count }\n    count++;\n  }\n  return 52\n};\n\nvar CommonBitsRemover = function CommonBitsRemover () {\n  this._commonCoord = null;\n  this._ccFilter = new CommonCoordinateFilter();\n};\n\nvar staticAccessors$42 = { CommonCoordinateFilter: { configurable: true },Translater: { configurable: true } };\nCommonBitsRemover.prototype.addCommonBits = function addCommonBits (geom) {\n  var trans = new Translater(this._commonCoord);\n  geom.apply(trans);\n  geom.geometryChanged();\n};\nCommonBitsRemover.prototype.removeCommonBits = function removeCommonBits (geom) {\n  if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) { return geom }\n  var invCoord = new Coordinate(this._commonCoord);\n  invCoord.x = -invCoord.x;\n  invCoord.y = -invCoord.y;\n  var trans = new Translater(invCoord);\n  geom.apply(trans);\n  geom.geometryChanged();\n  return geom\n};\nCommonBitsRemover.prototype.getCommonCoordinate = function getCommonCoordinate () {\n  return this._commonCoord\n};\nCommonBitsRemover.prototype.add = function add (geom) {\n  geom.apply(this._ccFilter);\n  this._commonCoord = this._ccFilter.getCommonCoordinate();\n};\nCommonBitsRemover.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCommonBitsRemover.prototype.getClass = function getClass () {\n  return CommonBitsRemover\n};\nstaticAccessors$42.CommonCoordinateFilter.get = function () { return CommonCoordinateFilter };\nstaticAccessors$42.Translater.get = function () { return Translater };\n\nObject.defineProperties( CommonBitsRemover, staticAccessors$42 );\n\nvar CommonCoordinateFilter = function CommonCoordinateFilter () {\n  this._commonBitsX = new CommonBits();\n  this._commonBitsY = new CommonBits();\n};\nCommonCoordinateFilter.prototype.filter = function filter (coord) {\n  this._commonBitsX.add(coord.x);\n  this._commonBitsY.add(coord.y);\n};\nCommonCoordinateFilter.prototype.getCommonCoordinate = function getCommonCoordinate () {\n  return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())\n};\nCommonCoordinateFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateFilter]\n};\nCommonCoordinateFilter.prototype.getClass = function getClass () {\n  return CommonCoordinateFilter\n};\n\nvar Translater = function Translater () {\n  this.trans = null;\n  var trans = arguments[0];\n  this.trans = trans;\n};\nTranslater.prototype.filter = function filter (seq, i) {\n  var xp = seq.getOrdinate(i, 0) + this.trans.x;\n  var yp = seq.getOrdinate(i, 1) + this.trans.y;\n  seq.setOrdinate(i, 0, xp);\n  seq.setOrdinate(i, 1, yp);\n};\nTranslater.prototype.isDone = function isDone () {\n  return false\n};\nTranslater.prototype.isGeometryChanged = function isGeometryChanged () {\n  return true\n};\nTranslater.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFilter]\n};\nTranslater.prototype.getClass = function getClass () {\n  return Translater\n};\n\nvar SnapOverlayOp = function SnapOverlayOp (g1, g2) {\n  this._geom = new Array(2).fill(null);\n  this._snapTolerance = null;\n  this._cbr = null;\n  this._geom[0] = g1;\n  this._geom[1] = g2;\n  this.computeSnapTolerance();\n};\nSnapOverlayOp.prototype.selfSnap = function selfSnap (geom) {\n  var snapper0 = new GeometrySnapper(geom);\n  var snapGeom = snapper0.snapTo(geom, this._snapTolerance);\n  return snapGeom\n};\nSnapOverlayOp.prototype.removeCommonBits = function removeCommonBits (geom) {\n  this._cbr = new CommonBitsRemover();\n  this._cbr.add(geom[0]);\n  this._cbr.add(geom[1]);\n  var remGeom = new Array(2).fill(null);\n  remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());\n  remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());\n  return remGeom\n};\nSnapOverlayOp.prototype.prepareResult = function prepareResult (geom) {\n  this._cbr.addCommonBits(geom);\n  return geom\n};\nSnapOverlayOp.prototype.getResultGeometry = function getResultGeometry (opCode) {\n  var prepGeom = this.snap(this._geom);\n  var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n  return this.prepareResult(result)\n};\nSnapOverlayOp.prototype.checkValid = function checkValid (g) {\n  if (!g.isValid()) {\n    System.out.println('Snapped geometry is invalid');\n  }\n};\nSnapOverlayOp.prototype.computeSnapTolerance = function computeSnapTolerance () {\n  this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n};\nSnapOverlayOp.prototype.snap = function snap (geom) {\n  var remGeom = this.removeCommonBits(geom);\n  var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);\n  return snapGeom\n};\nSnapOverlayOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSnapOverlayOp.prototype.getClass = function getClass () {\n  return SnapOverlayOp\n};\nSnapOverlayOp.overlayOp = function overlayOp (g0, g1, opCode) {\n  var op = new SnapOverlayOp(g0, g1);\n  return op.getResultGeometry(opCode)\n};\nSnapOverlayOp.union = function union (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)\n};\nSnapOverlayOp.intersection = function intersection (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)\n};\nSnapOverlayOp.symDifference = function symDifference (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)\n};\nSnapOverlayOp.difference = function difference (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)\n};\n\nvar SnapIfNeededOverlayOp = function SnapIfNeededOverlayOp (g1, g2) {\n  this._geom = new Array(2).fill(null);\n  this._geom[0] = g1;\n  this._geom[1] = g2;\n};\nSnapIfNeededOverlayOp.prototype.getResultGeometry = function getResultGeometry (opCode) {\n  var result = null;\n  var isSuccess = false;\n  var savedException = null;\n  try {\n    result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n    var isValid = true;\n    if (isValid) { isSuccess = true; }\n  } catch (ex) {\n    if (ex instanceof RuntimeException) {\n      savedException = ex;\n    } else { throw ex }\n  } finally {}\n  if (!isSuccess) {\n    try {\n      result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n    } catch (ex) {\n      if (ex instanceof RuntimeException) {\n        throw savedException\n      } else { throw ex }\n    } finally {}\n  }\n  return result\n};\nSnapIfNeededOverlayOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSnapIfNeededOverlayOp.prototype.getClass = function getClass () {\n  return SnapIfNeededOverlayOp\n};\nSnapIfNeededOverlayOp.overlayOp = function overlayOp (g0, g1, opCode) {\n  var op = new SnapIfNeededOverlayOp(g0, g1);\n  return op.getResultGeometry(opCode)\n};\nSnapIfNeededOverlayOp.union = function union (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)\n};\nSnapIfNeededOverlayOp.intersection = function intersection (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)\n};\nSnapIfNeededOverlayOp.symDifference = function symDifference (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)\n};\nSnapIfNeededOverlayOp.difference = function difference (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)\n};\n\nvar MonotoneChain$2 = function MonotoneChain () {\n  this.mce = null;\n  this.chainIndex = null;\n  var mce = arguments[0];\n  var chainIndex = arguments[1];\n  this.mce = mce;\n  this.chainIndex = chainIndex;\n};\nMonotoneChain$2.prototype.computeIntersections = function computeIntersections (mc, si) {\n  this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n};\nMonotoneChain$2.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChain$2.prototype.getClass = function getClass () {\n  return MonotoneChain$2\n};\n\nvar SweepLineEvent = function SweepLineEvent () {\n  this._label = null;\n  this._xValue = null;\n  this._eventType = null;\n  this._insertEvent = null;\n  this._deleteEventIndex = null;\n  this._obj = null;\n  if (arguments.length === 2) {\n    var x = arguments[0];\n    var insertEvent = arguments[1];\n    this._eventType = SweepLineEvent.DELETE;\n    this._xValue = x;\n    this._insertEvent = insertEvent;\n  } else if (arguments.length === 3) {\n    var label = arguments[0];\n    var x$1 = arguments[1];\n    var obj = arguments[2];\n    this._eventType = SweepLineEvent.INSERT;\n    this._label = label;\n    this._xValue = x$1;\n    this._obj = obj;\n  }\n};\n\nvar staticAccessors$43 = { INSERT: { configurable: true },DELETE: { configurable: true } };\nSweepLineEvent.prototype.isDelete = function isDelete () {\n  return this._eventType === SweepLineEvent.DELETE\n};\nSweepLineEvent.prototype.setDeleteEventIndex = function setDeleteEventIndex (deleteEventIndex) {\n  this._deleteEventIndex = deleteEventIndex;\n};\nSweepLineEvent.prototype.getObject = function getObject () {\n  return this._obj\n};\nSweepLineEvent.prototype.compareTo = function compareTo (o) {\n  var pe = o;\n  if (this._xValue < pe._xValue) { return -1 }\n  if (this._xValue > pe._xValue) { return 1 }\n  if (this._eventType < pe._eventType) { return -1 }\n  if (this._eventType > pe._eventType) { return 1 }\n  return 0\n};\nSweepLineEvent.prototype.getInsertEvent = function getInsertEvent () {\n  return this._insertEvent\n};\nSweepLineEvent.prototype.isInsert = function isInsert () {\n  return this._eventType === SweepLineEvent.INSERT\n};\nSweepLineEvent.prototype.isSameLabel = function isSameLabel (ev) {\n  if (this._label === null) { return false }\n  return this._label === ev._label\n};\nSweepLineEvent.prototype.getDeleteEventIndex = function getDeleteEventIndex () {\n  return this._deleteEventIndex\n};\nSweepLineEvent.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nSweepLineEvent.prototype.getClass = function getClass () {\n  return SweepLineEvent\n};\nstaticAccessors$43.INSERT.get = function () { return 1 };\nstaticAccessors$43.DELETE.get = function () { return 2 };\n\nObject.defineProperties( SweepLineEvent, staticAccessors$43 );\n\nvar EdgeSetIntersector = function EdgeSetIntersector () {};\n\nEdgeSetIntersector.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeSetIntersector.prototype.getClass = function getClass () {\n  return EdgeSetIntersector\n};\n\nvar SegmentIntersector$2 = function SegmentIntersector () {\n  this._hasIntersection = false;\n  this._hasProper = false;\n  this._hasProperInterior = false;\n  this._properIntersectionPoint = null;\n  this._li = null;\n  this._includeProper = null;\n  this._recordIsolated = null;\n  this._isSelfIntersection = null;\n  this._numIntersections = 0;\n  this.numTests = 0;\n  this._bdyNodes = null;\n  this._isDone = false;\n  this._isDoneWhenProperInt = false;\n  var li = arguments[0];\n  var includeProper = arguments[1];\n  var recordIsolated = arguments[2];\n  this._li = li;\n  this._includeProper = includeProper;\n  this._recordIsolated = recordIsolated;\n};\nSegmentIntersector$2.prototype.isTrivialIntersection = function isTrivialIntersection (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1) {\n    if (this._li.getIntersectionNum() === 1) {\n      if (SegmentIntersector$2.isAdjacentSegments(segIndex0, segIndex1)) { return true }\n      if (e0.isClosed()) {\n        var maxSegIndex = e0.getNumPoints() - 1;\n        if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||\n            (segIndex1 === 0 && segIndex0 === maxSegIndex)) {\n          return true\n        }\n      }\n    }\n  }\n  return false\n};\nSegmentIntersector$2.prototype.getProperIntersectionPoint = function getProperIntersectionPoint () {\n  return this._properIntersectionPoint\n};\nSegmentIntersector$2.prototype.setIsDoneIfProperInt = function setIsDoneIfProperInt (isDoneWhenProperInt) {\n  this._isDoneWhenProperInt = isDoneWhenProperInt;\n};\nSegmentIntersector$2.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection () {\n  return this._hasProperInterior\n};\nSegmentIntersector$2.prototype.isBoundaryPointInternal = function isBoundaryPointInternal (li, bdyNodes) {\n  for (var i = bdyNodes.iterator(); i.hasNext();) {\n    var node = i.next();\n    var pt = node.getCoordinate();\n    if (li.isIntersection(pt)) { return true }\n  }\n  return false\n};\nSegmentIntersector$2.prototype.hasProperIntersection = function hasProperIntersection () {\n  return this._hasProper\n};\nSegmentIntersector$2.prototype.hasIntersection = function hasIntersection () {\n  return this._hasIntersection\n};\nSegmentIntersector$2.prototype.isDone = function isDone () {\n  return this._isDone\n};\nSegmentIntersector$2.prototype.isBoundaryPoint = function isBoundaryPoint (li, bdyNodes) {\n  if (bdyNodes === null) { return false }\n  if (this.isBoundaryPointInternal(li, bdyNodes[0])) { return true }\n  if (this.isBoundaryPointInternal(li, bdyNodes[1])) { return true }\n  return false\n};\nSegmentIntersector$2.prototype.setBoundaryNodes = function setBoundaryNodes (bdyNodes0, bdyNodes1) {\n  this._bdyNodes = new Array(2).fill(null);\n  this._bdyNodes[0] = bdyNodes0;\n  this._bdyNodes[1] = bdyNodes1;\n};\nSegmentIntersector$2.prototype.addIntersections = function addIntersections (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  this.numTests++;\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    if (this._recordIsolated) {\n      e0.setIsolated(false);\n      e1.setIsolated(false);\n    }\n    this._numIntersections++;\n    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n      this._hasIntersection = true;\n      if (this._includeProper || !this._li.isProper()) {\n        e0.addIntersections(this._li, segIndex0, 0);\n        e1.addIntersections(this._li, segIndex1, 1);\n      }\n      if (this._li.isProper()) {\n        this._properIntersectionPoint = this._li.getIntersection(0).copy();\n        this._hasProper = true;\n        if (this._isDoneWhenProperInt) {\n          this._isDone = true;\n        }\n        if (!this.isBoundaryPoint(this._li, this._bdyNodes)) { this._hasProperInterior = true; }\n      }\n    }\n  }\n};\nSegmentIntersector$2.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentIntersector$2.prototype.getClass = function getClass () {\n  return SegmentIntersector$2\n};\nSegmentIntersector$2.isAdjacentSegments = function isAdjacentSegments (i1, i2) {\n  return Math.abs(i1 - i2) === 1\n};\n\nvar SimpleMCSweepLineIntersector = (function (EdgeSetIntersector$$1) {\n  function SimpleMCSweepLineIntersector () {\n    EdgeSetIntersector$$1.call(this);\n    this.events = new ArrayList();\n    this.nOverlaps = null;\n  }\n\n  if ( EdgeSetIntersector$$1 ) SimpleMCSweepLineIntersector.__proto__ = EdgeSetIntersector$$1;\n  SimpleMCSweepLineIntersector.prototype = Object.create( EdgeSetIntersector$$1 && EdgeSetIntersector$$1.prototype );\n  SimpleMCSweepLineIntersector.prototype.constructor = SimpleMCSweepLineIntersector;\n  SimpleMCSweepLineIntersector.prototype.prepareEvents = function prepareEvents () {\n    var this$1 = this;\n\n    Collections.sort(this.events);\n    for (var i = 0; i < this.events.size(); i++) {\n      var ev = this$1.events.get(i);\n      if (ev.isDelete()) {\n        ev.getInsertEvent().setDeleteEventIndex(i);\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.computeIntersections = function computeIntersections () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var si = arguments[0];\n      this.nOverlaps = 0;\n      this.prepareEvents();\n      for (var i = 0; i < this.events.size(); i++) {\n        var ev = this$1.events.get(i);\n        if (ev.isInsert()) {\n          this$1.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n        }\n        if (si.isDone()) {\n          break\n        }\n      }\n    } else if (arguments.length === 3) {\n      if (arguments[2] instanceof SegmentIntersector$2 && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n        var edges0 = arguments[0];\n        var edges1 = arguments[1];\n        var si$1 = arguments[2];\n        this.addEdges(edges0, edges0);\n        this.addEdges(edges1, edges1);\n        this.computeIntersections(si$1);\n      } else if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$2)) {\n        var edges = arguments[0];\n        var si$2 = arguments[1];\n        var testAllSegments = arguments[2];\n        if (testAllSegments) { this.addEdges(edges, null); } else { this.addEdges(edges); }\n        this.computeIntersections(si$2);\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.addEdge = function addEdge (edge, edgeSet) {\n    var this$1 = this;\n\n    var mce = edge.getMonotoneChainEdge();\n    var startIndex = mce.getStartIndexes();\n    for (var i = 0; i < startIndex.length - 1; i++) {\n      var mc = new MonotoneChain$2(mce, i);\n      var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n      this$1.events.add(insertEvent);\n      this$1.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.processOverlaps = function processOverlaps (start, end, ev0, si) {\n    var this$1 = this;\n\n    var mc0 = ev0.getObject();\n    for (var i = start; i < end; i++) {\n      var ev1 = this$1.events.get(i);\n      if (ev1.isInsert()) {\n        var mc1 = ev1.getObject();\n        if (!ev0.isSameLabel(ev1)) {\n          mc0.computeIntersections(mc1, si);\n          this$1.nOverlaps++;\n        }\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.addEdges = function addEdges () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var edges = arguments[0];\n      for (var i = edges.iterator(); i.hasNext();) {\n        var edge = i.next();\n        this$1.addEdge(edge, edge);\n      }\n    } else if (arguments.length === 2) {\n      var edges$1 = arguments[0];\n      var edgeSet = arguments[1];\n      for (var i$1 = edges$1.iterator(); i$1.hasNext();) {\n        var edge$1 = i$1.next();\n        this$1.addEdge(edge$1, edgeSet);\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  SimpleMCSweepLineIntersector.prototype.getClass = function getClass () {\n    return SimpleMCSweepLineIntersector\n  };\n\n  return SimpleMCSweepLineIntersector;\n}(EdgeSetIntersector));\n\nvar IntervalRTreeNode = function IntervalRTreeNode () {\n  this._min = Double.POSITIVE_INFINITY;\n  this._max = Double.NEGATIVE_INFINITY;\n};\n\nvar staticAccessors$45 = { NodeComparator: { configurable: true } };\nIntervalRTreeNode.prototype.getMin = function getMin () {\n  return this._min\n};\nIntervalRTreeNode.prototype.intersects = function intersects (queryMin, queryMax) {\n  if (this._min > queryMax || this._max < queryMin) { return false }\n  return true\n};\nIntervalRTreeNode.prototype.getMax = function getMax () {\n  return this._max\n};\nIntervalRTreeNode.prototype.toString = function toString () {\n  return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0))\n};\nIntervalRTreeNode.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nIntervalRTreeNode.prototype.getClass = function getClass () {\n  return IntervalRTreeNode\n};\nstaticAccessors$45.NodeComparator.get = function () { return NodeComparator };\n\nObject.defineProperties( IntervalRTreeNode, staticAccessors$45 );\n\nvar NodeComparator = function NodeComparator () {};\n\nNodeComparator.prototype.compare = function compare (o1, o2) {\n  var n1 = o1;\n  var n2 = o2;\n  var mid1 = (n1._min + n1._max) / 2;\n  var mid2 = (n2._min + n2._max) / 2;\n  if (mid1 < mid2) { return -1 }\n  if (mid1 > mid2) { return 1 }\n  return 0\n};\nNodeComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nNodeComparator.prototype.getClass = function getClass () {\n  return NodeComparator\n};\n\nvar IntervalRTreeLeafNode = (function (IntervalRTreeNode$$1) {\n  function IntervalRTreeLeafNode () {\n    IntervalRTreeNode$$1.call(this);\n    this._item = null;\n    var min = arguments[0];\n    var max = arguments[1];\n    var item = arguments[2];\n    this._min = min;\n    this._max = max;\n    this._item = item;\n  }\n\n  if ( IntervalRTreeNode$$1 ) IntervalRTreeLeafNode.__proto__ = IntervalRTreeNode$$1;\n  IntervalRTreeLeafNode.prototype = Object.create( IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype );\n  IntervalRTreeLeafNode.prototype.constructor = IntervalRTreeLeafNode;\n  IntervalRTreeLeafNode.prototype.query = function query (queryMin, queryMax, visitor) {\n    if (!this.intersects(queryMin, queryMax)) { return null }\n    visitor.visitItem(this._item);\n  };\n  IntervalRTreeLeafNode.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  IntervalRTreeLeafNode.prototype.getClass = function getClass () {\n    return IntervalRTreeLeafNode\n  };\n\n  return IntervalRTreeLeafNode;\n}(IntervalRTreeNode));\n\nvar IntervalRTreeBranchNode = (function (IntervalRTreeNode$$1) {\n  function IntervalRTreeBranchNode () {\n    IntervalRTreeNode$$1.call(this);\n    this._node1 = null;\n    this._node2 = null;\n    var n1 = arguments[0];\n    var n2 = arguments[1];\n    this._node1 = n1;\n    this._node2 = n2;\n    this.buildExtent(this._node1, this._node2);\n  }\n\n  if ( IntervalRTreeNode$$1 ) IntervalRTreeBranchNode.__proto__ = IntervalRTreeNode$$1;\n  IntervalRTreeBranchNode.prototype = Object.create( IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype );\n  IntervalRTreeBranchNode.prototype.constructor = IntervalRTreeBranchNode;\n  IntervalRTreeBranchNode.prototype.buildExtent = function buildExtent (n1, n2) {\n    this._min = Math.min(n1._min, n2._min);\n    this._max = Math.max(n1._max, n2._max);\n  };\n  IntervalRTreeBranchNode.prototype.query = function query (queryMin, queryMax, visitor) {\n    if (!this.intersects(queryMin, queryMax)) {\n      return null\n    }\n    if (this._node1 !== null) { this._node1.query(queryMin, queryMax, visitor); }\n    if (this._node2 !== null) { this._node2.query(queryMin, queryMax, visitor); }\n  };\n  IntervalRTreeBranchNode.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  IntervalRTreeBranchNode.prototype.getClass = function getClass () {\n    return IntervalRTreeBranchNode\n  };\n\n  return IntervalRTreeBranchNode;\n}(IntervalRTreeNode));\n\nvar SortedPackedIntervalRTree = function SortedPackedIntervalRTree () {\n  this._leaves = new ArrayList();\n  this._root = null;\n  this._level = 0;\n};\nSortedPackedIntervalRTree.prototype.buildTree = function buildTree () {\n    var this$1 = this;\n\n  Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n  var src = this._leaves;\n  var temp = null;\n  var dest = new ArrayList();\n  while (true) {\n    this$1.buildLevel(src, dest);\n    if (dest.size() === 1) { return dest.get(0) }\n    temp = src;\n    src = dest;\n    dest = temp;\n  }\n};\nSortedPackedIntervalRTree.prototype.insert = function insert (min, max, item) {\n  if (this._root !== null) { throw new Error('Index cannot be added to once it has been queried') }\n  this._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n};\nSortedPackedIntervalRTree.prototype.query = function query (min, max, visitor) {\n  this.init();\n  this._root.query(min, max, visitor);\n};\nSortedPackedIntervalRTree.prototype.buildRoot = function buildRoot () {\n  if (this._root !== null) { return null }\n  this._root = this.buildTree();\n};\nSortedPackedIntervalRTree.prototype.printNode = function printNode (node) {\n  System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n};\nSortedPackedIntervalRTree.prototype.init = function init () {\n  if (this._root !== null) { return null }\n  this.buildRoot();\n};\nSortedPackedIntervalRTree.prototype.buildLevel = function buildLevel (src, dest) {\n  this._level++;\n  dest.clear();\n  for (var i = 0; i < src.size(); i += 2) {\n    var n1 = src.get(i);\n    var n2 = i + 1 < src.size() ? src.get(i) : null;\n    if (n2 === null) {\n      dest.add(n1);\n    } else {\n      var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n      dest.add(node);\n    }\n  }\n};\nSortedPackedIntervalRTree.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSortedPackedIntervalRTree.prototype.getClass = function getClass () {\n  return SortedPackedIntervalRTree\n};\n\nvar ArrayListVisitor = function ArrayListVisitor () {\n  this._items = new ArrayList();\n};\nArrayListVisitor.prototype.visitItem = function visitItem (item) {\n  this._items.add(item);\n};\nArrayListVisitor.prototype.getItems = function getItems () {\n  return this._items\n};\nArrayListVisitor.prototype.interfaces_ = function interfaces_ () {\n  return [ItemVisitor]\n};\nArrayListVisitor.prototype.getClass = function getClass () {\n  return ArrayListVisitor\n};\n\nvar IndexedPointInAreaLocator = function IndexedPointInAreaLocator () {\n  this._index = null;\n  var g = arguments[0];\n  if (!hasInterface(g, Polygonal)) { throw new IllegalArgumentException('Argument must be Polygonal') }\n  this._index = new IntervalIndexedGeometry(g);\n};\n\nvar staticAccessors$44 = { SegmentVisitor: { configurable: true },IntervalIndexedGeometry: { configurable: true } };\nIndexedPointInAreaLocator.prototype.locate = function locate (p) {\n  var rcc = new RayCrossingCounter(p);\n  var visitor = new SegmentVisitor(rcc);\n  this._index.query(p.y, p.y, visitor);\n  return rcc.getLocation()\n};\nIndexedPointInAreaLocator.prototype.interfaces_ = function interfaces_ () {\n  return [PointOnGeometryLocator]\n};\nIndexedPointInAreaLocator.prototype.getClass = function getClass () {\n  return IndexedPointInAreaLocator\n};\nstaticAccessors$44.SegmentVisitor.get = function () { return SegmentVisitor };\nstaticAccessors$44.IntervalIndexedGeometry.get = function () { return IntervalIndexedGeometry };\n\nObject.defineProperties( IndexedPointInAreaLocator, staticAccessors$44 );\n\nvar SegmentVisitor = function SegmentVisitor () {\n  this._counter = null;\n  var counter = arguments[0];\n  this._counter = counter;\n};\nSegmentVisitor.prototype.visitItem = function visitItem (item) {\n  var seg = item;\n  this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n};\nSegmentVisitor.prototype.interfaces_ = function interfaces_ () {\n  return [ItemVisitor]\n};\nSegmentVisitor.prototype.getClass = function getClass () {\n  return SegmentVisitor\n};\n\nvar IntervalIndexedGeometry = function IntervalIndexedGeometry () {\n  this._index = new SortedPackedIntervalRTree();\n  var geom = arguments[0];\n  this.init(geom);\n};\nIntervalIndexedGeometry.prototype.init = function init (geom) {\n    var this$1 = this;\n\n  var lines = LinearComponentExtracter.getLines(geom);\n  for (var i = lines.iterator(); i.hasNext();) {\n    var line = i.next();\n    var pts = line.getCoordinates();\n    this$1.addLine(pts);\n  }\n};\nIntervalIndexedGeometry.prototype.addLine = function addLine (pts) {\n    var this$1 = this;\n\n  for (var i = 1; i < pts.length; i++) {\n    var seg = new LineSegment(pts[i - 1], pts[i]);\n    var min = Math.min(seg.p0.y, seg.p1.y);\n    var max = Math.max(seg.p0.y, seg.p1.y);\n    this$1._index.insert(min, max, seg);\n  }\n};\nIntervalIndexedGeometry.prototype.query = function query () {\n  if (arguments.length === 2) {\n    var min = arguments[0];\n    var max = arguments[1];\n    var visitor = new ArrayListVisitor();\n    this._index.query(min, max, visitor);\n    return visitor.getItems()\n  } else if (arguments.length === 3) {\n    var min$1 = arguments[0];\n    var max$1 = arguments[1];\n    var visitor$1 = arguments[2];\n    this._index.query(min$1, max$1, visitor$1);\n  }\n};\nIntervalIndexedGeometry.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nIntervalIndexedGeometry.prototype.getClass = function getClass () {\n  return IntervalIndexedGeometry\n};\n\nvar GeometryGraph = (function (PlanarGraph$$1) {\n  function GeometryGraph () {\n    PlanarGraph$$1.call(this);\n    this._parentGeom = null;\n    this._lineEdgeMap = new HashMap();\n    this._boundaryNodeRule = null;\n    this._useBoundaryDeterminationRule = true;\n    this._argIndex = null;\n    this._boundaryNodes = null;\n    this._hasTooFewPoints = false;\n    this._invalidPoint = null;\n    this._areaPtLocator = null;\n    this._ptLocator = new PointLocator();\n    if (arguments.length === 2) {\n      var argIndex = arguments[0];\n      var parentGeom = arguments[1];\n      var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n      this._argIndex = argIndex;\n      this._parentGeom = parentGeom;\n      this._boundaryNodeRule = boundaryNodeRule;\n      if (parentGeom !== null) {\n        this.add(parentGeom);\n      }\n    } else if (arguments.length === 3) {\n      var argIndex$1 = arguments[0];\n      var parentGeom$1 = arguments[1];\n      var boundaryNodeRule$1 = arguments[2];\n      this._argIndex = argIndex$1;\n      this._parentGeom = parentGeom$1;\n      this._boundaryNodeRule = boundaryNodeRule$1;\n      if (parentGeom$1 !== null) {\n        this.add(parentGeom$1);\n      }\n    }\n  }\n\n  if ( PlanarGraph$$1 ) GeometryGraph.__proto__ = PlanarGraph$$1;\n  GeometryGraph.prototype = Object.create( PlanarGraph$$1 && PlanarGraph$$1.prototype );\n  GeometryGraph.prototype.constructor = GeometryGraph;\n  GeometryGraph.prototype.insertBoundaryPoint = function insertBoundaryPoint (argIndex, coord) {\n    var n = this._nodes.addNode(coord);\n    var lbl = n.getLabel();\n    var boundaryCount = 1;\n    var loc = Location.NONE;\n    loc = lbl.getLocation(argIndex, Position.ON);\n    if (loc === Location.BOUNDARY) { boundaryCount++; }\n    var newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n    lbl.setLocation(argIndex, newLoc);\n  };\n  GeometryGraph.prototype.computeSelfNodes = function computeSelfNodes () {\n    if (arguments.length === 2) {\n      var li = arguments[0];\n      var computeRingSelfNodes = arguments[1];\n      return this.computeSelfNodes(li, computeRingSelfNodes, false)\n    } else if (arguments.length === 3) {\n      var li$1 = arguments[0];\n      var computeRingSelfNodes$1 = arguments[1];\n      var isDoneIfProperInt = arguments[2];\n      var si = new SegmentIntersector$2(li$1, true, false);\n      si.setIsDoneIfProperInt(isDoneIfProperInt);\n      var esi = this.createEdgeSetIntersector();\n      var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n      var computeAllSegments = computeRingSelfNodes$1 || !isRings;\n      esi.computeIntersections(this._edges, si, computeAllSegments);\n      this.addSelfIntersectionNodes(this._argIndex);\n      return si\n    }\n  };\n  GeometryGraph.prototype.computeSplitEdges = function computeSplitEdges (edgelist) {\n    for (var i = this._edges.iterator(); i.hasNext();) {\n      var e = i.next();\n      e.eiList.addSplitEdges(edgelist);\n    }\n  };\n  GeometryGraph.prototype.computeEdgeIntersections = function computeEdgeIntersections (g, li, includeProper) {\n    var si = new SegmentIntersector$2(li, includeProper, true);\n    si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n    var esi = this.createEdgeSetIntersector();\n    esi.computeIntersections(this._edges, g._edges, si);\n    return si\n  };\n  GeometryGraph.prototype.getGeometry = function getGeometry () {\n    return this._parentGeom\n  };\n  GeometryGraph.prototype.getBoundaryNodeRule = function getBoundaryNodeRule () {\n    return this._boundaryNodeRule\n  };\n  GeometryGraph.prototype.hasTooFewPoints = function hasTooFewPoints () {\n    return this._hasTooFewPoints\n  };\n  GeometryGraph.prototype.addPoint = function addPoint () {\n    if (arguments[0] instanceof Point) {\n      var p = arguments[0];\n      var coord = p.getCoordinate();\n      this.insertPoint(this._argIndex, coord, Location.INTERIOR);\n    } else if (arguments[0] instanceof Coordinate) {\n      var pt = arguments[0];\n      this.insertPoint(this._argIndex, pt, Location.INTERIOR);\n    }\n  };\n  GeometryGraph.prototype.addPolygon = function addPolygon (p) {\n    var this$1 = this;\n\n    this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n    for (var i = 0; i < p.getNumInteriorRing(); i++) {\n      var hole = p.getInteriorRingN(i);\n      this$1.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n    }\n  };\n  GeometryGraph.prototype.addEdge = function addEdge (e) {\n    this.insertEdge(e);\n    var coord = e.getCoordinates();\n    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n    this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n  };\n  GeometryGraph.prototype.addLineString = function addLineString (line) {\n    var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n    if (coord.length < 2) {\n      this._hasTooFewPoints = true;\n      this._invalidPoint = coord[0];\n      return null\n    }\n    var e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n    this._lineEdgeMap.put(line, e);\n    this.insertEdge(e);\n    Assert.isTrue(coord.length >= 2, 'found LineString with single point');\n    this.insertBoundaryPoint(this._argIndex, coord[0]);\n    this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n  };\n  GeometryGraph.prototype.getInvalidPoint = function getInvalidPoint () {\n    return this._invalidPoint\n  };\n  GeometryGraph.prototype.getBoundaryPoints = function getBoundaryPoints () {\n    var coll = this.getBoundaryNodes();\n    var pts = new Array(coll.size()).fill(null);\n    var i = 0;\n    for (var it = coll.iterator(); it.hasNext();) {\n      var node = it.next();\n      pts[i++] = node.getCoordinate().copy();\n    }\n    return pts\n  };\n  GeometryGraph.prototype.getBoundaryNodes = function getBoundaryNodes () {\n    if (this._boundaryNodes === null) { this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex); }\n    return this._boundaryNodes\n  };\n  GeometryGraph.prototype.addSelfIntersectionNode = function addSelfIntersectionNode (argIndex, coord, loc) {\n    if (this.isBoundaryNode(argIndex, coord)) { return null }\n    if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) { this.insertBoundaryPoint(argIndex, coord); } else { this.insertPoint(argIndex, coord, loc); }\n  };\n  GeometryGraph.prototype.addPolygonRing = function addPolygonRing (lr, cwLeft, cwRight) {\n    if (lr.isEmpty()) { return null }\n    var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n    if (coord.length < 4) {\n      this._hasTooFewPoints = true;\n      this._invalidPoint = coord[0];\n      return null\n    }\n    var left = cwLeft;\n    var right = cwRight;\n    if (CGAlgorithms.isCCW(coord)) {\n      left = cwRight;\n      right = cwLeft;\n    }\n    var e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n    this._lineEdgeMap.put(lr, e);\n    this.insertEdge(e);\n    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n  };\n  GeometryGraph.prototype.insertPoint = function insertPoint (argIndex, coord, onLocation) {\n    var n = this._nodes.addNode(coord);\n    var lbl = n.getLabel();\n    if (lbl === null) {\n      n._label = new Label(argIndex, onLocation);\n    } else { lbl.setLocation(argIndex, onLocation); }\n  };\n  GeometryGraph.prototype.createEdgeSetIntersector = function createEdgeSetIntersector () {\n    return new SimpleMCSweepLineIntersector()\n  };\n  GeometryGraph.prototype.addSelfIntersectionNodes = function addSelfIntersectionNodes (argIndex) {\n    var this$1 = this;\n\n    for (var i = this._edges.iterator(); i.hasNext();) {\n      var e = i.next();\n      var eLoc = e.getLabel().getLocation(argIndex);\n      for (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {\n        var ei = eiIt.next();\n        this$1.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n      }\n    }\n  };\n  GeometryGraph.prototype.add = function add () {\n    if (arguments.length === 1) {\n      var g = arguments[0];\n      if (g.isEmpty()) { return null }\n      if (g instanceof MultiPolygon) { this._useBoundaryDeterminationRule = false; }\n      if (g instanceof Polygon) { this.addPolygon(g); }\n      else if (g instanceof LineString) { this.addLineString(g); }\n      else if (g instanceof Point) { this.addPoint(g); }\n      else if (g instanceof MultiPoint) { this.addCollection(g); }\n      else if (g instanceof MultiLineString) { this.addCollection(g); }\n      else if (g instanceof MultiPolygon) { this.addCollection(g); }\n      else if (g instanceof GeometryCollection) { this.addCollection(g); }\n      else { throw new Error(g.getClass().getName()) }\n    } else { return PlanarGraph$$1.prototype.add.apply(this, arguments) }\n  };\n  GeometryGraph.prototype.addCollection = function addCollection (gc) {\n    var this$1 = this;\n\n    for (var i = 0; i < gc.getNumGeometries(); i++) {\n      var g = gc.getGeometryN(i);\n      this$1.add(g);\n    }\n  };\n  GeometryGraph.prototype.locate = function locate (pt) {\n    if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n      if (this._areaPtLocator === null) {\n        this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n      }\n      return this._areaPtLocator.locate(pt)\n    }\n    return this._ptLocator.locate(pt, this._parentGeom)\n  };\n  GeometryGraph.prototype.findEdge = function findEdge () {\n    if (arguments.length === 1) {\n      var line = arguments[0];\n      return this._lineEdgeMap.get(line)\n    } else { return PlanarGraph$$1.prototype.findEdge.apply(this, arguments) }\n  };\n  GeometryGraph.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  GeometryGraph.prototype.getClass = function getClass () {\n    return GeometryGraph\n  };\n  GeometryGraph.determineBoundary = function determineBoundary (boundaryNodeRule, boundaryCount) {\n    return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR\n  };\n\n  return GeometryGraph;\n}(PlanarGraph));\n\nvar GeometryGraphOp = function GeometryGraphOp () {\n  this._li = new RobustLineIntersector();\n  this._resultPrecisionModel = null;\n  this._arg = null;\n  if (arguments.length === 1) {\n    var g0 = arguments[0];\n    this.setComputationPrecision(g0.getPrecisionModel());\n    this._arg = new Array(1).fill(null);\n    this._arg[0] = new GeometryGraph(0, g0);\n  } else if (arguments.length === 2) {\n    var g0$1 = arguments[0];\n    var g1 = arguments[1];\n    var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n    if (g0$1.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) { this.setComputationPrecision(g0$1.getPrecisionModel()); } else { this.setComputationPrecision(g1.getPrecisionModel()); }\n    this._arg = new Array(2).fill(null);\n    this._arg[0] = new GeometryGraph(0, g0$1, boundaryNodeRule);\n    this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n  } else if (arguments.length === 3) {\n    var g0$2 = arguments[0];\n    var g1$1 = arguments[1];\n    var boundaryNodeRule$1 = arguments[2];\n    if (g0$2.getPrecisionModel().compareTo(g1$1.getPrecisionModel()) >= 0) { this.setComputationPrecision(g0$2.getPrecisionModel()); } else { this.setComputationPrecision(g1$1.getPrecisionModel()); }\n    this._arg = new Array(2).fill(null);\n    this._arg[0] = new GeometryGraph(0, g0$2, boundaryNodeRule$1);\n    this._arg[1] = new GeometryGraph(1, g1$1, boundaryNodeRule$1);\n  }\n};\nGeometryGraphOp.prototype.getArgGeometry = function getArgGeometry (i) {\n  return this._arg[i].getGeometry()\n};\nGeometryGraphOp.prototype.setComputationPrecision = function setComputationPrecision (pm) {\n  this._resultPrecisionModel = pm;\n  this._li.setPrecisionModel(this._resultPrecisionModel);\n};\nGeometryGraphOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryGraphOp.prototype.getClass = function getClass () {\n  return GeometryGraphOp\n};\n\n// operation.geometrygraph\n\nvar GeometryMapper = function GeometryMapper () {};\n\nGeometryMapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryMapper.prototype.getClass = function getClass () {\n  return GeometryMapper\n};\nGeometryMapper.map = function map () {\n  if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {\n    var geom = arguments[0];\n    var op = arguments[1];\n    var mapped = new ArrayList();\n    for (var i = 0; i < geom.getNumGeometries(); i++) {\n      var g = op.map(geom.getGeometryN(i));\n      if (g !== null) { mapped.add(g); }\n    }\n    return geom.getFactory().buildGeometry(mapped)\n  } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {\n    var geoms = arguments[0];\n    var op$1 = arguments[1];\n    var mapped$1 = new ArrayList();\n    for (var i$1 = geoms.iterator(); i$1.hasNext();) {\n      var g$1 = i$1.next();\n      var gr = op$1.map(g$1);\n      if (gr !== null) { mapped$1.add(gr); }\n    }\n    return mapped$1\n  }\n};\nGeometryMapper.MapOp = function MapOp () {};\n\nvar OverlayOp = (function (GeometryGraphOp) {\n  function OverlayOp () {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    GeometryGraphOp.call(this, g0, g1);\n    this._ptLocator = new PointLocator();\n    this._geomFact = null;\n    this._resultGeom = null;\n    this._graph = null;\n    this._edgeList = new EdgeList();\n    this._resultPolyList = new ArrayList();\n    this._resultLineList = new ArrayList();\n    this._resultPointList = new ArrayList();\n    this._graph = new PlanarGraph(new OverlayNodeFactory());\n    this._geomFact = g0.getFactory();\n  }\n\n  if ( GeometryGraphOp ) OverlayOp.__proto__ = GeometryGraphOp;\n  OverlayOp.prototype = Object.create( GeometryGraphOp && GeometryGraphOp.prototype );\n  OverlayOp.prototype.constructor = OverlayOp;\n  OverlayOp.prototype.insertUniqueEdge = function insertUniqueEdge (e) {\n    var existingEdge = this._edgeList.findEqualEdge(e);\n    if (existingEdge !== null) {\n      var existingLabel = existingEdge.getLabel();\n      var labelToMerge = e.getLabel();\n      if (!existingEdge.isPointwiseEqual(e)) {\n        labelToMerge = new Label(e.getLabel());\n        labelToMerge.flip();\n      }\n      var depth = existingEdge.getDepth();\n      if (depth.isNull()) {\n        depth.add(existingLabel);\n      }\n      depth.add(labelToMerge);\n      existingLabel.merge(labelToMerge);\n    } else {\n      this._edgeList.add(e);\n    }\n  };\n  OverlayOp.prototype.getGraph = function getGraph () {\n    return this._graph\n  };\n  OverlayOp.prototype.cancelDuplicateResultEdges = function cancelDuplicateResultEdges () {\n    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n      var de = it.next();\n      var sym = de.getSym();\n      if (de.isInResult() && sym.isInResult()) {\n        de.setInResult(false);\n        sym.setInResult(false);\n      }\n    }\n  };\n  OverlayOp.prototype.isCoveredByLA = function isCoveredByLA (coord) {\n    if (this.isCovered(coord, this._resultLineList)) { return true }\n    if (this.isCovered(coord, this._resultPolyList)) { return true }\n    return false\n  };\n  OverlayOp.prototype.computeGeometry = function computeGeometry (resultPointList, resultLineList, resultPolyList, opcode) {\n    var geomList = new ArrayList();\n    geomList.addAll(resultPointList);\n    geomList.addAll(resultLineList);\n    geomList.addAll(resultPolyList);\n    if (geomList.isEmpty()) { return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) }\n    return this._geomFact.buildGeometry(geomList)\n  };\n  OverlayOp.prototype.mergeSymLabels = function mergeSymLabels () {\n    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n      var node = nodeit.next();\n      node.getEdges().mergeSymLabels();\n    }\n  };\n  OverlayOp.prototype.isCovered = function isCovered (coord, geomList) {\n    var this$1 = this;\n\n    for (var it = geomList.iterator(); it.hasNext();) {\n      var geom = it.next();\n      var loc = this$1._ptLocator.locate(coord, geom);\n      if (loc !== Location.EXTERIOR) { return true }\n    }\n    return false\n  };\n  OverlayOp.prototype.replaceCollapsedEdges = function replaceCollapsedEdges () {\n    var newEdges = new ArrayList();\n    for (var it = this._edgeList.iterator(); it.hasNext();) {\n      var e = it.next();\n      if (e.isCollapsed()) {\n        it.remove();\n        newEdges.add(e.getCollapsedEdge());\n      }\n    }\n    this._edgeList.addAll(newEdges);\n  };\n  OverlayOp.prototype.updateNodeLabelling = function updateNodeLabelling () {\n    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n      var node = nodeit.next();\n      var lbl = node.getEdges().getLabel();\n      node.getLabel().merge(lbl);\n    }\n  };\n  OverlayOp.prototype.getResultGeometry = function getResultGeometry (overlayOpCode) {\n    this.computeOverlay(overlayOpCode);\n    return this._resultGeom\n  };\n  OverlayOp.prototype.insertUniqueEdges = function insertUniqueEdges (edges) {\n    var this$1 = this;\n\n    for (var i = edges.iterator(); i.hasNext();) {\n      var e = i.next();\n      this$1.insertUniqueEdge(e);\n    }\n  };\n  OverlayOp.prototype.computeOverlay = function computeOverlay (opCode) {\n    this.copyPoints(0);\n    this.copyPoints(1);\n    this._arg[0].computeSelfNodes(this._li, false);\n    this._arg[1].computeSelfNodes(this._li, false);\n    this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);\n    var baseSplitEdges = new ArrayList();\n    this._arg[0].computeSplitEdges(baseSplitEdges);\n    this._arg[1].computeSplitEdges(baseSplitEdges);\n    // const splitEdges = baseSplitEdges\n    this.insertUniqueEdges(baseSplitEdges);\n    this.computeLabelsFromDepths();\n    this.replaceCollapsedEdges();\n    EdgeNodingValidator.checkValid(this._edgeList.getEdges());\n    this._graph.addEdges(this._edgeList.getEdges());\n    this.computeLabelling();\n    this.labelIncompleteNodes();\n    this.findResultAreaEdges(opCode);\n    this.cancelDuplicateResultEdges();\n    var polyBuilder = new PolygonBuilder(this._geomFact);\n    polyBuilder.add(this._graph);\n    this._resultPolyList = polyBuilder.getPolygons();\n    var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);\n    this._resultLineList = lineBuilder.build(opCode);\n    var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);\n    this._resultPointList = pointBuilder.build(opCode);\n    this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);\n  };\n  OverlayOp.prototype.labelIncompleteNode = function labelIncompleteNode (n, targetIndex) {\n    var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n    n.getLabel().setLocation(targetIndex, loc);\n  };\n  OverlayOp.prototype.copyPoints = function copyPoints (argIndex) {\n    var this$1 = this;\n\n    for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n      var graphNode = i.next();\n      var newNode = this$1._graph.addNode(graphNode.getCoordinate());\n      newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n    }\n  };\n  OverlayOp.prototype.findResultAreaEdges = function findResultAreaEdges (opCode) {\n    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n      var de = it.next();\n      var label = de.getLabel();\n      if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {\n        de.setInResult(true);\n      }\n    }\n  };\n  OverlayOp.prototype.computeLabelsFromDepths = function computeLabelsFromDepths () {\n    for (var it = this._edgeList.iterator(); it.hasNext();) {\n      var e = it.next();\n      var lbl = e.getLabel();\n      var depth = e.getDepth();\n      if (!depth.isNull()) {\n        depth.normalize();\n        for (var i = 0; i < 2; i++) {\n          if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {\n            if (depth.getDelta(i) === 0) {\n              lbl.toLine(i);\n            } else {\n              Assert.isTrue(!depth.isNull(i, Position.LEFT), 'depth of LEFT side has not been initialized');\n              lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n              Assert.isTrue(!depth.isNull(i, Position.RIGHT), 'depth of RIGHT side has not been initialized');\n              lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n            }\n          }\n        }\n      }\n    }\n  };\n  OverlayOp.prototype.computeLabelling = function computeLabelling () {\n    var this$1 = this;\n\n    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n      var node = nodeit.next();\n      node.getEdges().computeLabelling(this$1._arg);\n    }\n    this.mergeSymLabels();\n    this.updateNodeLabelling();\n  };\n  OverlayOp.prototype.labelIncompleteNodes = function labelIncompleteNodes () {\n    var this$1 = this;\n\n    // let nodeCount = 0\n    for (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {\n      var n = ni.next();\n      var label = n.getLabel();\n      if (n.isIsolated()) {\n        // nodeCount++\n        if (label.isNull(0)) { this$1.labelIncompleteNode(n, 0); } else { this$1.labelIncompleteNode(n, 1); }\n      }\n      n.getEdges().updateLabelling(label);\n    }\n  };\n  OverlayOp.prototype.isCoveredByA = function isCoveredByA (coord) {\n    if (this.isCovered(coord, this._resultPolyList)) { return true }\n    return false\n  };\n  OverlayOp.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  OverlayOp.prototype.getClass = function getClass () {\n    return OverlayOp\n  };\n\n  return OverlayOp;\n}(GeometryGraphOp));\n\nOverlayOp.overlayOp = function (geom0, geom1, opCode) {\n  var gov = new OverlayOp(geom0, geom1);\n  var geomOv = gov.getResultGeometry(opCode);\n  return geomOv\n};\nOverlayOp.intersection = function (g, other) {\n  if (g.isEmpty() || other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory()) }\n  if (g.isGeometryCollection()) {\n    var g2 = other;\n    return GeometryCollectionMapper.map(g, {\n      interfaces_: function () {\n        return [GeometryMapper.MapOp]\n      },\n      map: function (g) {\n        return g.intersection(g2)\n      }\n    })\n  }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION)\n};\nOverlayOp.symDifference = function (g, other) {\n  if (g.isEmpty() || other.isEmpty()) {\n    if (g.isEmpty() && other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory()) }\n    if (g.isEmpty()) { return other.copy() }\n    if (other.isEmpty()) { return g.copy() }\n  }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE)\n};\nOverlayOp.resultDimension = function (opCode, g0, g1) {\n  var dim0 = g0.getDimension();\n  var dim1 = g1.getDimension();\n  var resultDimension = -1;\n  switch (opCode) {\n    case OverlayOp.INTERSECTION:\n      resultDimension = Math.min(dim0, dim1);\n      break\n    case OverlayOp.UNION:\n      resultDimension = Math.max(dim0, dim1);\n      break\n    case OverlayOp.DIFFERENCE:\n      resultDimension = dim0;\n      break\n    case OverlayOp.SYMDIFFERENCE:\n      resultDimension = Math.max(dim0, dim1);\n      break\n    default:\n  }\n  return resultDimension\n};\nOverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {\n  var result = null;\n  switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {\n    case -1:\n      result = geomFact.createGeometryCollection(new Array(0).fill(null));\n      break\n    case 0:\n      result = geomFact.createPoint();\n      break\n    case 1:\n      result = geomFact.createLineString();\n      break\n    case 2:\n      result = geomFact.createPolygon();\n      break\n    default:\n  }\n  return result\n};\nOverlayOp.difference = function (g, other) {\n  if (g.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory()) }\n  if (other.isEmpty()) { return g.copy() }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE)\n};\nOverlayOp.isResultOfOp = function () {\n  if (arguments.length === 2) {\n    var label = arguments[0];\n    var opCode = arguments[1];\n    var loc0 = label.getLocation(0);\n    var loc1 = label.getLocation(1);\n    return OverlayOp.isResultOfOp(loc0, loc1, opCode)\n  } else if (arguments.length === 3) {\n    var loc0$1 = arguments[0];\n    var loc1$1 = arguments[1];\n    var overlayOpCode = arguments[2];\n    if (loc0$1 === Location.BOUNDARY) { loc0$1 = Location.INTERIOR; }\n    if (loc1$1 === Location.BOUNDARY) { loc1$1 = Location.INTERIOR; }\n    switch (overlayOpCode) {\n      case OverlayOp.INTERSECTION:\n        return loc0$1 === Location.INTERIOR && loc1$1 === Location.INTERIOR\n      case OverlayOp.UNION:\n        return loc0$1 === Location.INTERIOR || loc1$1 === Location.INTERIOR\n      case OverlayOp.DIFFERENCE:\n        return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR\n      case OverlayOp.SYMDIFFERENCE:\n        return (loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR) || (loc0$1 !== Location.INTERIOR && loc1$1 === Location.INTERIOR)\n      default:\n    }\n    return false\n  }\n};\nOverlayOp.INTERSECTION = 1;\nOverlayOp.UNION = 2;\nOverlayOp.DIFFERENCE = 3;\nOverlayOp.SYMDIFFERENCE = 4;\n\nvar FuzzyPointLocator = function FuzzyPointLocator () {\n  this._g = null;\n  this._boundaryDistanceTolerance = null;\n  this._linework = null;\n  this._ptLocator = new PointLocator();\n  this._seg = new LineSegment();\n  var g = arguments[0];\n  var boundaryDistanceTolerance = arguments[1];\n  this._g = g;\n  this._boundaryDistanceTolerance = boundaryDistanceTolerance;\n  this._linework = this.extractLinework(g);\n};\nFuzzyPointLocator.prototype.isWithinToleranceOfBoundary = function isWithinToleranceOfBoundary (pt) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._linework.getNumGeometries(); i++) {\n    var line = this$1._linework.getGeometryN(i);\n    var seq = line.getCoordinateSequence();\n    for (var j = 0; j < seq.size() - 1; j++) {\n      seq.getCoordinate(j, this$1._seg.p0);\n      seq.getCoordinate(j + 1, this$1._seg.p1);\n      var dist = this$1._seg.distance(pt);\n      if (dist <= this$1._boundaryDistanceTolerance) { return true }\n    }\n  }\n  return false\n};\nFuzzyPointLocator.prototype.getLocation = function getLocation (pt) {\n  if (this.isWithinToleranceOfBoundary(pt)) { return Location.BOUNDARY }\n  return this._ptLocator.locate(pt, this._g)\n};\nFuzzyPointLocator.prototype.extractLinework = function extractLinework (g) {\n  var extracter = new PolygonalLineworkExtracter();\n  g.apply(extracter);\n  var linework = extracter.getLinework();\n  var lines = GeometryFactory.toLineStringArray(linework);\n  return g.getFactory().createMultiLineString(lines)\n};\nFuzzyPointLocator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nFuzzyPointLocator.prototype.getClass = function getClass () {\n  return FuzzyPointLocator\n};\n\nvar PolygonalLineworkExtracter = function PolygonalLineworkExtracter () {\n  this._linework = null;\n  this._linework = new ArrayList();\n};\nPolygonalLineworkExtracter.prototype.getLinework = function getLinework () {\n  return this._linework\n};\nPolygonalLineworkExtracter.prototype.filter = function filter (g) {\n    var this$1 = this;\n\n  if (g instanceof Polygon) {\n    var poly = g;\n    this._linework.add(poly.getExteriorRing());\n    for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n      this$1._linework.add(poly.getInteriorRingN(i));\n    }\n  }\n};\nPolygonalLineworkExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nPolygonalLineworkExtracter.prototype.getClass = function getClass () {\n  return PolygonalLineworkExtracter\n};\n\nvar OffsetPointGenerator = function OffsetPointGenerator () {\n  this._g = null;\n  this._doLeft = true;\n  this._doRight = true;\n  var g = arguments[0];\n  this._g = g;\n};\nOffsetPointGenerator.prototype.extractPoints = function extractPoints (line, offsetDistance, offsetPts) {\n    var this$1 = this;\n\n  var pts = line.getCoordinates();\n  for (var i = 0; i < pts.length - 1; i++) {\n    this$1.computeOffsetPoints(pts[i], pts[i + 1], offsetDistance, offsetPts);\n  }\n};\nOffsetPointGenerator.prototype.setSidesToGenerate = function setSidesToGenerate (doLeft, doRight) {\n  this._doLeft = doLeft;\n  this._doRight = doRight;\n};\nOffsetPointGenerator.prototype.getPoints = function getPoints (offsetDistance) {\n    var this$1 = this;\n\n  var offsetPts = new ArrayList();\n  var lines = LinearComponentExtracter.getLines(this._g);\n  for (var i = lines.iterator(); i.hasNext();) {\n    var line = i.next();\n    this$1.extractPoints(line, offsetDistance, offsetPts);\n  }\n  return offsetPts\n};\nOffsetPointGenerator.prototype.computeOffsetPoints = function computeOffsetPoints (p0, p1, offsetDistance, offsetPts) {\n  var dx = p1.x - p0.x;\n  var dy = p1.y - p0.y;\n  var len = Math.sqrt(dx * dx + dy * dy);\n  var ux = offsetDistance * dx / len;\n  var uy = offsetDistance * dy / len;\n  var midX = (p1.x + p0.x) / 2;\n  var midY = (p1.y + p0.y) / 2;\n  if (this._doLeft) {\n    var offsetLeft = new Coordinate(midX - uy, midY + ux);\n    offsetPts.add(offsetLeft);\n  }\n  if (this._doRight) {\n    var offsetRight = new Coordinate(midX + uy, midY - ux);\n    offsetPts.add(offsetRight);\n  }\n};\nOffsetPointGenerator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetPointGenerator.prototype.getClass = function getClass () {\n  return OffsetPointGenerator\n};\n\nvar OverlayResultValidator = function OverlayResultValidator () {\n  this._geom = null;\n  this._locFinder = null;\n  this._location = new Array(3).fill(null);\n  this._invalidLocation = null;\n  this._boundaryDistanceTolerance = OverlayResultValidator.TOLERANCE;\n  this._testCoords = new ArrayList();\n  var a = arguments[0];\n  var b = arguments[1];\n  var result = arguments[2];\n  this._boundaryDistanceTolerance = OverlayResultValidator.computeBoundaryDistanceTolerance(a, b);\n  this._geom = [a, b, result];\n  this._locFinder = [new FuzzyPointLocator(this._geom[0], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[1], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[2], this._boundaryDistanceTolerance)];\n};\n\nvar staticAccessors$46 = { TOLERANCE: { configurable: true } };\nOverlayResultValidator.prototype.reportResult = function reportResult (overlayOp, location, expectedInterior) {\n  System.out.println('Overlay result invalid - A:' + Location.toLocationSymbol(location[0]) + ' B:' + Location.toLocationSymbol(location[1]) + ' expected:' + (expectedInterior ? 'i' : 'e') + ' actual:' + Location.toLocationSymbol(location[2]));\n};\nOverlayResultValidator.prototype.isValid = function isValid (overlayOp) {\n  this.addTestPts(this._geom[0]);\n  this.addTestPts(this._geom[1]);\n  var isValid = this.checkValid(overlayOp);\n  return isValid\n};\nOverlayResultValidator.prototype.checkValid = function checkValid () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var overlayOp = arguments[0];\n    for (var i = 0; i < this._testCoords.size(); i++) {\n      var pt = this$1._testCoords.get(i);\n      if (!this$1.checkValid(overlayOp, pt)) {\n        this$1._invalidLocation = pt;\n        return false\n      }\n    }\n    return true\n  } else if (arguments.length === 2) {\n    var overlayOp$1 = arguments[0];\n    var pt$1 = arguments[1];\n    this._location[0] = this._locFinder[0].getLocation(pt$1);\n    this._location[1] = this._locFinder[1].getLocation(pt$1);\n    this._location[2] = this._locFinder[2].getLocation(pt$1);\n    if (OverlayResultValidator.hasLocation(this._location, Location.BOUNDARY)) { return true }\n    return this.isValidResult(overlayOp$1, this._location)\n  }\n};\nOverlayResultValidator.prototype.addTestPts = function addTestPts (g) {\n  var ptGen = new OffsetPointGenerator(g);\n  this._testCoords.addAll(ptGen.getPoints(5 * this._boundaryDistanceTolerance));\n};\nOverlayResultValidator.prototype.isValidResult = function isValidResult (overlayOp, location) {\n  var expectedInterior = OverlayOp.isResultOfOp(location[0], location[1], overlayOp);\n  var resultInInterior = location[2] === Location.INTERIOR;\n  var isValid = !(expectedInterior ^ resultInInterior);\n  if (!isValid) { this.reportResult(overlayOp, location, expectedInterior); }\n  return isValid\n};\nOverlayResultValidator.prototype.getInvalidLocation = function getInvalidLocation () {\n  return this._invalidLocation\n};\nOverlayResultValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOverlayResultValidator.prototype.getClass = function getClass () {\n  return OverlayResultValidator\n};\nOverlayResultValidator.hasLocation = function hasLocation (location, loc) {\n  for (var i = 0; i < 3; i++) {\n    if (location[i] === loc) { return true }\n  }\n  return false\n};\nOverlayResultValidator.computeBoundaryDistanceTolerance = function computeBoundaryDistanceTolerance (g0, g1) {\n  return Math.min(GeometrySnapper.computeSizeBasedSnapTolerance(g0), GeometrySnapper.computeSizeBasedSnapTolerance(g1))\n};\nOverlayResultValidator.isValid = function isValid (a, b, overlayOp, result) {\n  var validator = new OverlayResultValidator(a, b, result);\n  return validator.isValid(overlayOp)\n};\nstaticAccessors$46.TOLERANCE.get = function () { return 0.000001 };\n\nObject.defineProperties( OverlayResultValidator, staticAccessors$46 );\n\n// operation.overlay\n\nvar GeometryCombiner = function GeometryCombiner (geoms) {\n  this._geomFactory = null;\n  this._skipEmpty = false;\n  this._inputGeoms = null;\n  this._geomFactory = GeometryCombiner.extractFactory(geoms);\n  this._inputGeoms = geoms;\n};\nGeometryCombiner.prototype.extractElements = function extractElements (geom, elems) {\n    var this$1 = this;\n\n  if (geom === null) { return null }\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var elemGeom = geom.getGeometryN(i);\n    if (this$1._skipEmpty && elemGeom.isEmpty()) { continue }\n    elems.add(elemGeom);\n  }\n};\nGeometryCombiner.prototype.combine = function combine () {\n    var this$1 = this;\n\n  var elems = new ArrayList();\n  for (var i = this._inputGeoms.iterator(); i.hasNext();) {\n    var g = i.next();\n    this$1.extractElements(g, elems);\n  }\n  if (elems.size() === 0) {\n    if (this._geomFactory !== null) {\n      return this._geomFactory.createGeometryCollection(null)\n    }\n    return null\n  }\n  return this._geomFactory.buildGeometry(elems)\n};\nGeometryCombiner.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryCombiner.prototype.getClass = function getClass () {\n  return GeometryCombiner\n};\nGeometryCombiner.combine = function combine () {\n  if (arguments.length === 1) {\n    var geoms = arguments[0];\n    var combiner = new GeometryCombiner(geoms);\n    return combiner.combine()\n  } else if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    var combiner$1 = new GeometryCombiner(GeometryCombiner.createList(g0, g1));\n    return combiner$1.combine()\n  } else if (arguments.length === 3) {\n    var g0$1 = arguments[0];\n    var g1$1 = arguments[1];\n    var g2 = arguments[2];\n    var combiner$2 = new GeometryCombiner(GeometryCombiner.createList(g0$1, g1$1, g2));\n    return combiner$2.combine()\n  }\n};\nGeometryCombiner.extractFactory = function extractFactory (geoms) {\n  if (geoms.isEmpty()) { return null }\n  return geoms.iterator().next().getFactory()\n};\nGeometryCombiner.createList = function createList () {\n  if (arguments.length === 2) {\n    var obj0 = arguments[0];\n    var obj1 = arguments[1];\n    var list = new ArrayList();\n    list.add(obj0);\n    list.add(obj1);\n    return list\n  } else if (arguments.length === 3) {\n    var obj0$1 = arguments[0];\n    var obj1$1 = arguments[1];\n    var obj2 = arguments[2];\n    var list$1 = new ArrayList();\n    list$1.add(obj0$1);\n    list$1.add(obj1$1);\n    list$1.add(obj2);\n    return list$1\n  }\n};\n\nvar CascadedPolygonUnion = function CascadedPolygonUnion () {\n  this._inputPolys = null;\n  this._geomFactory = null;\n  var polys = arguments[0];\n  this._inputPolys = polys;\n  if (this._inputPolys === null) { this._inputPolys = new ArrayList(); }\n};\n\nvar staticAccessors$47 = { STRTREE_NODE_CAPACITY: { configurable: true } };\nCascadedPolygonUnion.prototype.reduceToGeometries = function reduceToGeometries (geomTree) {\n    var this$1 = this;\n\n  var geoms = new ArrayList();\n  for (var i = geomTree.iterator(); i.hasNext();) {\n    var o = i.next();\n    var geom = null;\n    if (hasInterface(o, List)) {\n      geom = this$1.unionTree(o);\n    } else if (o instanceof Geometry) {\n      geom = o;\n    }\n    geoms.add(geom);\n  }\n  return geoms\n};\nCascadedPolygonUnion.prototype.extractByEnvelope = function extractByEnvelope (env, geom, disjointGeoms) {\n  var intersectingGeoms = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var elem = geom.getGeometryN(i);\n    if (elem.getEnvelopeInternal().intersects(env)) { intersectingGeoms.add(elem); } else { disjointGeoms.add(elem); }\n  }\n  return this._geomFactory.buildGeometry(intersectingGeoms)\n};\nCascadedPolygonUnion.prototype.unionOptimized = function unionOptimized (g0, g1) {\n  var g0Env = g0.getEnvelopeInternal();\n  var g1Env = g1.getEnvelopeInternal();\n  if (!g0Env.intersects(g1Env)) {\n    var combo = GeometryCombiner.combine(g0, g1);\n    return combo\n  }\n  if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) { return this.unionActual(g0, g1) }\n  var commonEnv = g0Env.intersection(g1Env);\n  return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv)\n};\nCascadedPolygonUnion.prototype.union = function union () {\n  if (this._inputPolys === null) { throw new Error('union() method cannot be called twice') }\n  if (this._inputPolys.isEmpty()) { return null }\n  this._geomFactory = this._inputPolys.iterator().next().getFactory();\n  var index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);\n  for (var i = this._inputPolys.iterator(); i.hasNext();) {\n    var item = i.next();\n    index.insert(item.getEnvelopeInternal(), item);\n  }\n  this._inputPolys = null;\n  var itemTree = index.itemsTree();\n  var unionAll = this.unionTree(itemTree);\n  return unionAll\n};\nCascadedPolygonUnion.prototype.binaryUnion = function binaryUnion () {\n  if (arguments.length === 1) {\n    var geoms = arguments[0];\n    return this.binaryUnion(geoms, 0, geoms.size())\n  } else if (arguments.length === 3) {\n    var geoms$1 = arguments[0];\n    var start = arguments[1];\n    var end = arguments[2];\n    if (end - start <= 1) {\n      var g0 = CascadedPolygonUnion.getGeometry(geoms$1, start);\n      return this.unionSafe(g0, null)\n    } else if (end - start === 2) {\n      return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms$1, start), CascadedPolygonUnion.getGeometry(geoms$1, start + 1))\n    } else {\n      var mid = Math.trunc((end + start) / 2);\n      var g0$1 = this.binaryUnion(geoms$1, start, mid);\n      var g1 = this.binaryUnion(geoms$1, mid, end);\n      return this.unionSafe(g0$1, g1)\n    }\n  }\n};\nCascadedPolygonUnion.prototype.repeatedUnion = function repeatedUnion (geoms) {\n  var union = null;\n  for (var i = geoms.iterator(); i.hasNext();) {\n    var g = i.next();\n    if (union === null) { union = g.copy(); } else { union = union.union(g); }\n  }\n  return union\n};\nCascadedPolygonUnion.prototype.unionSafe = function unionSafe (g0, g1) {\n  if (g0 === null && g1 === null) { return null }\n  if (g0 === null) { return g1.copy() }\n  if (g1 === null) { return g0.copy() }\n  return this.unionOptimized(g0, g1)\n};\nCascadedPolygonUnion.prototype.unionActual = function unionActual (g0, g1) {\n  return CascadedPolygonUnion.restrictToPolygons(g0.union(g1))\n};\nCascadedPolygonUnion.prototype.unionTree = function unionTree (geomTree) {\n  var geoms = this.reduceToGeometries(geomTree);\n  var union = this.binaryUnion(geoms);\n  return union\n};\nCascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function unionUsingEnvelopeIntersection (g0, g1, common) {\n  var disjointPolys = new ArrayList();\n  var g0Int = this.extractByEnvelope(common, g0, disjointPolys);\n  var g1Int = this.extractByEnvelope(common, g1, disjointPolys);\n  var union = this.unionActual(g0Int, g1Int);\n  disjointPolys.add(union);\n  var overallUnion = GeometryCombiner.combine(disjointPolys);\n  return overallUnion\n};\nCascadedPolygonUnion.prototype.bufferUnion = function bufferUnion () {\n  if (arguments.length === 1) {\n    var geoms = arguments[0];\n    var factory = geoms.get(0).getFactory();\n    var gColl = factory.buildGeometry(geoms);\n    var unionAll = gColl.buffer(0.0);\n    return unionAll\n  } else if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    var factory$1 = g0.getFactory();\n    var gColl$1 = factory$1.createGeometryCollection([g0, g1]);\n    var unionAll$1 = gColl$1.buffer(0.0);\n    return unionAll$1\n  }\n};\nCascadedPolygonUnion.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCascadedPolygonUnion.prototype.getClass = function getClass () {\n  return CascadedPolygonUnion\n};\nCascadedPolygonUnion.restrictToPolygons = function restrictToPolygons (g) {\n  if (hasInterface(g, Polygonal)) {\n    return g\n  }\n  var polygons = PolygonExtracter.getPolygons(g);\n  if (polygons.size() === 1) { return polygons.get(0) }\n  return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons))\n};\nCascadedPolygonUnion.getGeometry = function getGeometry (list, index) {\n  if (index >= list.size()) { return null }\n  return list.get(index)\n};\nCascadedPolygonUnion.union = function union (polys) {\n  var op = new CascadedPolygonUnion(polys);\n  return op.union()\n};\nstaticAccessors$47.STRTREE_NODE_CAPACITY.get = function () { return 4 };\n\nObject.defineProperties( CascadedPolygonUnion, staticAccessors$47 );\n\nvar UnionOp = function UnionOp () {};\n\nUnionOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nUnionOp.prototype.getClass = function getClass () {\n  return UnionOp\n};\nUnionOp.union = function union (g, other) {\n  if (g.isEmpty() || other.isEmpty()) {\n    if (g.isEmpty() && other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory()) }\n    if (g.isEmpty()) { return other.copy() }\n    if (other.isEmpty()) { return g.copy() }\n  }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION)\n};\n\n// operation.union\n\n// operation\n\n/**\n * Polyfill for IE support\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdHVyZi1qc3RzL2pzdHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsMEJBQTBCLGFBQWE7O0FBRXZDLG9DQUFvQztBQUNwQywwREFBMEQ7QUFDMUQsMERBQTBEO0FBQzFELDhDQUE4QztBQUM5QyxnREFBZ0Q7O0FBRWhEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHlCQUF5QixvQkFBb0IscUJBQXFCLG9CQUFvQixrQkFBa0Isb0JBQW9CLE1BQU0sb0JBQW9CLE1BQU0sb0JBQW9CLE1BQU07QUFDOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLGFBQWEsb0JBQW9CLFVBQVUsb0JBQW9CLHFCQUFxQixvQkFBb0IsU0FBUyxvQkFBb0IsY0FBYyxvQkFBb0IsYUFBYTs7QUFFOU07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQsNENBQTRDO0FBQzVDLHVEQUF1RDtBQUN2RCwyQ0FBMkM7QUFDM0MsZ0RBQWdEO0FBQ2hELCtDQUErQzs7QUFFL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsb0JBQW9CLG9CQUFvQixvQkFBb0Isb0JBQW9CLHlCQUF5QixvQkFBb0IseUJBQXlCLG9CQUFvQix5QkFBeUIsb0JBQW9CLDhCQUE4QixvQkFBb0Isc0JBQXNCLG9CQUFvQiwyQkFBMkIsb0JBQW9CLGlDQUFpQyxvQkFBb0IsMEJBQTBCO0FBQzVjO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLElBQUk7QUFDSjtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsdURBQXVEO0FBQ3ZELDREQUE0RDtBQUM1RCw0REFBNEQ7QUFDNUQsNERBQTREO0FBQzVELGlFQUFpRTtBQUNqRSx5REFBeUQ7QUFDekQsOERBQThEO0FBQzlELG9FQUFvRTtBQUNwRSw2REFBNkQ7O0FBRTdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsd0JBQXdCLG9CQUFvQiw2QkFBNkIsb0JBQW9CLHdDQUF3QyxvQkFBb0IsdUNBQXVDLG9CQUFvQix1QkFBdUIsb0JBQW9CLDJCQUEyQixvQkFBb0IsdUNBQXVDLG9CQUFvQixzQ0FBc0Msb0JBQW9CLDBCQUEwQjs7QUFFeGQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLDJFQUEyRTtBQUMzRSwwRUFBMEU7QUFDMUUsMERBQTBEO0FBQzFELDhEQUE4RDtBQUM5RCwwRUFBMEU7QUFDMUUseUVBQXlFO0FBQ3pFLDZEQUE2RDs7QUFFN0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkMsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQThEOztBQUU5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0EsYUFBYTtBQUNiLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsa0JBQWtCO0FBQzVDLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsMkJBQTJCLHFCQUFxQixvQkFBb0IsNEJBQTRCLG9CQUFvQixtQkFBbUI7O0FBRXZJLHlEQUF5RDtBQUN6RCwrREFBK0Q7QUFDL0Qsc0RBQXNEOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw4Q0FBOEM7QUFDOUMsMkNBQTJDO0FBQzNDLG9CQUFvQixtQkFBbUI7QUFDdkMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGtEQUFrRDtBQUNsRCwrQ0FBK0M7QUFDL0Msc0JBQXNCLHVCQUF1QjtBQUM3Qyw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQywwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3QkFBd0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDZCQUE2QjtBQUM3QixxQkFBcUI7QUFDckI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0EsZUFBZTtBQUNmLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHdCQUF3QjtBQUN4QiwyQkFBMkIsa0JBQWtCO0FBQzdDLHNCQUFzQjtBQUN0Qix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG1CQUFtQjtBQUMxRCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDZCQUE2QixrQkFBa0IsZ0NBQWdDLHFCQUFxQixPQUFPO0FBQzNHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSw2QkFBNkIsa0JBQWtCLGlDQUFpQyxzQkFBc0IsT0FBTztBQUM3RztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsWUFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRDQUE0QyxTQUFTO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQkFBMEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QixP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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZCxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixhQUFhLG9CQUFvQixhQUFhLG9CQUFvQixlQUFlLG9CQUFvQixlQUFlLG9CQUFvQixlQUFlLG9CQUFvQixlQUFlLG9CQUFvQiw4QkFBOEIsb0JBQW9CLHdCQUF3QixvQkFBb0IsNEJBQTRCO0FBQ25XO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsaUVBQWlFO0FBQ2pFLDJEQUEyRDtBQUMzRCwrREFBK0Q7O0FBRS9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsUUFBUSxvQkFBb0IsV0FBVyxvQkFBb0IsU0FBUyxvQkFBb0IscUJBQXFCO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJBQXFCLE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQixRQUFRO0FBQzNCLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QyxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsOENBQThDO0FBQzlDLDRDQUE0QztBQUM1Qyx3REFBd0Q7O0FBRXhEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIseUJBQXlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0EsSUFBSTtBQUNKLGtDQUFrQyxVQUFVO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEOztBQUVBOztBQUVBLDJCQUEyQixjQUFjLG9CQUFvQixjQUFjLG9CQUFvQixjQUFjLG9CQUFvQixxQkFBcUIsb0JBQW9CLGNBQWMsb0JBQW9CLFNBQVM7O0FBRXJOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLHFDQUFxQztBQUNyQyxJQUFJO0FBQ0osd0NBQXdDO0FBQ3hDLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQsd0RBQXdEO0FBQ3hELGlEQUFpRDtBQUNqRCw0Q0FBNEM7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7O0FBRUEsMkJBQTJCLG9DQUFvQyxvQkFBb0IsNENBQTRDLG9CQUFvQixzQ0FBc0Msb0JBQW9CLCtCQUErQjtBQUM1TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsSUFBSTtBQUNKLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0oseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLCtFQUErRTtBQUMvRSx5RUFBeUU7QUFDekUsa0VBQWtFOztBQUVsRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFdBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLDRDQUE0QztBQUM1QywwQ0FBMEM7QUFDMUMsb0dBQW9HO0FBQ3BHLDJIQUEySDtBQUMzSDtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EOztBQUVwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCwyREFBMkQ7QUFDM0Q7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRix3REFBd0Q7QUFDeEQ7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsOEJBQThCO0FBQzlCLHNDQUFzQztBQUN0QyxpQ0FBaUM7QUFDakMsc0NBQXNDO0FBQ3RDLDJDQUEyQztBQUMzQyx3Q0FBd0M7QUFDeEMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsMkRBQTJEO0FBQzNELGtCQUFrQiwrQkFBK0I7QUFDakQ7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxREFBcUQ7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix5REFBeUQ7QUFDekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0Esb0dBQW9HO0FBQ3BHO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBLHlFQUF5RTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWE7QUFDOUM7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUNBQXFDO0FBQ3pEO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsY0FBYyx1RUFBdUUsaUJBQWlCO0FBQzFLO0FBQ0EsK0JBQStCLGNBQWMsaUNBQWlDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixjQUFjO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsYUFBYTtBQUNsRDtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx1Q0FBdUMsZUFBZTtBQUN0RDtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNDQUFzQztBQUN0QyxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLGFBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix3QkFBd0I7QUFDMUMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3RELCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVCQUF1QjtBQUM1RDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsZ0NBQWdDO0FBQ2xELG9CQUFvQiwrQkFBK0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrREFBa0Qsa0JBQWtCO0FBQ3BFLGtCQUFrQixPQUFPO0FBQ3pCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixzQkFBc0IsT0FBTztBQUM3Qix3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLDRDQUE0QztBQUM1QywwQkFBMEI7QUFDMUIsc0JBQXNCLE9BQU87QUFDN0I7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLGtEQUFrRDs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQ0FBaUM7QUFDakMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QyxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsWUFBWSxxRUFBcUU7QUFDbko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBOztBQUVBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUMsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkJBQTZCO0FBQy9DO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQztBQUNwQztBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSw2QkFBNkI7QUFDN0Isb0NBQW9DO0FBQ3BDO0FBQ0EsNkJBQTZCO0FBQzdCLG9DQUFvQztBQUNwQztBQUNBLDZCQUE2QjtBQUM3Qiw0Q0FBNEM7QUFDNUMsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFOztBQUVqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEOztBQUUxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMENBQTBDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGFBQWEsb0JBQW9CLGFBQWEsb0JBQW9CLGFBQWEsb0JBQW9CLGVBQWUsb0JBQW9CLHlCQUF5QjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5REFBeUQsaUJBQWlCO0FBQzFFO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQixRQUFRO0FBQ1IsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLGtEQUFrRCxvQ0FBb0MsT0FBTztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxrREFBa0Q7QUFDbEQsNERBQTREOztBQUU1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBCQUEwQixvQkFBb0IsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxpRUFBaUU7O0FBRWpFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQyxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0Esc0JBQXNCLHVCQUF1QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRCx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUNBQWlDO0FBQ3ZEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLHdCQUF3Qiw2QkFBNkI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBCQUEwQixvQkFBb0IseUNBQXlDO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDRFQUE0RTs7QUFFNUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsV0FBVyxvQkFBb0IsMkJBQTJCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLDhEQUE4RDs7QUFFOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixXQUFXLG9CQUFvQixzQkFBc0I7QUFDaEY7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MseURBQXlEOztBQUV6RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiwyQkFBMkI7QUFDN0M7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhEQUE4RCxhQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBK0QsaUJBQWlCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxhQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQ0FBa0MsT0FBTztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxhQUFhO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix3QkFBd0I7QUFDeEIsaUNBQWlDO0FBQ2pDLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0RBQStELGlCQUFpQjtBQUNoRjtBQUNBLDBCQUEwQjtBQUMxQixzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxrQkFBa0IsK0JBQStCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSwrQkFBK0IsZ0VBQWdFO0FBQy9GO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQSxrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQSxrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQSxrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQSxrQ0FBa0M7QUFDbEMsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyx5Q0FBeUM7QUFDekMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6Qyw4Q0FBOEM7QUFDOUMsc0NBQXNDO0FBQ3RDLDJDQUEyQztBQUMzQyxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEMsbUNBQW1DO0FBQ25DLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCO0FBQ0EsMERBQTBEO0FBQzFELGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZLE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMEJBQTBCLG9CQUFvQixlQUFlO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQsa0RBQWtEOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFlBQVk7QUFDN0M7QUFDQSwwQkFBMEIsb0JBQW9CLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsdUJBQXVCO0FBQ3ZCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFc0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWRiYXNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3R1cmYtanN0cy9qc3RzLm1qcz8wOTIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFBvbHlmaWxsIHNlcnZpY2UgdjMuMTMuMFxuICogRm9yIGRldGFpbGVkIGNyZWRpdHMgYW5kIGxpY2VuY2UgaW5mb3JtYXRpb24gc2VlIGh0dHA6Ly9naXRodWIuY29tL2ZpbmFuY2lhbC10aW1lcy9wb2x5ZmlsbC1zZXJ2aWNlXG4gKlxuICogLSBBcnJheS5wcm90b3R5cGUuZmlsbCwgTGljZW5zZTogQ0MwICovXG5cbmlmICghKCdmaWxsJyBpbiBBcnJheS5wcm90b3R5cGUpKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcnJheS5wcm90b3R5cGUsICdmaWxsJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbCAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSB1bmRlZmluZWQgfHwgdGhpcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRoaXMgKyAnIGlzIG5vdCBhbiBvYmplY3QnKVxuICAgICAgfVxuXG4gICAgICB2YXIgYXJyYXlMaWtlID0gT2JqZWN0KHRoaXMpO1xuXG4gICAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5taW4oYXJyYXlMaWtlLmxlbmd0aCwgOTAwNzE5OTI1NDc0MDk5MSksIDApIHx8IDA7XG5cbiAgICAgIHZhciByZWxhdGl2ZVN0YXJ0ID0gMSBpbiBhcmd1bWVudHMgPyBwYXJzZUludChOdW1iZXIoYXJndW1lbnRzWzFdKSwgMTApIHx8IDAgOiAwO1xuXG4gICAgICByZWxhdGl2ZVN0YXJ0ID0gcmVsYXRpdmVTdGFydCA8IDAgPyBNYXRoLm1heChsZW5ndGggKyByZWxhdGl2ZVN0YXJ0LCAwKSA6IE1hdGgubWluKHJlbGF0aXZlU3RhcnQsIGxlbmd0aCk7XG5cbiAgICAgIHZhciByZWxhdGl2ZUVuZCA9IDIgaW4gYXJndW1lbnRzICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gcGFyc2VJbnQoTnVtYmVyKGFyZ3VtZW50c1syXSksIDEwKSB8fCAwIDogbGVuZ3RoO1xuXG4gICAgICByZWxhdGl2ZUVuZCA9IHJlbGF0aXZlRW5kIDwgMCA/IE1hdGgubWF4KGxlbmd0aCArIGFyZ3VtZW50c1syXSwgMCkgOiBNYXRoLm1pbihyZWxhdGl2ZUVuZCwgbGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKHJlbGF0aXZlU3RhcnQgPCByZWxhdGl2ZUVuZCkge1xuICAgICAgICBhcnJheUxpa2VbcmVsYXRpdmVTdGFydF0gPSB2YWx1ZTtcblxuICAgICAgICArK3JlbGF0aXZlU3RhcnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheUxpa2VcbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBvbHlmaWxsIGZvciBJRSBzdXBwb3J0XG4gKi9cbk51bWJlci5pc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpXG59O1xuXG5OdW1iZXIuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyAmJlxuICBpc0Zpbml0ZSh2YWwpICYmXG4gIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsXG59O1xuXG5OdW1iZXIucGFyc2VGbG9hdCA9IE51bWJlci5wYXJzZUZsb2F0IHx8IHBhcnNlRmxvYXQ7XG5cbk51bWJlci5pc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59O1xuXG4vKipcbiAqIFBvbHlmaWxsIGZvciBJRSBzdXBwb3J0XG4gKi9cbk1hdGgudHJ1bmMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB4IDwgMCA/IE1hdGguY2VpbCh4KSA6IE1hdGguZmxvb3IoeClcbn07XG5cbnZhciBOdW1iZXJVdGlsID0gZnVuY3Rpb24gTnVtYmVyVXRpbCAoKSB7fTtcblxuTnVtYmVyVXRpbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk51bWJlclV0aWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTnVtYmVyVXRpbFxufTtcbk51bWJlclV0aWwucHJvdG90eXBlLmVxdWFsc1dpdGhUb2xlcmFuY2UgPSBmdW5jdGlvbiBlcXVhbHNXaXRoVG9sZXJhbmNlICh4MSwgeDIsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gTWF0aC5hYnMoeDEgLSB4MikgPD0gdG9sZXJhbmNlXG59O1xuXG52YXIgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uID0gKGZ1bmN0aW9uIChFcnJvcikge1xuXHRmdW5jdGlvbiBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gKG1lc3NhZ2UpIHtcblx0XHRFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXHRcdHRoaXMubmFtZSA9ICdJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24nO1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG5cdFx0dGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG5cdH1cblxuXHRpZiAoIEVycm9yICkgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uLl9fcHJvdG9fXyA9IEVycm9yO1xuXHRJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXJyb3IgJiYgRXJyb3IucHJvdG90eXBlICk7XG5cdElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb247XG5cblx0cmV0dXJuIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjtcbn0oRXJyb3IpKTtcblxudmFyIERvdWJsZSA9IGZ1bmN0aW9uIERvdWJsZSAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxID0geyBNQVhfVkFMVUU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuRG91YmxlLmlzTmFOID0gZnVuY3Rpb24gaXNOYU4gKG4pIHsgcmV0dXJuIE51bWJlci5pc05hTihuKSB9O1xuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHMgPSBmdW5jdGlvbiBkb3VibGVUb0xvbmdCaXRzIChuKSB7IHJldHVybiBuIH07XG5Eb3VibGUubG9uZ0JpdHNUb0RvdWJsZSA9IGZ1bmN0aW9uIGxvbmdCaXRzVG9Eb3VibGUgKG4pIHsgcmV0dXJuIG4gfTtcbkRvdWJsZS5pc0luZmluaXRlID0gZnVuY3Rpb24gaXNJbmZpbml0ZSAobikgeyByZXR1cm4gIU51bWJlci5pc0Zpbml0ZShuKSB9O1xuc3RhdGljQWNjZXNzb3JzJDEuTUFYX1ZBTFVFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE51bWJlci5NQVhfVkFMVUUgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIERvdWJsZSwgc3RhdGljQWNjZXNzb3JzJDEgKTtcblxudmFyIENvbXBhcmFibGUgPSBmdW5jdGlvbiBDb21wYXJhYmxlICgpIHt9O1xuXG52YXIgQ2xvbmFibGUgPSBmdW5jdGlvbiBDbG9uYWJsZSAoKSB7fTtcblxudmFyIENvbXBhcmF0b3IgPSBmdW5jdGlvbiBDb21wYXJhdG9yICgpIHt9O1xuXG5mdW5jdGlvbiBTZXJpYWxpemFibGUgKCkge31cblxuLy8gaW1wb3J0IEFzc2VydCBmcm9tICcuLi91dGlsL0Fzc2VydCdcblxudmFyIENvb3JkaW5hdGUgPSBmdW5jdGlvbiBDb29yZGluYXRlICgpIHtcbiAgdGhpcy54ID0gbnVsbDtcbiAgdGhpcy55ID0gbnVsbDtcbiAgdGhpcy56ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnggPSAwLjA7XG4gICAgdGhpcy55ID0gMC4wO1xuICAgIHRoaXMueiA9IENvb3JkaW5hdGUuTlVMTF9PUkRJTkFURTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy54ID0gYy54O1xuICAgIHRoaXMueSA9IGMueTtcbiAgICB0aGlzLnogPSBjLno7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHRoaXMueCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnkgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy56ID0gQ29vcmRpbmF0ZS5OVUxMX09SRElOQVRFO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB0aGlzLnggPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy55ID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMueiA9IGFyZ3VtZW50c1syXTtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgRGltZW5zaW9uYWxDb21wYXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTlVMTF9PUkRJTkFURTogeyBjb25maWd1cmFibGU6IHRydWUgfSxYOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sWjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuc2V0T3JkaW5hdGUgPSBmdW5jdGlvbiBzZXRPcmRpbmF0ZSAob3JkaW5hdGVJbmRleCwgdmFsdWUpIHtcbiAgc3dpdGNoIChvcmRpbmF0ZUluZGV4KSB7XG4gICAgY2FzZSBDb29yZGluYXRlLlg6XG4gICAgICB0aGlzLnggPSB2YWx1ZTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBDb29yZGluYXRlLlk6XG4gICAgICB0aGlzLnkgPSB2YWx1ZTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBDb29yZGluYXRlLlo6XG4gICAgICB0aGlzLnogPSB2YWx1ZTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0ludmFsaWQgb3JkaW5hdGUgaW5kZXg6ICcgKyBvcmRpbmF0ZUluZGV4KVxuICB9XG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuZXF1YWxzMkQgPSBmdW5jdGlvbiBlcXVhbHMyRCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0aGlzLnggIT09IG90aGVyLngpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAodGhpcy55ICE9PSBvdGhlci55KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoIU51bWJlclV0aWwuZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLngsIGMueCwgdG9sZXJhbmNlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICghTnVtYmVyVXRpbC5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueSwgYy55LCB0b2xlcmFuY2UpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmdldE9yZGluYXRlID0gZnVuY3Rpb24gZ2V0T3JkaW5hdGUgKG9yZGluYXRlSW5kZXgpIHtcbiAgc3dpdGNoIChvcmRpbmF0ZUluZGV4KSB7XG4gICAgY2FzZSBDb29yZGluYXRlLlg6XG4gICAgICByZXR1cm4gdGhpcy54XG4gICAgY2FzZSBDb29yZGluYXRlLlk6XG4gICAgICByZXR1cm4gdGhpcy55XG4gICAgY2FzZSBDb29yZGluYXRlLlo6XG4gICAgICByZXR1cm4gdGhpcy56XG4gICAgZGVmYXVsdDpcbiAgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdJbnZhbGlkIG9yZGluYXRlIGluZGV4OiAnICsgb3JkaW5hdGVJbmRleClcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5lcXVhbHMzRCA9IGZ1bmN0aW9uIGVxdWFsczNEIChvdGhlcikge1xuICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmXG4gICAgICAgICB0aGlzLnkgPT09IG90aGVyLnkgJiZcbiAgICAgICAgICgodGhpcy56ID09PSBvdGhlci56IHx8IERvdWJsZS5pc05hTih0aGlzLnopKSAmJlxuICAgICAgICAgRG91YmxlLmlzTmFOKG90aGVyLnopKVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0aGlzLmVxdWFsczJEKG90aGVyKVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmVxdWFsSW5aID0gZnVuY3Rpb24gZXF1YWxJblogKGMsIHRvbGVyYW5jZSkge1xuICByZXR1cm4gTnVtYmVyVXRpbC5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueiwgYy56LCB0b2xlcmFuY2UpXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIHZhciBvdGhlciA9IG87XG4gIGlmICh0aGlzLnggPCBvdGhlci54KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLnggPiBvdGhlci54KSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMueSA8IG90aGVyLnkpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMueSA+IG90aGVyLnkpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAvLyB0cnkge1xuICAvLyB2YXIgY29vcmQgPSBudWxsXG4gIC8vIHJldHVybiBjb29yZFxuICAvLyB9IGNhdGNoIChlKSB7XG4gIC8vIGlmIChlIGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pIHtcbiAgLy8gICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJ0aGlzIHNob3VsZG4ndCBoYXBwZW4gYmVjYXVzZSB0aGlzIGNsYXNzIGlzIENsb25lYWJsZVwiKVxuICAvLyAgIHJldHVybiBudWxsXG4gIC8vIH0gZWxzZSB0aHJvdyBlXG4gIC8vIH0gZmluYWxseSB7fVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHRoaXMpXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiAnKCcgKyB0aGlzLnggKyAnLCAnICsgdGhpcy55ICsgJywgJyArIHRoaXMueiArICcpJ1xufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmRpc3RhbmNlM0QgPSBmdW5jdGlvbiBkaXN0YW5jZTNEIChjKSB7XG4gIHZhciBkeCA9IHRoaXMueCAtIGMueDtcbiAgdmFyIGR5ID0gdGhpcy55IC0gYy55O1xuICB2YXIgZHogPSB0aGlzLnogLSBjLno7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKGMpIHtcbiAgdmFyIGR4ID0gdGhpcy54IC0gYy54O1xuICB2YXIgZHkgPSB0aGlzLnkgLSBjLnk7XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSAoKSB7XG4gIHZhciByZXN1bHQgPSAxNztcbiAgcmVzdWx0ID0gMzcgKiByZXN1bHQgKyBDb29yZGluYXRlLmhhc2hDb2RlKHRoaXMueCk7XG4gIHJlc3VsdCA9IDM3ICogcmVzdWx0ICsgQ29vcmRpbmF0ZS5oYXNoQ29kZSh0aGlzLnkpO1xuICByZXR1cm4gcmVzdWx0XG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGUgKG90aGVyKSB7XG4gIHRoaXMueCA9IG90aGVyLng7XG4gIHRoaXMueSA9IG90aGVyLnk7XG4gIHRoaXMueiA9IG90aGVyLno7XG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZSwgQ2xvbmFibGUsIFNlcmlhbGl6YWJsZV1cbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVcbn07XG5Db29yZGluYXRlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBmID0gRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHMoeCk7XG4gICAgcmV0dXJuIE1hdGgudHJ1bmMoKGYgXiBmKSA+Pj4gMzIpXG4gIH1cbn07XG5zdGF0aWNBY2Nlc3NvcnMuRGltZW5zaW9uYWxDb21wYXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERpbWVuc2lvbmFsQ29tcGFyYXRvciB9O1xuc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNjY4MzEwODkwMjQyODM2NjkxMCB9O1xuc3RhdGljQWNjZXNzb3JzLk5VTExfT1JESU5BVEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gRG91YmxlLk5hTiB9O1xuc3RhdGljQWNjZXNzb3JzLlguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzLlkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzLlouZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29vcmRpbmF0ZSwgc3RhdGljQWNjZXNzb3JzICk7XG5cbnZhciBEaW1lbnNpb25hbENvbXBhcmF0b3IgPSBmdW5jdGlvbiBEaW1lbnNpb25hbENvbXBhcmF0b3IgKGRpbWVuc2lvbnNUb1Rlc3QpIHtcbiAgdGhpcy5fZGltZW5zaW9uc1RvVGVzdCA9IDI7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGRpbWVuc2lvbnNUb1Rlc3QkMSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoZGltZW5zaW9uc1RvVGVzdCQxICE9PSAyICYmIGRpbWVuc2lvbnNUb1Rlc3QkMSAhPT0gMykgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdvbmx5IDIgb3IgMyBkaW1lbnNpb25zIG1heSBiZSBzcGVjaWZpZWQnKSB9XG4gICAgdGhpcy5fZGltZW5zaW9uc1RvVGVzdCA9IGRpbWVuc2lvbnNUb1Rlc3QkMTtcbiAgfVxufTtcbkRpbWVuc2lvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKG8xLCBvMikge1xuICB2YXIgYzEgPSBvMTtcbiAgdmFyIGMyID0gbzI7XG4gIHZhciBjb21wWCA9IERpbWVuc2lvbmFsQ29tcGFyYXRvci5jb21wYXJlKGMxLngsIGMyLngpO1xuICBpZiAoY29tcFggIT09IDApIHsgcmV0dXJuIGNvbXBYIH1cbiAgdmFyIGNvbXBZID0gRGltZW5zaW9uYWxDb21wYXJhdG9yLmNvbXBhcmUoYzEueSwgYzIueSk7XG4gIGlmIChjb21wWSAhPT0gMCkgeyByZXR1cm4gY29tcFkgfVxuICBpZiAodGhpcy5fZGltZW5zaW9uc1RvVGVzdCA8PSAyKSB7IHJldHVybiAwIH1cbiAgdmFyIGNvbXBaID0gRGltZW5zaW9uYWxDb21wYXJhdG9yLmNvbXBhcmUoYzEueiwgYzIueik7XG4gIHJldHVybiBjb21wWlxufTtcbkRpbWVuc2lvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYXRvcl1cbn07XG5EaW1lbnNpb25hbENvbXBhcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRGltZW5zaW9uYWxDb21wYXJhdG9yXG59O1xuRGltZW5zaW9uYWxDb21wYXJhdG9yLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChhIDwgYikgeyByZXR1cm4gLTEgfVxuICBpZiAoYSA+IGIpIHsgcmV0dXJuIDEgfVxuICBpZiAoRG91YmxlLmlzTmFOKGEpKSB7XG4gICAgaWYgKERvdWJsZS5pc05hTihiKSkgeyByZXR1cm4gMCB9XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKERvdWJsZS5pc05hTihiKSkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuXG4vLyBpbXBvcnQgaGFzSW50ZXJmYWNlIGZyb20gJy4uLy4uLy4uLy4uL2hhc0ludGVyZmFjZSdcbi8vIGltcG9ydCBDb29yZGluYXRlU2VxdWVuY2UgZnJvbSAnLi9Db29yZGluYXRlU2VxdWVuY2UnXG5cbnZhciBDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gZnVuY3Rpb24gQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSAoKSB7fTtcblxuQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlICgpIHtcbiAgLy8gaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgLy8gaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gIC8vICAgbGV0IGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdXG4gIC8vIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAvLyAgIGxldCBjb29yZFNlcSA9IGFyZ3VtZW50c1swXVxuICAvLyB9XG4gIC8vIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAvLyBsZXQgc2l6ZSA9IGFyZ3VtZW50c1swXVxuICAvLyBsZXQgZGltZW5zaW9uID0gYXJndW1lbnRzWzFdXG4gIC8vIH1cbn07XG5Db29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5XG59O1xuXG52YXIgTG9jYXRpb24gPSBmdW5jdGlvbiBMb2NhdGlvbiAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0ID0geyBJTlRFUklPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxCT1VOREFSWTogeyBjb25maWd1cmFibGU6IHRydWUgfSxFWFRFUklPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxOT05FOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkxvY2F0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTG9jYXRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTG9jYXRpb25cbn07XG5Mb2NhdGlvbi50b0xvY2F0aW9uU3ltYm9sID0gZnVuY3Rpb24gdG9Mb2NhdGlvblN5bWJvbCAobG9jYXRpb25WYWx1ZSkge1xuICBzd2l0Y2ggKGxvY2F0aW9uVmFsdWUpIHtcbiAgICBjYXNlIExvY2F0aW9uLkVYVEVSSU9SOlxuICAgICAgcmV0dXJuICdlJ1xuICAgIGNhc2UgTG9jYXRpb24uQk9VTkRBUlk6XG4gICAgICByZXR1cm4gJ2InXG4gICAgY2FzZSBMb2NhdGlvbi5JTlRFUklPUjpcbiAgICAgIHJldHVybiAnaSdcbiAgICBjYXNlIExvY2F0aW9uLk5PTkU6XG4gICAgICByZXR1cm4gJy0nXG4gICAgZGVmYXVsdDpcbiAgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdVbmtub3duIGxvY2F0aW9uIHZhbHVlOiAnICsgbG9jYXRpb25WYWx1ZSlcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNC5JTlRFUklPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkNC5CT1VOREFSWS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkNC5FWFRFUklPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkNC5OT05FLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMb2NhdGlvbiwgc3RhdGljQWNjZXNzb3JzJDQgKTtcblxudmFyIGhhc0ludGVyZmFjZSA9IGZ1bmN0aW9uIChvLCBpKSB7XG4gIHJldHVybiBvLmludGVyZmFjZXNfICYmIG8uaW50ZXJmYWNlc18oKS5pbmRleE9mKGkpID4gLTFcbn07XG5cbnZhciBNYXRoVXRpbCA9IGZ1bmN0aW9uIE1hdGhVdGlsICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDUgPSB7IExPR18xMDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5NYXRoVXRpbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1hdGhVdGlsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1hdGhVdGlsXG59O1xuTWF0aFV0aWwubG9nMTAgPSBmdW5jdGlvbiBsb2cxMCAoeCkge1xuICB2YXIgbG4gPSBNYXRoLmxvZyh4KTtcbiAgaWYgKERvdWJsZS5pc0luZmluaXRlKGxuKSkgeyByZXR1cm4gbG4gfVxuICBpZiAoRG91YmxlLmlzTmFOKGxuKSkgeyByZXR1cm4gbG4gfVxuICByZXR1cm4gbG4gLyBNYXRoVXRpbC5MT0dfMTBcbn07XG5NYXRoVXRpbC5taW4gPSBmdW5jdGlvbiBtaW4gKHYxLCB2MiwgdjMsIHY0KSB7XG4gIHZhciBtaW4gPSB2MTtcbiAgaWYgKHYyIDwgbWluKSB7IG1pbiA9IHYyOyB9XG4gIGlmICh2MyA8IG1pbikgeyBtaW4gPSB2MzsgfVxuICBpZiAodjQgPCBtaW4pIHsgbWluID0gdjQ7IH1cbiAgcmV0dXJuIG1pblxufTtcbk1hdGhVdGlsLmNsYW1wID0gZnVuY3Rpb24gY2xhbXAgKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ251bWJlcicgJiYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSkge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtaW4gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1heCA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoeCA8IG1pbikgeyByZXR1cm4gbWluIH1cbiAgICBpZiAoeCA+IG1heCkgeyByZXR1cm4gbWF4IH1cbiAgICByZXR1cm4geFxuICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSAmJiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pICYmIE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSkpIHtcbiAgICB2YXIgeCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtaW4kMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWF4JDEgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKHgkMSA8IG1pbiQxKSB7IHJldHVybiBtaW4kMSB9XG4gICAgaWYgKHgkMSA+IG1heCQxKSB7IHJldHVybiBtYXgkMSB9XG4gICAgcmV0dXJuIHgkMVxuICB9XG59O1xuTWF0aFV0aWwud3JhcCA9IGZ1bmN0aW9uIHdyYXAgKGluZGV4LCBtYXgpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBtYXggLSAtaW5kZXggJSBtYXhcbiAgfVxuICByZXR1cm4gaW5kZXggJSBtYXhcbn07XG5NYXRoVXRpbC5tYXggPSBmdW5jdGlvbiBtYXggKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciB2MSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgdjIgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHYzID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBtYXggPSB2MTtcbiAgICBpZiAodjIgPiBtYXgpIHsgbWF4ID0gdjI7IH1cbiAgICBpZiAodjMgPiBtYXgpIHsgbWF4ID0gdjM7IH1cbiAgICByZXR1cm4gbWF4XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciB2MSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB2MiQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB2MyQxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciB2NCA9IGFyZ3VtZW50c1szXTtcbiAgICB2YXIgbWF4JDEgPSB2MSQxO1xuICAgIGlmICh2MiQxID4gbWF4JDEpIHsgbWF4JDEgPSB2MiQxOyB9XG4gICAgaWYgKHYzJDEgPiBtYXgkMSkgeyBtYXgkMSA9IHYzJDE7IH1cbiAgICBpZiAodjQgPiBtYXgkMSkgeyBtYXgkMSA9IHY0OyB9XG4gICAgcmV0dXJuIG1heCQxXG4gIH1cbn07XG5NYXRoVXRpbC5hdmVyYWdlID0gZnVuY3Rpb24gYXZlcmFnZSAoeDEsIHgyKSB7XG4gIHJldHVybiAoeDEgKyB4MikgLyAyLjBcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNS5MT0dfMTAuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aC5sb2coMTApIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNYXRoVXRpbCwgc3RhdGljQWNjZXNzb3JzJDUgKTtcblxudmFyIFN0cmluZ0J1ZmZlciA9IGZ1bmN0aW9uIFN0cmluZ0J1ZmZlciAoc3RyKSB7XG4gIHRoaXMuc3RyID0gc3RyO1xufTtcblN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kIChlKSB7XG4gIHRoaXMuc3RyICs9IGU7XG59O1xuXG5TdHJpbmdCdWZmZXIucHJvdG90eXBlLnNldENoYXJBdCA9IGZ1bmN0aW9uIHNldENoYXJBdCAoaSwgYykge1xuICB0aGlzLnN0ciA9IHRoaXMuc3RyLnN1YnN0cigwLCBpKSArIGMgKyB0aGlzLnN0ci5zdWJzdHIoaSArIDEpO1xufTtcblxuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlKSB7XG4gIHJldHVybiB0aGlzLnN0clxufTtcblxudmFyIEludGVnZXIgPSBmdW5jdGlvbiBJbnRlZ2VyICh2YWx1ZSkge1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG59O1xuSW50ZWdlci5wcm90b3R5cGUuaW50VmFsdWUgPSBmdW5jdGlvbiBpbnRWYWx1ZSAoKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlXG59O1xuSW50ZWdlci5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIGlmICh0aGlzLnZhbHVlIDwgbykgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy52YWx1ZSA+IG8pIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcbkludGVnZXIuaXNOYU4gPSBmdW5jdGlvbiBpc05hTiAobikgeyByZXR1cm4gTnVtYmVyLmlzTmFOKG4pIH07XG5cbnZhciBDaGFyYWN0ZXIgPSBmdW5jdGlvbiBDaGFyYWN0ZXIgKCkge307XG5cbkNoYXJhY3Rlci5pc1doaXRlc3BhY2UgPSBmdW5jdGlvbiBpc1doaXRlc3BhY2UgKGMpIHsgcmV0dXJuICgoYyA8PSAzMiAmJiBjID49IDApIHx8IGMgPT09IDEyNykgfTtcbkNoYXJhY3Rlci50b1VwcGVyQ2FzZSA9IGZ1bmN0aW9uIHRvVXBwZXJDYXNlIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCkgfTtcblxudmFyIEREID0gZnVuY3Rpb24gREQgKCkge1xuICB0aGlzLl9oaSA9IDAuMDtcbiAgdGhpcy5fbG8gPSAwLjA7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5pbml0KDAuMCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQoeCk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgICAgdmFyIGRkID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KGRkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgc3RyID0gYXJndW1lbnRzWzBdO1xuICAgICAgREQuY2FsbCh0aGlzLCBERC5wYXJzZShzdHIpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBoaSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG8gPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5pbml0KGhpLCBsbyk7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNyA9IHsgUEk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sVFdPX1BJOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFBJXzI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxOYU46IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRVBTOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNQTElUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1BWF9QUklOVF9ESUdJVFM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sVEVOOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE9ORTogeyBjb25maWd1cmFibGU6IHRydWUgfSxTQ0lfTk9UX0VYUE9ORU5UX0NIQVI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU0NJX05PVF9aRVJPOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5ERC5wcm90b3R5cGUubGUgPSBmdW5jdGlvbiBsZSAoeSkge1xuICByZXR1cm4gKHRoaXMuX2hpIDwgeS5faGkgfHwgdGhpcy5faGkgPT09IHkuX2hpKSAmJiB0aGlzLl9sbyA8PSB5Ll9sb1xufTtcbkRELnByb3RvdHlwZS5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMgPSBmdW5jdGlvbiBleHRyYWN0U2lnbmlmaWNhbnREaWdpdHMgKGluc2VydERlY2ltYWxQb2ludCwgbWFnbml0dWRlKSB7XG4gIHZhciB5ID0gdGhpcy5hYnMoKTtcbiAgdmFyIG1hZyA9IERELm1hZ25pdHVkZSh5Ll9oaSk7XG4gIHZhciBzY2FsZSA9IERELlRFTi5wb3cobWFnKTtcbiAgeSA9IHkuZGl2aWRlKHNjYWxlKTtcbiAgaWYgKHkuZ3QoREQuVEVOKSkge1xuICAgIHkgPSB5LmRpdmlkZShERC5URU4pO1xuICAgIG1hZyArPSAxO1xuICB9IGVsc2UgaWYgKHkubHQoREQuT05FKSkge1xuICAgIHkgPSB5Lm11bHRpcGx5KERELlRFTik7XG4gICAgbWFnIC09IDE7XG4gIH1cbiAgdmFyIGRlY2ltYWxQb2ludFBvcyA9IG1hZyArIDE7XG4gIHZhciBidWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gIHZhciBudW1EaWdpdHMgPSBERC5NQVhfUFJJTlRfRElHSVRTIC0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbnVtRGlnaXRzOyBpKyspIHtcbiAgICBpZiAoaW5zZXJ0RGVjaW1hbFBvaW50ICYmIGkgPT09IGRlY2ltYWxQb2ludFBvcykge1xuICAgICAgYnVmLmFwcGVuZCgnLicpO1xuICAgIH1cbiAgICB2YXIgZGlnaXQgPSBNYXRoLnRydW5jKHkuX2hpKTtcbiAgICBpZiAoZGlnaXQgPCAwKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICB2YXIgcmViaWFzQnkxMCA9IGZhbHNlO1xuICAgIHZhciBkaWdpdENoYXIgPSAwO1xuICAgIGlmIChkaWdpdCA+IDkpIHtcbiAgICAgIHJlYmlhc0J5MTAgPSB0cnVlO1xuICAgICAgZGlnaXRDaGFyID0gJzknO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWdpdENoYXIgPSAnMCcgKyBkaWdpdDtcbiAgICB9XG4gICAgYnVmLmFwcGVuZChkaWdpdENoYXIpO1xuICAgIHkgPSB5LnN1YnRyYWN0KERELnZhbHVlT2YoZGlnaXQpKS5tdWx0aXBseShERC5URU4pO1xuICAgIGlmIChyZWJpYXNCeTEwKSB7IHkuc2VsZkFkZChERC5URU4pOyB9XG4gICAgdmFyIGNvbnRpbnVlRXh0cmFjdGluZ0RpZ2l0cyA9IHRydWU7XG4gICAgdmFyIHJlbU1hZyA9IERELm1hZ25pdHVkZSh5Ll9oaSk7XG4gICAgaWYgKHJlbU1hZyA8IDAgJiYgTWF0aC5hYnMocmVtTWFnKSA+PSBudW1EaWdpdHMgLSBpKSB7IGNvbnRpbnVlRXh0cmFjdGluZ0RpZ2l0cyA9IGZhbHNlOyB9XG4gICAgaWYgKCFjb250aW51ZUV4dHJhY3RpbmdEaWdpdHMpIHsgYnJlYWsgfVxuICB9XG4gIG1hZ25pdHVkZVswXSA9IG1hZztcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG59O1xuREQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gIHJldHVybiB0aGlzLm11bHRpcGx5KHRoaXMpXG59O1xuREQucHJvdG90eXBlLmRvdWJsZVZhbHVlID0gZnVuY3Rpb24gZG91YmxlVmFsdWUgKCkge1xuICByZXR1cm4gdGhpcy5faGkgKyB0aGlzLl9sb1xufTtcbkRELnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0ICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuYWRkKHkubmVnYXRlKCkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLmFkZCgteSQxKVxuICB9XG59O1xuREQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuX2hpID09PSB5Ll9oaSAmJiB0aGlzLl9sbyA9PT0geS5fbG9cbiAgfVxufTtcbkRELnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8gKCkge1xuICByZXR1cm4gdGhpcy5faGkgPT09IDAuMCAmJiB0aGlzLl9sbyA9PT0gMC4wXG59O1xuREQucHJvdG90eXBlLnNlbGZTdWJ0cmFjdCA9IGZ1bmN0aW9uIHNlbGZTdWJ0cmFjdCAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiB0aGlzLnNlbGZBZGQoLXkuX2hpLCAteS5fbG8pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIHRoaXMgfVxuICAgIHJldHVybiB0aGlzLnNlbGZBZGQoLXkkMSwgMC4wKVxuICB9XG59O1xuREQucHJvdG90eXBlLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcgPSBmdW5jdGlvbiBnZXRTcGVjaWFsTnVtYmVyU3RyaW5nICgpIHtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpIHsgcmV0dXJuICcwLjAnIH1cbiAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gJ05hTiAnIH1cbiAgcmV0dXJuIG51bGxcbn07XG5ERC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gbWluICh4KSB7XG4gIGlmICh0aGlzLmxlKHgpKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geFxuICB9XG59O1xuREQucHJvdG90eXBlLnNlbGZEaXZpZGUgPSBmdW5jdGlvbiBzZWxmRGl2aWRlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh5Ll9oaSwgeS5fbG8pXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLnNlbGZEaXZpZGUoeSQxLCAwLjApXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeWhpID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5bG8gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGhjID0gbnVsbDtcbiAgICB2YXIgdGMgPSBudWxsO1xuICAgIHZhciBoeSA9IG51bGw7XG4gICAgdmFyIHR5ID0gbnVsbDtcbiAgICB2YXIgQyA9IG51bGw7XG4gICAgdmFyIGMgPSBudWxsO1xuICAgIHZhciBVID0gbnVsbDtcbiAgICB2YXIgdSA9IG51bGw7XG4gICAgQyA9IHRoaXMuX2hpIC8geWhpO1xuICAgIGMgPSBERC5TUExJVCAqIEM7XG4gICAgaGMgPSBjIC0gQztcbiAgICB1ID0gREQuU1BMSVQgKiB5aGk7XG4gICAgaGMgPSBjIC0gaGM7XG4gICAgdGMgPSBDIC0gaGM7XG4gICAgaHkgPSB1IC0geWhpO1xuICAgIFUgPSBDICogeWhpO1xuICAgIGh5ID0gdSAtIGh5O1xuICAgIHR5ID0geWhpIC0gaHk7XG4gICAgdSA9IGhjICogaHkgLSBVICsgaGMgKiB0eSArIHRjICogaHkgKyB0YyAqIHR5O1xuICAgIGMgPSAodGhpcy5faGkgLSBVIC0gdSArIHRoaXMuX2xvIC0gQyAqIHlsbykgLyB5aGk7XG4gICAgdSA9IEMgKyBjO1xuICAgIHRoaXMuX2hpID0gdTtcbiAgICB0aGlzLl9sbyA9IEMgLSB1ICsgYztcbiAgICByZXR1cm4gdGhpc1xuICB9XG59O1xuREQucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbiBkdW1wICgpIHtcbiAgcmV0dXJuICdERDwnICsgdGhpcy5faGkgKyAnLCAnICsgdGhpcy5fbG8gKyAnPidcbn07XG5ERC5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGhjID0gbnVsbDtcbiAgICB2YXIgdGMgPSBudWxsO1xuICAgIHZhciBoeSA9IG51bGw7XG4gICAgdmFyIHR5ID0gbnVsbDtcbiAgICB2YXIgQyA9IG51bGw7XG4gICAgdmFyIGMgPSBudWxsO1xuICAgIHZhciBVID0gbnVsbDtcbiAgICB2YXIgdSA9IG51bGw7XG4gICAgQyA9IHRoaXMuX2hpIC8geS5faGk7XG4gICAgYyA9IERELlNQTElUICogQztcbiAgICBoYyA9IGMgLSBDO1xuICAgIHUgPSBERC5TUExJVCAqIHkuX2hpO1xuICAgIGhjID0gYyAtIGhjO1xuICAgIHRjID0gQyAtIGhjO1xuICAgIGh5ID0gdSAtIHkuX2hpO1xuICAgIFUgPSBDICogeS5faGk7XG4gICAgaHkgPSB1IC0gaHk7XG4gICAgdHkgPSB5Ll9oaSAtIGh5O1xuICAgIHUgPSBoYyAqIGh5IC0gVSArIGhjICogdHkgKyB0YyAqIGh5ICsgdGMgKiB0eTtcbiAgICBjID0gKHRoaXMuX2hpIC0gVSAtIHUgKyB0aGlzLl9sbyAtIEMgKiB5Ll9sbykgLyB5Ll9oaTtcbiAgICB1ID0gQyArIGM7XG4gICAgdmFyIHpoaSA9IHU7XG4gICAgdmFyIHpsbyA9IEMgLSB1ICsgYztcbiAgICByZXR1cm4gbmV3IEREKHpoaSwgemxvKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoRG91YmxlLmlzTmFOKHkkMSkpIHsgcmV0dXJuIERELmNyZWF0ZU5hTigpIH1cbiAgICByZXR1cm4gREQuY29weSh0aGlzKS5zZWxmRGl2aWRlKHkkMSwgMC4wKVxuICB9XG59O1xuREQucHJvdG90eXBlLmdlID0gZnVuY3Rpb24gZ2UgKHkpIHtcbiAgcmV0dXJuICh0aGlzLl9oaSA+IHkuX2hpIHx8IHRoaXMuX2hpID09PSB5Ll9oaSkgJiYgdGhpcy5fbG8gPj0geS5fbG9cbn07XG5ERC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChleHApIHtcbiAgaWYgKGV4cCA9PT0gMC4wKSB7IHJldHVybiBERC52YWx1ZU9mKDEuMCkgfVxuICB2YXIgciA9IG5ldyBERCh0aGlzKTtcbiAgdmFyIHMgPSBERC52YWx1ZU9mKDEuMCk7XG4gIHZhciBuID0gTWF0aC5hYnMoZXhwKTtcbiAgaWYgKG4gPiAxKSB7XG4gICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHtcbiAgICAgICAgcy5zZWxmTXVsdGlwbHkocik7XG4gICAgICB9XG4gICAgICBuIC89IDI7XG4gICAgICBpZiAobiA+IDApIHsgciA9IHIuc3FyKCk7IH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcyA9IHI7XG4gIH1cbiAgaWYgKGV4cCA8IDApIHsgcmV0dXJuIHMucmVjaXByb2NhbCgpIH1cbiAgcmV0dXJuIHNcbn07XG5ERC5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uIGNlaWwgKCkge1xuICBpZiAodGhpcy5pc05hTigpKSB7IHJldHVybiBERC5OYU4gfVxuICB2YXIgZmhpID0gTWF0aC5jZWlsKHRoaXMuX2hpKTtcbiAgdmFyIGZsbyA9IDAuMDtcbiAgaWYgKGZoaSA9PT0gdGhpcy5faGkpIHtcbiAgICBmbG8gPSBNYXRoLmNlaWwodGhpcy5fbG8pO1xuICB9XG4gIHJldHVybiBuZXcgREQoZmhpLCBmbG8pXG59O1xuREQucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgb3RoZXIgPSBvO1xuICBpZiAodGhpcy5faGkgPCBvdGhlci5faGkpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX2hpID4gb3RoZXIuX2hpKSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX2xvIDwgb3RoZXIuX2xvKSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9sbyA+IG90aGVyLl9sbykgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuREQucHJvdG90eXBlLnJpbnQgPSBmdW5jdGlvbiByaW50ICgpIHtcbiAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gdGhpcyB9XG4gIHZhciBwbHVzNSA9IHRoaXMuYWRkKDAuNSk7XG4gIHJldHVybiBwbHVzNS5mbG9vcigpXG59O1xuREQucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5pbml0KHZhbHVlKTtcbiAgICByZXR1cm4gdGhpc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHZhbHVlJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5pbml0KHZhbHVlJDEpO1xuICAgIHJldHVybiB0aGlzXG4gIH1cbn07XG5ERC5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gbWF4ICh4KSB7XG4gIGlmICh0aGlzLmdlKHgpKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geFxuICB9XG59O1xuREQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0ICgpIHtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpIHsgcmV0dXJuIERELnZhbHVlT2YoMC4wKSB9XG4gIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgIHJldHVybiBERC5OYU5cbiAgfVxuICB2YXIgeCA9IDEuMCAvIE1hdGguc3FydCh0aGlzLl9oaSk7XG4gIHZhciBheCA9IHRoaXMuX2hpICogeDtcbiAgdmFyIGF4ZGQgPSBERC52YWx1ZU9mKGF4KTtcbiAgdmFyIGRpZmZTcSA9IHRoaXMuc3VidHJhY3QoYXhkZC5zcXIoKSk7XG4gIHZhciBkMiA9IGRpZmZTcS5faGkgKiAoeCAqIDAuNSk7XG4gIHJldHVybiBheGRkLmFkZChkMilcbn07XG5ERC5wcm90b3R5cGUuc2VsZkFkZCA9IGZ1bmN0aW9uIHNlbGZBZGQgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5zZWxmQWRkKHkuX2hpLCB5Ll9sbylcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIEggPSBudWxsO1xuICAgICAgdmFyIGggPSBudWxsO1xuICAgICAgdmFyIFMgPSBudWxsO1xuICAgICAgdmFyIHMgPSBudWxsO1xuICAgICAgdmFyIGUgPSBudWxsO1xuICAgICAgdmFyIGYgPSBudWxsO1xuICAgICAgUyA9IHRoaXMuX2hpICsgeSQxO1xuICAgICAgZSA9IFMgLSB0aGlzLl9oaTtcbiAgICAgIHMgPSBTIC0gZTtcbiAgICAgIHMgPSB5JDEgLSBlICsgKHRoaXMuX2hpIC0gcyk7XG4gICAgICBmID0gcyArIHRoaXMuX2xvO1xuICAgICAgSCA9IFMgKyBmO1xuICAgICAgaCA9IGYgKyAoUyAtIEgpO1xuICAgICAgdGhpcy5faGkgPSBIICsgaDtcbiAgICAgIHRoaXMuX2xvID0gaCArIChIIC0gdGhpcy5faGkpO1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB5aGkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHlsbyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgSCQxID0gbnVsbDtcbiAgICB2YXIgaCQxID0gbnVsbDtcbiAgICB2YXIgVCA9IG51bGw7XG4gICAgdmFyIHQgPSBudWxsO1xuICAgIHZhciBTJDEgPSBudWxsO1xuICAgIHZhciBzJDEgPSBudWxsO1xuICAgIHZhciBlJDEgPSBudWxsO1xuICAgIHZhciBmJDEgPSBudWxsO1xuICAgIFMkMSA9IHRoaXMuX2hpICsgeWhpO1xuICAgIFQgPSB0aGlzLl9sbyArIHlsbztcbiAgICBlJDEgPSBTJDEgLSB0aGlzLl9oaTtcbiAgICBmJDEgPSBUIC0gdGhpcy5fbG87XG4gICAgcyQxID0gUyQxIC0gZSQxO1xuICAgIHQgPSBUIC0gZiQxO1xuICAgIHMkMSA9IHloaSAtIGUkMSArICh0aGlzLl9oaSAtIHMkMSk7XG4gICAgdCA9IHlsbyAtIGYkMSArICh0aGlzLl9sbyAtIHQpO1xuICAgIGUkMSA9IHMkMSArIFQ7XG4gICAgSCQxID0gUyQxICsgZSQxO1xuICAgIGgkMSA9IGUkMSArIChTJDEgLSBIJDEpO1xuICAgIGUkMSA9IHQgKyBoJDE7XG4gICAgdmFyIHpoaSA9IEgkMSArIGUkMTtcbiAgICB2YXIgemxvID0gZSQxICsgKEgkMSAtIHpoaSk7XG4gICAgdGhpcy5faGkgPSB6aGk7XG4gICAgdGhpcy5fbG8gPSB6bG87XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufTtcbkRELnByb3RvdHlwZS5zZWxmTXVsdGlwbHkgPSBmdW5jdGlvbiBzZWxmTXVsdGlwbHkgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkoeS5faGksIHkuX2xvKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB5JDEgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkoeSQxLCAwLjApXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeWhpID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5bG8gPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGh4ID0gbnVsbDtcbiAgICB2YXIgdHggPSBudWxsO1xuICAgIHZhciBoeSA9IG51bGw7XG4gICAgdmFyIHR5ID0gbnVsbDtcbiAgICB2YXIgQyA9IG51bGw7XG4gICAgdmFyIGMgPSBudWxsO1xuICAgIEMgPSBERC5TUExJVCAqIHRoaXMuX2hpO1xuICAgIGh4ID0gQyAtIHRoaXMuX2hpO1xuICAgIGMgPSBERC5TUExJVCAqIHloaTtcbiAgICBoeCA9IEMgLSBoeDtcbiAgICB0eCA9IHRoaXMuX2hpIC0gaHg7XG4gICAgaHkgPSBjIC0geWhpO1xuICAgIEMgPSB0aGlzLl9oaSAqIHloaTtcbiAgICBoeSA9IGMgLSBoeTtcbiAgICB0eSA9IHloaSAtIGh5O1xuICAgIGMgPSBoeCAqIGh5IC0gQyArIGh4ICogdHkgKyB0eCAqIGh5ICsgdHggKiB0eSArICh0aGlzLl9oaSAqIHlsbyArIHRoaXMuX2xvICogeWhpKTtcbiAgICB2YXIgemhpID0gQyArIGM7XG4gICAgaHggPSBDIC0gemhpO1xuICAgIHZhciB6bG8gPSBjICsgaHg7XG4gICAgdGhpcy5faGkgPSB6aGk7XG4gICAgdGhpcy5fbG8gPSB6bG87XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufTtcbkRELnByb3RvdHlwZS5zZWxmU3FyID0gZnVuY3Rpb24gc2VsZlNxciAoKSB7XG4gIHJldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0aGlzKVxufTtcbkRELnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uIGZsb29yICgpIHtcbiAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gREQuTmFOIH1cbiAgdmFyIGZoaSA9IE1hdGguZmxvb3IodGhpcy5faGkpO1xuICB2YXIgZmxvID0gMC4wO1xuICBpZiAoZmhpID09PSB0aGlzLl9oaSkge1xuICAgIGZsbyA9IE1hdGguZmxvb3IodGhpcy5fbG8pO1xuICB9XG4gIHJldHVybiBuZXcgREQoZmhpLCBmbG8pXG59O1xuREQucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSAoKSB7XG4gIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gbmV3IEREKC10aGlzLl9oaSwgLXRoaXMuX2xvKVxufTtcbkRELnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgLy8gdHJ5IHtcbiAgLy8gcmV0dXJuIG51bGxcbiAgLy8gfSBjYXRjaCAoZXgpIHtcbiAgLy8gaWYgKGV4IGluc3RhbmNlb2YgQ2xvbmVOb3RTdXBwb3J0ZWRFeGNlcHRpb24pIHtcbiAgLy8gICByZXR1cm4gbnVsbFxuICAvLyB9IGVsc2UgdGhyb3cgZXhcbiAgLy8gfSBmaW5hbGx5IHt9XG59O1xuREQucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoeS5pc05hTigpKSB7IHJldHVybiBERC5jcmVhdGVOYU4oKSB9XG4gICAgcmV0dXJuIERELmNvcHkodGhpcykuc2VsZk11bHRpcGx5KHkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChEb3VibGUuaXNOYU4oeSQxKSkgeyByZXR1cm4gREQuY3JlYXRlTmFOKCkgfVxuICAgIHJldHVybiBERC5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh5JDEsIDAuMClcbiAgfVxufTtcbkRELnByb3RvdHlwZS5pc05hTiA9IGZ1bmN0aW9uIGlzTmFOICgpIHtcbiAgcmV0dXJuIERvdWJsZS5pc05hTih0aGlzLl9oaSlcbn07XG5ERC5wcm90b3R5cGUuaW50VmFsdWUgPSBmdW5jdGlvbiBpbnRWYWx1ZSAoKSB7XG4gIHJldHVybiBNYXRoLnRydW5jKHRoaXMuX2hpKVxufTtcbkRELnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIG1hZyA9IERELm1hZ25pdHVkZSh0aGlzLl9oaSk7XG4gIGlmIChtYWcgPj0gLTMgJiYgbWFnIDw9IDIwKSB7IHJldHVybiB0aGlzLnRvU3RhbmRhcmROb3RhdGlvbigpIH1cbiAgcmV0dXJuIHRoaXMudG9TY2lOb3RhdGlvbigpXG59O1xuREQucHJvdG90eXBlLnRvU3RhbmRhcmROb3RhdGlvbiA9IGZ1bmN0aW9uIHRvU3RhbmRhcmROb3RhdGlvbiAoKSB7XG4gIHZhciBzcGVjaWFsU3RyID0gdGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7XG4gIGlmIChzcGVjaWFsU3RyICE9PSBudWxsKSB7IHJldHVybiBzcGVjaWFsU3RyIH1cbiAgdmFyIG1hZ25pdHVkZSA9IG5ldyBBcnJheSgxKS5maWxsKG51bGwpO1xuICB2YXIgc2lnRGlnaXRzID0gdGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHModHJ1ZSwgbWFnbml0dWRlKTtcbiAgdmFyIGRlY2ltYWxQb2ludFBvcyA9IG1hZ25pdHVkZVswXSArIDE7XG4gIHZhciBudW0gPSBzaWdEaWdpdHM7XG4gIGlmIChzaWdEaWdpdHMuY2hhckF0KDApID09PSAnLicpIHtcbiAgICBudW0gPSAnMCcgKyBzaWdEaWdpdHM7XG4gIH0gZWxzZSBpZiAoZGVjaW1hbFBvaW50UG9zIDwgMCkge1xuICAgIG51bSA9ICcwLicgKyBERC5zdHJpbmdPZkNoYXIoJzAnLCAtZGVjaW1hbFBvaW50UG9zKSArIHNpZ0RpZ2l0cztcbiAgfSBlbHNlIGlmIChzaWdEaWdpdHMuaW5kZXhPZignLicpID09PSAtMSkge1xuICAgIHZhciBudW1aZXJvZXMgPSBkZWNpbWFsUG9pbnRQb3MgLSBzaWdEaWdpdHMubGVuZ3RoO1xuICAgIHZhciB6ZXJvZXMgPSBERC5zdHJpbmdPZkNoYXIoJzAnLCBudW1aZXJvZXMpO1xuICAgIG51bSA9IHNpZ0RpZ2l0cyArIHplcm9lcyArICcuMCc7XG4gIH1cbiAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IHJldHVybiAnLScgKyBudW0gfVxuICByZXR1cm4gbnVtXG59O1xuREQucHJvdG90eXBlLnJlY2lwcm9jYWwgPSBmdW5jdGlvbiByZWNpcHJvY2FsICgpIHtcbiAgdmFyIGhjID0gbnVsbDtcbiAgdmFyIHRjID0gbnVsbDtcbiAgdmFyIGh5ID0gbnVsbDtcbiAgdmFyIHR5ID0gbnVsbDtcbiAgdmFyIEMgPSBudWxsO1xuICB2YXIgYyA9IG51bGw7XG4gIHZhciBVID0gbnVsbDtcbiAgdmFyIHUgPSBudWxsO1xuICBDID0gMS4wIC8gdGhpcy5faGk7XG4gIGMgPSBERC5TUExJVCAqIEM7XG4gIGhjID0gYyAtIEM7XG4gIHUgPSBERC5TUExJVCAqIHRoaXMuX2hpO1xuICBoYyA9IGMgLSBoYztcbiAgdGMgPSBDIC0gaGM7XG4gIGh5ID0gdSAtIHRoaXMuX2hpO1xuICBVID0gQyAqIHRoaXMuX2hpO1xuICBoeSA9IHUgLSBoeTtcbiAgdHkgPSB0aGlzLl9oaSAtIGh5O1xuICB1ID0gaGMgKiBoeSAtIFUgKyBoYyAqIHR5ICsgdGMgKiBoeSArIHRjICogdHk7XG4gIGMgPSAoMS4wIC0gVSAtIHUgLSBDICogdGhpcy5fbG8pIC8gdGhpcy5faGk7XG4gIHZhciB6aGkgPSBDICsgYztcbiAgdmFyIHpsbyA9IEMgLSB6aGkgKyBjO1xuICByZXR1cm4gbmV3IEREKHpoaSwgemxvKVxufTtcbkRELnByb3RvdHlwZS50b1NjaU5vdGF0aW9uID0gZnVuY3Rpb24gdG9TY2lOb3RhdGlvbiAoKSB7XG4gIGlmICh0aGlzLmlzWmVybygpKSB7IHJldHVybiBERC5TQ0lfTk9UX1pFUk8gfVxuICB2YXIgc3BlY2lhbFN0ciA9IHRoaXMuZ2V0U3BlY2lhbE51bWJlclN0cmluZygpO1xuICBpZiAoc3BlY2lhbFN0ciAhPT0gbnVsbCkgeyByZXR1cm4gc3BlY2lhbFN0ciB9XG4gIHZhciBtYWduaXR1ZGUgPSBuZXcgQXJyYXkoMSkuZmlsbChudWxsKTtcbiAgdmFyIGRpZ2l0cyA9IHRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKGZhbHNlLCBtYWduaXR1ZGUpO1xuICB2YXIgZXhwU3RyID0gREQuU0NJX05PVF9FWFBPTkVOVF9DSEFSICsgbWFnbml0dWRlWzBdO1xuICBpZiAoZGlnaXRzLmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCBsZWFkaW5nIHplcm86ICcgKyBkaWdpdHMpXG4gIH1cbiAgdmFyIHRyYWlsaW5nRGlnaXRzID0gJyc7XG4gIGlmIChkaWdpdHMubGVuZ3RoID4gMSkgeyB0cmFpbGluZ0RpZ2l0cyA9IGRpZ2l0cy5zdWJzdHJpbmcoMSk7IH1cbiAgdmFyIGRpZ2l0c1dpdGhEZWNpbWFsID0gZGlnaXRzLmNoYXJBdCgwKSArICcuJyArIHRyYWlsaW5nRGlnaXRzO1xuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgcmV0dXJuICctJyArIGRpZ2l0c1dpdGhEZWNpbWFsICsgZXhwU3RyIH1cbiAgcmV0dXJuIGRpZ2l0c1dpdGhEZWNpbWFsICsgZXhwU3RyXG59O1xuREQucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIERELk5hTiB9XG4gIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyByZXR1cm4gdGhpcy5uZWdhdGUoKSB9XG4gIHJldHVybiBuZXcgREQodGhpcylcbn07XG5ERC5wcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUgKCkge1xuICByZXR1cm4gKHRoaXMuX2hpID4gMC4wIHx8IHRoaXMuX2hpID09PSAwLjApICYmIHRoaXMuX2xvID4gMC4wXG59O1xuREQucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKHkpIHtcbiAgcmV0dXJuICh0aGlzLl9oaSA8IHkuX2hpIHx8IHRoaXMuX2hpID09PSB5Ll9oaSkgJiYgdGhpcy5fbG8gPCB5Ll9sb1xufTtcbkRELnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gREQuY29weSh0aGlzKS5zZWxmQWRkKHkpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBERC5jb3B5KHRoaXMpLnNlbGZBZGQoeSQxKVxuICB9XG59O1xuREQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5faGkgPSB4O1xuICAgICAgdGhpcy5fbG8gPSAwLjA7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgICAgdmFyIGRkID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5faGkgPSBkZC5faGk7XG4gICAgICB0aGlzLl9sbyA9IGRkLl9sbztcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBoaSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG8gPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5faGkgPSBoaTtcbiAgICB0aGlzLl9sbyA9IGxvO1xuICB9XG59O1xuREQucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKHkpIHtcbiAgcmV0dXJuICh0aGlzLl9oaSA+IHkuX2hpIHx8IHRoaXMuX2hpID09PSB5Ll9oaSkgJiYgdGhpcy5fbG8gPiB5Ll9sb1xufTtcbkRELnByb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSAoKSB7XG4gIHJldHVybiAodGhpcy5faGkgPCAwLjAgfHwgdGhpcy5faGkgPT09IDAuMCkgJiYgdGhpcy5fbG8gPCAwLjBcbn07XG5ERC5wcm90b3R5cGUudHJ1bmMgPSBmdW5jdGlvbiB0cnVuYyAoKSB7XG4gIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIERELk5hTiB9XG4gIGlmICh0aGlzLmlzUG9zaXRpdmUoKSkgeyByZXR1cm4gdGhpcy5mbG9vcigpOyB9IGVsc2UgeyByZXR1cm4gdGhpcy5jZWlsKCkgfVxufTtcbkRELnByb3RvdHlwZS5zaWdudW0gPSBmdW5jdGlvbiBzaWdudW0gKCkge1xuICBpZiAodGhpcy5faGkgPiAwKSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX2hpIDwgMCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5fbG8gPiAwKSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX2xvIDwgMCkgeyByZXR1cm4gLTEgfVxuICByZXR1cm4gMFxufTtcbkRELnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZXJpYWxpemFibGUsIENvbXBhcmFibGUsIENsb25hYmxlXVxufTtcbkRELnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEREXG59O1xuREQuc3FyID0gZnVuY3Rpb24gc3FyICh4KSB7XG4gIHJldHVybiBERC52YWx1ZU9mKHgpLnNlbGZNdWx0aXBseSh4KVxufTtcbkRELnZhbHVlT2YgPSBmdW5jdGlvbiB2YWx1ZU9mICgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHN0ciA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gREQucGFyc2Uoc3RyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIG5ldyBERCh4KVxuICB9XG59O1xuREQuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKHgpIHtcbiAgcmV0dXJuIERELnZhbHVlT2YoeCkuc3FydCgpXG59O1xuREQucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSAoc3RyKSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIHN0cmxlbiA9IHN0ci5sZW5ndGg7XG4gIHdoaWxlIChDaGFyYWN0ZXIuaXNXaGl0ZXNwYWNlKHN0ci5jaGFyQXQoaSkpKSB7IGkrKzsgfVxuICB2YXIgaXNOZWdhdGl2ZSA9IGZhbHNlO1xuICBpZiAoaSA8IHN0cmxlbikge1xuICAgIHZhciBzaWduQ2ggPSBzdHIuY2hhckF0KGkpO1xuICAgIGlmIChzaWduQ2ggPT09ICctJyB8fCBzaWduQ2ggPT09ICcrJykge1xuICAgICAgaSsrO1xuICAgICAgaWYgKHNpZ25DaCA9PT0gJy0nKSB7IGlzTmVnYXRpdmUgPSB0cnVlOyB9XG4gICAgfVxuICB9XG4gIHZhciB2YWwgPSBuZXcgREQoKTtcbiAgdmFyIG51bURpZ2l0cyA9IDA7XG4gIHZhciBudW1CZWZvcmVEZWMgPSAwO1xuICB2YXIgZXhwID0gMDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoaSA+PSBzdHJsZW4pIHsgYnJlYWsgfVxuICAgIHZhciBjaCA9IHN0ci5jaGFyQXQoaSk7XG4gICAgaSsrO1xuICAgIGlmIChDaGFyYWN0ZXIuaXNEaWdpdChjaCkpIHtcbiAgICAgIHZhciBkID0gY2ggLSAnMCc7XG4gICAgICB2YWwuc2VsZk11bHRpcGx5KERELlRFTik7XG4gICAgICB2YWwuc2VsZkFkZChkKTtcbiAgICAgIG51bURpZ2l0cysrO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgIG51bUJlZm9yZURlYyA9IG51bURpZ2l0cztcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgIHZhciBleHBTdHIgPSBzdHIuc3Vic3RyaW5nKGkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXhwID0gSW50ZWdlci5wYXJzZUludChleHBTdHIpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgaWYgKGV4IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZXhwb25lbnQgJyArIGV4cFN0ciArICcgaW4gc3RyaW5nICcgKyBzdHIpXG4gICAgICAgIH0gZWxzZSB7IHRocm93IGV4IH1cbiAgICAgIH0gZmluYWxseSB7fVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiICsgY2ggKyBcIicgYXQgcG9zaXRpb24gXCIgKyBpICsgJyBpbiBzdHJpbmcgJyArIHN0cilcbiAgfVxuICB2YXIgdmFsMiA9IHZhbDtcbiAgdmFyIG51bURlY1BsYWNlcyA9IG51bURpZ2l0cyAtIG51bUJlZm9yZURlYyAtIGV4cDtcbiAgaWYgKG51bURlY1BsYWNlcyA9PT0gMCkge1xuICAgIHZhbDIgPSB2YWw7XG4gIH0gZWxzZSBpZiAobnVtRGVjUGxhY2VzID4gMCkge1xuICAgIHZhciBzY2FsZSA9IERELlRFTi5wb3cobnVtRGVjUGxhY2VzKTtcbiAgICB2YWwyID0gdmFsLmRpdmlkZShzY2FsZSk7XG4gIH0gZWxzZSBpZiAobnVtRGVjUGxhY2VzIDwgMCkge1xuICAgIHZhciBzY2FsZSQxID0gREQuVEVOLnBvdygtbnVtRGVjUGxhY2VzKTtcbiAgICB2YWwyID0gdmFsLm11bHRpcGx5KHNjYWxlJDEpO1xuICB9XG4gIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgcmV0dXJuIHZhbDIubmVnYXRlKClcbiAgfVxuICByZXR1cm4gdmFsMlxufTtcbkRELmNyZWF0ZU5hTiA9IGZ1bmN0aW9uIGNyZWF0ZU5hTiAoKSB7XG4gIHJldHVybiBuZXcgREQoRG91YmxlLk5hTiwgRG91YmxlLk5hTilcbn07XG5ERC5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGQpIHtcbiAgcmV0dXJuIG5ldyBERChkZClcbn07XG5ERC5tYWduaXR1ZGUgPSBmdW5jdGlvbiBtYWduaXR1ZGUgKHgpIHtcbiAgdmFyIHhBYnMgPSBNYXRoLmFicyh4KTtcbiAgdmFyIHhMb2cxMCA9IE1hdGgubG9nKHhBYnMpIC8gTWF0aC5sb2coMTApO1xuICB2YXIgeE1hZyA9IE1hdGgudHJ1bmMoTWF0aC5mbG9vcih4TG9nMTApKTtcbiAgdmFyIHhBcHByb3ggPSBNYXRoLnBvdygxMCwgeE1hZyk7XG4gIGlmICh4QXBwcm94ICogMTAgPD0geEFicykgeyB4TWFnICs9IDE7IH1cbiAgcmV0dXJuIHhNYWdcbn07XG5ERC5zdHJpbmdPZkNoYXIgPSBmdW5jdGlvbiBzdHJpbmdPZkNoYXIgKGNoLCBsZW4pIHtcbiAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1Zi5hcHBlbmQoY2gpO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlBJLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBERCgzLjE0MTU5MjY1MzU4OTc5MzExNmUrMDAsIDEuMjI0NjQ2Nzk5MTQ3MzUzMjA3ZS0xNikgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlRXT19QSS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgREQoNi4yODMxODUzMDcxNzk1ODYyMzJlKzAwLCAyLjQ0OTI5MzU5ODI5NDcwNjQxNGUtMTYpIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5QSV8yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBERCgxLjU3MDc5NjMyNjc5NDg5NjU1OGUrMDAsIDYuMTIzMjMzOTk1NzM2NzY2MDM2ZS0xNykgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEREKDIuNzE4MjgxODI4NDU5MDQ1MDkxZSswMCwgMS40NDU2NDY4OTE3MjkyNTAxNThlLTE2KSB9O1xuc3RhdGljQWNjZXNzb3JzJDcuTmFOLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBERChEb3VibGUuTmFOLCBEb3VibGUuTmFOKSB9O1xuc3RhdGljQWNjZXNzb3JzJDcuRVBTLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEuMjMyNTk1MTY0NDA3ODNlLTMyIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5TUExJVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxMzQyMTc3MjkuMCB9O1xuc3RhdGljQWNjZXNzb3JzJDcuTUFYX1BSSU5UX0RJR0lUUy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzMiB9O1xuc3RhdGljQWNjZXNzb3JzJDcuVEVOLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERELnZhbHVlT2YoMTAuMCkgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3Lk9ORS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBERC52YWx1ZU9mKDEuMCkgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlNDSV9OT1RfRVhQT05FTlRfQ0hBUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnRScgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlNDSV9OT1RfWkVSTy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnMC4wRTAnIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBERCwgc3RhdGljQWNjZXNzb3JzJDcgKTtcblxudmFyIENHQWxnb3JpdGhtc0REID0gZnVuY3Rpb24gQ0dBbGdvcml0aG1zREQgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNiA9IHsgRFBfU0FGRV9FUFNJTE9OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkNHQWxnb3JpdGhtc0RELnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ0dBbGdvcml0aG1zREQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ0dBbGdvcml0aG1zRERcbn07XG5DR0FsZ29yaXRobXNERC5vcmllbnRhdGlvbkluZGV4ID0gZnVuY3Rpb24gb3JpZW50YXRpb25JbmRleCAocDEsIHAyLCBxKSB7XG4gIHZhciBpbmRleCA9IENHQWxnb3JpdGhtc0RELm9yaWVudGF0aW9uSW5kZXhGaWx0ZXIocDEsIHAyLCBxKTtcbiAgaWYgKGluZGV4IDw9IDEpIHsgcmV0dXJuIGluZGV4IH1cbiAgdmFyIGR4MSA9IERELnZhbHVlT2YocDIueCkuc2VsZkFkZCgtcDEueCk7XG4gIHZhciBkeTEgPSBERC52YWx1ZU9mKHAyLnkpLnNlbGZBZGQoLXAxLnkpO1xuICB2YXIgZHgyID0gREQudmFsdWVPZihxLngpLnNlbGZBZGQoLXAyLngpO1xuICB2YXIgZHkyID0gREQudmFsdWVPZihxLnkpLnNlbGZBZGQoLXAyLnkpO1xuICByZXR1cm4gZHgxLnNlbGZNdWx0aXBseShkeTIpLnNlbGZTdWJ0cmFjdChkeTEuc2VsZk11bHRpcGx5KGR4MikpLnNpZ251bSgpXG59O1xuQ0dBbGdvcml0aG1zREQuc2lnbk9mRGV0MngyID0gZnVuY3Rpb24gc2lnbk9mRGV0MngyICh4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgZGV0ID0geDEubXVsdGlwbHkoeTIpLnNlbGZTdWJ0cmFjdCh5MS5tdWx0aXBseSh4MikpO1xuICByZXR1cm4gZGV0LnNpZ251bSgpXG59O1xuQ0dBbGdvcml0aG1zREQuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChwMSwgcDIsIHExLCBxMikge1xuICB2YXIgZGVub20xID0gREQudmFsdWVPZihxMi55KS5zZWxmU3VidHJhY3QocTEueSkuc2VsZk11bHRpcGx5KERELnZhbHVlT2YocDIueCkuc2VsZlN1YnRyYWN0KHAxLngpKTtcbiAgdmFyIGRlbm9tMiA9IERELnZhbHVlT2YocTIueCkuc2VsZlN1YnRyYWN0KHExLngpLnNlbGZNdWx0aXBseShERC52YWx1ZU9mKHAyLnkpLnNlbGZTdWJ0cmFjdChwMS55KSk7XG4gIHZhciBkZW5vbSA9IGRlbm9tMS5zdWJ0cmFjdChkZW5vbTIpO1xuICB2YXIgbnVteDEgPSBERC52YWx1ZU9mKHEyLngpLnNlbGZTdWJ0cmFjdChxMS54KS5zZWxmTXVsdGlwbHkoREQudmFsdWVPZihwMS55KS5zZWxmU3VidHJhY3QocTEueSkpO1xuICB2YXIgbnVteDIgPSBERC52YWx1ZU9mKHEyLnkpLnNlbGZTdWJ0cmFjdChxMS55KS5zZWxmTXVsdGlwbHkoREQudmFsdWVPZihwMS54KS5zZWxmU3VidHJhY3QocTEueCkpO1xuICB2YXIgbnVteCA9IG51bXgxLnN1YnRyYWN0KG51bXgyKTtcbiAgdmFyIGZyYWNQID0gbnVteC5zZWxmRGl2aWRlKGRlbm9tKS5kb3VibGVWYWx1ZSgpO1xuICB2YXIgeCA9IERELnZhbHVlT2YocDEueCkuc2VsZkFkZChERC52YWx1ZU9mKHAyLngpLnNlbGZTdWJ0cmFjdChwMS54KS5zZWxmTXVsdGlwbHkoZnJhY1ApKS5kb3VibGVWYWx1ZSgpO1xuICB2YXIgbnVteTEgPSBERC52YWx1ZU9mKHAyLngpLnNlbGZTdWJ0cmFjdChwMS54KS5zZWxmTXVsdGlwbHkoREQudmFsdWVPZihwMS55KS5zZWxmU3VidHJhY3QocTEueSkpO1xuICB2YXIgbnVteTIgPSBERC52YWx1ZU9mKHAyLnkpLnNlbGZTdWJ0cmFjdChwMS55KS5zZWxmTXVsdGlwbHkoREQudmFsdWVPZihwMS54KS5zZWxmU3VidHJhY3QocTEueCkpO1xuICB2YXIgbnVteSA9IG51bXkxLnN1YnRyYWN0KG51bXkyKTtcbiAgdmFyIGZyYWNRID0gbnVteS5zZWxmRGl2aWRlKGRlbm9tKS5kb3VibGVWYWx1ZSgpO1xuICB2YXIgeSA9IERELnZhbHVlT2YocTEueSkuc2VsZkFkZChERC52YWx1ZU9mKHEyLnkpLnNlbGZTdWJ0cmFjdChxMS55KS5zZWxmTXVsdGlwbHkoZnJhY1EpKS5kb3VibGVWYWx1ZSgpO1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoeCwgeSlcbn07XG5DR0FsZ29yaXRobXNERC5vcmllbnRhdGlvbkluZGV4RmlsdGVyID0gZnVuY3Rpb24gb3JpZW50YXRpb25JbmRleEZpbHRlciAocGEsIHBiLCBwYykge1xuICB2YXIgZGV0c3VtID0gbnVsbDtcbiAgdmFyIGRldGxlZnQgPSAocGEueCAtIHBjLngpICogKHBiLnkgLSBwYy55KTtcbiAgdmFyIGRldHJpZ2h0ID0gKHBhLnkgLSBwYy55KSAqIChwYi54IC0gcGMueCk7XG4gIHZhciBkZXQgPSBkZXRsZWZ0IC0gZGV0cmlnaHQ7XG4gIGlmIChkZXRsZWZ0ID4gMC4wKSB7XG4gICAgaWYgKGRldHJpZ2h0IDw9IDAuMCkge1xuICAgICAgcmV0dXJuIENHQWxnb3JpdGhtc0RELnNpZ251bShkZXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRldHN1bSA9IGRldGxlZnQgKyBkZXRyaWdodDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGV0bGVmdCA8IDAuMCkge1xuICAgIGlmIChkZXRyaWdodCA+PSAwLjApIHtcbiAgICAgIHJldHVybiBDR0FsZ29yaXRobXNERC5zaWdudW0oZGV0KVxuICAgIH0gZWxzZSB7XG4gICAgICBkZXRzdW0gPSAtZGV0bGVmdCAtIGRldHJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQ0dBbGdvcml0aG1zREQuc2lnbnVtKGRldClcbiAgfVxuICB2YXIgZXJyYm91bmQgPSBDR0FsZ29yaXRobXNERC5EUF9TQUZFX0VQU0lMT04gKiBkZXRzdW07XG4gIGlmIChkZXQgPj0gZXJyYm91bmQgfHwgLWRldCA+PSBlcnJib3VuZCkge1xuICAgIHJldHVybiBDR0FsZ29yaXRobXNERC5zaWdudW0oZGV0KVxuICB9XG4gIHJldHVybiAyXG59O1xuQ0dBbGdvcml0aG1zREQuc2lnbnVtID0gZnVuY3Rpb24gc2lnbnVtICh4KSB7XG4gIGlmICh4ID4gMCkgeyByZXR1cm4gMSB9XG4gIGlmICh4IDwgMCkgeyByZXR1cm4gLTEgfVxuICByZXR1cm4gMFxufTtcbnN0YXRpY0FjY2Vzc29ycyQ2LkRQX1NBRkVfRVBTSUxPTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxZS0xNSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ0dBbGdvcml0aG1zREQsIHN0YXRpY0FjY2Vzc29ycyQ2ICk7XG5cbnZhciBDb29yZGluYXRlU2VxdWVuY2UgPSBmdW5jdGlvbiBDb29yZGluYXRlU2VxdWVuY2UgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkOCA9IHsgWDogeyBjb25maWd1cmFibGU6IHRydWUgfSxZOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFo6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5zdGF0aWNBY2Nlc3NvcnMkOC5YLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQ4LlkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDguWi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkOC5NLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMgfTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuc2V0T3JkaW5hdGUgPSBmdW5jdGlvbiBzZXRPcmRpbmF0ZSAoaW5kZXgsIG9yZGluYXRlSW5kZXgsIHZhbHVlKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldE9yZGluYXRlID0gZnVuY3Rpb24gZ2V0T3JkaW5hdGUgKGluZGV4LCBvcmRpbmF0ZUluZGV4KSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldENvb3JkaW5hdGVDb3B5ID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZUNvcHkgKGkpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYIChpbmRleCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmV4cGFuZEVudmVsb3BlID0gZnVuY3Rpb24gZXhwYW5kRW52ZWxvcGUgKGVudikge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSAoaW5kZXgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS50b0Nvb3JkaW5hdGVBcnJheSA9IGZ1bmN0aW9uIHRvQ29vcmRpbmF0ZUFycmF5ICgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDbG9uYWJsZV1cbn07XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29vcmRpbmF0ZVNlcXVlbmNlLCBzdGF0aWNBY2Nlc3NvcnMkOCApO1xuXG52YXIgRXhjZXB0aW9uID0gZnVuY3Rpb24gRXhjZXB0aW9uICgpIHt9O1xuXG52YXIgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoRXhjZXB0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24gKCkge1xuICAgIEV4Y2VwdGlvbiQkMS5jYWxsKHRoaXMsICdQcm9qZWN0aXZlIHBvaW50IG5vdCByZXByZXNlbnRhYmxlIG9uIHRoZSBDYXJ0ZXNpYW4gcGxhbmUuJyk7XG4gIH1cblxuICBpZiAoIEV4Y2VwdGlvbiQkMSApIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24uX19wcm90b19fID0gRXhjZXB0aW9uJCQxO1xuICBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEV4Y2VwdGlvbiQkMSAmJiBFeGNlcHRpb24kJDEucHJvdG90eXBlICk7XG4gIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbjtcbiAgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uXG4gIH07XG5cbiAgcmV0dXJuIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb247XG59KEV4Y2VwdGlvbikpO1xuXG52YXIgU3lzdGVtID0gZnVuY3Rpb24gU3lzdGVtICgpIHt9O1xuXG5TeXN0ZW0uYXJyYXljb3B5ID0gZnVuY3Rpb24gYXJyYXljb3B5IChzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcywgbGVuKSB7XG4gIHZhciBjID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BvczsgaSA8IHNyY1BvcyArIGxlbjsgaSsrKSB7XG4gICAgZGVzdFtkZXN0UG9zICsgY10gPSBzcmNbaV07XG4gICAgYysrO1xuICB9XG59O1xuXG5TeXN0ZW0uZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eSAobmFtZSkge1xuICByZXR1cm4ge1xuICAgICdsaW5lLnNlcGFyYXRvcic6ICdcXG4nXG4gIH1bbmFtZV1cbn07XG5cbnZhciBIQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIEhDb29yZGluYXRlICgpIHtcbiAgdGhpcy54ID0gbnVsbDtcbiAgdGhpcy55ID0gbnVsbDtcbiAgdGhpcy53ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnggPSAwLjA7XG4gICAgdGhpcy55ID0gMC4wO1xuICAgIHRoaXMudyA9IDEuMDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy54ID0gcC54O1xuICAgIHRoaXMueSA9IHAueTtcbiAgICB0aGlzLncgPSAxLjA7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIF94ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIF95ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy54ID0gX3g7XG4gICAgICB0aGlzLnkgPSBfeTtcbiAgICAgIHRoaXMudyA9IDEuMDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEhDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEhDb29yZGluYXRlKSB7XG4gICAgICB2YXIgcDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcDIgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLnggPSBwMS55ICogcDIudyAtIHAyLnkgKiBwMS53O1xuICAgICAgdGhpcy55ID0gcDIueCAqIHAxLncgLSBwMS54ICogcDIudztcbiAgICAgIHRoaXMudyA9IHAxLnggKiBwMi55IC0gcDIueCAqIHAxLnk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwMSQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHAyJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLnggPSBwMSQxLnkgLSBwMiQxLnk7XG4gICAgICB0aGlzLnkgPSBwMiQxLnggLSBwMSQxLng7XG4gICAgICB0aGlzLncgPSBwMSQxLnggKiBwMiQxLnkgLSBwMiQxLnggKiBwMSQxLnk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgX3gkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgX3kkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgX3cgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy54ID0gX3gkMTtcbiAgICB0aGlzLnkgPSBfeSQxO1xuICAgIHRoaXMudyA9IF93O1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgcDEkMiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDIkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcTEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHEyID0gYXJndW1lbnRzWzNdO1xuICAgIHZhciBweCA9IHAxJDIueSAtIHAyJDIueTtcbiAgICB2YXIgcHkgPSBwMiQyLnggLSBwMSQyLng7XG4gICAgdmFyIHB3ID0gcDEkMi54ICogcDIkMi55IC0gcDIkMi54ICogcDEkMi55O1xuICAgIHZhciBxeCA9IHExLnkgLSBxMi55O1xuICAgIHZhciBxeSA9IHEyLnggLSBxMS54O1xuICAgIHZhciBxdyA9IHExLnggKiBxMi55IC0gcTIueCAqIHExLnk7XG4gICAgdGhpcy54ID0gcHkgKiBxdyAtIHF5ICogcHc7XG4gICAgdGhpcy55ID0gcXggKiBwdyAtIHB4ICogcXc7XG4gICAgdGhpcy53ID0gcHggKiBxeSAtIHF4ICogcHk7XG4gIH1cbn07XG5IQ29vcmRpbmF0ZS5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkgKCkge1xuICB2YXIgYSA9IHRoaXMueSAvIHRoaXMudztcbiAgaWYgKERvdWJsZS5pc05hTihhKSB8fCBEb3VibGUuaXNJbmZpbml0ZShhKSkge1xuICAgIHRocm93IG5ldyBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uKClcbiAgfVxuICByZXR1cm4gYVxufTtcbkhDb29yZGluYXRlLnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCAoKSB7XG4gIHZhciBhID0gdGhpcy54IC8gdGhpcy53O1xuICBpZiAoRG91YmxlLmlzTmFOKGEpIHx8IERvdWJsZS5pc0luZmluaXRlKGEpKSB7XG4gICAgdGhyb3cgbmV3IE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24oKVxuICB9XG4gIHJldHVybiBhXG59O1xuSENvb3JkaW5hdGUucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgdmFyIHAgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICBwLnggPSB0aGlzLmdldFgoKTtcbiAgcC55ID0gdGhpcy5nZXRZKCk7XG4gIHJldHVybiBwXG59O1xuSENvb3JkaW5hdGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5IQ29vcmRpbmF0ZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBIQ29vcmRpbmF0ZVxufTtcbkhDb29yZGluYXRlLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAocDEsIHAyLCBxMSwgcTIpIHtcbiAgdmFyIHB4ID0gcDEueSAtIHAyLnk7XG4gIHZhciBweSA9IHAyLnggLSBwMS54O1xuICB2YXIgcHcgPSBwMS54ICogcDIueSAtIHAyLnggKiBwMS55O1xuICB2YXIgcXggPSBxMS55IC0gcTIueTtcbiAgdmFyIHF5ID0gcTIueCAtIHExLng7XG4gIHZhciBxdyA9IHExLnggKiBxMi55IC0gcTIueCAqIHExLnk7XG4gIHZhciB4ID0gcHkgKiBxdyAtIHF5ICogcHc7XG4gIHZhciB5ID0gcXggKiBwdyAtIHB4ICogcXc7XG4gIHZhciB3ID0gcHggKiBxeSAtIHF4ICogcHk7XG4gIHZhciB4SW50ID0geCAvIHc7XG4gIHZhciB5SW50ID0geSAvIHc7XG4gIGlmIChEb3VibGUuaXNOYU4oeEludCkgfHwgKERvdWJsZS5pc0luZmluaXRlKHhJbnQpIHx8IERvdWJsZS5pc05hTih5SW50KSkgfHwgRG91YmxlLmlzSW5maW5pdGUoeUludCkpIHtcbiAgICB0aHJvdyBuZXcgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbigpXG4gIH1cbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHhJbnQsIHlJbnQpXG59O1xuXG52YXIgRW52ZWxvcGUgPSBmdW5jdGlvbiBFbnZlbG9wZSAoKSB7XG4gIHRoaXMuX21pbnggPSBudWxsO1xuICB0aGlzLl9tYXh4ID0gbnVsbDtcbiAgdGhpcy5fbWlueSA9IG51bGw7XG4gIHRoaXMuX21heHkgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQocC54LCBwLngsIHAueSwgcC55KTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVudmVsb3BlKSB7XG4gICAgICB2YXIgZW52ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KGVudik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAyID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuaW5pdChwMS54LCBwMi54LCBwMS55LCBwMi55KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHgxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB4MiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgeTEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHkyID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuaW5pdCh4MSwgeDIsIHkxLCB5Mik7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkOSA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuRW52ZWxvcGUucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiBnZXRBcmVhICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSAqIHRoaXMuZ2V0SGVpZ2h0KClcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIEVudmVsb3BlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBvdGhlckVudmVsb3BlID0gb3RoZXI7XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7XG4gICAgcmV0dXJuIG90aGVyRW52ZWxvcGUuaXNOdWxsKClcbiAgfVxuICByZXR1cm4gdGhpcy5fbWF4eCA9PT0gb3RoZXJFbnZlbG9wZS5nZXRNYXhYKCkgJiYgdGhpcy5fbWF4eSA9PT0gb3RoZXJFbnZlbG9wZS5nZXRNYXhZKCkgJiYgdGhpcy5fbWlueCA9PT0gb3RoZXJFbnZlbG9wZS5nZXRNaW5YKCkgJiYgdGhpcy5fbWlueSA9PT0gb3RoZXJFbnZlbG9wZS5nZXRNaW5ZKClcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChlbnYpIHtcbiAgaWYgKHRoaXMuaXNOdWxsKCkgfHwgZW52LmlzTnVsbCgpIHx8ICF0aGlzLmludGVyc2VjdHMoZW52KSkgeyByZXR1cm4gbmV3IEVudmVsb3BlKCkgfVxuICB2YXIgaW50TWluWCA9IHRoaXMuX21pbnggPiBlbnYuX21pbnggPyB0aGlzLl9taW54IDogZW52Ll9taW54O1xuICB2YXIgaW50TWluWSA9IHRoaXMuX21pbnkgPiBlbnYuX21pbnkgPyB0aGlzLl9taW55IDogZW52Ll9taW55O1xuICB2YXIgaW50TWF4WCA9IHRoaXMuX21heHggPCBlbnYuX21heHggPyB0aGlzLl9tYXh4IDogZW52Ll9tYXh4O1xuICB2YXIgaW50TWF4WSA9IHRoaXMuX21heHkgPCBlbnYuX21heHkgPyB0aGlzLl9tYXh5IDogZW52Ll9tYXh5O1xuICByZXR1cm4gbmV3IEVudmVsb3BlKGludE1pblgsIGludE1heFgsIGludE1pblksIGludE1heFkpXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmlzTnVsbCA9IGZ1bmN0aW9uIGlzTnVsbCAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXh4IDwgdGhpcy5fbWlueFxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRNYXhYID0gZnVuY3Rpb24gZ2V0TWF4WCAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXh4XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmNvdmVycyA9IGZ1bmN0aW9uIGNvdmVycyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY292ZXJzKHAueCwgcC55KVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRW52ZWxvcGUpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICh0aGlzLmlzTnVsbCgpIHx8IG90aGVyLmlzTnVsbCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIG90aGVyLmdldE1pblgoKSA+PSB0aGlzLl9taW54ICYmIG90aGVyLmdldE1heFgoKSA8PSB0aGlzLl9tYXh4ICYmIG90aGVyLmdldE1pblkoKSA+PSB0aGlzLl9taW55ICYmIG90aGVyLmdldE1heFkoKSA8PSB0aGlzLl9tYXh5XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5pc051bGwoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiB4ID49IHRoaXMuX21pbnggJiYgeCA8PSB0aGlzLl9tYXh4ICYmIHkgPj0gdGhpcy5fbWlueSAmJiB5IDw9IHRoaXMuX21heHlcbiAgfVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVudmVsb3BlKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAodGhpcy5pc051bGwoKSB8fCBvdGhlci5pc051bGwoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiAhKG90aGVyLl9taW54ID4gdGhpcy5fbWF4eCB8fCBvdGhlci5fbWF4eCA8IHRoaXMuX21pbnggfHwgb3RoZXIuX21pbnkgPiB0aGlzLl9tYXh5IHx8IG90aGVyLl9tYXh5IDwgdGhpcy5fbWlueSlcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0cyhwLngsIHAueSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLmlzTnVsbCgpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuICEoeCA+IHRoaXMuX21heHggfHwgeCA8IHRoaXMuX21pbnggfHwgeSA+IHRoaXMuX21heHkgfHwgeSA8IHRoaXMuX21pbnkpXG4gIH1cbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0TWluWSA9IGZ1bmN0aW9uIGdldE1pblkgKCkge1xuICByZXR1cm4gdGhpcy5fbWlueVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRNaW5YID0gZnVuY3Rpb24gZ2V0TWluWCAoKSB7XG4gIHJldHVybiB0aGlzLl9taW54XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmV4cGFuZFRvSW5jbHVkZSA9IGZ1bmN0aW9uIGV4cGFuZFRvSW5jbHVkZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5leHBhbmRUb0luY2x1ZGUocC54LCBwLnkpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRW52ZWxvcGUpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmIChvdGhlci5pc051bGwoKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICAgICAgdGhpcy5fbWlueCA9IG90aGVyLmdldE1pblgoKTtcbiAgICAgICAgdGhpcy5fbWF4eCA9IG90aGVyLmdldE1heFgoKTtcbiAgICAgICAgdGhpcy5fbWlueSA9IG90aGVyLmdldE1pblkoKTtcbiAgICAgICAgdGhpcy5fbWF4eSA9IG90aGVyLmdldE1heFkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvdGhlci5fbWlueCA8IHRoaXMuX21pbngpIHtcbiAgICAgICAgICB0aGlzLl9taW54ID0gb3RoZXIuX21pbng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyLl9tYXh4ID4gdGhpcy5fbWF4eCkge1xuICAgICAgICAgIHRoaXMuX21heHggPSBvdGhlci5fbWF4eDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIuX21pbnkgPCB0aGlzLl9taW55KSB7XG4gICAgICAgICAgdGhpcy5fbWlueSA9IG90aGVyLl9taW55O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci5fbWF4eSA+IHRoaXMuX21heHkpIHtcbiAgICAgICAgICB0aGlzLl9tYXh5ID0gb3RoZXIuX21heHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLmlzTnVsbCgpKSB7XG4gICAgICB0aGlzLl9taW54ID0geDtcbiAgICAgIHRoaXMuX21heHggPSB4O1xuICAgICAgdGhpcy5fbWlueSA9IHk7XG4gICAgICB0aGlzLl9tYXh5ID0geTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHggPCB0aGlzLl9taW54KSB7XG4gICAgICAgIHRoaXMuX21pbnggPSB4O1xuICAgICAgfVxuICAgICAgaWYgKHggPiB0aGlzLl9tYXh4KSB7XG4gICAgICAgIHRoaXMuX21heHggPSB4O1xuICAgICAgfVxuICAgICAgaWYgKHkgPCB0aGlzLl9taW55KSB7XG4gICAgICAgIHRoaXMuX21pbnkgPSB5O1xuICAgICAgfVxuICAgICAgaWYgKHkgPiB0aGlzLl9tYXh5KSB7XG4gICAgICAgIHRoaXMuX21heHkgPSB5O1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5taW5FeHRlbnQgPSBmdW5jdGlvbiBtaW5FeHRlbnQgKCkge1xuICBpZiAodGhpcy5pc051bGwoKSkgeyByZXR1cm4gMC4wIH1cbiAgdmFyIHcgPSB0aGlzLmdldFdpZHRoKCk7XG4gIHZhciBoID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgaWYgKHcgPCBoKSB7IHJldHVybiB3IH1cbiAgcmV0dXJuIGhcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiBnZXRXaWR0aCAoKSB7XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICByZXR1cm4gdGhpcy5fbWF4eCAtIHRoaXMuX21pbnhcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIHZhciBlbnYgPSBvO1xuICBpZiAodGhpcy5pc051bGwoKSkge1xuICAgIGlmIChlbnYuaXNOdWxsKCkpIHsgcmV0dXJuIDAgfVxuICAgIHJldHVybiAtMVxuICB9IGVsc2Uge1xuICAgIGlmIChlbnYuaXNOdWxsKCkpIHsgcmV0dXJuIDEgfVxuICB9XG4gIGlmICh0aGlzLl9taW54IDwgZW52Ll9taW54KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9taW54ID4gZW52Ll9taW54KSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX21pbnkgPCBlbnYuX21pbnkpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX21pbnkgPiBlbnYuX21pbnkpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fbWF4eCA8IGVudi5fbWF4eCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5fbWF4eCA+IGVudi5fbWF4eCkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl9tYXh5IDwgZW52Ll9tYXh5KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9tYXh5ID4gZW52Ll9tYXh5KSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlICh0cmFuc1gsIHRyYW5zWSkge1xuICBpZiAodGhpcy5pc051bGwoKSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdGhpcy5pbml0KHRoaXMuZ2V0TWluWCgpICsgdHJhbnNYLCB0aGlzLmdldE1heFgoKSArIHRyYW5zWCwgdGhpcy5nZXRNaW5ZKCkgKyB0cmFuc1ksIHRoaXMuZ2V0TWF4WSgpICsgdHJhbnNZKTtcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiAnRW52WycgKyB0aGlzLl9taW54ICsgJyA6ICcgKyB0aGlzLl9tYXh4ICsgJywgJyArIHRoaXMuX21pbnkgKyAnIDogJyArIHRoaXMuX21heHkgKyAnXSdcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuc2V0VG9OdWxsID0gZnVuY3Rpb24gc2V0VG9OdWxsICgpIHtcbiAgdGhpcy5fbWlueCA9IDA7XG4gIHRoaXMuX21heHggPSAtMTtcbiAgdGhpcy5fbWlueSA9IDA7XG4gIHRoaXMuX21heHkgPSAtMTtcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SGVpZ2h0ICgpIHtcbiAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIHJldHVybiB0aGlzLl9tYXh5IC0gdGhpcy5fbWlueVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5tYXhFeHRlbnQgPSBmdW5jdGlvbiBtYXhFeHRlbnQgKCkge1xuICBpZiAodGhpcy5pc051bGwoKSkgeyByZXR1cm4gMC4wIH1cbiAgdmFyIHcgPSB0aGlzLmdldFdpZHRoKCk7XG4gIHZhciBoID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgaWYgKHcgPiBoKSB7IHJldHVybiB3IH1cbiAgcmV0dXJuIGhcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZXhwYW5kQnkgPSBmdW5jdGlvbiBleHBhbmRCeSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuZXhwYW5kQnkoZGlzdGFuY2UsIGRpc3RhbmNlKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGRlbHRhWCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZGVsdGFZID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLmlzTnVsbCgpKSB7IHJldHVybiBudWxsIH1cbiAgICB0aGlzLl9taW54IC09IGRlbHRhWDtcbiAgICB0aGlzLl9tYXh4ICs9IGRlbHRhWDtcbiAgICB0aGlzLl9taW55IC09IGRlbHRhWTtcbiAgICB0aGlzLl9tYXh5ICs9IGRlbHRhWTtcbiAgICBpZiAodGhpcy5fbWlueCA+IHRoaXMuX21heHggfHwgdGhpcy5fbWlueSA+IHRoaXMuX21heHkpIHsgdGhpcy5zZXRUb051bGwoKTsgfVxuICB9XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBFbnZlbG9wZSkge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY292ZXJzKG90aGVyKVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jb3ZlcnMocClcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiB0aGlzLmNvdmVycyh4LCB5KVxuICB9XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmNlbnRyZSA9IGZ1bmN0aW9uIGNlbnRyZSAoKSB7XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7IHJldHVybiBudWxsIH1cbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKCh0aGlzLmdldE1pblgoKSArIHRoaXMuZ2V0TWF4WCgpKSAvIDIuMCwgKHRoaXMuZ2V0TWluWSgpICsgdGhpcy5nZXRNYXhZKCkpIC8gMi4wKVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5zZXRUb051bGwoKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KHAueCwgcC54LCBwLnksIHAueSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBFbnZlbG9wZSkge1xuICAgICAgdmFyIGVudiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuX21pbnggPSBlbnYuX21pbng7XG4gICAgICB0aGlzLl9tYXh4ID0gZW52Ll9tYXh4O1xuICAgICAgdGhpcy5fbWlueSA9IGVudi5fbWlueTtcbiAgICAgIHRoaXMuX21heHkgPSBlbnYuX21heHk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAyID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuaW5pdChwMS54LCBwMi54LCBwMS55LCBwMi55KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHgxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB4MiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgeTEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHkyID0gYXJndW1lbnRzWzNdO1xuICAgIGlmICh4MSA8IHgyKSB7XG4gICAgICB0aGlzLl9taW54ID0geDE7XG4gICAgICB0aGlzLl9tYXh4ID0geDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21pbnggPSB4MjtcbiAgICAgIHRoaXMuX21heHggPSB4MTtcbiAgICB9XG4gICAgaWYgKHkxIDwgeTIpIHtcbiAgICAgIHRoaXMuX21pbnkgPSB5MTtcbiAgICAgIHRoaXMuX21heHkgPSB5MjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWlueSA9IHkyO1xuICAgICAgdGhpcy5fbWF4eSA9IHkxO1xuICAgIH1cbiAgfVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRNYXhZID0gZnVuY3Rpb24gZ2V0TWF4WSAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXh5XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKGVudikge1xuICBpZiAodGhpcy5pbnRlcnNlY3RzKGVudikpIHsgcmV0dXJuIDAgfVxuICB2YXIgZHggPSAwLjA7XG4gIGlmICh0aGlzLl9tYXh4IDwgZW52Ll9taW54KSB7IGR4ID0gZW52Ll9taW54IC0gdGhpcy5fbWF4eDsgfSBlbHNlIGlmICh0aGlzLl9taW54ID4gZW52Ll9tYXh4KSB7IGR4ID0gdGhpcy5fbWlueCAtIGVudi5fbWF4eDsgfVxuICB2YXIgZHkgPSAwLjA7XG4gIGlmICh0aGlzLl9tYXh5IDwgZW52Ll9taW55KSB7IGR5ID0gZW52Ll9taW55IC0gdGhpcy5fbWF4eTsgfSBlbHNlIGlmICh0aGlzLl9taW55ID4gZW52Ll9tYXh5KSB7IGR5ID0gdGhpcy5fbWlueSAtIGVudi5fbWF4eTsgfVxuICBpZiAoZHggPT09IDAuMCkgeyByZXR1cm4gZHkgfVxuICBpZiAoZHkgPT09IDAuMCkgeyByZXR1cm4gZHggfVxuICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlICgpIHtcbiAgdmFyIHJlc3VsdCA9IDE3O1xuICByZXN1bHQgPSAzNyAqIHJlc3VsdCArIENvb3JkaW5hdGUuaGFzaENvZGUodGhpcy5fbWlueCk7XG4gIHJlc3VsdCA9IDM3ICogcmVzdWx0ICsgQ29vcmRpbmF0ZS5oYXNoQ29kZSh0aGlzLl9tYXh4KTtcbiAgcmVzdWx0ID0gMzcgKiByZXN1bHQgKyBDb29yZGluYXRlLmhhc2hDb2RlKHRoaXMuX21pbnkpO1xuICByZXN1bHQgPSAzNyAqIHJlc3VsdCArIENvb3JkaW5hdGUuaGFzaENvZGUodGhpcy5fbWF4eSk7XG4gIHJldHVybiByZXN1bHRcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZSwgU2VyaWFsaXphYmxlXVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVudmVsb3BlXG59O1xuRW52ZWxvcGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDIgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHEgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKHEueCA+PSAocDEueCA8IHAyLnggPyBwMS54IDogcDIueCkgJiYgcS54IDw9IChwMS54ID4gcDIueCA/IHAxLnggOiBwMi54KSAmJiAocS55ID49IChwMS55IDwgcDIueSA/IHAxLnkgOiBwMi55KSAmJiBxLnkgPD0gKHAxLnkgPiBwMi55ID8gcDEueSA6IHAyLnkpKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBwMSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMiQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBxMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgcTIgPSBhcmd1bWVudHNbM107XG4gICAgdmFyIG1pbnEgPSBNYXRoLm1pbihxMS54LCBxMi54KTtcbiAgICB2YXIgbWF4cSA9IE1hdGgubWF4KHExLngsIHEyLngpO1xuICAgIHZhciBtaW5wID0gTWF0aC5taW4ocDEkMS54LCBwMiQxLngpO1xuICAgIHZhciBtYXhwID0gTWF0aC5tYXgocDEkMS54LCBwMiQxLngpO1xuICAgIGlmIChtaW5wID4gbWF4cSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChtYXhwIDwgbWlucSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIG1pbnEgPSBNYXRoLm1pbihxMS55LCBxMi55KTtcbiAgICBtYXhxID0gTWF0aC5tYXgocTEueSwgcTIueSk7XG4gICAgbWlucCA9IE1hdGgubWluKHAxJDEueSwgcDIkMS55KTtcbiAgICBtYXhwID0gTWF0aC5tYXgocDEkMS55LCBwMiQxLnkpO1xuICAgIGlmIChtaW5wID4gbWF4cSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChtYXhwIDwgbWlucSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5zdGF0aWNBY2Nlc3NvcnMkOS5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDU4NzM5MjE4ODUyNzMxMDI0MjAgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEVudmVsb3BlLCBzdGF0aWNBY2Nlc3NvcnMkOSApO1xuXG52YXIgcmVnRXhlcyA9IHtcbiAgJ3R5cGVTdHInOiAvXlxccyooXFx3KylcXHMqXFwoXFxzKiguKilcXHMqXFwpXFxzKiQvLFxuICAnZW1wdHlUeXBlU3RyJzogL15cXHMqKFxcdyspXFxzKkVNUFRZXFxzKiQvLFxuICAnc3BhY2VzJzogL1xccysvLFxuICAncGFyZW5Db21tYSc6IC9cXClcXHMqLFxccypcXCgvLFxuICAnZG91YmxlUGFyZW5Db21tYSc6IC9cXClcXHMqXFwpXFxzKixcXHMqXFwoXFxzKlxcKC8sIC8vIGNhbid0IHVzZSB7Mn0gaGVyZVxuICAndHJpbVBhcmVucyc6IC9eXFxzKlxcKD8oLio/KVxcKT9cXHMqJC9cbn07XG5cbi8qKlxuICogQ2xhc3MgZm9yIHJlYWRpbmcgYW5kIHdyaXRpbmcgV2VsbC1Lbm93biBUZXh0LlxuICpcbiAqIE5PVEU6IEFkYXB0ZWQgZnJvbSBPcGVuTGF5ZXJzIDIuMTEgaW1wbGVtZW50YXRpb24uXG4gKi9cblxuLyoqIENyZWF0ZSBhIG5ldyBwYXJzZXIgZm9yIFdLVFxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnlGYWN0b3J5fSBnZW9tZXRyeUZhY3RvcnlcbiAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgV0tUUGFyc2VyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgV0tUUGFyc2VyID0gZnVuY3Rpb24gV0tUUGFyc2VyIChnZW9tZXRyeUZhY3RvcnkpIHtcbiAgdGhpcy5nZW9tZXRyeUZhY3RvcnkgPSBnZW9tZXRyeUZhY3RvcnkgfHwgbmV3IEdlb21ldHJ5RmFjdG9yeSgpO1xufTtcbi8qKlxuICogRGVzZXJpYWxpemUgYSBXS1Qgc3RyaW5nIGFuZCByZXR1cm4gYSBnZW9tZXRyeS4gU3VwcG9ydHMgV0tUIGZvciBQT0lOVCxcbiAqIE1VTFRJUE9JTlQsIExJTkVTVFJJTkcsIExJTkVBUlJJTkcsIE1VTFRJTElORVNUUklORywgUE9MWUdPTiwgTVVMVElQT0xZR09OLFxuICogYW5kIEdFT01FVFJZQ09MTEVDVElPTi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gd2t0IEEgV0tUIHN0cmluZy5cbiAqIEByZXR1cm4ge0dlb21ldHJ5fSBBIGdlb21ldHJ5IGluc3RhbmNlLlxuICogQHByaXZhdGVcbiAqL1xuV0tUUGFyc2VyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gcmVhZCAod2t0KSB7XG4gIHZhciBnZW9tZXRyeSwgdHlwZSwgc3RyO1xuICB3a3QgPSB3a3QucmVwbGFjZSgvW1xcblxccl0vZywgJyAnKTtcbiAgdmFyIG1hdGNoZXMgPSByZWdFeGVzLnR5cGVTdHIuZXhlYyh3a3QpO1xuICBpZiAod2t0LnNlYXJjaCgnRU1QVFknKSAhPT0gLTEpIHtcbiAgICBtYXRjaGVzID0gcmVnRXhlcy5lbXB0eVR5cGVTdHIuZXhlYyh3a3QpO1xuICAgIG1hdGNoZXNbMl0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICB0eXBlID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgIHN0ciA9IG1hdGNoZXNbMl07XG4gICAgaWYgKHBhcnNlJDFbdHlwZV0pIHtcbiAgICAgIGdlb21ldHJ5ID0gcGFyc2UkMVt0eXBlXS5hcHBseSh0aGlzLCBbc3RyXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGdlb21ldHJ5ID09PSB1bmRlZmluZWQpIHsgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgV0tUICcgKyB3a3QpIH1cblxuICByZXR1cm4gZ2VvbWV0cnlcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGEgZ2VvbWV0cnkgaW50byBhIFdLVCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgQSBmZWF0dXJlIG9yIGFycmF5IG9mIGZlYXR1cmVzLlxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgV0tUIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW5wdXQgZ2VvbWV0cmllcy5cbiAqIEBwcml2YXRlXG4gKi9cbldLVFBhcnNlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoZ2VvbWV0cnkpIHtcbiAgcmV0dXJuIHRoaXMuZXh0cmFjdEdlb21ldHJ5KGdlb21ldHJ5KVxufTtcblxuLyoqXG4gKiBFbnRyeSBwb2ludCB0byBjb25zdHJ1Y3QgdGhlIFdLVCBmb3IgYSBzaW5nbGUgR2VvbWV0cnkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5XG4gKiBAcmV0dXJuIHtTdHJpbmd9IEEgV0tUIHN0cmluZyBvZiByZXByZXNlbnRpbmcgdGhlIGdlb21ldHJ5LlxuICogQHByaXZhdGVcbiAqL1xuV0tUUGFyc2VyLnByb3RvdHlwZS5leHRyYWN0R2VvbWV0cnkgPSBmdW5jdGlvbiBleHRyYWN0R2VvbWV0cnkgKGdlb21ldHJ5KSB7XG4gIHZhciB0eXBlID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cnlUeXBlKCkudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCFleHRyYWN0JDFbdHlwZV0pIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZhciB3a3RUeXBlID0gdHlwZS50b1VwcGVyQ2FzZSgpO1xuICB2YXIgZGF0YTtcbiAgaWYgKGdlb21ldHJ5LmlzRW1wdHkoKSkge1xuICAgIGRhdGEgPSB3a3RUeXBlICsgJyBFTVBUWSc7XG4gIH0gZWxzZSB7XG4gICAgZGF0YSA9IHdrdFR5cGUgKyAnKCcgKyBleHRyYWN0JDFbdHlwZV0uYXBwbHkodGhpcywgW2dlb21ldHJ5XSkgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn07XG5cbi8qKlxuICogT2JqZWN0IHdpdGggcHJvcGVydGllcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnZW9tZXRyeSB0eXBlcy4gUHJvcGVydHkgdmFsdWVzXG4gKiBhcmUgZnVuY3Rpb25zIHRoYXQgZG8gdGhlIGFjdHVhbCBkYXRhIGV4dHJhY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXh0cmFjdCQxID0ge1xuICBjb29yZGluYXRlOiBmdW5jdGlvbiBjb29yZGluYXRlIChjb29yZGluYXRlJDEpIHtcbiAgICByZXR1cm4gY29vcmRpbmF0ZSQxLnggKyAnICcgKyBjb29yZGluYXRlJDEueVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBzcGFjZSBkZWxpbWl0ZWQgc3RyaW5nIG9mIHBvaW50IGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvaW50fVxuICAgKiAgICAgICAgICBwb2ludFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIG9mIGNvb3JkaW5hdGVzIHJlcHJlc2VudGluZyB0aGUgcG9pbnQuXG4gICAqL1xuICBwb2ludDogZnVuY3Rpb24gcG9pbnQgKHBvaW50JDEpIHtcbiAgICByZXR1cm4gZXh0cmFjdCQxLmNvb3JkaW5hdGUuY2FsbCh0aGlzLCBwb2ludCQxLl9jb29yZGluYXRlcy5fY29vcmRpbmF0ZXNbMF0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvbW1hIGRlbGltaXRlZCBzdHJpbmcgb2YgcG9pbnQgY29vcmRpbmF0ZXMgZnJvbSBhIG11bHRpcG9pbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlQb2ludH1cbiAgICogICAgICAgICAgbXVsdGlwb2ludFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIG9mIHBvaW50IGNvb3JkaW5hdGUgc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlXG4gICAqICAgICAgICAgbXVsdGlwb2ludC5cbiAgICovXG4gIG11bHRpcG9pbnQ6IGZ1bmN0aW9uIG11bHRpcG9pbnQgKG11bHRpcG9pbnQkMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG11bHRpcG9pbnQkMS5fZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgYXJyYXkucHVzaCgnKCcgKyBleHRyYWN0JDEucG9pbnQuYXBwbHkodGhpcyQxLCBbbXVsdGlwb2ludCQxLl9nZW9tZXRyaWVzW2ldXSkgKyAnKScpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuam9pbignLCcpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvbW1hIGRlbGltaXRlZCBzdHJpbmcgb2YgcG9pbnQgY29vcmRpbmF0ZXMgZnJvbSBhIGxpbmUuXG4gICAqXG4gICAqIEBwYXJhbSB7TGluZVN0cmluZ30gbGluZXN0cmluZ1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEEgc3RyaW5nIG9mIHBvaW50IGNvb3JkaW5hdGUgc3RyaW5ncyByZXByZXNlbnRpbmcgdGhlIGxpbmVzdHJpbmcuXG4gICAqL1xuICBsaW5lc3RyaW5nOiBmdW5jdGlvbiBsaW5lc3RyaW5nIChsaW5lc3RyaW5nJDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lc3RyaW5nJDEuX3BvaW50cy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2goZXh0cmFjdCQxLmNvb3JkaW5hdGUuYXBwbHkodGhpcyQxLCBbbGluZXN0cmluZyQxLl9wb2ludHMuX2Nvb3JkaW5hdGVzW2ldXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuam9pbignLCcpXG4gIH0sXG5cbiAgbGluZWFycmluZzogZnVuY3Rpb24gbGluZWFycmluZyAobGluZWFycmluZyQxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZWFycmluZyQxLl9wb2ludHMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcnJheS5wdXNoKGV4dHJhY3QkMS5jb29yZGluYXRlLmFwcGx5KHRoaXMkMSwgW2xpbmVhcnJpbmckMS5fcG9pbnRzLl9jb29yZGluYXRlc1tpXV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJywnKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nIG9mIGxpbmVzdHJpbmcgc3RyaW5ncyBmcm9tIGFcbiAgICogbXVsdGlsaW5lc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpTGluZVN0cmluZ30gbXVsdGlsaW5lc3RyaW5nXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgb2Ygb2YgbGluZXN0cmluZyBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgbXVsdGlsaW5lc3RyaW5nLlxuICAgKi9cbiAgbXVsdGlsaW5lc3RyaW5nOiBmdW5jdGlvbiBtdWx0aWxpbmVzdHJpbmcgKG11bHRpbGluZXN0cmluZyQxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbXVsdGlsaW5lc3RyaW5nJDEuX2dlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2goJygnICtcbiAgICAgICAgZXh0cmFjdCQxLmxpbmVzdHJpbmcuYXBwbHkodGhpcyQxLCBbbXVsdGlsaW5lc3RyaW5nJDEuX2dlb21ldHJpZXNbaV1dKSArXG4gICAgICAgICcpJyk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5qb2luKCcsJylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgY29tbWEgZGVsaW1pdGVkIHN0cmluZyBvZiBsaW5lYXIgcmluZyBhcnJheXMgZnJvbSBhIHBvbHlnb24uXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seWdvbn0gcG9seWdvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEFuIGFycmF5IG9mIGxpbmVhciByaW5nIGFycmF5cyByZXByZXNlbnRpbmcgdGhlIHBvbHlnb24uXG4gICAqL1xuICBwb2x5Z29uOiBmdW5jdGlvbiBwb2x5Z29uIChwb2x5Z29uJDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGFycmF5LnB1c2goJygnICsgZXh0cmFjdCQxLmxpbmVzdHJpbmcuYXBwbHkodGhpcywgW3BvbHlnb24kMS5fc2hlbGxdKSArICcpJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvbHlnb24kMS5faG9sZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2goJygnICsgZXh0cmFjdCQxLmxpbmVzdHJpbmcuYXBwbHkodGhpcyQxLCBbcG9seWdvbiQxLl9ob2xlc1tpXV0pICsgJyknKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJywnKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgcG9seWdvbiBhcnJheXMgZnJvbSBhIG11bHRpcG9seWdvbi5cbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aVBvbHlnb259IG11bHRpcG9seWdvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEFuIGFycmF5IG9mIHBvbHlnb24gYXJyYXlzIHJlcHJlc2VudGluZyB0aGUgbXVsdGlwb2x5Z29uLlxuICAgKi9cbiAgbXVsdGlwb2x5Z29uOiBmdW5jdGlvbiBtdWx0aXBvbHlnb24gKG11bHRpcG9seWdvbiQxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbXVsdGlwb2x5Z29uJDEuX2dlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2goJygnICsgZXh0cmFjdCQxLnBvbHlnb24uYXBwbHkodGhpcyQxLCBbbXVsdGlwb2x5Z29uJDEuX2dlb21ldHJpZXNbaV1dKSArICcpJyk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5qb2luKCcsJylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBXS1QgcG9ydGlvbiBiZXR3ZWVuICdHRU9NRVRSWUNPTExFQ1RJT04oJyBhbmQgJyknIGZvciBhblxuICAgKiBnZW9tZXRyeWNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7R2VvbWV0cnlDb2xsZWN0aW9ufSBjb2xsZWN0aW9uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gaW50ZXJuYWwgV0tUIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb2xsZWN0aW9uLlxuICAgKi9cbiAgZ2VvbWV0cnljb2xsZWN0aW9uOiBmdW5jdGlvbiBnZW9tZXRyeWNvbGxlY3Rpb24gKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2xsZWN0aW9uLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcnJheS5wdXNoKHRoaXMkMS5leHRyYWN0R2VvbWV0cnkoY29sbGVjdGlvbi5fZ2VvbWV0cmllc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuam9pbignLCcpXG4gIH1cbn07XG5cbi8qKlxuICogT2JqZWN0IHdpdGggcHJvcGVydGllcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnZW9tZXRyeSB0eXBlcy4gUHJvcGVydHkgdmFsdWVzXG4gKiBhcmUgZnVuY3Rpb25zIHRoYXQgZG8gdGhlIGFjdHVhbCBwYXJzaW5nLlxuICogQHByaXZhdGVcbiAqL1xudmFyIHBhcnNlJDEgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm4gcG9pbnQgZ2VvbWV0cnkgZ2l2ZW4gYSBwb2ludCBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBwb2ludC5cbiAgICogQHJldHVybiB7UG9pbnR9IEEgcG9pbnQgZ2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwb2ludDogZnVuY3Rpb24gcG9pbnQgKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KClcbiAgICB9XG5cbiAgICB2YXIgY29vcmRzID0gc3RyLnRyaW0oKS5zcGxpdChyZWdFeGVzLnNwYWNlcyk7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KG5ldyBDb29yZGluYXRlKE51bWJlci5wYXJzZUZsb2F0KGNvb3Jkc1swXSksXG4gICAgICBOdW1iZXIucGFyc2VGbG9hdChjb29yZHNbMV0pKSlcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbXVsdGlwb2ludCBnZW9tZXRyeSBnaXZlbiBhIG11bHRpcG9pbnQgV0tUIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIEEgV0tUIGZyYWdtZW50IHJlcHJlc2VudGluZyB0aGUgbXVsdGlwb2ludC5cbiAgICogQHJldHVybiB7UG9pbnR9IEEgbXVsdGlwb2ludCBmZWF0dXJlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbXVsdGlwb2ludDogZnVuY3Rpb24gbXVsdGlwb2ludCAoc3RyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KClcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQ7XG4gICAgdmFyIHBvaW50cyA9IHN0ci50cmltKCkuc3BsaXQoJywnKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldLnJlcGxhY2UocmVnRXhlcy50cmltUGFyZW5zLCAnJDEnKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChwYXJzZSQxLnBvaW50LmFwcGx5KHRoaXMkMSwgW3BvaW50XSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChjb21wb25lbnRzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBsaW5lc3RyaW5nIGdlb21ldHJ5IGdpdmVuIGEgbGluZXN0cmluZyBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBsaW5lc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtMaW5lU3RyaW5nfSBBIGxpbmVzdHJpbmcgZ2VvbWV0cnkuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBsaW5lc3RyaW5nOiBmdW5jdGlvbiBsaW5lc3RyaW5nIChzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKClcbiAgICB9XG5cbiAgICB2YXIgcG9pbnRzID0gc3RyLnRyaW0oKS5zcGxpdCgnLCcpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgdmFyIGNvb3JkcztcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb29yZHMgPSBwb2ludHNbaV0udHJpbSgpLnNwbGl0KHJlZ0V4ZXMuc3BhY2VzKTtcbiAgICAgIGNvbXBvbmVudHMucHVzaChuZXcgQ29vcmRpbmF0ZShOdW1iZXIucGFyc2VGbG9hdChjb29yZHNbMF0pLCBOdW1iZXIucGFyc2VGbG9hdChjb29yZHNbMV0pKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGNvbXBvbmVudHMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGxpbmVhcnJpbmcgZ2VvbWV0cnkgZ2l2ZW4gYSBsaW5lYXJyaW5nIFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIGxpbmVhcnJpbmcuXG4gICAqIEByZXR1cm4ge0xpbmVhclJpbmd9IEEgbGluZWFycmluZyBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGxpbmVhcnJpbmc6IGZ1bmN0aW9uIGxpbmVhcnJpbmcgKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoKVxuICAgIH1cblxuICAgIHZhciBwb2ludHMgPSBzdHIudHJpbSgpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICB2YXIgY29vcmRzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvb3JkcyA9IHBvaW50c1tpXS50cmltKCkuc3BsaXQocmVnRXhlcy5zcGFjZXMpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKG5ldyBDb29yZGluYXRlKE51bWJlci5wYXJzZUZsb2F0KGNvb3Jkc1swXSksIE51bWJlci5wYXJzZUZsb2F0KGNvb3Jkc1sxXSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoY29tcG9uZW50cylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbXVsdGlsaW5lc3RyaW5nIGdlb21ldHJ5IGdpdmVuIGEgbXVsdGlsaW5lc3RyaW5nIFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIG11bHRpbGluZXN0cmluZy5cbiAgICogQHJldHVybiB7TXVsdGlMaW5lU3RyaW5nfSBBIG11bHRpbGluZXN0cmluZyBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG11bHRpbGluZXN0cmluZzogZnVuY3Rpb24gbXVsdGlsaW5lc3RyaW5nIChzdHIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZygpXG4gICAgfVxuXG4gICAgdmFyIGxpbmU7XG4gICAgdmFyIGxpbmVzID0gc3RyLnRyaW0oKS5zcGxpdChyZWdFeGVzLnBhcmVuQ29tbWEpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBsaW5lID0gbGluZXNbaV0ucmVwbGFjZShyZWdFeGVzLnRyaW1QYXJlbnMsICckMScpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKHBhcnNlJDEubGluZXN0cmluZy5hcHBseSh0aGlzJDEsIFtsaW5lXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGNvbXBvbmVudHMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHBvbHlnb24gZ2VvbWV0cnkgZ2l2ZW4gYSBwb2x5Z29uIFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIHBvbHlnb24uXG4gICAqIEByZXR1cm4ge1BvbHlnb259IEEgcG9seWdvbiBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBvbHlnb246IGZ1bmN0aW9uIHBvbHlnb24gKHN0cikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbigpXG4gICAgfVxuXG4gICAgdmFyIHJpbmcsIGxpbmVzdHJpbmcsIGxpbmVhcnJpbmc7XG4gICAgdmFyIHJpbmdzID0gc3RyLnRyaW0oKS5zcGxpdChyZWdFeGVzLnBhcmVuQ29tbWEpO1xuICAgIHZhciBzaGVsbDtcbiAgICB2YXIgaG9sZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmluZ3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHJpbmcgPSByaW5nc1tpXS5yZXBsYWNlKHJlZ0V4ZXMudHJpbVBhcmVucywgJyQxJyk7XG4gICAgICBsaW5lc3RyaW5nID0gcGFyc2UkMS5saW5lc3RyaW5nLmFwcGx5KHRoaXMkMSwgW3JpbmddKTtcbiAgICAgIGxpbmVhcnJpbmcgPSB0aGlzJDEuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobGluZXN0cmluZy5fcG9pbnRzKTtcbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHNoZWxsID0gbGluZWFycmluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvbGVzLnB1c2gobGluZWFycmluZyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKHNoZWxsLCBob2xlcylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbXVsdGlwb2x5Z29uIGdlb21ldHJ5IGdpdmVuIGEgbXVsdGlwb2x5Z29uIFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIG11bHRpcG9seWdvbi5cbiAgICogQHJldHVybiB7TXVsdGlQb2x5Z29ufSBBIG11bHRpcG9seWdvbiBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIG11bHRpcG9seWdvbjogZnVuY3Rpb24gbXVsdGlwb2x5Z29uIChzdHIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbigpXG4gICAgfVxuXG4gICAgdmFyIHBvbHlnb247XG4gICAgdmFyIHBvbHlnb25zID0gc3RyLnRyaW0oKS5zcGxpdChyZWdFeGVzLmRvdWJsZVBhcmVuQ29tbWEpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvbHlnb25zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBwb2x5Z29uID0gcG9seWdvbnNbaV0ucmVwbGFjZShyZWdFeGVzLnRyaW1QYXJlbnMsICckMScpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKHBhcnNlJDEucG9seWdvbi5hcHBseSh0aGlzJDEsIFtwb2x5Z29uXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGNvbXBvbmVudHMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGdlb21ldHJ5Y29sbGVjdGlvbiBnaXZlbiBhIGdlb21ldHJ5Y29sbGVjdGlvbiBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBnZW9tZXRyeWNvbGxlY3Rpb24uXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5Q29sbGVjdGlvbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdlb21ldHJ5Y29sbGVjdGlvbjogZnVuY3Rpb24gZ2VvbWV0cnljb2xsZWN0aW9uIChzdHIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpXG4gICAgfVxuXG4gICAgLy8gc2VwYXJhdGUgY29tcG9uZW50cyBvZiB0aGUgY29sbGVjdGlvbiB3aXRoIHxcbiAgICBzdHIgPSBzdHIucmVwbGFjZSgvLFxccyooW0EtWmEtel0pL2csICd8JDEnKTtcbiAgICB2YXIgd2t0QXJyYXkgPSBzdHIudHJpbSgpLnNwbGl0KCd8Jyk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gd2t0QXJyYXkubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaCh0aGlzJDEucmVhZCh3a3RBcnJheVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGNvbXBvbmVudHMpXG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHRoZSBXZWxsLUtub3duIFRleHQgcmVwcmVzZW50YXRpb24gb2YgYSB7QGxpbmsgR2VvbWV0cnl9LiBUaGVcbiAqIFdlbGwtS25vd24gVGV4dCBmb3JtYXQgaXMgZGVmaW5lZCBpbiB0aGUgPEFcbiAqIEhSRUY9XCJodHRwOi8vd3d3Lm9wZW5naXMub3JnL3RlY2huby9zcGVjcy5odG1cIj4gT0dDIFNpbXBsZSBGZWF0dXJlc1xuICogU3BlY2lmaWNhdGlvbiBmb3IgU1FMPC9BPi5cbiAqIDxwPlxuICogVGhlIDxjb2RlPldLVFdyaXRlcjwvY29kZT4gb3V0cHV0cyBjb29yZGluYXRlcyByb3VuZGVkIHRvIHRoZSBwcmVjaXNpb25cbiAqIG1vZGVsLiBPbmx5IHRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZVxuICogb3JkaW5hdGVzIHRvIHRoZSByZXF1aXJlZCBwcmVjaXNpb24gd2lsbCBiZSBvdXRwdXQuXG4gKiA8cD5cbiAqIFRoZSBTRlMgV0tUIHNwZWMgZG9lcyBub3QgZGVmaW5lIGEgc3BlY2lhbCB0YWcgZm9yIHtAbGluayBMaW5lYXJSaW5nfXMuXG4gKiBVbmRlciB0aGUgc3BlYywgcmluZ3MgYXJlIG91dHB1dCBhcyA8Y29kZT5MSU5FU1RSSU5HPC9jb2RlPnMuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0dlb21ldHJ5RmFjdG9yeX0gZ2VvbWV0cnlGYWN0b3J5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFdLVFdyaXRlciA9IGZ1bmN0aW9uIFdLVFdyaXRlciAoZ2VvbWV0cnlGYWN0b3J5KSB7XG4gIHRoaXMucGFyc2VyID0gbmV3IFdLVFBhcnNlcihnZW9tZXRyeUZhY3RvcnkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIDxjb2RlPkdlb21ldHJ5PC9jb2RlPiB0byBpdHMgV2VsbC1rbm93biBUZXh0IHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnl9IGdlb21ldHJ5IGEgPGNvZGU+R2VvbWV0cnk8L2NvZGU+IHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGEgPEdlb21ldHJ5IFRhZ2dlZCBUZXh0PiBzdHJpbmcgKHNlZSB0aGUgT3BlbkdJUyBTaW1wbGVcbiAqICAgICAgIEZlYXR1cmVzIFNwZWNpZmljYXRpb24pLlxuICogQG1lbWJlcm9mIFdLVFdyaXRlclxuICovXG5XS1RXcml0ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKGdlb21ldHJ5KSB7XG4gIHJldHVybiB0aGlzLnBhcnNlci53cml0ZShnZW9tZXRyeSlcbn07XG4vKipcbiAqIEdlbmVyYXRlcyB0aGUgV0tUIGZvciBhIDx0dD5MSU5FU1RSSU5HPC90dD4gc3BlY2lmaWVkIGJ5IHR3b1xuICoge0BsaW5rIENvb3JkaW5hdGV9cy5cbiAqXG4gKiBAcGFyYW0gcDAgdGhlIGZpcnN0IGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0gcDEgdGhlIHNlY29uZCBjb29yZGluYXRlLlxuICpcbiAqIEByZXR1cm4gdGhlIFdLVC5cbiAqIEBwcml2YXRlXG4gKi9cbldLVFdyaXRlci50b0xpbmVTdHJpbmcgPSBmdW5jdGlvbiB0b0xpbmVTdHJpbmcgKHAwLCBwMSkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMikge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJylcbiAgfVxuICByZXR1cm4gJ0xJTkVTVFJJTkcgKCAnICsgcDAueCArICcgJyArIHAwLnkgKyAnLCAnICsgcDEueCArICcgJyArIHAxLnkgKyAnICknXG59O1xuXG52YXIgUnVudGltZUV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoRXJyb3IpIHtcbiAgZnVuY3Rpb24gUnVudGltZUV4Y2VwdGlvbiAobWVzc2FnZSkge1xuICAgIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ1J1bnRpbWVFeGNlcHRpb24nO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XG4gIH1cblxuICBpZiAoIEVycm9yICkgUnVudGltZUV4Y2VwdGlvbi5fX3Byb3RvX18gPSBFcnJvcjtcbiAgUnVudGltZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvciAmJiBFcnJvci5wcm90b3R5cGUgKTtcbiAgUnVudGltZUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSdW50aW1lRXhjZXB0aW9uO1xuXG4gIHJldHVybiBSdW50aW1lRXhjZXB0aW9uO1xufShFcnJvcikpO1xuXG52YXIgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChSdW50aW1lRXhjZXB0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbiAoKSB7XG4gICAgUnVudGltZUV4Y2VwdGlvbiQkMS5jYWxsKHRoaXMpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBSdW50aW1lRXhjZXB0aW9uJCQxLmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIFJ1bnRpbWVFeGNlcHRpb24kJDEuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIFJ1bnRpbWVFeGNlcHRpb24kJDEgKSBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24uX19wcm90b19fID0gUnVudGltZUV4Y2VwdGlvbiQkMTtcbiAgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJ1bnRpbWVFeGNlcHRpb24kJDEgJiYgUnVudGltZUV4Y2VwdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbjtcbiAgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uXG4gIH07XG5cbiAgcmV0dXJuIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbjtcbn0oUnVudGltZUV4Y2VwdGlvbikpO1xuXG52YXIgQXNzZXJ0ID0gZnVuY3Rpb24gQXNzZXJ0ICgpIHt9O1xuXG5Bc3NlcnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Bc3NlcnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQXNzZXJ0XG59O1xuQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlID0gZnVuY3Rpb24gc2hvdWxkTmV2ZXJSZWFjaEhlcmUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZShudWxsKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBhcmd1bWVudHNbMF07XG4gICAgdGhyb3cgbmV3IEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbignU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmUnICsgKG1lc3NhZ2UgIT09IG51bGwgPyAnOiAnICsgbWVzc2FnZSA6ICcnKSlcbiAgfVxufTtcbkFzc2VydC5pc1RydWUgPSBmdW5jdGlvbiBpc1RydWUgKCkge1xuICB2YXIgYXNzZXJ0aW9uO1xuICB2YXIgbWVzc2FnZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBhc3NlcnRpb24gPSBhcmd1bWVudHNbMF07XG4gICAgQXNzZXJ0LmlzVHJ1ZShhc3NlcnRpb24sIG51bGwpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBhc3NlcnRpb24gPSBhcmd1bWVudHNbMF07XG4gICAgbWVzc2FnZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoIWFzc2VydGlvbikge1xuICAgICAgaWYgKG1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uKG1lc3NhZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuQXNzZXJ0LmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoKSB7XG4gIHZhciBleHBlY3RlZFZhbHVlO1xuICB2YXIgYWN0dWFsVmFsdWU7XG4gIHZhciBtZXNzYWdlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGV4cGVjdGVkVmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgYWN0dWFsVmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgQXNzZXJ0LmVxdWFscyhleHBlY3RlZFZhbHVlLCBhY3R1YWxWYWx1ZSwgbnVsbCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGV4cGVjdGVkVmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgYWN0dWFsVmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgbWVzc2FnZSA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoIWFjdHVhbFZhbHVlLmVxdWFscyhleHBlY3RlZFZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbignRXhwZWN0ZWQgJyArIGV4cGVjdGVkVmFsdWUgKyAnIGJ1dCBlbmNvdW50ZXJlZCAnICsgYWN0dWFsVmFsdWUgKyAobWVzc2FnZSAhPT0gbnVsbCA/ICc6ICcgKyBtZXNzYWdlIDogJycpKVxuICAgIH1cbiAgfVxufTtcblxudmFyIExpbmVJbnRlcnNlY3RvciA9IGZ1bmN0aW9uIExpbmVJbnRlcnNlY3RvciAoKSB7XG4gIHRoaXMuX3Jlc3VsdCA9IG51bGw7XG4gIHRoaXMuX2lucHV0TGluZXMgPSBBcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5KDIpOyB9KTtcbiAgdGhpcy5faW50UHQgPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgdGhpcy5faW50TGluZUluZGV4ID0gbnVsbDtcbiAgdGhpcy5faXNQcm9wZXIgPSBudWxsO1xuICB0aGlzLl9wYSA9IG51bGw7XG4gIHRoaXMuX3BiID0gbnVsbDtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBudWxsO1xuICB0aGlzLl9pbnRQdFswXSA9IG5ldyBDb29yZGluYXRlKCk7XG4gIHRoaXMuX2ludFB0WzFdID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgdGhpcy5fcGEgPSB0aGlzLl9pbnRQdFswXTtcbiAgdGhpcy5fcGIgPSB0aGlzLl9pbnRQdFsxXTtcbiAgdGhpcy5fcmVzdWx0ID0gMDtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTAgPSB7IERPTlRfSU5URVJTRUNUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERPX0lOVEVSU0VDVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDT0xMSU5FQVI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTk9fSU5URVJTRUNUSU9OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFBPSU5UX0lOVEVSU0VDVElPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxDT0xMSU5FQVJfSU5URVJTRUNUSU9OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldEluZGV4QWxvbmdTZWdtZW50ID0gZnVuY3Rpb24gZ2V0SW5kZXhBbG9uZ1NlZ21lbnQgKHNlZ21lbnRJbmRleCwgaW50SW5kZXgpIHtcbiAgdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCk7XG4gIHJldHVybiB0aGlzLl9pbnRMaW5lSW5kZXhbc2VnbWVudEluZGV4XVtpbnRJbmRleF1cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldFRvcG9sb2d5U3VtbWFyeSA9IGZ1bmN0aW9uIGdldFRvcG9sb2d5U3VtbWFyeSAoKSB7XG4gIHZhciBjYXRCdWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gIGlmICh0aGlzLmlzRW5kUG9pbnQoKSkgeyBjYXRCdWYuYXBwZW5kKCcgZW5kcG9pbnQnKTsgfVxuICBpZiAodGhpcy5faXNQcm9wZXIpIHsgY2F0QnVmLmFwcGVuZCgnIHByb3BlcicpOyB9XG4gIGlmICh0aGlzLmlzQ29sbGluZWFyKCkpIHsgY2F0QnVmLmFwcGVuZCgnIGNvbGxpbmVhcicpOyB9XG4gIHJldHVybiBjYXRCdWYudG9TdHJpbmcoKVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb24gKHAxLCBwMiwgcDMsIHA0KSB7XG4gIHRoaXMuX2lucHV0TGluZXNbMF1bMF0gPSBwMTtcbiAgdGhpcy5faW5wdXRMaW5lc1swXVsxXSA9IHAyO1xuICB0aGlzLl9pbnB1dExpbmVzWzFdWzBdID0gcDM7XG4gIHRoaXMuX2lucHV0TGluZXNbMV1bMV0gPSBwNDtcbiAgdGhpcy5fcmVzdWx0ID0gdGhpcy5jb21wdXRlSW50ZXJzZWN0KHAxLCBwMiwgcDMsIHA0KTtcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldEludGVyc2VjdGlvbk51bSA9IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbk51bSAoKSB7XG4gIHJldHVybiB0aGlzLl9yZXN1bHRcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbXB1dGVJbnRMaW5lSW5kZXggPSBmdW5jdGlvbiBjb21wdXRlSW50TGluZUluZGV4ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAodGhpcy5faW50TGluZUluZGV4ID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9pbnRMaW5lSW5kZXggPSBBcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5KDIpOyB9KTtcbiAgICAgIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgwKTtcbiAgICAgIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgxKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzZWdtZW50SW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGRpc3QwID0gdGhpcy5nZXRFZGdlRGlzdGFuY2Uoc2VnbWVudEluZGV4LCAwKTtcbiAgICB2YXIgZGlzdDEgPSB0aGlzLmdldEVkZ2VEaXN0YW5jZShzZWdtZW50SW5kZXgsIDEpO1xuICAgIGlmIChkaXN0MCA+IGRpc3QxKSB7XG4gICAgICB0aGlzLl9pbnRMaW5lSW5kZXhbc2VnbWVudEluZGV4XVswXSA9IDA7XG4gICAgICB0aGlzLl9pbnRMaW5lSW5kZXhbc2VnbWVudEluZGV4XVsxXSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ludExpbmVJbmRleFtzZWdtZW50SW5kZXhdWzBdID0gMTtcbiAgICAgIHRoaXMuX2ludExpbmVJbmRleFtzZWdtZW50SW5kZXhdWzFdID0gMDtcbiAgICB9XG4gIH1cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmlzUHJvcGVyID0gZnVuY3Rpb24gaXNQcm9wZXIgKCkge1xuICByZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSAmJiB0aGlzLl9pc1Byb3BlclxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuc2V0UHJlY2lzaW9uTW9kZWwgPSBmdW5jdGlvbiBzZXRQcmVjaXNpb25Nb2RlbCAocHJlY2lzaW9uTW9kZWwpIHtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBwcmVjaXNpb25Nb2RlbDtcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpc0ludGVyaW9ySW50ZXJzZWN0aW9uICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmICh0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgaW5wdXRMaW5lSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yZXN1bHQ7IGkrKykge1xuICAgICAgaWYgKCEodGhpcyQxLl9pbnRQdFtpXS5lcXVhbHMyRCh0aGlzJDEuX2lucHV0TGluZXNbaW5wdXRMaW5lSW5kZXhdWzBdKSB8fCB0aGlzJDEuX2ludFB0W2ldLmVxdWFsczJEKHRoaXMkMS5faW5wdXRMaW5lc1tpbnB1dExpbmVJbmRleF1bMV0pKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uIChpbnRJbmRleCkge1xuICByZXR1cm4gdGhpcy5faW50UHRbaW50SW5kZXhdXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pc0VuZFBvaW50ID0gZnVuY3Rpb24gaXNFbmRQb2ludCAoKSB7XG4gIHJldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbigpICYmICF0aGlzLl9pc1Byb3BlclxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaGFzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jlc3VsdCAhPT0gTGluZUludGVyc2VjdG9yLk5PX0lOVEVSU0VDVElPTlxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0RWRnZURpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RWRnZURpc3RhbmNlIChzZWdtZW50SW5kZXgsIGludEluZGV4KSB7XG4gIHZhciBkaXN0ID0gTGluZUludGVyc2VjdG9yLmNvbXB1dGVFZGdlRGlzdGFuY2UodGhpcy5faW50UHRbaW50SW5kZXhdLCB0aGlzLl9pbnB1dExpbmVzW3NlZ21lbnRJbmRleF1bMF0sIHRoaXMuX2lucHV0TGluZXNbc2VnbWVudEluZGV4XVsxXSk7XG4gIHJldHVybiBkaXN0XG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pc0NvbGxpbmVhciA9IGZ1bmN0aW9uIGlzQ29sbGluZWFyICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jlc3VsdCA9PT0gTGluZUludGVyc2VjdG9yLkNPTExJTkVBUl9JTlRFUlNFQ1RJT05cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gV0tUV3JpdGVyLnRvTGluZVN0cmluZyh0aGlzLl9pbnB1dExpbmVzWzBdWzBdLCB0aGlzLl9pbnB1dExpbmVzWzBdWzFdKSArICcgLSAnICsgV0tUV3JpdGVyLnRvTGluZVN0cmluZyh0aGlzLl9pbnB1dExpbmVzWzFdWzBdLCB0aGlzLl9pbnB1dExpbmVzWzFdWzFdKSArIHRoaXMuZ2V0VG9wb2xvZ3lTdW1tYXJ5KClcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldEVuZHBvaW50ID0gZnVuY3Rpb24gZ2V0RW5kcG9pbnQgKHNlZ21lbnRJbmRleCwgcHRJbmRleCkge1xuICByZXR1cm4gdGhpcy5faW5wdXRMaW5lc1tzZWdtZW50SW5kZXhdW3B0SW5kZXhdXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pc0ludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGlzSW50ZXJzZWN0aW9uIChwdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVzdWx0OyBpKyspIHtcbiAgICBpZiAodGhpcyQxLl9pbnRQdFtpXS5lcXVhbHMyRChwdCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW9uQWxvbmdTZWdtZW50ID0gZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uQWxvbmdTZWdtZW50IChzZWdtZW50SW5kZXgsIGludEluZGV4KSB7XG4gIHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgpO1xuICByZXR1cm4gdGhpcy5faW50UHRbdGhpcy5faW50TGluZUluZGV4W3NlZ21lbnRJbmRleF1baW50SW5kZXhdXVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBMaW5lSW50ZXJzZWN0b3Jcbn07XG5MaW5lSW50ZXJzZWN0b3IuY29tcHV0ZUVkZ2VEaXN0YW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVFZGdlRGlzdGFuY2UgKHAsIHAwLCBwMSkge1xuICB2YXIgZHggPSBNYXRoLmFicyhwMS54IC0gcDAueCk7XG4gIHZhciBkeSA9IE1hdGguYWJzKHAxLnkgLSBwMC55KTtcbiAgdmFyIGRpc3QgPSAtMS4wO1xuICBpZiAocC5lcXVhbHMocDApKSB7XG4gICAgZGlzdCA9IDAuMDtcbiAgfSBlbHNlIGlmIChwLmVxdWFscyhwMSkpIHtcbiAgICBpZiAoZHggPiBkeSkgeyBkaXN0ID0gZHg7IH0gZWxzZSB7IGRpc3QgPSBkeTsgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwZHggPSBNYXRoLmFicyhwLnggLSBwMC54KTtcbiAgICB2YXIgcGR5ID0gTWF0aC5hYnMocC55IC0gcDAueSk7XG4gICAgaWYgKGR4ID4gZHkpIHsgZGlzdCA9IHBkeDsgfSBlbHNlIHsgZGlzdCA9IHBkeTsgfVxuICAgIGlmIChkaXN0ID09PSAwLjAgJiYgIXAuZXF1YWxzKHAwKSkge1xuICAgICAgZGlzdCA9IE1hdGgubWF4KHBkeCwgcGR5KTtcbiAgICB9XG4gIH1cbiAgQXNzZXJ0LmlzVHJ1ZSghKGRpc3QgPT09IDAuMCAmJiAhcC5lcXVhbHMocDApKSwgJ0JhZCBkaXN0YW5jZSBjYWxjdWxhdGlvbicpO1xuICByZXR1cm4gZGlzdFxufTtcbkxpbmVJbnRlcnNlY3Rvci5ub25Sb2J1c3RDb21wdXRlRWRnZURpc3RhbmNlID0gZnVuY3Rpb24gbm9uUm9idXN0Q29tcHV0ZUVkZ2VEaXN0YW5jZSAocCwgcDEsIHAyKSB7XG4gIHZhciBkeCA9IHAueCAtIHAxLng7XG4gIHZhciBkeSA9IHAueSAtIHAxLnk7XG4gIHZhciBkaXN0ID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgQXNzZXJ0LmlzVHJ1ZSghKGRpc3QgPT09IDAuMCAmJiAhcC5lcXVhbHMocDEpKSwgJ0ludmFsaWQgZGlzdGFuY2UgY2FsY3VsYXRpb24nKTtcbiAgcmV0dXJuIGRpc3Rcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMTAuRE9OVF9JTlRFUlNFQ1QuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDEwLkRPX0lOVEVSU0VDVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTAuQ09MTElORUFSLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMC5OT19JTlRFUlNFQ1RJT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDEwLlBPSU5UX0lOVEVSU0VDVElPTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTAuQ09MTElORUFSX0lOVEVSU0VDVElPTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMaW5lSW50ZXJzZWN0b3IsIHN0YXRpY0FjY2Vzc29ycyQxMCApO1xuXG52YXIgUm9idXN0TGluZUludGVyc2VjdG9yID0gKGZ1bmN0aW9uIChMaW5lSW50ZXJzZWN0b3IkJDEpIHtcbiAgZnVuY3Rpb24gUm9idXN0TGluZUludGVyc2VjdG9yICgpIHtcbiAgICBMaW5lSW50ZXJzZWN0b3IkJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICggTGluZUludGVyc2VjdG9yJCQxICkgUm9idXN0TGluZUludGVyc2VjdG9yLl9fcHJvdG9fXyA9IExpbmVJbnRlcnNlY3RvciQkMTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVJbnRlcnNlY3RvciQkMSAmJiBMaW5lSW50ZXJzZWN0b3IkJDEucHJvdG90eXBlICk7XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb2J1c3RMaW5lSW50ZXJzZWN0b3I7XG5cbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pc0luU2VnbWVudEVudmVsb3BlcyA9IGZ1bmN0aW9uIGlzSW5TZWdtZW50RW52ZWxvcGVzIChpbnRQdCkge1xuICAgIHZhciBlbnYwID0gbmV3IEVudmVsb3BlKHRoaXMuX2lucHV0TGluZXNbMF1bMF0sIHRoaXMuX2lucHV0TGluZXNbMF1bMV0pO1xuICAgIHZhciBlbnYxID0gbmV3IEVudmVsb3BlKHRoaXMuX2lucHV0TGluZXNbMV1bMF0sIHRoaXMuX2lucHV0TGluZXNbMV1bMV0pO1xuICAgIHJldHVybiBlbnYwLmNvbnRhaW5zKGludFB0KSAmJiBlbnYxLmNvbnRhaW5zKGludFB0KVxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0aW9uICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgcDIgPSBhcmd1bWVudHNbMl07XG4gICAgICB0aGlzLl9pc1Byb3BlciA9IGZhbHNlO1xuICAgICAgaWYgKEVudmVsb3BlLmludGVyc2VjdHMocDEsIHAyLCBwKSkge1xuICAgICAgICBpZiAoQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgocDEsIHAyLCBwKSA9PT0gMCAmJiBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleChwMiwgcDEsIHApID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5faXNQcm9wZXIgPSB0cnVlO1xuICAgICAgICAgIGlmIChwLmVxdWFscyhwMSkgfHwgcC5lcXVhbHMocDIpKSB7XG4gICAgICAgICAgICB0aGlzLl9pc1Byb3BlciA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZXN1bHQgPSBMaW5lSW50ZXJzZWN0b3IkJDEuUE9JTlRfSU5URVJTRUNUSU9OO1xuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc3VsdCA9IExpbmVJbnRlcnNlY3RvciQkMS5OT19JTlRFUlNFQ1RJT047XG4gICAgfSBlbHNlIHsgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5ub3JtYWxpemVUb01pbmltdW0gPSBmdW5jdGlvbiBub3JtYWxpemVUb01pbmltdW0gKG4xLCBuMiwgbjMsIG40LCBub3JtUHQpIHtcbiAgICBub3JtUHQueCA9IHRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKG4xLngsIG4yLngsIG4zLngsIG40LngpO1xuICAgIG5vcm1QdC55ID0gdGhpcy5zbWFsbGVzdEluQWJzVmFsdWUobjEueSwgbjIueSwgbjMueSwgbjQueSk7XG4gICAgbjEueCAtPSBub3JtUHQueDtcbiAgICBuMS55IC09IG5vcm1QdC55O1xuICAgIG4yLnggLT0gbm9ybVB0Lng7XG4gICAgbjIueSAtPSBub3JtUHQueTtcbiAgICBuMy54IC09IG5vcm1QdC54O1xuICAgIG4zLnkgLT0gbm9ybVB0Lnk7XG4gICAgbjQueCAtPSBub3JtUHQueDtcbiAgICBuNC55IC09IG5vcm1QdC55O1xuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLnNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIHNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbiAocDEsIHAyLCBxMSwgcTIpIHtcbiAgICB2YXIgaW50UHQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBpbnRQdCA9IEhDb29yZGluYXRlLmludGVyc2VjdGlvbihwMSwgcDIsIHExLCBxMik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uKSB7XG4gICAgICAgIGludFB0ID0gUm9idXN0TGluZUludGVyc2VjdG9yLm5lYXJlc3RFbmRwb2ludChwMSwgcDIsIHExLCBxMik7XG4gICAgICB9IGVsc2UgeyB0aHJvdyBlIH1cbiAgICB9IGZpbmFsbHkge31cbiAgICByZXR1cm4gaW50UHRcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24gKHAxLCBwMiwgcTEsIHEyKSB7XG4gICAgdmFyIGludFB0ID0gdGhpcy5pbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbihwMSwgcDIsIHExLCBxMik7XG4gICAgaWYgKCF0aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKGludFB0KSkge1xuICAgICAgaW50UHQgPSBuZXcgQ29vcmRpbmF0ZShSb2J1c3RMaW5lSW50ZXJzZWN0b3IubmVhcmVzdEVuZHBvaW50KHAxLCBwMiwgcTEsIHEyKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wcmVjaXNpb25Nb2RlbCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fcHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoaW50UHQpO1xuICAgIH1cbiAgICByZXR1cm4gaW50UHRcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5zbWFsbGVzdEluQWJzVmFsdWUgPSBmdW5jdGlvbiBzbWFsbGVzdEluQWJzVmFsdWUgKHgxLCB4MiwgeDMsIHg0KSB7XG4gICAgdmFyIHggPSB4MTtcbiAgICB2YXIgeGFicyA9IE1hdGguYWJzKHgpO1xuICAgIGlmIChNYXRoLmFicyh4MikgPCB4YWJzKSB7XG4gICAgICB4ID0geDI7XG4gICAgICB4YWJzID0gTWF0aC5hYnMoeDIpO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoeDMpIDwgeGFicykge1xuICAgICAgeCA9IHgzO1xuICAgICAgeGFicyA9IE1hdGguYWJzKHgzKTtcbiAgICB9XG4gICAgaWYgKE1hdGguYWJzKHg0KSA8IHhhYnMpIHtcbiAgICAgIHggPSB4NDtcbiAgICB9XG4gICAgcmV0dXJuIHhcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jaGVja0REID0gZnVuY3Rpb24gY2hlY2tERCAocDEsIHAyLCBxMSwgcTIsIGludFB0KSB7XG4gICAgdmFyIGludFB0REQgPSBDR0FsZ29yaXRobXNERC5pbnRlcnNlY3Rpb24ocDEsIHAyLCBxMSwgcTIpO1xuICAgIHZhciBpc0luID0gdGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhpbnRQdEREKTtcbiAgICBTeXN0ZW0ub3V0LnByaW50bG4oJ0REIGluIGVudiA9ICcgKyBpc0luICsgJyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tICcgKyBpbnRQdEREKTtcbiAgICBpZiAoaW50UHQuZGlzdGFuY2UoaW50UHRERCkgPiAwLjAwMDEpIHtcbiAgICAgIFN5c3RlbS5vdXQucHJpbnRsbignRGlzdGFuY2UgPSAnICsgaW50UHQuZGlzdGFuY2UoaW50UHRERCkpO1xuICAgIH1cbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pbnRlcnNlY3Rpb25XaXRoTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uIChwMSwgcDIsIHExLCBxMikge1xuICAgIHZhciBuMSA9IG5ldyBDb29yZGluYXRlKHAxKTtcbiAgICB2YXIgbjIgPSBuZXcgQ29vcmRpbmF0ZShwMik7XG4gICAgdmFyIG4zID0gbmV3IENvb3JkaW5hdGUocTEpO1xuICAgIHZhciBuNCA9IG5ldyBDb29yZGluYXRlKHEyKTtcbiAgICB2YXIgbm9ybVB0ID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB0aGlzLm5vcm1hbGl6ZVRvRW52Q2VudHJlKG4xLCBuMiwgbjMsIG40LCBub3JtUHQpO1xuICAgIHZhciBpbnRQdCA9IHRoaXMuc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uKG4xLCBuMiwgbjMsIG40KTtcbiAgICBpbnRQdC54ICs9IG5vcm1QdC54O1xuICAgIGludFB0LnkgKz0gbm9ybVB0Lnk7XG4gICAgcmV0dXJuIGludFB0XG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24gKHAxLCBwMiwgcTEsIHEyKSB7XG4gICAgdmFyIHAxcTFwMiA9IEVudmVsb3BlLmludGVyc2VjdHMocDEsIHAyLCBxMSk7XG4gICAgdmFyIHAxcTJwMiA9IEVudmVsb3BlLmludGVyc2VjdHMocDEsIHAyLCBxMik7XG4gICAgdmFyIHExcDFxMiA9IEVudmVsb3BlLmludGVyc2VjdHMocTEsIHEyLCBwMSk7XG4gICAgdmFyIHExcDJxMiA9IEVudmVsb3BlLmludGVyc2VjdHMocTEsIHEyLCBwMik7XG4gICAgaWYgKHAxcTFwMiAmJiBwMXEycDIpIHtcbiAgICAgIHRoaXMuX2ludFB0WzBdID0gcTE7XG4gICAgICB0aGlzLl9pbnRQdFsxXSA9IHEyO1xuICAgICAgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIGlmIChxMXAxcTIgJiYgcTFwMnEyKSB7XG4gICAgICB0aGlzLl9pbnRQdFswXSA9IHAxO1xuICAgICAgdGhpcy5faW50UHRbMV0gPSBwMjtcbiAgICAgIHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEuQ09MTElORUFSX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICBpZiAocDFxMXAyICYmIHExcDFxMikge1xuICAgICAgdGhpcy5faW50UHRbMF0gPSBxMTtcbiAgICAgIHRoaXMuX2ludFB0WzFdID0gcDE7XG4gICAgICByZXR1cm4gcTEuZXF1YWxzKHAxKSAmJiAhcDFxMnAyICYmICFxMXAycTIgPyBMaW5lSW50ZXJzZWN0b3IkJDEuUE9JTlRfSU5URVJTRUNUSU9OIDogTGluZUludGVyc2VjdG9yJCQxLkNPTExJTkVBUl9JTlRFUlNFQ1RJT05cbiAgICB9XG4gICAgaWYgKHAxcTFwMiAmJiBxMXAycTIpIHtcbiAgICAgIHRoaXMuX2ludFB0WzBdID0gcTE7XG4gICAgICB0aGlzLl9pbnRQdFsxXSA9IHAyO1xuICAgICAgcmV0dXJuIHExLmVxdWFscyhwMikgJiYgIXAxcTJwMiAmJiAhcTFwMXEyID8gTGluZUludGVyc2VjdG9yJCQxLlBPSU5UX0lOVEVSU0VDVElPTiA6IExpbmVJbnRlcnNlY3RvciQkMS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIGlmIChwMXEycDIgJiYgcTFwMXEyKSB7XG4gICAgICB0aGlzLl9pbnRQdFswXSA9IHEyO1xuICAgICAgdGhpcy5faW50UHRbMV0gPSBwMTtcbiAgICAgIHJldHVybiBxMi5lcXVhbHMocDEpICYmICFwMXExcDIgJiYgIXExcDJxMiA/IExpbmVJbnRlcnNlY3RvciQkMS5QT0lOVF9JTlRFUlNFQ1RJT04gOiBMaW5lSW50ZXJzZWN0b3IkJDEuQ09MTElORUFSX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICBpZiAocDFxMnAyICYmIHExcDJxMikge1xuICAgICAgdGhpcy5faW50UHRbMF0gPSBxMjtcbiAgICAgIHRoaXMuX2ludFB0WzFdID0gcDI7XG4gICAgICByZXR1cm4gcTIuZXF1YWxzKHAyKSAmJiAhcDFxMXAyICYmICFxMXAxcTIgPyBMaW5lSW50ZXJzZWN0b3IkJDEuUE9JTlRfSU5URVJTRUNUSU9OIDogTGluZUludGVyc2VjdG9yJCQxLkNPTExJTkVBUl9JTlRFUlNFQ1RJT05cbiAgICB9XG4gICAgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5OT19JTlRFUlNFQ1RJT05cbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5ub3JtYWxpemVUb0VudkNlbnRyZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVRvRW52Q2VudHJlIChuMDAsIG4wMSwgbjEwLCBuMTEsIG5vcm1QdCkge1xuICAgIHZhciBtaW5YMCA9IG4wMC54IDwgbjAxLnggPyBuMDAueCA6IG4wMS54O1xuICAgIHZhciBtaW5ZMCA9IG4wMC55IDwgbjAxLnkgPyBuMDAueSA6IG4wMS55O1xuICAgIHZhciBtYXhYMCA9IG4wMC54ID4gbjAxLnggPyBuMDAueCA6IG4wMS54O1xuICAgIHZhciBtYXhZMCA9IG4wMC55ID4gbjAxLnkgPyBuMDAueSA6IG4wMS55O1xuICAgIHZhciBtaW5YMSA9IG4xMC54IDwgbjExLnggPyBuMTAueCA6IG4xMS54O1xuICAgIHZhciBtaW5ZMSA9IG4xMC55IDwgbjExLnkgPyBuMTAueSA6IG4xMS55O1xuICAgIHZhciBtYXhYMSA9IG4xMC54ID4gbjExLnggPyBuMTAueCA6IG4xMS54O1xuICAgIHZhciBtYXhZMSA9IG4xMC55ID4gbjExLnkgPyBuMTAueSA6IG4xMS55O1xuICAgIHZhciBpbnRNaW5YID0gbWluWDAgPiBtaW5YMSA/IG1pblgwIDogbWluWDE7XG4gICAgdmFyIGludE1heFggPSBtYXhYMCA8IG1heFgxID8gbWF4WDAgOiBtYXhYMTtcbiAgICB2YXIgaW50TWluWSA9IG1pblkwID4gbWluWTEgPyBtaW5ZMCA6IG1pblkxO1xuICAgIHZhciBpbnRNYXhZID0gbWF4WTAgPCBtYXhZMSA/IG1heFkwIDogbWF4WTE7XG4gICAgdmFyIGludE1pZFggPSAoaW50TWluWCArIGludE1heFgpIC8gMi4wO1xuICAgIHZhciBpbnRNaWRZID0gKGludE1pblkgKyBpbnRNYXhZKSAvIDIuMDtcbiAgICBub3JtUHQueCA9IGludE1pZFg7XG4gICAgbm9ybVB0LnkgPSBpbnRNaWRZO1xuICAgIG4wMC54IC09IG5vcm1QdC54O1xuICAgIG4wMC55IC09IG5vcm1QdC55O1xuICAgIG4wMS54IC09IG5vcm1QdC54O1xuICAgIG4wMS55IC09IG5vcm1QdC55O1xuICAgIG4xMC54IC09IG5vcm1QdC54O1xuICAgIG4xMC55IC09IG5vcm1QdC55O1xuICAgIG4xMS54IC09IG5vcm1QdC54O1xuICAgIG4xMS55IC09IG5vcm1QdC55O1xuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3QgPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0IChwMSwgcDIsIHExLCBxMikge1xuICAgIHRoaXMuX2lzUHJvcGVyID0gZmFsc2U7XG4gICAgaWYgKCFFbnZlbG9wZS5pbnRlcnNlY3RzKHAxLCBwMiwgcTEsIHEyKSkgeyByZXR1cm4gTGluZUludGVyc2VjdG9yJCQxLk5PX0lOVEVSU0VDVElPTiB9XG4gICAgdmFyIFBxMSA9IENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHAxLCBwMiwgcTEpO1xuICAgIHZhciBQcTIgPSBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleChwMSwgcDIsIHEyKTtcbiAgICBpZiAoKFBxMSA+IDAgJiYgUHEyID4gMCkgfHwgKFBxMSA8IDAgJiYgUHEyIDwgMCkpIHtcbiAgICAgIHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEuTk9fSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIHZhciBRcDEgPSBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleChxMSwgcTIsIHAxKTtcbiAgICB2YXIgUXAyID0gQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgocTEsIHEyLCBwMik7XG4gICAgaWYgKChRcDEgPiAwICYmIFFwMiA+IDApIHx8IChRcDEgPCAwICYmIFFwMiA8IDApKSB7XG4gICAgICByZXR1cm4gTGluZUludGVyc2VjdG9yJCQxLk5PX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICB2YXIgY29sbGluZWFyID0gUHExID09PSAwICYmIFBxMiA9PT0gMCAmJiBRcDEgPT09IDAgJiYgUXAyID09PSAwO1xuICAgIGlmIChjb2xsaW5lYXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb24ocDEsIHAyLCBxMSwgcTIpXG4gICAgfVxuICAgIGlmIChQcTEgPT09IDAgfHwgUHEyID09PSAwIHx8IFFwMSA9PT0gMCB8fCBRcDIgPT09IDApIHtcbiAgICAgIHRoaXMuX2lzUHJvcGVyID0gZmFsc2U7XG4gICAgICBpZiAocDEuZXF1YWxzMkQocTEpIHx8IHAxLmVxdWFsczJEKHEyKSkge1xuICAgICAgICB0aGlzLl9pbnRQdFswXSA9IHAxO1xuICAgICAgfSBlbHNlIGlmIChwMi5lcXVhbHMyRChxMSkgfHwgcDIuZXF1YWxzMkQocTIpKSB7XG4gICAgICAgIHRoaXMuX2ludFB0WzBdID0gcDI7XG4gICAgICB9IGVsc2UgaWYgKFBxMSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9pbnRQdFswXSA9IG5ldyBDb29yZGluYXRlKHExKTtcbiAgICAgIH0gZWxzZSBpZiAoUHEyID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2ludFB0WzBdID0gbmV3IENvb3JkaW5hdGUocTIpO1xuICAgICAgfSBlbHNlIGlmIChRcDEgPT09IDApIHtcbiAgICAgICAgdGhpcy5faW50UHRbMF0gPSBuZXcgQ29vcmRpbmF0ZShwMSk7XG4gICAgICB9IGVsc2UgaWYgKFFwMiA9PT0gMCkge1xuICAgICAgICB0aGlzLl9pbnRQdFswXSA9IG5ldyBDb29yZGluYXRlKHAyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faXNQcm9wZXIgPSB0cnVlO1xuICAgICAgdGhpcy5faW50UHRbMF0gPSB0aGlzLmludGVyc2VjdGlvbihwMSwgcDIsIHExLCBxMik7XG4gICAgfVxuICAgIHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEuUE9JTlRfSU5URVJTRUNUSU9OXG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFJvYnVzdExpbmVJbnRlcnNlY3RvclxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IubmVhcmVzdEVuZHBvaW50ID0gZnVuY3Rpb24gbmVhcmVzdEVuZHBvaW50IChwMSwgcDIsIHExLCBxMikge1xuICAgIHZhciBuZWFyZXN0UHQgPSBwMTtcbiAgICB2YXIgbWluRGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShwMSwgcTEsIHEyKTtcbiAgICB2YXIgZGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShwMiwgcTEsIHEyKTtcbiAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgbmVhcmVzdFB0ID0gcDI7XG4gICAgfVxuICAgIGRpc3QgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocTEsIHAxLCBwMik7XG4gICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgIG5lYXJlc3RQdCA9IHExO1xuICAgIH1cbiAgICBkaXN0ID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKHEyLCBwMSwgcDIpO1xuICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICBuZWFyZXN0UHQgPSBxMjtcbiAgICB9XG4gICAgcmV0dXJuIG5lYXJlc3RQdFxuICB9O1xuXG4gIHJldHVybiBSb2J1c3RMaW5lSW50ZXJzZWN0b3I7XG59KExpbmVJbnRlcnNlY3RvcikpO1xuXG52YXIgUm9idXN0RGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiBSb2J1c3REZXRlcm1pbmFudCAoKSB7fTtcblxuUm9idXN0RGV0ZXJtaW5hbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Sb2J1c3REZXRlcm1pbmFudC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBSb2J1c3REZXRlcm1pbmFudFxufTtcblJvYnVzdERldGVybWluYW50Lm9yaWVudGF0aW9uSW5kZXggPSBmdW5jdGlvbiBvcmllbnRhdGlvbkluZGV4IChwMSwgcDIsIHEpIHtcbiAgdmFyIGR4MSA9IHAyLnggLSBwMS54O1xuICB2YXIgZHkxID0gcDIueSAtIHAxLnk7XG4gIHZhciBkeDIgPSBxLnggLSBwMi54O1xuICB2YXIgZHkyID0gcS55IC0gcDIueTtcbiAgcmV0dXJuIFJvYnVzdERldGVybWluYW50LnNpZ25PZkRldDJ4MihkeDEsIGR5MSwgZHgyLCBkeTIpXG59O1xuUm9idXN0RGV0ZXJtaW5hbnQuc2lnbk9mRGV0MngyID0gZnVuY3Rpb24gc2lnbk9mRGV0MngyICh4MSwgeTEsIHgyLCB5Mikge1xuICB2YXIgc2lnbiA9IG51bGw7XG4gIHZhciBzd2FwID0gbnVsbDtcbiAgdmFyIGsgPSBudWxsO1xuICBzaWduID0gMTtcbiAgaWYgKHgxID09PSAwLjAgfHwgeTIgPT09IDAuMCkge1xuICAgIGlmICh5MSA9PT0gMC4wIHx8IHgyID09PSAwLjApIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIGlmICh5MSA+IDApIHtcbiAgICAgIGlmICh4MiA+IDApIHtcbiAgICAgICAgcmV0dXJuIC1zaWduXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeDIgPiAwKSB7XG4gICAgICAgIHJldHVybiBzaWduXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHkxID09PSAwLjAgfHwgeDIgPT09IDAuMCkge1xuICAgIGlmICh5MiA+IDApIHtcbiAgICAgIGlmICh4MSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNpZ25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeDEgPiAwKSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZ25cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHkxID4gMC4wKSB7XG4gICAgaWYgKHkyID4gMC4wKSB7XG4gICAgICBpZiAoeTEgPD0geTIpIHtcbiAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduID0gLXNpZ247XG4gICAgICAgIHN3YXAgPSB4MTtcbiAgICAgICAgeDEgPSB4MjtcbiAgICAgICAgeDIgPSBzd2FwO1xuICAgICAgICBzd2FwID0geTE7XG4gICAgICAgIHkxID0geTI7XG4gICAgICAgIHkyID0gc3dhcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHkxIDw9IC15Mikge1xuICAgICAgICBzaWduID0gLXNpZ247XG4gICAgICAgIHgyID0gLXgyO1xuICAgICAgICB5MiA9IC15MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3YXAgPSB4MTtcbiAgICAgICAgeDEgPSAteDI7XG4gICAgICAgIHgyID0gc3dhcDtcbiAgICAgICAgc3dhcCA9IHkxO1xuICAgICAgICB5MSA9IC15MjtcbiAgICAgICAgeTIgPSBzd2FwO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoeTIgPiAwLjApIHtcbiAgICAgIGlmICgteTEgPD0geTIpIHtcbiAgICAgICAgc2lnbiA9IC1zaWduO1xuICAgICAgICB4MSA9IC14MTtcbiAgICAgICAgeTEgPSAteTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2FwID0gLXgxO1xuICAgICAgICB4MSA9IHgyO1xuICAgICAgICB4MiA9IHN3YXA7XG4gICAgICAgIHN3YXAgPSAteTE7XG4gICAgICAgIHkxID0geTI7XG4gICAgICAgIHkyID0gc3dhcDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHkxID49IHkyKSB7XG4gICAgICAgIHgxID0gLXgxO1xuICAgICAgICB5MSA9IC15MTtcbiAgICAgICAgeDIgPSAteDI7XG4gICAgICAgIHkyID0gLXkyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2lnbiA9IC1zaWduO1xuICAgICAgICBzd2FwID0gLXgxO1xuICAgICAgICB4MSA9IC14MjtcbiAgICAgICAgeDIgPSBzd2FwO1xuICAgICAgICBzd2FwID0gLXkxO1xuICAgICAgICB5MSA9IC15MjtcbiAgICAgICAgeTIgPSBzd2FwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoeDEgPiAwLjApIHtcbiAgICBpZiAoeDIgPiAwLjApIHtcbiAgICAgIGlmICh4MSA8PSB4Mikge1xuICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWduXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaWduXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh4MiA+IDAuMCkge1xuICAgICAgcmV0dXJuIC1zaWduXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4MSA+PSB4Mikge1xuICAgICAgICBzaWduID0gLXNpZ247XG4gICAgICAgIHgxID0gLXgxO1xuICAgICAgICB4MiA9IC14MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfVxuICAgIH1cbiAgfVxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGsgPSBNYXRoLmZsb29yKHgyIC8geDEpO1xuICAgIHgyID0geDIgLSBrICogeDE7XG4gICAgeTIgPSB5MiAtIGsgKiB5MTtcbiAgICBpZiAoeTIgPCAwLjApIHtcbiAgICAgIHJldHVybiAtc2lnblxuICAgIH1cbiAgICBpZiAoeTIgPiB5MSkge1xuICAgICAgcmV0dXJuIHNpZ25cbiAgICB9XG4gICAgaWYgKHgxID4geDIgKyB4Mikge1xuICAgICAgaWYgKHkxIDwgeTIgKyB5Mikge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeTEgPiB5MiArIHkyKSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB4MSAtIHgyO1xuICAgICAgICB5MiA9IHkxIC0geTI7XG4gICAgICAgIHNpZ24gPSAtc2lnbjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHkyID09PSAwLjApIHtcbiAgICAgIGlmICh4MiA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHgyID09PSAwLjApIHtcbiAgICAgIHJldHVybiBzaWduXG4gICAgfVxuICAgIGsgPSBNYXRoLmZsb29yKHgxIC8geDIpO1xuICAgIHgxID0geDEgLSBrICogeDI7XG4gICAgeTEgPSB5MSAtIGsgKiB5MjtcbiAgICBpZiAoeTEgPCAwLjApIHtcbiAgICAgIHJldHVybiBzaWduXG4gICAgfVxuICAgIGlmICh5MSA+IHkyKSB7XG4gICAgICByZXR1cm4gLXNpZ25cbiAgICB9XG4gICAgaWYgKHgyID4geDEgKyB4MSkge1xuICAgICAgaWYgKHkyIDwgeTEgKyB5MSkge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHkyID4geTEgKyB5MSkge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDEgPSB4MiAtIHgxO1xuICAgICAgICB5MSA9IHkyIC0geTE7XG4gICAgICAgIHNpZ24gPSAtc2lnbjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHkxID09PSAwLjApIHtcbiAgICAgIGlmICh4MSA9PT0gMC4wKSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoeDEgPT09IDAuMCkge1xuICAgICAgcmV0dXJuIC1zaWduXG4gICAgfVxuICB9XG59O1xuXG52YXIgUmF5Q3Jvc3NpbmdDb3VudGVyID0gZnVuY3Rpb24gUmF5Q3Jvc3NpbmdDb3VudGVyICgpIHtcbiAgdGhpcy5fcCA9IG51bGw7XG4gIHRoaXMuX2Nyb3NzaW5nQ291bnQgPSAwO1xuICB0aGlzLl9pc1BvaW50T25TZWdtZW50ID0gZmFsc2U7XG4gIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9wID0gcDtcbn07XG5SYXlDcm9zc2luZ0NvdW50ZXIucHJvdG90eXBlLmNvdW50U2VnbWVudCA9IGZ1bmN0aW9uIGNvdW50U2VnbWVudCAocDEsIHAyKSB7XG4gIGlmIChwMS54IDwgdGhpcy5fcC54ICYmIHAyLnggPCB0aGlzLl9wLngpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAodGhpcy5fcC54ID09PSBwMi54ICYmIHRoaXMuX3AueSA9PT0gcDIueSkge1xuICAgIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQgPSB0cnVlO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKHAxLnkgPT09IHRoaXMuX3AueSAmJiBwMi55ID09PSB0aGlzLl9wLnkpIHtcbiAgICB2YXIgbWlueCA9IHAxLng7XG4gICAgdmFyIG1heHggPSBwMi54O1xuICAgIGlmIChtaW54ID4gbWF4eCkge1xuICAgICAgbWlueCA9IHAyLng7XG4gICAgICBtYXh4ID0gcDEueDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3AueCA+PSBtaW54ICYmIHRoaXMuX3AueCA8PSBtYXh4KSB7XG4gICAgICB0aGlzLl9pc1BvaW50T25TZWdtZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAoKHAxLnkgPiB0aGlzLl9wLnkgJiYgcDIueSA8PSB0aGlzLl9wLnkpIHx8IChwMi55ID4gdGhpcy5fcC55ICYmIHAxLnkgPD0gdGhpcy5fcC55KSkge1xuICAgIHZhciB4MSA9IHAxLnggLSB0aGlzLl9wLng7XG4gICAgdmFyIHkxID0gcDEueSAtIHRoaXMuX3AueTtcbiAgICB2YXIgeDIgPSBwMi54IC0gdGhpcy5fcC54O1xuICAgIHZhciB5MiA9IHAyLnkgLSB0aGlzLl9wLnk7XG4gICAgdmFyIHhJbnRTaWduID0gUm9idXN0RGV0ZXJtaW5hbnQuc2lnbk9mRGV0MngyKHgxLCB5MSwgeDIsIHkyKTtcbiAgICBpZiAoeEludFNpZ24gPT09IDAuMCkge1xuICAgICAgdGhpcy5faXNQb2ludE9uU2VnbWVudCA9IHRydWU7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBpZiAoeTIgPCB5MSkgeyB4SW50U2lnbiA9IC14SW50U2lnbjsgfVxuICAgIGlmICh4SW50U2lnbiA+IDAuMCkge1xuICAgICAgdGhpcy5fY3Jvc3NpbmdDb3VudCsrO1xuICAgIH1cbiAgfVxufTtcblJheUNyb3NzaW5nQ291bnRlci5wcm90b3R5cGUuaXNQb2ludEluUG9seWdvbiA9IGZ1bmN0aW9uIGlzUG9pbnRJblBvbHlnb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRMb2NhdGlvbigpICE9PSBMb2NhdGlvbi5FWFRFUklPUlxufTtcblJheUNyb3NzaW5nQ291bnRlci5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAoKSB7XG4gIGlmICh0aGlzLl9pc1BvaW50T25TZWdtZW50KSB7IHJldHVybiBMb2NhdGlvbi5CT1VOREFSWSB9XG4gIGlmICh0aGlzLl9jcm9zc2luZ0NvdW50ICUgMiA9PT0gMSkge1xuICAgIHJldHVybiBMb2NhdGlvbi5JTlRFUklPUlxuICB9XG4gIHJldHVybiBMb2NhdGlvbi5FWFRFUklPUlxufTtcblJheUNyb3NzaW5nQ291bnRlci5wcm90b3R5cGUuaXNPblNlZ21lbnQgPSBmdW5jdGlvbiBpc09uU2VnbWVudCAoKSB7XG4gIHJldHVybiB0aGlzLl9pc1BvaW50T25TZWdtZW50XG59O1xuUmF5Q3Jvc3NpbmdDb3VudGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUmF5Q3Jvc3NpbmdDb3VudGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFJheUNyb3NzaW5nQ291bnRlclxufTtcblJheUNyb3NzaW5nQ291bnRlci5sb2NhdGVQb2ludEluUmluZyA9IGZ1bmN0aW9uIGxvY2F0ZVBvaW50SW5SaW5nICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciByaW5nID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBjb3VudGVyID0gbmV3IFJheUNyb3NzaW5nQ291bnRlcihwKTtcbiAgICB2YXIgcDEgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIHZhciBwMiA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCByaW5nLnNpemUoKTsgaSsrKSB7XG4gICAgICByaW5nLmdldENvb3JkaW5hdGUoaSwgcDEpO1xuICAgICAgcmluZy5nZXRDb29yZGluYXRlKGkgLSAxLCBwMik7XG4gICAgICBjb3VudGVyLmNvdW50U2VnbWVudChwMSwgcDIpO1xuICAgICAgaWYgKGNvdW50ZXIuaXNPblNlZ21lbnQoKSkgeyByZXR1cm4gY291bnRlci5nZXRMb2NhdGlvbigpIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvdW50ZXIuZ2V0TG9jYXRpb24oKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgcCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciByaW5nJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGNvdW50ZXIkMSA9IG5ldyBSYXlDcm9zc2luZ0NvdW50ZXIocCQxKTtcbiAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPCByaW5nJDEubGVuZ3RoOyBpJDErKykge1xuICAgICAgdmFyIHAxJDEgPSByaW5nJDFbaSQxXTtcbiAgICAgIHZhciBwMiQxID0gcmluZyQxW2kkMSAtIDFdO1xuICAgICAgY291bnRlciQxLmNvdW50U2VnbWVudChwMSQxLCBwMiQxKTtcbiAgICAgIGlmIChjb3VudGVyJDEuaXNPblNlZ21lbnQoKSkgeyByZXR1cm4gY291bnRlciQxLmdldExvY2F0aW9uKCkgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnRlciQxLmdldExvY2F0aW9uKClcbiAgfVxufTtcblxudmFyIENHQWxnb3JpdGhtcyA9IGZ1bmN0aW9uIENHQWxnb3JpdGhtcyAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzID0geyBDTE9DS1dJU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sUklHSFQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ09VTlRFUkNMT0NLV0lTRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxMRUZUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENPTExJTkVBUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxTVFJBSUdIVDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5DR0FsZ29yaXRobXMucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5DR0FsZ29yaXRobXMucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ0dBbGdvcml0aG1zXG59O1xuQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXggPSBmdW5jdGlvbiBvcmllbnRhdGlvbkluZGV4IChwMSwgcDIsIHEpIHtcbiAgcmV0dXJuIENHQWxnb3JpdGhtc0RELm9yaWVudGF0aW9uSW5kZXgocDEsIHAyLCBxKVxufTtcbkNHQWxnb3JpdGhtcy5zaWduZWRBcmVhID0gZnVuY3Rpb24gc2lnbmVkQXJlYSAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciByaW5nID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChyaW5nLmxlbmd0aCA8IDMpIHsgcmV0dXJuIDAuMCB9XG4gICAgdmFyIHN1bSA9IDAuMDtcbiAgICB2YXIgeDAgPSByaW5nWzBdLng7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCByaW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIHggPSByaW5nW2ldLnggLSB4MDtcbiAgICAgIHZhciB5MSA9IHJpbmdbaSArIDFdLnk7XG4gICAgICB2YXIgeTIgPSByaW5nW2kgLSAxXS55O1xuICAgICAgc3VtICs9IHggKiAoeTIgLSB5MSk7XG4gICAgfVxuICAgIHJldHVybiBzdW0gLyAyLjBcbiAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gICAgdmFyIHJpbmckMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbiA9IHJpbmckMS5zaXplKCk7XG4gICAgaWYgKG4gPCAzKSB7IHJldHVybiAwLjAgfVxuICAgIHZhciBwMCA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgdmFyIHAxID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB2YXIgcDIgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIHJpbmckMS5nZXRDb29yZGluYXRlKDAsIHAxKTtcbiAgICByaW5nJDEuZ2V0Q29vcmRpbmF0ZSgxLCBwMik7XG4gICAgdmFyIHgwJDEgPSBwMS54O1xuICAgIHAyLnggLT0geDAkMTtcbiAgICB2YXIgc3VtJDEgPSAwLjA7XG4gICAgZm9yICh2YXIgaSQxID0gMTsgaSQxIDwgbiAtIDE7IGkkMSsrKSB7XG4gICAgICBwMC55ID0gcDEueTtcbiAgICAgIHAxLnggPSBwMi54O1xuICAgICAgcDEueSA9IHAyLnk7XG4gICAgICByaW5nJDEuZ2V0Q29vcmRpbmF0ZShpJDEgKyAxLCBwMik7XG4gICAgICBwMi54IC09IHgwJDE7XG4gICAgICBzdW0kMSArPSBwMS54ICogKHAwLnkgLSBwMi55KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bSQxIC8gMi4wXG4gIH1cbn07XG5DR0FsZ29yaXRobXMuZGlzdGFuY2VMaW5lTGluZSA9IGZ1bmN0aW9uIGRpc3RhbmNlTGluZUxpbmUgKEEsIEIsIEMsIEQpIHtcbiAgaWYgKEEuZXF1YWxzKEIpKSB7IHJldHVybiBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoQSwgQywgRCkgfVxuICBpZiAoQy5lcXVhbHMoRCkpIHsgcmV0dXJuIENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShELCBBLCBCKSB9XG4gIHZhciBub0ludGVyc2VjdGlvbiA9IGZhbHNlO1xuICBpZiAoIUVudmVsb3BlLmludGVyc2VjdHMoQSwgQiwgQywgRCkpIHtcbiAgICBub0ludGVyc2VjdGlvbiA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbm9tID0gKEIueCAtIEEueCkgKiAoRC55IC0gQy55KSAtIChCLnkgLSBBLnkpICogKEQueCAtIEMueCk7XG4gICAgaWYgKGRlbm9tID09PSAwKSB7XG4gICAgICBub0ludGVyc2VjdGlvbiA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByTnVtYiA9IChBLnkgLSBDLnkpICogKEQueCAtIEMueCkgLSAoQS54IC0gQy54KSAqIChELnkgLSBDLnkpO1xuICAgICAgdmFyIHNOdW0gPSAoQS55IC0gQy55KSAqIChCLnggLSBBLngpIC0gKEEueCAtIEMueCkgKiAoQi55IC0gQS55KTtcbiAgICAgIHZhciBzID0gc051bSAvIGRlbm9tO1xuICAgICAgdmFyIHIgPSByTnVtYiAvIGRlbm9tO1xuICAgICAgaWYgKHIgPCAwIHx8IHIgPiAxIHx8IHMgPCAwIHx8IHMgPiAxKSB7XG4gICAgICAgIG5vSW50ZXJzZWN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5vSW50ZXJzZWN0aW9uKSB7XG4gICAgcmV0dXJuIE1hdGhVdGlsLm1pbihDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoQSwgQywgRCksIENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShCLCBDLCBEKSwgQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKEMsIEEsIEIpLCBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoRCwgQSwgQikpXG4gIH1cbiAgcmV0dXJuIDAuMFxufTtcbkNHQWxnb3JpdGhtcy5pc1BvaW50SW5SaW5nID0gZnVuY3Rpb24gaXNQb2ludEluUmluZyAocCwgcmluZykge1xuICByZXR1cm4gQ0dBbGdvcml0aG1zLmxvY2F0ZVBvaW50SW5SaW5nKHAsIHJpbmcpICE9PSBMb2NhdGlvbi5FWFRFUklPUlxufTtcbkNHQWxnb3JpdGhtcy5jb21wdXRlTGVuZ3RoID0gZnVuY3Rpb24gY29tcHV0ZUxlbmd0aCAocHRzKSB7XG4gIHZhciBuID0gcHRzLnNpemUoKTtcbiAgaWYgKG4gPD0gMSkgeyByZXR1cm4gMC4wIH1cbiAgdmFyIGxlbiA9IDAuMDtcbiAgdmFyIHAgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICBwdHMuZ2V0Q29vcmRpbmF0ZSgwLCBwKTtcbiAgdmFyIHgwID0gcC54O1xuICB2YXIgeTAgPSBwLnk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgcHRzLmdldENvb3JkaW5hdGUoaSwgcCk7XG4gICAgdmFyIHgxID0gcC54O1xuICAgIHZhciB5MSA9IHAueTtcbiAgICB2YXIgZHggPSB4MSAtIHgwO1xuICAgIHZhciBkeSA9IHkxIC0geTA7XG4gICAgbGVuICs9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgeDAgPSB4MTtcbiAgICB5MCA9IHkxO1xuICB9XG4gIHJldHVybiBsZW5cbn07XG5DR0FsZ29yaXRobXMuaXNDQ1cgPSBmdW5jdGlvbiBpc0NDVyAocmluZykge1xuICB2YXIgblB0cyA9IHJpbmcubGVuZ3RoIC0gMTtcbiAgaWYgKG5QdHMgPCAzKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1JpbmcgaGFzIGZld2VyIHRoYW4gNCBwb2ludHMsIHNvIG9yaWVudGF0aW9uIGNhbm5vdCBiZSBkZXRlcm1pbmVkJykgfVxuICB2YXIgaGlQdCA9IHJpbmdbMF07XG4gIHZhciBoaUluZGV4ID0gMDtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gblB0czsgaSsrKSB7XG4gICAgdmFyIHAgPSByaW5nW2ldO1xuICAgIGlmIChwLnkgPiBoaVB0LnkpIHtcbiAgICAgIGhpUHQgPSBwO1xuICAgICAgaGlJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHZhciBpUHJldiA9IGhpSW5kZXg7XG4gIGRvIHtcbiAgICBpUHJldiA9IGlQcmV2IC0gMTtcbiAgICBpZiAoaVByZXYgPCAwKSB7IGlQcmV2ID0gblB0czsgfVxuICB9IHdoaWxlIChyaW5nW2lQcmV2XS5lcXVhbHMyRChoaVB0KSAmJiBpUHJldiAhPT0gaGlJbmRleClcbiAgdmFyIGlOZXh0ID0gaGlJbmRleDtcbiAgZG8ge1xuICAgIGlOZXh0ID0gKGlOZXh0ICsgMSkgJSBuUHRzO1xuICB9IHdoaWxlIChyaW5nW2lOZXh0XS5lcXVhbHMyRChoaVB0KSAmJiBpTmV4dCAhPT0gaGlJbmRleClcbiAgdmFyIHByZXYgPSByaW5nW2lQcmV2XTtcbiAgdmFyIG5leHQgPSByaW5nW2lOZXh0XTtcbiAgaWYgKHByZXYuZXF1YWxzMkQoaGlQdCkgfHwgbmV4dC5lcXVhbHMyRChoaVB0KSB8fCBwcmV2LmVxdWFsczJEKG5leHQpKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBkaXNjID0gQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbihwcmV2LCBoaVB0LCBuZXh0KTtcbiAgdmFyIGlzQ0NXID0gZmFsc2U7XG4gIGlmIChkaXNjID09PSAwKSB7XG4gICAgaXNDQ1cgPSBwcmV2LnggPiBuZXh0Lng7XG4gIH0gZWxzZSB7XG4gICAgaXNDQ1cgPSBkaXNjID4gMDtcbiAgfVxuICByZXR1cm4gaXNDQ1dcbn07XG5DR0FsZ29yaXRobXMubG9jYXRlUG9pbnRJblJpbmcgPSBmdW5jdGlvbiBsb2NhdGVQb2ludEluUmluZyAocCwgcmluZykge1xuICByZXR1cm4gUmF5Q3Jvc3NpbmdDb3VudGVyLmxvY2F0ZVBvaW50SW5SaW5nKHAsIHJpbmcpXG59O1xuQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lUGVycGVuZGljdWxhciA9IGZ1bmN0aW9uIGRpc3RhbmNlUG9pbnRMaW5lUGVycGVuZGljdWxhciAocCwgQSwgQikge1xuICB2YXIgbGVuMiA9IChCLnggLSBBLngpICogKEIueCAtIEEueCkgKyAoQi55IC0gQS55KSAqIChCLnkgLSBBLnkpO1xuICB2YXIgcyA9ICgoQS55IC0gcC55KSAqIChCLnggLSBBLngpIC0gKEEueCAtIHAueCkgKiAoQi55IC0gQS55KSkgLyBsZW4yO1xuICByZXR1cm4gTWF0aC5hYnMocykgKiBNYXRoLnNxcnQobGVuMilcbn07XG5DR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uID0gZnVuY3Rpb24gY29tcHV0ZU9yaWVudGF0aW9uIChwMSwgcDIsIHEpIHtcbiAgcmV0dXJuIENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHAxLCBwMiwgcSlcbn07XG5DR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUgPSBmdW5jdGlvbiBkaXN0YW5jZVBvaW50TGluZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxpbmUgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0xpbmUgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSB2ZXJ0ZXgnKSB9XG4gICAgdmFyIG1pbkRpc3RhbmNlID0gcC5kaXN0YW5jZShsaW5lWzBdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgZGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShwLCBsaW5lW2ldLCBsaW5lW2kgKyAxXSk7XG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbkRpc3RhbmNlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIEEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIEIgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKEEueCA9PT0gQi54ICYmIEEueSA9PT0gQi55KSB7IHJldHVybiBwJDEuZGlzdGFuY2UoQSkgfVxuICAgIHZhciBsZW4yID0gKEIueCAtIEEueCkgKiAoQi54IC0gQS54KSArIChCLnkgLSBBLnkpICogKEIueSAtIEEueSk7XG4gICAgdmFyIHIgPSAoKHAkMS54IC0gQS54KSAqIChCLnggLSBBLngpICsgKHAkMS55IC0gQS55KSAqIChCLnkgLSBBLnkpKSAvIGxlbjI7XG4gICAgaWYgKHIgPD0gMC4wKSB7IHJldHVybiBwJDEuZGlzdGFuY2UoQSkgfVxuICAgIGlmIChyID49IDEuMCkgeyByZXR1cm4gcCQxLmRpc3RhbmNlKEIpIH1cbiAgICB2YXIgcyA9ICgoQS55IC0gcCQxLnkpICogKEIueCAtIEEueCkgLSAoQS54IC0gcCQxLngpICogKEIueSAtIEEueSkpIC8gbGVuMjtcbiAgICByZXR1cm4gTWF0aC5hYnMocykgKiBNYXRoLnNxcnQobGVuMilcbiAgfVxufTtcbkNHQWxnb3JpdGhtcy5pc09uTGluZSA9IGZ1bmN0aW9uIGlzT25MaW5lIChwLCBwdCkge1xuICB2YXIgbGluZUludGVyc2VjdG9yID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IHB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAwID0gcHRbaSAtIDFdO1xuICAgIHZhciBwMSA9IHB0W2ldO1xuICAgIGxpbmVJbnRlcnNlY3Rvci5jb21wdXRlSW50ZXJzZWN0aW9uKHAsIHAwLCBwMSk7XG4gICAgaWYgKGxpbmVJbnRlcnNlY3Rvci5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuc3RhdGljQWNjZXNzb3JzJDMuQ0xPQ0tXSVNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xIH07XG5zdGF0aWNBY2Nlc3NvcnMkMy5SSUdIVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFIH07XG5zdGF0aWNBY2Nlc3NvcnMkMy5DT1VOVEVSQ0xPQ0tXSVNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQzLkxFRlQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ0dBbGdvcml0aG1zLkNPVU5URVJDTE9DS1dJU0UgfTtcbnN0YXRpY0FjY2Vzc29ycyQzLkNPTExJTkVBUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMy5TVFJBSUdIVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ09MTElORUFSIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDR0FsZ29yaXRobXMsIHN0YXRpY0FjY2Vzc29ycyQzICk7XG5cbnZhciBHZW9tZXRyeUNvbXBvbmVudEZpbHRlciA9IGZ1bmN0aW9uIEdlb21ldHJ5Q29tcG9uZW50RmlsdGVyICgpIHt9O1xuXG5HZW9tZXRyeUNvbXBvbmVudEZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnZW9tKSB7fTtcbkdlb21ldHJ5Q29tcG9uZW50RmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlDb21wb25lbnRGaWx0ZXJcbn07XG5cbnZhciBHZW9tZXRyeSA9IGZ1bmN0aW9uIEdlb21ldHJ5ICgpIHtcbiAgdmFyIGZhY3RvcnkgPSBhcmd1bWVudHNbMF07XG5cbiAgdGhpcy5fZW52ZWxvcGUgPSBudWxsO1xuICB0aGlzLl9mYWN0b3J5ID0gbnVsbDtcbiAgdGhpcy5fU1JJRCA9IG51bGw7XG4gIHRoaXMuX3VzZXJEYXRhID0gbnVsbDtcbiAgdGhpcy5fZmFjdG9yeSA9IGZhY3Rvcnk7XG4gIHRoaXMuX1NSSUQgPSBmYWN0b3J5LmdldFNSSUQoKTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTEgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX1BPSU5UOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9NVUxUSVBPSU5UOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9MSU5FU1RSSU5HOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9MSU5FQVJSSU5HOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9NVUxUSUxJTkVTVFJJTkc6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX1BPTFlHT046IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX01VTFRJUE9MWUdPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxTT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGdlb21ldHJ5Q2hhbmdlZEZpbHRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuR2VvbWV0cnkucHJvdG90eXBlLmlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZnVuY3Rpb24gaXNHZW9tZXRyeUNvbGxlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKSA9PT0gR2VvbWV0cnkuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTlxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0RmFjdG9yeSAoKSB7XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldEdlb21ldHJ5TiA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5TiAobikge1xuICByZXR1cm4gdGhpc1xufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gZ2V0QXJlYSAoKSB7XG4gIHJldHVybiAwLjBcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuaXNSZWN0YW5nbGUgPSBmdW5jdGlvbiBpc1JlY3RhbmdsZSAoKSB7XG4gIHJldHVybiBmYWxzZVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkpIHtcbiAgICB2YXIgZyQxID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChnJDEgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gdGhpcy5lcXVhbHNUb3BvKGckMSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICB2YXIgbyA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoIShvIGluc3RhbmNlb2YgR2VvbWV0cnkpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGcgPSBvO1xuICAgIHJldHVybiB0aGlzLmVxdWFsc0V4YWN0KGcpXG4gIH1cbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZXF1YWxzRXhhY3QgPSBmdW5jdGlvbiBlcXVhbHNFeGFjdCAob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMgPT09IG90aGVyIHx8IHRoaXMuZXF1YWxzRXhhY3Qob3RoZXIsIDApXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdlb21ldHJ5Q2hhbmdlZCA9IGZ1bmN0aW9uIGdlb21ldHJ5Q2hhbmdlZCAoKSB7XG4gIHRoaXMuYXBwbHkoR2VvbWV0cnkuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyKTtcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uID0gZnVuY3Rpb24gZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uICgpIHtcbiAgdGhpcy5fZW52ZWxvcGUgPSBudWxsO1xufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5lcXVhbHNOb3JtID0gZnVuY3Rpb24gZXF1YWxzTm9ybSAoZykge1xuICBpZiAoZyA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdGhpcy5ub3JtKCkuZXF1YWxzRXhhY3QoZy5ub3JtKCkpXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gIHJldHVybiAwLjBcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0TnVtR2VvbWV0cmllcyA9IGZ1bmN0aW9uIGdldE51bUdlb21ldHJpZXMgKCkge1xuICByZXR1cm4gMVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBvID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvdGhlciA9IG87XG4gICAgaWYgKHRoaXMuZ2V0U29ydEluZGV4KCkgIT09IG90aGVyLmdldFNvcnRJbmRleCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKSAtIG90aGVyLmdldFNvcnRJbmRleCgpXG4gICAgfVxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSAmJiBvdGhlci5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGlmIChvdGhlci5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhvKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgb3RoZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgY29tcCA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5nZXRTb3J0SW5kZXgoKSAhPT0gb3RoZXIkMS5nZXRTb3J0SW5kZXgoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCkgLSBvdGhlciQxLmdldFNvcnRJbmRleCgpXG4gICAgfVxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSAmJiBvdGhlciQxLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgaWYgKG90aGVyJDEuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21wYXJlVG9TYW1lQ2xhc3Mob3RoZXIkMSwgY29tcClcbiAgfVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRVc2VyRGF0YSA9IGZ1bmN0aW9uIGdldFVzZXJEYXRhICgpIHtcbiAgcmV0dXJuIHRoaXMuX3VzZXJEYXRhXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldFNSSUQgPSBmdW5jdGlvbiBnZXRTUklEICgpIHtcbiAgcmV0dXJuIHRoaXMuX1NSSURcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0RW52ZWxvcGUgPSBmdW5jdGlvbiBnZXRFbnZlbG9wZSAoKSB7XG4gIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS50b0dlb21ldHJ5KHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbiA9IGZ1bmN0aW9uIGNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uIChnKSB7XG4gIGlmIChnLmdldFNvcnRJbmRleCgpID09PSBHZW9tZXRyeS5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBHZW9tZXRyeUNvbGxlY3Rpb24gYXJndW1lbnRzJylcbiAgfVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsIChhLCBiLCB0b2xlcmFuY2UpIHtcbiAgaWYgKHRvbGVyYW5jZSA9PT0gMCkge1xuICAgIHJldHVybiBhLmVxdWFscyhiKVxuICB9XG4gIHJldHVybiBhLmRpc3RhbmNlKGIpIDw9IHRvbGVyYW5jZVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5ub3JtID0gZnVuY3Rpb24gbm9ybSAoKSB7XG4gIHZhciBjb3B5ID0gdGhpcy5jb3B5KCk7XG4gIGNvcHkubm9ybWFsaXplKCk7XG4gIHJldHVybiBjb3B5XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldFByZWNpc2lvbk1vZGVsID0gZnVuY3Rpb24gZ2V0UHJlY2lzaW9uTW9kZWwgKCkge1xuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldEVudmVsb3BlSW50ZXJuYWwgPSBmdW5jdGlvbiBnZXRFbnZlbG9wZUludGVybmFsICgpIHtcbiAgaWYgKHRoaXMuX2VudmVsb3BlID09PSBudWxsKSB7XG4gICAgdGhpcy5fZW52ZWxvcGUgPSB0aGlzLmNvbXB1dGVFbnZlbG9wZUludGVybmFsKCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBFbnZlbG9wZSh0aGlzLl9lbnZlbG9wZSlcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuc2V0U1JJRCA9IGZ1bmN0aW9uIHNldFNSSUQgKFNSSUQpIHtcbiAgdGhpcy5fU1JJRCA9IFNSSUQ7XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLnNldFVzZXJEYXRhID0gZnVuY3Rpb24gc2V0VXNlckRhdGEgKHVzZXJEYXRhKSB7XG4gIHRoaXMuX3VzZXJEYXRhID0gdXNlckRhdGE7XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIHZhciBpID0gYS5pdGVyYXRvcigpO1xuICB2YXIgaiA9IGIuaXRlcmF0b3IoKTtcbiAgd2hpbGUgKGkuaGFzTmV4dCgpICYmIGouaGFzTmV4dCgpKSB7XG4gICAgdmFyIGFFbGVtZW50ID0gaS5uZXh0KCk7XG4gICAgdmFyIGJFbGVtZW50ID0gai5uZXh0KCk7XG4gICAgdmFyIGNvbXBhcmlzb24gPSBhRWxlbWVudC5jb21wYXJlVG8oYkVsZW1lbnQpO1xuICAgIGlmIChjb21wYXJpc29uICE9PSAwKSB7XG4gICAgICByZXR1cm4gY29tcGFyaXNvblxuICAgIH1cbiAgfVxuICBpZiAoaS5oYXNOZXh0KCkpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIGlmIChqLmhhc05leHQoKSkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIHJldHVybiAwXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICByZXR1cm4gdGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuaGFzaENvZGUoKVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5pc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZCA9IGZ1bmN0aW9uIGlzR2VvbWV0cnlDb2xsZWN0aW9uT3JEZXJpdmVkICgpIHtcbiAgaWYgKHRoaXMuZ2V0U29ydEluZGV4KCkgPT09IEdlb21ldHJ5LlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT04gfHwgdGhpcy5nZXRTb3J0SW5kZXgoKSA9PT0gR2VvbWV0cnkuU09SVElOREVYX01VTFRJUE9JTlQgfHwgdGhpcy5nZXRTb3J0SW5kZXgoKSA9PT0gR2VvbWV0cnkuU09SVElOREVYX01VTFRJTElORVNUUklORyB8fCB0aGlzLmdldFNvcnRJbmRleCgpID09PSBHZW9tZXRyeS5TT1JUSU5ERVhfTVVMVElQT0xZR09OKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ2xvbmFibGUsIENvbXBhcmFibGUsIFNlcmlhbGl6YWJsZV1cbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeVxufTtcbkdlb21ldHJ5Lmhhc05vbkVtcHR5RWxlbWVudHMgPSBmdW5jdGlvbiBoYXNOb25FbXB0eUVsZW1lbnRzIChnZW9tZXRyaWVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICghZ2VvbWV0cmllc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkdlb21ldHJ5Lmhhc051bGxFbGVtZW50cyA9IGZ1bmN0aW9uIGhhc051bGxFbGVtZW50cyAoYXJyYXkpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcnJheVtpXSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuc3RhdGljQWNjZXNzb3JzJDExLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gODc2MzYyMjY3OTE4NzM3NjcwMiB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9QT0lOVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX01VTFRJUE9JTlQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9MSU5FU1RSSU5HLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5TT1JUSU5ERVhfTElORUFSUklORy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX01VTFRJTElORVNUUklORy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0IH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX1BPTFlHT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNSB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9NVUxUSVBPTFlHT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNiB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT04uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNyB9O1xuc3RhdGljQWNjZXNzb3JzJDExLmdlb21ldHJ5Q2hhbmdlZEZpbHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnZW9tZXRyeUNoYW5nZWRGaWx0ZXIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEdlb21ldHJ5LCBzdGF0aWNBY2Nlc3NvcnMkMTEgKTtcblxudmFyIGdlb21ldHJ5Q2hhbmdlZEZpbHRlciA9IGZ1bmN0aW9uIGdlb21ldHJ5Q2hhbmdlZEZpbHRlciAoKSB7fTtcblxuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5Q29tcG9uZW50RmlsdGVyXVxufTtcbmdlb21ldHJ5Q2hhbmdlZEZpbHRlci5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGdlb20pIHtcbiAgZ2VvbS5nZW9tZXRyeUNoYW5nZWRBY3Rpb24oKTtcbn07XG5cbnZhciBDb29yZGluYXRlRmlsdGVyID0gZnVuY3Rpb24gQ29vcmRpbmF0ZUZpbHRlciAoKSB7fTtcblxuQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChjb29yZCkge307XG5Db29yZGluYXRlRmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlRmlsdGVyXG59O1xuXG52YXIgQm91bmRhcnlOb2RlUnVsZSA9IGZ1bmN0aW9uIEJvdW5kYXJ5Tm9kZVJ1bGUgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTIgPSB7IE1vZDJCb3VuZGFyeU5vZGVSdWxlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxNdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxNb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1PRDJfQk9VTkRBUllfUlVMRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxFTkRQT0lOVF9CT1VOREFSWV9SVUxFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1VTFRJVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTU9OT1ZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE9HQ19TRlNfQk9VTkRBUllfUlVMRTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5Cb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pc0luQm91bmRhcnkgPSBmdW5jdGlvbiBpc0luQm91bmRhcnkgKGJvdW5kYXJ5Q291bnQpIHt9O1xuQm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQm91bmRhcnlOb2RlUnVsZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5Nb2QyQm91bmRhcnlOb2RlUnVsZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNb2QyQm91bmRhcnlOb2RlUnVsZSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5NdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLk1PRDJfQk9VTkRBUllfUlVMRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUoKSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLkVORFBPSU5UX0JPVU5EQVJZX1JVTEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSgpIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuTVVMVElWQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUoKSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLk1PTk9WQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSgpIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuT0dDX1NGU19CT1VOREFSWV9SVUxFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJvdW5kYXJ5Tm9kZVJ1bGUuTU9EMl9CT1VOREFSWV9SVUxFIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCb3VuZGFyeU5vZGVSdWxlLCBzdGF0aWNBY2Nlc3NvcnMkMTIgKTtcblxudmFyIE1vZDJCb3VuZGFyeU5vZGVSdWxlID0gZnVuY3Rpb24gTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUgKCkge307XG5cbk1vZDJCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pc0luQm91bmRhcnkgPSBmdW5jdGlvbiBpc0luQm91bmRhcnkgKGJvdW5kYXJ5Q291bnQpIHtcbiAgcmV0dXJuIGJvdW5kYXJ5Q291bnQgJSAyID09PSAxXG59O1xuTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0JvdW5kYXJ5Tm9kZVJ1bGVdXG59O1xuTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9kMkJvdW5kYXJ5Tm9kZVJ1bGVcbn07XG5cbnZhciBFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgPSBmdW5jdGlvbiBFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgKCkge307XG5cbkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaXNJbkJvdW5kYXJ5ID0gZnVuY3Rpb24gaXNJbkJvdW5kYXJ5IChib3VuZGFyeUNvdW50KSB7XG4gIHJldHVybiBib3VuZGFyeUNvdW50ID4gMFxufTtcbkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQm91bmRhcnlOb2RlUnVsZV1cbn07XG5FbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlXG59O1xuXG52YXIgTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgPSBmdW5jdGlvbiBNdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSAoKSB7fTtcblxuTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmlzSW5Cb3VuZGFyeSA9IGZ1bmN0aW9uIGlzSW5Cb3VuZGFyeSAoYm91bmRhcnlDb3VudCkge1xuICByZXR1cm4gYm91bmRhcnlDb3VudCA+IDFcbn07XG5NdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQm91bmRhcnlOb2RlUnVsZV1cbn07XG5NdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZVxufTtcblxudmFyIE1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgPSBmdW5jdGlvbiBNb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlICgpIHt9O1xuXG5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pc0luQm91bmRhcnkgPSBmdW5jdGlvbiBpc0luQm91bmRhcnkgKGJvdW5kYXJ5Q291bnQpIHtcbiAgcmV0dXJuIGJvdW5kYXJ5Q291bnQgPT09IDFcbn07XG5Nb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtCb3VuZGFyeU5vZGVSdWxlXVxufTtcbk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZVxufTtcblxuLy8gaW1wb3J0IEl0ZXJhdG9yIGZyb20gJy4vSXRlcmF0b3InXG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvQ29sbGVjdGlvbi5odG1sXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIENvbGxlY3Rpb24gKCkge307XG5cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoKSB7fTtcblxuLyoqXG4gKiBBcHBlbmRzIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gdGhlIHNwZWNpZmllZCBjb2xsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhpc1xuICogbGlzdCwgaW4gdGhlIG9yZGVyIHRoYXQgdGhleSBhcmUgcmV0dXJuZWQgYnkgdGhlIHNwZWNpZmllZCBjb2xsZWN0aW9uJ3NcbiAqIGl0ZXJhdG9yIChvcHRpb25hbCBvcGVyYXRpb24pLlxuICogQHBhcmFtIHtqYXZhc2NyaXB0LnV0aWwuQ29sbGVjdGlvbn0gY1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gYWRkQWxsICgpIHt9O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbGxlY3Rpb24gY29udGFpbnMgbm8gZWxlbWVudHMuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGVsZW1lbnRzIGluIHRoaXMgY29sbGVjdGlvbi5cbiAqIEByZXR1cm4ge2phdmFzY3JpcHQudXRpbC5JdGVyYXRvcn1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGVsZW1lbnRzIGluIHRoaXMgY29sbGVjdGlvbi5cbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge307XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBvZiB0aGUgZWxlbWVudHMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5ICgpIHt9O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgdGhlIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhpcyBjb2xsZWN0aW9uIGlmIGl0XG4gKiBpcyBwcmVzZW50LiAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge09iamVjdH0gZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICgpIHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBPcHRpb25hbCBtZXNzYWdlXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24gKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbn1cbkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5wcm90b3R5cGUubmFtZSA9ICdJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uJztcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9JdGVyYXRvci5odG1sXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJdGVyYXRvciA9IGZ1bmN0aW9uIEl0ZXJhdG9yICgpIHt9O1xuXG5JdGVyYXRvci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uIGhhc05leHQgKCkge307XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmV4dCBlbGVtZW50IGluIHRoZSBpdGVyYXRpb24uXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCAoKSB7fTtcblxuLyoqXG4gKiBSZW1vdmVzIGZyb20gdGhlIHVuZGVybHlpbmcgY29sbGVjdGlvbiB0aGUgbGFzdCBlbGVtZW50IHJldHVybmVkIGJ5IHRoZVxuICogaXRlcmF0b3IgKG9wdGlvbmFsIG9wZXJhdGlvbikuXG4gKi9cbkl0ZXJhdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge307XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvTGlzdC5odG1sXG4gKlxuICogQGV4dGVuZHMge2phdmFzY3JpcHQudXRpbC5Db2xsZWN0aW9ufVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTGlzdCA9IChmdW5jdGlvbiAoQ29sbGVjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBMaXN0ICgpIHtcbiAgICBDb2xsZWN0aW9uJCQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIENvbGxlY3Rpb24kJDEgKSBMaXN0Ll9fcHJvdG9fXyA9IENvbGxlY3Rpb24kJDE7XG4gIExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ29sbGVjdGlvbiQkMSAmJiBDb2xsZWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpc3Q7XG5cbiAgTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHsgfTtcblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBpbiB0aGlzIGxpc3Qgd2l0aCB0aGVcbiAgICogc3BlY2lmaWVkIGVsZW1lbnQgKG9wdGlvbmFsIG9wZXJhdGlvbikuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge09iamVjdH0gZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICBMaXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKCkgeyB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb2xsZWN0aW9uIGNvbnRhaW5zIG5vIGVsZW1lbnRzLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkgeyB9O1xuXG4gIHJldHVybiBMaXN0O1xufShDb2xsZWN0aW9uKSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIE9wdGlvbmFsIG1lc3NhZ2VcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gTm9TdWNoRWxlbWVudEV4Y2VwdGlvbiAobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xufVxuTm9TdWNoRWxlbWVudEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5Ob1N1Y2hFbGVtZW50RXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gJ05vU3VjaEVsZW1lbnRFeGNlcHRpb24nO1xuXG4vLyBpbXBvcnQgT3BlcmF0aW9uTm90U3VwcG9ydGVkIGZyb20gJy4vT3BlcmF0aW9uTm90U3VwcG9ydGVkJ1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL0FycmF5TGlzdC5odG1sXG4gKlxuICogQGV4dGVuZHMgTGlzdFxuICogQHByaXZhdGVcbiAqL1xudmFyIEFycmF5TGlzdCA9IChmdW5jdGlvbiAoTGlzdCQkMSkge1xuICBmdW5jdGlvbiBBcnJheUxpc3QgKCkge1xuICAgIExpc3QkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmFycmF5XyA9IFtdO1xuXG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBMaXN0JCQxICkgQXJyYXlMaXN0Ll9fcHJvdG9fXyA9IExpc3QkJDE7XG4gIEFycmF5TGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaXN0JCQxICYmIExpc3QkJDEucHJvdG90eXBlICk7XG4gIEFycmF5TGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcnJheUxpc3Q7XG5cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eSA9IGZ1bmN0aW9uIGVuc3VyZUNhcGFjaXR5ICgpIHt9O1xuICBBcnJheUxpc3QucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkgeyByZXR1cm4gW0xpc3QkJDEsIENvbGxlY3Rpb25dIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5hcnJheV8ucHVzaChlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcnJheV8uc3BsaWNlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICBBcnJheUxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgIHRoaXMuYXJyYXlfID0gW107XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiBhZGRBbGwgKGMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSBjLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdGhpcyQxLmFkZChpLm5leHQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGluZGV4LCBlbGVtZW50KSB7XG4gICAgdmFyIG9sZEVsZW1lbnQgPSB0aGlzLmFycmF5X1tpbmRleF07XG4gICAgdGhpcy5hcnJheV9baW5kZXhdID0gZWxlbWVudDtcbiAgICByZXR1cm4gb2xkRWxlbWVudFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvcl8odGhpcylcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2l6ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbigpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfW2luZGV4XVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGggPT09IDBcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzJDEuYXJyYXlfW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAobykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzJDEuYXJyYXlfW2ldID09PSBvKSB7XG4gICAgICAgIHRoaXMkMS5hcnJheV8uc3BsaWNlKGksIDEpO1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvdW5kXG4gIH07XG5cbiAgcmV0dXJuIEFycmF5TGlzdDtcbn0oTGlzdCkpO1xuXG4vKipcbiAqIEBleHRlbmRzIHtJdGVyYXRvcn1cbiAqIEBwYXJhbSB7QXJyYXlMaXN0fSBhcnJheUxpc3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIEl0ZXJhdG9yXyA9IChmdW5jdGlvbiAoSXRlcmF0b3IkJDEpIHtcbiAgZnVuY3Rpb24gSXRlcmF0b3JfIChhcnJheUxpc3QpIHtcbiAgICBJdGVyYXRvciQkMS5jYWxsKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheUxpc3R9XG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMuYXJyYXlMaXN0XyA9IGFycmF5TGlzdDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uXyA9IDA7XG4gIH1cblxuICBpZiAoIEl0ZXJhdG9yJCQxICkgSXRlcmF0b3JfLl9fcHJvdG9fXyA9IEl0ZXJhdG9yJCQxO1xuICBJdGVyYXRvcl8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSXRlcmF0b3IkJDEgJiYgSXRlcmF0b3IkJDEucHJvdG90eXBlICk7XG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJdGVyYXRvcl87XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCAoKSB7XG4gICAgaWYgKHRoaXMucG9zaXRpb25fID09PSB0aGlzLmFycmF5TGlzdF8uc2l6ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoRWxlbWVudEV4Y2VwdGlvbigpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFycmF5TGlzdF8uZ2V0KHRoaXMucG9zaXRpb25fKyspXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gaGFzTmV4dCAoKSB7XG4gICAgaWYgKHRoaXMucG9zaXRpb25fIDwgdGhpcy5hcnJheUxpc3RfLnNpemUoKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBUT0RPOiBzaG91bGQgYmUgaW4gTGlzdEl0ZXJhdG9yXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheUxpc3RfLnNldCh0aGlzLnBvc2l0aW9uXyAtIDEsIGVsZW1lbnQpXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgIHRoaXMuYXJyYXlMaXN0Xy5yZW1vdmUodGhpcy5hcnJheUxpc3RfLmdldCh0aGlzLnBvc2l0aW9uXykpO1xuICB9O1xuXG4gIHJldHVybiBJdGVyYXRvcl87XG59KEl0ZXJhdG9yKSk7XG5cbnZhciBDb29yZGluYXRlTGlzdCA9IChmdW5jdGlvbiAoQXJyYXlMaXN0JCQxKSB7XG4gIGZ1bmN0aW9uIENvb3JkaW5hdGVMaXN0ICgpIHtcbiAgICBBcnJheUxpc3QkJDEuY2FsbCh0aGlzKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eShjb29yZC5sZW5ndGgpO1xuICAgICAgdGhpcy5hZGQoY29vcmQsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGNvb3JkJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgYWxsb3dSZXBlYXRlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMuZW5zdXJlQ2FwYWNpdHkoY29vcmQkMS5sZW5ndGgpO1xuICAgICAgdGhpcy5hZGQoY29vcmQkMSwgYWxsb3dSZXBlYXRlZCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBBcnJheUxpc3QkJDEgKSBDb29yZGluYXRlTGlzdC5fX3Byb3RvX18gPSBBcnJheUxpc3QkJDE7XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFycmF5TGlzdCQkMSAmJiBBcnJheUxpc3QkJDEucHJvdG90eXBlICk7XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvb3JkaW5hdGVMaXN0O1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IGNvb3JkQXJyYXlUeXBlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIHN0YXRpY0FjY2Vzc29ycy5jb29yZEFycmF5VHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQXJyYXkoMCkuZmlsbChudWxsKSB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoaSlcbiAgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIGFkZEFsbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGNvbGwgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgYWxsb3dSZXBlYXRlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSBjb2xsLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgICB0aGlzJDEuYWRkKGkubmV4dCgpLCBhbGxvd1JlcGVhdGVkKTtcbiAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0NoYW5nZWRcbiAgICB9IGVsc2UgeyByZXR1cm4gQXJyYXlMaXN0JCQxLnByb3RvdHlwZS5hZGRBbGwuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjbG9uZSA9IEFycmF5TGlzdCQkMS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgIGNsb25lLmFkZChpLCB0aGlzJDEuZ2V0KGkpLmNvcHkoKSk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZVxuICB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUudG9Db29yZGluYXRlQXJyYXkgPSBmdW5jdGlvbiB0b0Nvb3JkaW5hdGVBcnJheSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheShDb29yZGluYXRlTGlzdC5jb29yZEFycmF5VHlwZSlcbiAgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzBdO1xuICAgICAgQXJyYXlMaXN0JCQxLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBjb29yZCk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhciBjb29yZCQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgYWxsb3dSZXBlYXRlZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdGhpcy5hZGQoY29vcmQkMSwgYWxsb3dSZXBlYXRlZCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhciBjb29yZCQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgYWxsb3dSZXBlYXRlZCQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBpZiAoIWFsbG93UmVwZWF0ZWQkMSkge1xuICAgICAgICAgIGlmICh0aGlzLnNpemUoKSA+PSAxKSB7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMuZ2V0KHRoaXMuc2l6ZSgpIC0gMSk7XG4gICAgICAgICAgICBpZiAobGFzdC5lcXVhbHMyRChjb29yZCQyKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEFycmF5TGlzdCQkMS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgY29vcmQkMik7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdmFyIG9iaiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGFsbG93UmVwZWF0ZWQkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdGhpcy5hZGQob2JqLCBhbGxvd1JlcGVhdGVkJDIpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdib29sZWFuJyAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICB2YXIgY29vcmQkMyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGFsbG93UmVwZWF0ZWQkMyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNvb3JkJDMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgdGhpcyQxLmFkZChjb29yZCQzW2kkMV0sIGFsbG93UmVwZWF0ZWQkMyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGkkMiA9IGNvb3JkJDMubGVuZ3RoIC0gMTsgaSQyID49IDA7IGkkMi0tKSB7XG4gICAgICAgICAgICB0aGlzJDEuYWRkKGNvb3JkJDNbaSQyXSwgYWxsb3dSZXBlYXRlZCQzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Jvb2xlYW4nICYmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICAgICAgdmFyIGkkMyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGNvb3JkJDQgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBhbGxvd1JlcGVhdGVkJDQgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIGlmICghYWxsb3dSZXBlYXRlZCQ0KSB7XG4gICAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNpemUoKTtcbiAgICAgICAgICBpZiAoc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGlmIChpJDMgPiAwKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5nZXQoaSQzIC0gMSk7XG4gICAgICAgICAgICAgIGlmIChwcmV2LmVxdWFsczJEKGNvb3JkJDQpKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpJDMgPCBzaXplKSB7XG4gICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXQoaSQzKTtcbiAgICAgICAgICAgICAgaWYgKG5leHQuZXF1YWxzMkQoY29vcmQkNCkpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBBcnJheUxpc3QkJDEucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIGkkMywgY29vcmQkNCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgY29vcmQkNSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBhbGxvd1JlcGVhdGVkJDUgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgZW5kID0gYXJndW1lbnRzWzNdO1xuICAgICAgdmFyIGluYyA9IDE7XG4gICAgICBpZiAoc3RhcnQgPiBlbmQpIHsgaW5jID0gLTE7IH1cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSAhPT0gZW5kOyBpICs9IGluYykge1xuICAgICAgICB0aGlzJDEuYWRkKGNvb3JkJDVbaV0sIGFsbG93UmVwZWF0ZWQkNSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmNsb3NlUmluZyA9IGZ1bmN0aW9uIGNsb3NlUmluZyAoKSB7XG4gICAgaWYgKHRoaXMuc2l6ZSgpID4gMCkgeyB0aGlzLmFkZChuZXcgQ29vcmRpbmF0ZSh0aGlzLmdldCgwKSksIGZhbHNlKTsgfVxuICB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gQ29vcmRpbmF0ZUxpc3RcbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29vcmRpbmF0ZUxpc3QsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBDb29yZGluYXRlTGlzdDtcbn0oQXJyYXlMaXN0KSk7XG5cbnZhciBDb29yZGluYXRlQXJyYXlzID0gZnVuY3Rpb24gQ29vcmRpbmF0ZUFycmF5cyAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxMyA9IHsgRm9yd2FyZENvbXBhcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQmlkaXJlY3Rpb25hbENvbXBhcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sY29vcmRBcnJheVR5cGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuc3RhdGljQWNjZXNzb3JzJDEzLkZvcndhcmRDb21wYXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEZvcndhcmRDb21wYXJhdG9yIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTMuQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMy5jb29yZEFycmF5VHlwZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQXJyYXkoMCkuZmlsbChudWxsKSB9O1xuXG5Db29yZGluYXRlQXJyYXlzLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlzXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5pc1JpbmcgPSBmdW5jdGlvbiBpc1JpbmcgKHB0cykge1xuICBpZiAocHRzLmxlbmd0aCA8IDQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCFwdHNbMF0uZXF1YWxzMkQocHRzW3B0cy5sZW5ndGggLSAxXSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRydWVcbn07XG5Db29yZGluYXRlQXJyYXlzLnB0Tm90SW5MaXN0ID0gZnVuY3Rpb24gcHROb3RJbkxpc3QgKHRlc3RQdHMsIHB0cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRlc3RQdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGVzdFB0ID0gdGVzdFB0c1tpXTtcbiAgICBpZiAoQ29vcmRpbmF0ZUFycmF5cy5pbmRleE9mKHRlc3RQdCwgcHRzKSA8IDApIHsgcmV0dXJuIHRlc3RQdCB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5Db29yZGluYXRlQXJyYXlzLnNjcm9sbCA9IGZ1bmN0aW9uIHNjcm9sbCAoY29vcmRpbmF0ZXMsIGZpcnN0Q29vcmRpbmF0ZSkge1xuICB2YXIgaSA9IENvb3JkaW5hdGVBcnJheXMuaW5kZXhPZihmaXJzdENvb3JkaW5hdGUsIGNvb3JkaW5hdGVzKTtcbiAgaWYgKGkgPCAwKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG5ld0Nvb3JkaW5hdGVzID0gbmV3IEFycmF5KGNvb3JkaW5hdGVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgU3lzdGVtLmFycmF5Y29weShjb29yZGluYXRlcywgaSwgbmV3Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLmxlbmd0aCAtIGkpO1xuICBTeXN0ZW0uYXJyYXljb3B5KGNvb3JkaW5hdGVzLCAwLCBuZXdDb29yZGluYXRlcywgY29vcmRpbmF0ZXMubGVuZ3RoIC0gaSwgaSk7XG4gIFN5c3RlbS5hcnJheWNvcHkobmV3Q29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLCAwLCBjb29yZGluYXRlcy5sZW5ndGgpO1xufTtcbkNvb3JkaW5hdGVBcnJheXMuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgY29vcmQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb29yZDIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGNvb3JkMSA9PT0gY29vcmQyKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAoY29vcmQxID09PSBudWxsIHx8IGNvb3JkMiA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChjb29yZDEubGVuZ3RoICE9PSBjb29yZDIubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZDEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghY29vcmQxW2ldLmVxdWFscyhjb29yZDJbaV0pKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBjb29yZDEkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgY29vcmQyJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGNvb3JkaW5hdGVDb21wYXJhdG9yID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChjb29yZDEkMSA9PT0gY29vcmQyJDEpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb29yZDEkMSA9PT0gbnVsbCB8fCBjb29yZDIkMSA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmIChjb29yZDEkMS5sZW5ndGggIT09IGNvb3JkMiQxLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNvb3JkMSQxLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgIGlmIChjb29yZGluYXRlQ29tcGFyYXRvci5jb21wYXJlKGNvb3JkMSQxW2kkMV0sIGNvb3JkMiQxW2kkMV0pICE9PSAwKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5Db29yZGluYXRlQXJyYXlzLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAoY29vcmRpbmF0ZXMsIGVudikge1xuICB2YXIgY29vcmRMaXN0ID0gbmV3IENvb3JkaW5hdGVMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZW52LmludGVyc2VjdHMoY29vcmRpbmF0ZXNbaV0pKSB7IGNvb3JkTGlzdC5hZGQoY29vcmRpbmF0ZXNbaV0sIHRydWUpOyB9XG4gIH1cbiAgcmV0dXJuIGNvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5oYXNSZXBlYXRlZFBvaW50cyA9IGZ1bmN0aW9uIGhhc1JlcGVhdGVkUG9pbnRzIChjb29yZCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGNvb3JkLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNvb3JkW2kgLSAxXS5lcXVhbHMoY29vcmRbaV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5Db29yZGluYXRlQXJyYXlzLnJlbW92ZVJlcGVhdGVkUG9pbnRzID0gZnVuY3Rpb24gcmVtb3ZlUmVwZWF0ZWRQb2ludHMgKGNvb3JkKSB7XG4gIGlmICghQ29vcmRpbmF0ZUFycmF5cy5oYXNSZXBlYXRlZFBvaW50cyhjb29yZCkpIHsgcmV0dXJuIGNvb3JkIH1cbiAgdmFyIGNvb3JkTGlzdCA9IG5ldyBDb29yZGluYXRlTGlzdChjb29yZCwgZmFsc2UpO1xuICByZXR1cm4gY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KClcbn07XG5Db29yZGluYXRlQXJyYXlzLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlIChjb29yZCkge1xuICB2YXIgbGFzdCA9IGNvb3JkLmxlbmd0aCAtIDE7XG4gIHZhciBtaWQgPSBNYXRoLnRydW5jKGxhc3QgLyAyKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbWlkOyBpKyspIHtcbiAgICB2YXIgdG1wID0gY29vcmRbaV07XG4gICAgY29vcmRbaV0gPSBjb29yZFtsYXN0IC0gaV07XG4gICAgY29vcmRbbGFzdCAtIGldID0gdG1wO1xuICB9XG59O1xuQ29vcmRpbmF0ZUFycmF5cy5yZW1vdmVOdWxsID0gZnVuY3Rpb24gcmVtb3ZlTnVsbCAoY29vcmQpIHtcbiAgdmFyIG5vbk51bGwgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNvb3JkW2ldICE9PSBudWxsKSB7IG5vbk51bGwrKzsgfVxuICB9XG4gIHZhciBuZXdDb29yZCA9IG5ldyBBcnJheShub25OdWxsKS5maWxsKG51bGwpO1xuICBpZiAobm9uTnVsbCA9PT0gMCkgeyByZXR1cm4gbmV3Q29vcmQgfVxuICB2YXIgaiA9IDA7XG4gIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNvb3JkLmxlbmd0aDsgaSQxKyspIHtcbiAgICBpZiAoY29vcmRbaSQxXSAhPT0gbnVsbCkgeyBuZXdDb29yZFtqKytdID0gY29vcmRbaSQxXTsgfVxuICB9XG4gIHJldHVybiBuZXdDb29yZFxufTtcbkNvb3JkaW5hdGVBcnJheXMuY29weURlZXAgPSBmdW5jdGlvbiBjb3B5RGVlcCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb3B5ID0gbmV3IEFycmF5KGNvb3JkaW5hdGVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3B5W2ldID0gbmV3IENvb3JkaW5hdGUoY29vcmRpbmF0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY29weVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDUpIHtcbiAgICB2YXIgc3JjID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzcmNTdGFydCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZGVzdCA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgZGVzdFN0YXJ0ID0gYXJndW1lbnRzWzNdO1xuICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHNbNF07XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGVuZ3RoOyBpJDErKykge1xuICAgICAgZGVzdFtkZXN0U3RhcnQgKyBpJDFdID0gbmV3IENvb3JkaW5hdGUoc3JjW3NyY1N0YXJ0ICsgaSQxXSk7XG4gICAgfVxuICB9XG59O1xuQ29vcmRpbmF0ZUFycmF5cy5pc0VxdWFsUmV2ZXJzZWQgPSBmdW5jdGlvbiBpc0VxdWFsUmV2ZXJzZWQgKHB0czEsIHB0czIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAxID0gcHRzMVtpXTtcbiAgICB2YXIgcDIgPSBwdHMyW3B0czEubGVuZ3RoIC0gaSAtIDFdO1xuICAgIGlmIChwMS5jb21wYXJlVG8ocDIpICE9PSAwKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5Db29yZGluYXRlQXJyYXlzLmVudmVsb3BlID0gZnVuY3Rpb24gZW52ZWxvcGUgKGNvb3JkaW5hdGVzKSB7XG4gIHZhciBlbnYgPSBuZXcgRW52ZWxvcGUoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGVudi5leHBhbmRUb0luY2x1ZGUoY29vcmRpbmF0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBlbnZcbn07XG5Db29yZGluYXRlQXJyYXlzLnRvQ29vcmRpbmF0ZUFycmF5ID0gZnVuY3Rpb24gdG9Db29yZGluYXRlQXJyYXkgKGNvb3JkTGlzdCkge1xuICByZXR1cm4gY29vcmRMaXN0LnRvQXJyYXkoQ29vcmRpbmF0ZUFycmF5cy5jb29yZEFycmF5VHlwZSlcbn07XG5Db29yZGluYXRlQXJyYXlzLmF0TGVhc3ROQ29vcmRpbmF0ZXNPck5vdGhpbmcgPSBmdW5jdGlvbiBhdExlYXN0TkNvb3JkaW5hdGVzT3JOb3RoaW5nIChuLCBjKSB7XG4gIHJldHVybiBjLmxlbmd0aCA+PSBuID8gYyA6IFtdXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAoY29vcmRpbmF0ZSwgY29vcmRpbmF0ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjb29yZGluYXRlLmVxdWFscyhjb29yZGluYXRlc1tpXSkpIHtcbiAgICAgIHJldHVybiBpXG4gICAgfVxuICB9XG4gIHJldHVybiAtMVxufTtcbkNvb3JkaW5hdGVBcnJheXMuaW5jcmVhc2luZ0RpcmVjdGlvbiA9IGZ1bmN0aW9uIGluY3JlYXNpbmdEaXJlY3Rpb24gKHB0cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgudHJ1bmMocHRzLmxlbmd0aCAvIDIpOyBpKyspIHtcbiAgICB2YXIgaiA9IHB0cy5sZW5ndGggLSAxIC0gaTtcbiAgICB2YXIgY29tcCA9IHB0c1tpXS5jb21wYXJlVG8ocHRzW2pdKTtcbiAgICBpZiAoY29tcCAhPT0gMCkgeyByZXR1cm4gY29tcCB9XG4gIH1cbiAgcmV0dXJuIDFcbn07XG5Db29yZGluYXRlQXJyYXlzLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChwdHMxLCBwdHMyKSB7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKGkgPCBwdHMxLmxlbmd0aCAmJiBpIDwgcHRzMi5sZW5ndGgpIHtcbiAgICB2YXIgY29tcGFyZSA9IHB0czFbaV0uY29tcGFyZVRvKHB0czJbaV0pO1xuICAgIGlmIChjb21wYXJlICE9PSAwKSB7IHJldHVybiBjb21wYXJlIH1cbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPCBwdHMyLmxlbmd0aCkgeyByZXR1cm4gLTEgfVxuICBpZiAoaSA8IHB0czEubGVuZ3RoKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5Db29yZGluYXRlQXJyYXlzLm1pbkNvb3JkaW5hdGUgPSBmdW5jdGlvbiBtaW5Db29yZGluYXRlIChjb29yZGluYXRlcykge1xuICB2YXIgbWluQ29vcmQgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG1pbkNvb3JkID09PSBudWxsIHx8IG1pbkNvb3JkLmNvbXBhcmVUbyhjb29yZGluYXRlc1tpXSkgPiAwKSB7XG4gICAgICBtaW5Db29yZCA9IGNvb3JkaW5hdGVzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWluQ29vcmRcbn07XG5Db29yZGluYXRlQXJyYXlzLmV4dHJhY3QgPSBmdW5jdGlvbiBleHRyYWN0IChwdHMsIHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBNYXRoVXRpbC5jbGFtcChzdGFydCwgMCwgcHRzLmxlbmd0aCk7XG4gIGVuZCA9IE1hdGhVdGlsLmNsYW1wKGVuZCwgLTEsIHB0cy5sZW5ndGgpO1xuICB2YXIgbnB0cyA9IGVuZCAtIHN0YXJ0ICsgMTtcbiAgaWYgKGVuZCA8IDApIHsgbnB0cyA9IDA7IH1cbiAgaWYgKHN0YXJ0ID49IHB0cy5sZW5ndGgpIHsgbnB0cyA9IDA7IH1cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7IG5wdHMgPSAwOyB9XG4gIHZhciBleHRyYWN0UHRzID0gbmV3IEFycmF5KG5wdHMpLmZpbGwobnVsbCk7XG4gIGlmIChucHRzID09PSAwKSB7IHJldHVybiBleHRyYWN0UHRzIH1cbiAgdmFyIGlQdHMgPSAwO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBleHRyYWN0UHRzW2lQdHMrK10gPSBwdHNbaV07XG4gIH1cbiAgcmV0dXJuIGV4dHJhY3RQdHNcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb29yZGluYXRlQXJyYXlzLCBzdGF0aWNBY2Nlc3NvcnMkMTMgKTtcblxudmFyIEZvcndhcmRDb21wYXJhdG9yID0gZnVuY3Rpb24gRm9yd2FyZENvbXBhcmF0b3IgKCkge307XG5cbkZvcndhcmRDb21wYXJhdG9yLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAobzEsIG8yKSB7XG4gIHZhciBwdHMxID0gbzE7XG4gIHZhciBwdHMyID0gbzI7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlzLmNvbXBhcmUocHRzMSwgcHRzMilcbn07XG5Gb3J3YXJkQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYXRvcl1cbn07XG5Gb3J3YXJkQ29tcGFyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBGb3J3YXJkQ29tcGFyYXRvclxufTtcblxudmFyIEJpZGlyZWN0aW9uYWxDb21wYXJhdG9yID0gZnVuY3Rpb24gQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IgKCkge307XG5cbkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAobzEsIG8yKSB7XG4gIHZhciBwdHMxID0gbzE7XG4gIHZhciBwdHMyID0gbzI7XG4gIGlmIChwdHMxLmxlbmd0aCA8IHB0czIubGVuZ3RoKSB7IHJldHVybiAtMSB9XG4gIGlmIChwdHMxLmxlbmd0aCA+IHB0czIubGVuZ3RoKSB7IHJldHVybiAxIH1cbiAgaWYgKHB0czEubGVuZ3RoID09PSAwKSB7IHJldHVybiAwIH1cbiAgdmFyIGZvcndhcmRDb21wID0gQ29vcmRpbmF0ZUFycmF5cy5jb21wYXJlKHB0czEsIHB0czIpO1xuICB2YXIgaXNFcXVhbFJldiA9IENvb3JkaW5hdGVBcnJheXMuaXNFcXVhbFJldmVyc2VkKHB0czEsIHB0czIpO1xuICBpZiAoaXNFcXVhbFJldikgeyByZXR1cm4gMCB9XG4gIHJldHVybiBmb3J3YXJkQ29tcFxufTtcbkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yLnByb3RvdHlwZS5PTERjb21wYXJlID0gZnVuY3Rpb24gT0xEY29tcGFyZSAobzEsIG8yKSB7XG4gIHZhciBwdHMxID0gbzE7XG4gIHZhciBwdHMyID0gbzI7XG4gIGlmIChwdHMxLmxlbmd0aCA8IHB0czIubGVuZ3RoKSB7IHJldHVybiAtMSB9XG4gIGlmIChwdHMxLmxlbmd0aCA+IHB0czIubGVuZ3RoKSB7IHJldHVybiAxIH1cbiAgaWYgKHB0czEubGVuZ3RoID09PSAwKSB7IHJldHVybiAwIH1cbiAgdmFyIGRpcjEgPSBDb29yZGluYXRlQXJyYXlzLmluY3JlYXNpbmdEaXJlY3Rpb24ocHRzMSk7XG4gIHZhciBkaXIyID0gQ29vcmRpbmF0ZUFycmF5cy5pbmNyZWFzaW5nRGlyZWN0aW9uKHB0czIpO1xuICB2YXIgaTEgPSBkaXIxID4gMCA/IDAgOiBwdHMxLmxlbmd0aCAtIDE7XG4gIHZhciBpMiA9IGRpcjIgPiAwID8gMCA6IHB0czEubGVuZ3RoIC0gMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBhcmVQdCA9IHB0czFbaTFdLmNvbXBhcmVUbyhwdHMyW2kyXSk7XG4gICAgaWYgKGNvbXBhcmVQdCAhPT0gMCkgeyByZXR1cm4gY29tcGFyZVB0IH1cbiAgICBpMSArPSBkaXIxO1xuICAgIGkyICs9IGRpcjI7XG4gIH1cbiAgcmV0dXJuIDBcbn07XG5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYXRvcl1cbn07XG5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCaWRpcmVjdGlvbmFsQ29tcGFyYXRvclxufTtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9NYXAuaHRtbFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIE1hcCQxID0gZnVuY3Rpb24gTWFwICgpIHt9O1xuXG5NYXAkMS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0ICgpIHt9O1xuLyoqXG4gKiBBc3NvY2lhdGVzIHRoZSBzcGVjaWZpZWQgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkIGtleSBpbiB0aGlzIG1hcCAob3B0aW9uYWxcbiAqIG9wZXJhdGlvbikuXG4gKiBAcGFyYW0ge09iamVjdH0ga2V5XG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuTWFwJDEucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIHB1dCAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Yga2V5LXZhbHVlIG1hcHBpbmdzIGluIHRoaXMgbWFwLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5NYXAkMS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge307XG5cbi8qKlxuICogUmV0dXJucyBhIENvbGxlY3Rpb24gdmlldyBvZiB0aGUgdmFsdWVzIGNvbnRhaW5lZCBpbiB0aGlzIG1hcC5cbiAqIEByZXR1cm4ge2phdmFzY3JpcHQudXRpbC5Db2xsZWN0aW9ufVxuICovXG5NYXAkMS5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzICgpIHt9O1xuXG4vKipcbiAqIFJldHVybnMgYSB7QGxpbmsgU2V0fSB2aWV3IG9mIHRoZSBtYXBwaW5ncyBjb250YWluZWQgaW4gdGhpcyBtYXAuXG4gKiBUaGUgc2V0IGlzIGJhY2tlZCBieSB0aGUgbWFwLCBzbyBjaGFuZ2VzIHRvIHRoZSBtYXAgYXJlXG4gKiByZWZsZWN0ZWQgaW4gdGhlIHNldCwgYW5kIHZpY2UtdmVyc2EuSWYgdGhlIG1hcCBpcyBtb2RpZmllZFxuICogd2hpbGUgYW4gaXRlcmF0aW9uIG92ZXIgdGhlIHNldCBpcyBpbiBwcm9ncmVzcyAoZXhjZXB0IHRocm91Z2hcbiAqIHRoZSBpdGVyYXRvcidzIG93biA8dHQ+cmVtb3ZlPC90dD4gb3BlcmF0aW9uLCBvciB0aHJvdWdoIHRoZVxuICogPHR0PnNldFZhbHVlPC90dD4gb3BlcmF0aW9uIG9uIGEgbWFwIGVudHJ5IHJldHVybmVkIGJ5IHRoZVxuICogaXRlcmF0b3IpIHRoZSByZXN1bHRzIG9mIHRoZSBpdGVyYXRpb24gYXJlIHVuZGVmaW5lZC5UaGUgc2V0XG4gKiBzdXBwb3J0cyBlbGVtZW50IHJlbW92YWwsIHdoaWNoIHJlbW92ZXMgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIG1hcHBpbmcgZnJvbSB0aGUgbWFwLCB2aWEgdGhlIDx0dD5JdGVyYXRvci5yZW1vdmU8L3R0PixcbiAqIDx0dD5TZXQucmVtb3ZlPC90dD4sIDx0dD5yZW1vdmVBbGw8L3R0PiwgPHR0PnJldGFpbkFsbDwvdHQ+IGFuZFxuICogPHR0PmNsZWFyPC90dD4gb3BlcmF0aW9ucy5JdCBkb2VzIG5vdCBzdXBwb3J0IHRoZVxuICogPHR0PmFkZDwvdHQ+IG9yIDx0dD5hZGRBbGw8L3R0PiBvcGVyYXRpb25zLlxuICpcbiAqIEByZXR1cm4ge1NldH0gYSBzZXQgdmlldyBvZiB0aGUgbWFwcGluZ3MgY29udGFpbmVkIGluIHRoaXMgbWFwXG4gKi9cbk1hcCQxLnByb3RvdHlwZS5lbnRyeVNldCA9IGZ1bmN0aW9uIGVudHJ5U2V0ICgpIHt9O1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL1NvcnRlZE1hcC5odG1sXG4gKlxuICogQGV4dGVuZHMge01hcH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIFNvcnRlZE1hcCA9IChmdW5jdGlvbiAoTWFwKSB7XG5cdGZ1bmN0aW9uIFNvcnRlZE1hcCAoKSB7XG5cdFx0TWFwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1pZiAoIE1hcCApIFNvcnRlZE1hcC5fX3Byb3RvX18gPSBNYXA7XG5cdFNvcnRlZE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXAgJiYgTWFwLnByb3RvdHlwZSApO1xuXHRTb3J0ZWRNYXAucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29ydGVkTWFwO1xuXG5cdFxuXG5cdHJldHVybiBTb3J0ZWRNYXA7XG59KE1hcCQxKSk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIE9wdGlvbmFsIG1lc3NhZ2VcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gT3BlcmF0aW9uTm90U3VwcG9ydGVkIChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG59XG5PcGVyYXRpb25Ob3RTdXBwb3J0ZWQucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuT3BlcmF0aW9uTm90U3VwcG9ydGVkLnByb3RvdHlwZS5uYW1lID0gJ09wZXJhdGlvbk5vdFN1cHBvcnRlZCc7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvU2V0Lmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7Q29sbGVjdGlvbn1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU2V0KCkge31cblNldC5wcm90b3R5cGUgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgc2V0IGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgZWxlbWVudC4gTW9yZSBmb3JtYWxseSxcbiAqIHJldHVybnMgdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGlzIHNldCBjb250YWlucyBhbiBlbGVtZW50IGUgc3VjaCB0aGF0IChvPT1udWxsID9cbiAqIGU9PW51bGwgOiBvLmVxdWFscyhlKSkuXG4gKiBAcGFyYW0ge09iamVjdH0gZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKCkge307XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG9jcy5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9IYXNoU2V0Lmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7amF2YXNjcmlwdC51dGlsLlNldH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIEhhc2hTZXQgPSAoZnVuY3Rpb24gKFNldCQkMSkge1xuICBmdW5jdGlvbiBIYXNoU2V0ICgpIHtcbiAgICBTZXQkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmFycmF5XyA9IFtdO1xuXG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBTZXQkJDEgKSBIYXNoU2V0Ll9fcHJvdG9fXyA9IFNldCQkMTtcbiAgSGFzaFNldC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTZXQkJDEgJiYgU2V0JCQxLnByb3RvdHlwZSApO1xuICBIYXNoU2V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhc2hTZXQ7XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyAobykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgZSA9IHRoaXMkMS5hcnJheV9baV07XG4gICAgICBpZiAoZSA9PT0gbykge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG8pIHtcbiAgICBpZiAodGhpcy5jb250YWlucyhvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpcy5hcnJheV8ucHVzaChvKTtcblxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gYWRkQWxsIChjKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gYy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHRoaXMkMS5hZGQoaS5uZXh0KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAobykge1xuICAgIC8vIHRocm93IG5ldyBqYXZhc2NyaXB0LnV0aWwuT3BlcmF0aW9uTm90U3VwcG9ydGVkKClcbiAgICB0aHJvdyBuZXcgRXJyb3IoKVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGggPT09IDBcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJyYXkucHVzaCh0aGlzJDEuYXJyYXlfW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yICgpIHtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yXyQxKHRoaXMpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hTZXQ7XG59KFNldCkpO1xuXG4vKipcbiAgICogQGV4dGVuZHMge0l0ZXJhdG9yfVxuICAgKiBAcGFyYW0ge0hhc2hTZXR9IGhhc2hTZXRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xudmFyIEl0ZXJhdG9yXyQxID0gKGZ1bmN0aW9uIChJdGVyYXRvciQkMSkge1xuICBmdW5jdGlvbiBJdGVyYXRvcl8gKGhhc2hTZXQpIHtcbiAgICBJdGVyYXRvciQkMS5jYWxsKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIYXNoU2V0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5oYXNoU2V0XyA9IGhhc2hTZXQ7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMucG9zaXRpb25fID0gMDtcbiAgfVxuXG4gIGlmICggSXRlcmF0b3IkJDEgKSBJdGVyYXRvcl8uX19wcm90b19fID0gSXRlcmF0b3IkJDE7XG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJdGVyYXRvciQkMSAmJiBJdGVyYXRvciQkMS5wcm90b3R5cGUgKTtcbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEl0ZXJhdG9yXztcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBJdGVyYXRvcl8ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICBpZiAodGhpcy5wb3NpdGlvbl8gPT09IHRoaXMuaGFzaFNldF8uc2l6ZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoRWxlbWVudEV4Y2VwdGlvbigpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhhc2hTZXRfLmFycmF5X1t0aGlzLnBvc2l0aW9uXysrXVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uIGhhc05leHQgKCkge1xuICAgIGlmICh0aGlzLnBvc2l0aW9uXyA8IHRoaXMuaGFzaFNldF8uc2l6ZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgIHRocm93IG5ldyBPcGVyYXRpb25Ob3RTdXBwb3J0ZWQoKVxuICB9O1xuXG4gIHJldHVybiBJdGVyYXRvcl87XG59KEl0ZXJhdG9yKSk7XG5cbnZhciBCTEFDSyA9IDA7XG52YXIgUkVEID0gMTtcbmZ1bmN0aW9uIGNvbG9yT2YgKHApIHsgcmV0dXJuIChwID09PSBudWxsID8gQkxBQ0sgOiBwLmNvbG9yKSB9XG5mdW5jdGlvbiBwYXJlbnRPZiAocCkgeyByZXR1cm4gKHAgPT09IG51bGwgPyBudWxsIDogcC5wYXJlbnQpIH1cbmZ1bmN0aW9uIHNldENvbG9yIChwLCBjKSB7IGlmIChwICE9PSBudWxsKSB7IHAuY29sb3IgPSBjOyB9IH1cbmZ1bmN0aW9uIGxlZnRPZiAocCkgeyByZXR1cm4gKHAgPT09IG51bGwgPyBudWxsIDogcC5sZWZ0KSB9XG5mdW5jdGlvbiByaWdodE9mIChwKSB7IHJldHVybiAocCA9PT0gbnVsbCA/IG51bGwgOiBwLnJpZ2h0KSB9XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvVHJlZU1hcC5odG1sXG4gKlxuICogQGV4dGVuZHMge1NvcnRlZE1hcH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVHJlZU1hcCAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5yb290XyA9IG51bGw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAqL1xuICB0aGlzLnNpemVfID0gMDtcbn1cblRyZWVNYXAucHJvdG90eXBlID0gbmV3IFNvcnRlZE1hcCgpO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBwID0gdGhpcy5yb290XztcbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICB2YXIgY21wID0ga2V5Wydjb21wYXJlVG8nXShwLmtleSk7XG4gICAgaWYgKGNtcCA8IDApIHsgcCA9IHAubGVmdDsgfVxuICAgIGVsc2UgaWYgKGNtcCA+IDApIHsgcCA9IHAucmlnaHQ7IH1cbiAgICBlbHNlIHsgcmV0dXJuIHAudmFsdWUgfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICBpZiAodGhpcy5yb290XyA9PT0gbnVsbCkge1xuICAgIHRoaXMucm9vdF8gPSB7XG4gICAgICBrZXk6IGtleSxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGxlZnQ6IG51bGwsXG4gICAgICByaWdodDogbnVsbCxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGNvbG9yOiBCTEFDSyxcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7IHJldHVybiB0aGlzLnZhbHVlIH0sXG4gICAgICBnZXRLZXk6IGZ1bmN0aW9uIGdldEtleSAoKSB7IHJldHVybiB0aGlzLmtleSB9XG4gICAgfTtcbiAgICB0aGlzLnNpemVfID0gMTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZhciB0ID0gdGhpcy5yb290XztcbiAgdmFyIHBhcmVudDtcbiAgdmFyIGNtcDtcbiAgZG8ge1xuICAgIHBhcmVudCA9IHQ7XG4gICAgY21wID0ga2V5Wydjb21wYXJlVG8nXSh0LmtleSk7XG4gICAgaWYgKGNtcCA8IDApIHtcbiAgICAgIHQgPSB0LmxlZnQ7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICB0ID0gdC5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG9sZFZhbHVlID0gdC52YWx1ZTtcbiAgICAgIHQudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgIH1cbiAgfSB3aGlsZSAodCAhPT0gbnVsbClcbiAgdmFyIGUgPSB7XG4gICAga2V5OiBrZXksXG4gICAgbGVmdDogbnVsbCxcbiAgICByaWdodDogbnVsbCxcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgY29sb3I6IEJMQUNLLFxuICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSAoKSB7IHJldHVybiB0aGlzLnZhbHVlIH0sXG4gICAgZ2V0S2V5OiBmdW5jdGlvbiBnZXRLZXkgKCkgeyByZXR1cm4gdGhpcy5rZXkgfVxuICB9O1xuICBpZiAoY21wIDwgMCkge1xuICAgIHBhcmVudC5sZWZ0ID0gZTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQucmlnaHQgPSBlO1xuICB9XG4gIHRoaXMuZml4QWZ0ZXJJbnNlcnRpb24oZSk7XG4gIHRoaXMuc2l6ZV8rKztcbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHhcbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUuZml4QWZ0ZXJJbnNlcnRpb24gPSBmdW5jdGlvbiAoeCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB4LmNvbG9yID0gUkVEO1xuICB3aGlsZSAoeCAhPSBudWxsICYmIHggIT09IHRoaXMucm9vdF8gJiYgeC5wYXJlbnQuY29sb3IgPT09IFJFRCkge1xuICAgIGlmIChwYXJlbnRPZih4KSA9PT0gbGVmdE9mKHBhcmVudE9mKHBhcmVudE9mKHgpKSkpIHtcbiAgICAgIHZhciB5ID0gcmlnaHRPZihwYXJlbnRPZihwYXJlbnRPZih4KSkpO1xuICAgICAgaWYgKGNvbG9yT2YoeSkgPT09IFJFRCkge1xuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZih4KSwgQkxBQ0spO1xuICAgICAgICBzZXRDb2xvcih5LCBCTEFDSyk7XG4gICAgICAgIHNldENvbG9yKHBhcmVudE9mKHBhcmVudE9mKHgpKSwgUkVEKTtcbiAgICAgICAgeCA9IHBhcmVudE9mKHBhcmVudE9mKHgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh4ID09PSByaWdodE9mKHBhcmVudE9mKHgpKSkge1xuICAgICAgICAgIHggPSBwYXJlbnRPZih4KTtcbiAgICAgICAgICB0aGlzJDEucm90YXRlTGVmdCh4KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZih4KSwgQkxBQ0spO1xuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZihwYXJlbnRPZih4KSksIFJFRCk7XG4gICAgICAgIHRoaXMkMS5yb3RhdGVSaWdodChwYXJlbnRPZihwYXJlbnRPZih4KSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeSQxID0gbGVmdE9mKHBhcmVudE9mKHBhcmVudE9mKHgpKSk7XG4gICAgICBpZiAoY29sb3JPZih5JDEpID09PSBSRUQpIHtcbiAgICAgICAgc2V0Q29sb3IocGFyZW50T2YoeCksIEJMQUNLKTtcbiAgICAgICAgc2V0Q29sb3IoeSQxLCBCTEFDSyk7XG4gICAgICAgIHNldENvbG9yKHBhcmVudE9mKHBhcmVudE9mKHgpKSwgUkVEKTtcbiAgICAgICAgeCA9IHBhcmVudE9mKHBhcmVudE9mKHgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh4ID09PSBsZWZ0T2YocGFyZW50T2YoeCkpKSB7XG4gICAgICAgICAgeCA9IHBhcmVudE9mKHgpO1xuICAgICAgICAgIHRoaXMkMS5yb3RhdGVSaWdodCh4KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZih4KSwgQkxBQ0spO1xuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZihwYXJlbnRPZih4KSksIFJFRCk7XG4gICAgICAgIHRoaXMkMS5yb3RhdGVMZWZ0KHBhcmVudE9mKHBhcmVudE9mKHgpKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRoaXMucm9vdF8uY29sb3IgPSBCTEFDSztcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIHAgPSB0aGlzLmdldEZpcnN0RW50cnkoKTtcbiAgaWYgKHAgIT09IG51bGwpIHtcbiAgICBhcnJheUxpc3QuYWRkKHAudmFsdWUpO1xuICAgIHdoaWxlICgocCA9IFRyZWVNYXAuc3VjY2Vzc29yKHApKSAhPT0gbnVsbCkge1xuICAgICAgYXJyYXlMaXN0LmFkZChwLnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5TGlzdFxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUuZW50cnlTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoYXNoU2V0ID0gbmV3IEhhc2hTZXQoKTtcbiAgdmFyIHAgPSB0aGlzLmdldEZpcnN0RW50cnkoKTtcbiAgaWYgKHAgIT09IG51bGwpIHtcbiAgICBoYXNoU2V0LmFkZChwKTtcbiAgICB3aGlsZSAoKHAgPSBUcmVlTWFwLnN1Y2Nlc3NvcihwKSkgIT09IG51bGwpIHtcbiAgICAgIGhhc2hTZXQuYWRkKHApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaGFzaFNldFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gcFxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gKHApIHtcbiAgaWYgKHAgIT0gbnVsbCkge1xuICAgIHZhciByID0gcC5yaWdodDtcbiAgICBwLnJpZ2h0ID0gci5sZWZ0O1xuICAgIGlmIChyLmxlZnQgIT0gbnVsbCkgeyByLmxlZnQucGFyZW50ID0gcDsgfVxuICAgIHIucGFyZW50ID0gcC5wYXJlbnQ7XG4gICAgaWYgKHAucGFyZW50ID09PSBudWxsKSB7IHRoaXMucm9vdF8gPSByOyB9IGVsc2UgaWYgKHAucGFyZW50LmxlZnQgPT09IHApIHsgcC5wYXJlbnQubGVmdCA9IHI7IH0gZWxzZSB7IHAucGFyZW50LnJpZ2h0ID0gcjsgfVxuICAgIHIubGVmdCA9IHA7XG4gICAgcC5wYXJlbnQgPSByO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwXG4gKi9cblRyZWVNYXAucHJvdG90eXBlLnJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gKHApIHtcbiAgaWYgKHAgIT0gbnVsbCkge1xuICAgIHZhciBsID0gcC5sZWZ0O1xuICAgIHAubGVmdCA9IGwucmlnaHQ7XG4gICAgaWYgKGwucmlnaHQgIT0gbnVsbCkgeyBsLnJpZ2h0LnBhcmVudCA9IHA7IH1cbiAgICBsLnBhcmVudCA9IHAucGFyZW50O1xuICAgIGlmIChwLnBhcmVudCA9PT0gbnVsbCkgeyB0aGlzLnJvb3RfID0gbDsgfSBlbHNlIGlmIChwLnBhcmVudC5yaWdodCA9PT0gcCkgeyBwLnBhcmVudC5yaWdodCA9IGw7IH0gZWxzZSB7IHAucGFyZW50LmxlZnQgPSBsOyB9XG4gICAgbC5yaWdodCA9IHA7XG4gICAgcC5wYXJlbnQgPSBsO1xuICB9XG59O1xuXG4vKipcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUuZ2V0Rmlyc3RFbnRyeSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHAgPSB0aGlzLnJvb3RfO1xuICBpZiAocCAhPSBudWxsKSB7XG4gICAgd2hpbGUgKHAubGVmdCAhPSBudWxsKSB7XG4gICAgICBwID0gcC5sZWZ0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gdFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuVHJlZU1hcC5zdWNjZXNzb3IgPSBmdW5jdGlvbiAodCkge1xuICBpZiAodCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9IGVsc2UgaWYgKHQucmlnaHQgIT09IG51bGwpIHtcbiAgICB2YXIgcCA9IHQucmlnaHQ7XG4gICAgd2hpbGUgKHAubGVmdCAhPT0gbnVsbCkge1xuICAgICAgcCA9IHAubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIHBcbiAgfSBlbHNlIHtcbiAgICB2YXIgcCQxID0gdC5wYXJlbnQ7XG4gICAgdmFyIGNoID0gdDtcbiAgICB3aGlsZSAocCQxICE9PSBudWxsICYmIGNoID09PSBwJDEucmlnaHQpIHtcbiAgICAgIGNoID0gcCQxO1xuICAgICAgcCQxID0gcCQxLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHAkMVxuICB9XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5zaXplX1xufTtcblxudmFyIExpbmVhbCA9IGZ1bmN0aW9uIExpbmVhbCAoKSB7fTtcblxuTGluZWFsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTGluZWFsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExpbmVhbFxufTtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9Tb3J0ZWRTZXQuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtTZXR9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFNvcnRlZFNldCAoKSB7fVxuU29ydGVkU2V0LnByb3RvdHlwZSA9IG5ldyBTZXQoKTtcblxuLy8gaW1wb3J0IEl0ZXJhdG9yIGZyb20gJy4vSXRlcmF0b3InXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL1RyZWVTZXQuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtTb3J0ZWRTZXR9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFRyZWVTZXQgKCkge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAqL1xuICB0aGlzLmFycmF5XyA9IFtdO1xuXG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKTtcbiAgfVxufVxuVHJlZVNldC5wcm90b3R5cGUgPSBuZXcgU29ydGVkU2V0KCk7XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKG8pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGUgPSB0aGlzJDEuYXJyYXlfW2ldO1xuICAgIGlmIChlWydjb21wYXJlVG8nXShvKSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5jb250YWlucyhvKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGUgPSB0aGlzJDEuYXJyYXlfW2ldO1xuICAgIGlmIChlWydjb21wYXJlVG8nXShvKSA9PT0gMSkge1xuICAgICAgdGhpcyQxLmFycmF5Xy5zcGxpY2UoaSwgMCwgbyk7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHRoaXMuYXJyYXlfLnB1c2gobyk7XG5cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIChjKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSBjLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHRoaXMkMS5hZGQoaS5uZXh0KCkpO1xuICB9XG4gIHJldHVybiB0cnVlXG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlU2V0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICB0aHJvdyBuZXcgT3BlcmF0aW9uTm90U3VwcG9ydGVkKClcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGhcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGggPT09IDBcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBhcnJheSA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5LnB1c2godGhpcyQxLmFycmF5X1tpXSk7XG4gIH1cblxuICByZXR1cm4gYXJyYXlcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IEl0ZXJhdG9yXyQyKHRoaXMpXG59O1xuXG4vKipcbiAqIEBleHRlbmRzIHtqYXZhc2NyaXB0LnV0aWwuSXRlcmF0b3J9XG4gKiBAcGFyYW0ge2phdmFzY3JpcHQudXRpbC5UcmVlU2V0fSB0cmVlU2V0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBJdGVyYXRvcl8kMiA9IGZ1bmN0aW9uICh0cmVlU2V0KSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7amF2YXNjcmlwdC51dGlsLlRyZWVTZXR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnRyZWVTZXRfID0gdHJlZVNldDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnBvc2l0aW9uXyA9IDA7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5JdGVyYXRvcl8kMi5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMucG9zaXRpb25fID09PSB0aGlzLnRyZWVTZXRfLnNpemUoKSkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uKClcbiAgfVxuICByZXR1cm4gdGhpcy50cmVlU2V0Xy5hcnJheV9bdGhpcy5wb3NpdGlvbl8rK11cbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkl0ZXJhdG9yXyQyLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wb3NpdGlvbl8gPCB0aGlzLnRyZWVTZXRfLnNpemUoKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkl0ZXJhdG9yXyQyLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBPcGVyYXRpb25Ob3RTdXBwb3J0ZWQoKVxufTtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9BcnJheXMuaHRtbFxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIEFycmF5cyA9IGZ1bmN0aW9uIEFycmF5cyAoKSB7fTtcblxuQXJyYXlzLnNvcnQgPSBmdW5jdGlvbiBzb3J0ICgpIHtcbiAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gIHZhciBpO1xuICB2YXIgdDtcbiAgdmFyIGNvbXBhcmF0b3I7XG4gIHZhciBjb21wYXJlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEuY29tcGFyZVRvKGIpXG4gICAgfTtcbiAgICBhLnNvcnQoY29tcGFyZSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbXBhcmF0b3IgPSBhcmd1bWVudHNbMV07XG4gICAgY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gY29tcGFyYXRvclsnY29tcGFyZSddKGEsIGIpXG4gICAgfTtcbiAgICBhLnNvcnQoY29tcGFyZSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHQgPSBhLnNsaWNlKGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICB0LnNvcnQoKTtcbiAgICB2YXIgciA9IGEuc2xpY2UoMCwgYXJndW1lbnRzWzFdKS5jb25jYXQodCwgYS5zbGljZShhcmd1bWVudHNbMl0sIGEubGVuZ3RoKSk7XG4gICAgYS5zcGxpY2UoMCwgYS5sZW5ndGgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhLnB1c2gocltpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB0ID0gYS5zbGljZShhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgY29tcGFyYXRvciA9IGFyZ3VtZW50c1szXTtcbiAgICBjb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb21wYXJhdG9yWydjb21wYXJlJ10oYSwgYilcbiAgICB9O1xuICAgIHQuc29ydChjb21wYXJlKTtcbiAgICByID0gYS5zbGljZSgwLCBhcmd1bWVudHNbMV0pLmNvbmNhdCh0LCBhLnNsaWNlKGFyZ3VtZW50c1syXSwgYS5sZW5ndGgpKTtcbiAgICBhLnNwbGljZSgwLCBhLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGEucHVzaChyW2ldKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheUxpc3R9XG4gKi9cbkFycmF5cy5hc0xpc3QgPSBmdW5jdGlvbiBhc0xpc3QgKGFycmF5KSB7XG4gIHZhciBhcnJheUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5TGlzdC5hZGQoYXJyYXlbaV0pO1xuICB9XG4gIHJldHVybiBhcnJheUxpc3Rcbn07XG5cbnZhciBEaW1lbnNpb24gPSBmdW5jdGlvbiBEaW1lbnNpb24gKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTQgPSB7IFA6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTDogeyBjb25maWd1cmFibGU6IHRydWUgfSxBOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEZBTFNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFRSVUU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRE9OVENBUkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU1lNX0ZBTFNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNZTV9UUlVFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNZTV9ET05UQ0FSRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxTWU1fUDogeyBjb25maWd1cmFibGU6IHRydWUgfSxTWU1fTDogeyBjb25maWd1cmFibGU6IHRydWUgfSxTWU1fQTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5zdGF0aWNBY2Nlc3NvcnMkMTQuUC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuTC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuQS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuRkFMU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTEgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5UUlVFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0yIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuRE9OVENBUkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTMgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5TWU1fRkFMU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0YnIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuU1lNX1RSVUUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ1QnIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuU1lNX0RPTlRDQVJFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcqJyB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LlNZTV9QLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcwJyB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LlNZTV9MLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcxJyB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LlNZTV9BLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcyJyB9O1xuXG5EaW1lbnNpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5EaW1lbnNpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRGltZW5zaW9uXG59O1xuRGltZW5zaW9uLnRvRGltZW5zaW9uU3ltYm9sID0gZnVuY3Rpb24gdG9EaW1lbnNpb25TeW1ib2wgKGRpbWVuc2lvblZhbHVlKSB7XG4gIHN3aXRjaCAoZGltZW5zaW9uVmFsdWUpIHtcbiAgICBjYXNlIERpbWVuc2lvbi5GQUxTRTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uU1lNX0ZBTFNFXG4gICAgY2FzZSBEaW1lbnNpb24uVFJVRTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uU1lNX1RSVUVcbiAgICBjYXNlIERpbWVuc2lvbi5ET05UQ0FSRTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uU1lNX0RPTlRDQVJFXG4gICAgY2FzZSBEaW1lbnNpb24uUDpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uU1lNX1BcbiAgICBjYXNlIERpbWVuc2lvbi5MOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5TWU1fTFxuICAgIGNhc2UgRGltZW5zaW9uLkE6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlNZTV9BXG4gICAgZGVmYXVsdDpcbiAgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdVbmtub3duIGRpbWVuc2lvbiB2YWx1ZTogJyArIGRpbWVuc2lvblZhbHVlKVxufTtcbkRpbWVuc2lvbi50b0RpbWVuc2lvblZhbHVlID0gZnVuY3Rpb24gdG9EaW1lbnNpb25WYWx1ZSAoZGltZW5zaW9uU3ltYm9sKSB7XG4gIHN3aXRjaCAoQ2hhcmFjdGVyLnRvVXBwZXJDYXNlKGRpbWVuc2lvblN5bWJvbCkpIHtcbiAgICBjYXNlIERpbWVuc2lvbi5TWU1fRkFMU0U6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLkZBTFNFXG4gICAgY2FzZSBEaW1lbnNpb24uU1lNX1RSVUU6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlRSVUVcbiAgICBjYXNlIERpbWVuc2lvbi5TWU1fRE9OVENBUkU6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLkRPTlRDQVJFXG4gICAgY2FzZSBEaW1lbnNpb24uU1lNX1A6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlBcbiAgICBjYXNlIERpbWVuc2lvbi5TWU1fTDpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uTFxuICAgIGNhc2UgRGltZW5zaW9uLlNZTV9BOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5BXG4gICAgZGVmYXVsdDpcbiAgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdVbmtub3duIGRpbWVuc2lvbiBzeW1ib2w6ICcgKyBkaW1lbnNpb25TeW1ib2wpXG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggRGltZW5zaW9uLCBzdGF0aWNBY2Nlc3NvcnMkMTQgKTtcblxudmFyIEdlb21ldHJ5RmlsdGVyID0gZnVuY3Rpb24gR2VvbWV0cnlGaWx0ZXIgKCkge307XG5cbkdlb21ldHJ5RmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGdlb20pIHt9O1xuR2VvbWV0cnlGaWx0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUZpbHRlclxufTtcblxudmFyIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlciA9IGZ1bmN0aW9uIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlciAoKSB7fTtcblxuQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHNlcSwgaSkge307XG5Db29yZGluYXRlU2VxdWVuY2VGaWx0ZXIucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlci5wcm90b3R5cGUuaXNHZW9tZXRyeUNoYW5nZWQgPSBmdW5jdGlvbiBpc0dlb21ldHJ5Q2hhbmdlZCAoKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXJcbn07XG5cbnZhciBHZW9tZXRyeUNvbGxlY3Rpb24gPSAoZnVuY3Rpb24gKEdlb21ldHJ5JCQxKSB7XG4gIGZ1bmN0aW9uIEdlb21ldHJ5Q29sbGVjdGlvbiAoZ2VvbWV0cmllcywgZmFjdG9yeSkge1xuICAgIEdlb21ldHJ5JCQxLmNhbGwodGhpcywgZmFjdG9yeSk7XG4gICAgdGhpcy5fZ2VvbWV0cmllcyA9IGdlb21ldHJpZXMgfHwgW107XG5cbiAgICBpZiAoR2VvbWV0cnkkJDEuaGFzTnVsbEVsZW1lbnRzKHRoaXMuX2dlb21ldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdnZW9tZXRyaWVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50cycpXG4gICAgfVxuICB9XG5cbiAgaWYgKCBHZW9tZXRyeSQkMSApIEdlb21ldHJ5Q29sbGVjdGlvbi5fX3Byb3RvX18gPSBHZW9tZXRyeSQkMTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5JCQxICYmIEdlb21ldHJ5JCQxLnByb3RvdHlwZSApO1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VvbWV0cnlDb2xsZWN0aW9uO1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCA9IGZ1bmN0aW9uIGNvbXB1dGVFbnZlbG9wZUludGVybmFsICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBlbnZlbG9wZSA9IG5ldyBFbnZlbG9wZSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZW52ZWxvcGUuZXhwYW5kVG9JbmNsdWRlKHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5nZXRFbnZlbG9wZUludGVybmFsKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZW52ZWxvcGVcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRHZW9tZXRyeU4gPSBmdW5jdGlvbiBnZXRHZW9tZXRyeU4gKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1tuXVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5JCQxLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT05cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjb29yZGluYXRlcyA9IG5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpO1xuICAgIHZhciBrID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGRDb29yZGluYXRlcyA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZENvb3JkaW5hdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGsrKztcbiAgICAgICAgY29vcmRpbmF0ZXNba10gPSBjaGlsZENvb3JkaW5hdGVzW2pdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZXNcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gZ2V0QXJlYSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZWEgKz0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmdldEFyZWEoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZWFcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5lcXVhbHNFeGFjdCA9IGZ1bmN0aW9uIGVxdWFsc0V4YWN0ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHZhciBvdGhlckNvbGxlY3Rpb24gPSBvdGhlcjtcbiAgICAgIGlmICh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCAhPT0gb3RoZXJDb2xsZWN0aW9uLl9nZW9tZXRyaWVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMkMS5fZ2VvbWV0cmllc1tpXS5lcXVhbHNFeGFjdChvdGhlckNvbGxlY3Rpb24uX2dlb21ldHJpZXNbaV0sIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnkkJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5ub3JtYWxpemUoKTtcbiAgICB9XG4gICAgQXJyYXlzLnNvcnQodGhpcy5fZ2VvbWV0cmllcyk7XG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgcmV0dXJuIHRoaXMuX2dlb21ldHJpZXNbMF0uZ2V0Q29vcmRpbmF0ZSgpXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24gPSBmdW5jdGlvbiBnZXRCb3VuZGFyeURpbWVuc2lvbiAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZGltZW5zaW9uID0gRGltZW5zaW9uLkZBTFNFO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGltZW5zaW9uID0gTWF0aC5tYXgoZGltZW5zaW9uLCB0aGlzJDEuX2dlb21ldHJpZXNbaV0uZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSk7XG4gICAgfVxuICAgIHJldHVybiBkaW1lbnNpb25cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGRpbWVuc2lvbiA9IERpbWVuc2lvbi5GQUxTRTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRpbWVuc2lvbiA9IE1hdGgubWF4KGRpbWVuc2lvbiwgdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmdldERpbWVuc2lvbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvblxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3VtID0gMC4wO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3VtICs9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5nZXRMZW5ndGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE51bVBvaW50cyA9IGZ1bmN0aW9uIGdldE51bVBvaW50cyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbnVtUG9pbnRzID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG51bVBvaW50cyArPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uZ2V0TnVtUG9pbnRzKCk7XG4gICAgfVxuICAgIHJldHVybiBudW1Qb2ludHNcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXROdW1HZW9tZXRyaWVzID0gZnVuY3Rpb24gZ2V0TnVtR2VvbWV0cmllcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG4gPSB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtcbiAgICB2YXIgcmV2R2VvbXMgPSBuZXcgQXJyYXkobikuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldkdlb21zW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihyZXZHZW9tcylcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5jb21wYXJlVG9TYW1lQ2xhc3MgPSBmdW5jdGlvbiBjb21wYXJlVG9TYW1lQ2xhc3MgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBvID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRoZXNlRWxlbWVudHMgPSBuZXcgVHJlZVNldChBcnJheXMuYXNMaXN0KHRoaXMuX2dlb21ldHJpZXMpKTtcbiAgICAgIHZhciBvdGhlckVsZW1lbnRzID0gbmV3IFRyZWVTZXQoQXJyYXlzLmFzTGlzdChvLl9nZW9tZXRyaWVzKSk7XG4gICAgICByZXR1cm4gdGhpcy5jb21wYXJlKHRoZXNlRWxlbWVudHMsIG90aGVyRWxlbWVudHMpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgbyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNvbXAgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgZ2MgPSBvJDE7XG4gICAgICB2YXIgbjEgPSB0aGlzLmdldE51bUdlb21ldHJpZXMoKTtcbiAgICAgIHZhciBuMiA9IGdjLmdldE51bUdlb21ldHJpZXMoKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgbjEgJiYgaSA8IG4yKSB7XG4gICAgICAgIHZhciB0aGlzR2VvbSA9IHRoaXMkMS5nZXRHZW9tZXRyeU4oaSk7XG4gICAgICAgIHZhciBvdGhlckdlb20gPSBnYy5nZXRHZW9tZXRyeU4oaSk7XG4gICAgICAgIHZhciBob2xlQ29tcCA9IHRoaXNHZW9tLmNvbXBhcmVUb1NhbWVDbGFzcyhvdGhlckdlb20sIGNvbXApO1xuICAgICAgICBpZiAoaG9sZUNvbXAgIT09IDApIHsgcmV0dXJuIGhvbGVDb21wIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCBuMSkgeyByZXR1cm4gMSB9XG4gICAgICBpZiAoaSA8IG4yKSB7IHJldHVybiAtMSB9XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlRmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzJDEuX2dlb21ldHJpZXNbaV0uYXBwbHkoZmlsdGVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLl9nZW9tZXRyaWVzW2kkMV0uYXBwbHkoZmlsdGVyJDEpO1xuICAgICAgICBpZiAoZmlsdGVyJDEuaXNEb25lKCkpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyJDEuaXNHZW9tZXRyeUNoYW5nZWQoKSkgeyB0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpOyB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBHZW9tZXRyeUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZpbHRlciQyLmZpbHRlcih0aGlzKTtcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICB0aGlzJDEuX2dlb21ldHJpZXNbaSQyXS5hcHBseShmaWx0ZXIkMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBHZW9tZXRyeUNvbXBvbmVudEZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZpbHRlciQzLmZpbHRlcih0aGlzKTtcbiAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpJDMrKykge1xuICAgICAgICB0aGlzJDEuX2dlb21ldHJpZXNbaSQzXS5hcHBseShmaWx0ZXIkMyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICAgIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyk7XG4gICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCk7XG4gICAgcmV0dXJuIG51bGxcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBnYyA9IEdlb21ldHJ5JCQxLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGdjLl9nZW9tZXRyaWVzID0gbmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ2MuX2dlb21ldHJpZXNbaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uY2xvbmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGdjXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlUeXBlICgpIHtcbiAgICByZXR1cm4gJ0dlb21ldHJ5Q29sbGVjdGlvbidcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZ2VvbWV0cmllcyA9IG5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdlb21ldHJpZXNbaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uY29weSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzLCB0aGlzLl9mYWN0b3J5KVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCF0aGlzJDEuX2dlb21ldHJpZXNbaV0uaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb25cbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTU2OTQ3Mjc3MjYzOTUwMjE0NjcgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggR2VvbWV0cnlDb2xsZWN0aW9uLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uO1xufShHZW9tZXRyeSkpO1xuXG52YXIgTXVsdGlMaW5lU3RyaW5nID0gKGZ1bmN0aW9uIChHZW9tZXRyeUNvbGxlY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gTXVsdGlMaW5lU3RyaW5nICgpIHtcbiAgICBHZW9tZXRyeUNvbGxlY3Rpb24kJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICggR2VvbWV0cnlDb2xsZWN0aW9uJCQxICkgTXVsdGlMaW5lU3RyaW5nLl9fcHJvdG9fXyA9IEdlb21ldHJ5Q29sbGVjdGlvbiQkMTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5Q29sbGVjdGlvbiQkMSAmJiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aUxpbmVTdHJpbmc7XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkuU09SVElOREVYX01VTFRJTElORVNUUklOR1xuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcywgb3RoZXIsIHRvbGVyYW5jZSlcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCgpKSB7XG4gICAgICByZXR1cm4gRGltZW5zaW9uLkZBTFNFXG4gICAgfVxuICAgIHJldHVybiAwXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gMVxuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBuTGluZXMgPSB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDtcbiAgICB2YXIgcmV2TGluZXMgPSBuZXcgQXJyYXkobkxpbmVzKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV2TGluZXNbbkxpbmVzIC0gMSAtIGldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyhyZXZMaW5lcylcbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgICByZXR1cm4gbmV3IEJvdW5kYXJ5T3AodGhpcykuZ2V0Qm91bmRhcnkoKVxuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdNdWx0aUxpbmVTdHJpbmcnXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGxpbmVTdHJpbmdzID0gbmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpbmVTdHJpbmdzW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmNvcHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MsIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtMaW5lYWxdXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE11bHRpTGluZVN0cmluZ1xuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA4MTY2NjY1MTMyNDQ1NDMzNzQxIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE11bHRpTGluZVN0cmluZywgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIE11bHRpTGluZVN0cmluZztcbn0oR2VvbWV0cnlDb2xsZWN0aW9uKSk7XG5cbnZhciBCb3VuZGFyeU9wID0gZnVuY3Rpb24gQm91bmRhcnlPcCAoKSB7XG4gIHRoaXMuX2dlb20gPSBudWxsO1xuICB0aGlzLl9nZW9tRmFjdCA9IG51bGw7XG4gIHRoaXMuX2JuUnVsZSA9IG51bGw7XG4gIHRoaXMuX2VuZHBvaW50TWFwID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYm5SdWxlID0gQm91bmRhcnlOb2RlUnVsZS5NT0QyX0JPVU5EQVJZX1JVTEU7XG4gICAgdGhpcy5fZ2VvbSA9IGdlb207XG4gICAgdGhpcy5fZ2VvbUZhY3QgPSBnZW9tLmdldEZhY3RvcnkoKTtcbiAgICB0aGlzLl9iblJ1bGUgPSBiblJ1bGU7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGJuUnVsZSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2dlb20gPSBnZW9tJDE7XG4gICAgdGhpcy5fZ2VvbUZhY3QgPSBnZW9tJDEuZ2V0RmFjdG9yeSgpO1xuICAgIHRoaXMuX2JuUnVsZSA9IGJuUnVsZSQxO1xuICB9XG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiBib3VuZGFyeU11bHRpTGluZVN0cmluZyAobUxpbmUpIHtcbiAgaWYgKHRoaXMuX2dlb20uaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KClcbiAgfVxuICB2YXIgYmR5UHRzID0gdGhpcy5jb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyhtTGluZSk7XG4gIGlmIChiZHlQdHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvaW50KGJkeVB0c1swXSlcbiAgfVxuICByZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMoYmR5UHRzKVxufTtcbkJvdW5kYXJ5T3AucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICBpZiAodGhpcy5fZ2VvbSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHsgcmV0dXJuIHRoaXMuYm91bmRhcnlMaW5lU3RyaW5nKHRoaXMuX2dlb20pIH1cbiAgaWYgKHRoaXMuX2dlb20gaW5zdGFuY2VvZiBNdWx0aUxpbmVTdHJpbmcpIHsgcmV0dXJuIHRoaXMuYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcodGhpcy5fZ2VvbSkgfVxuICByZXR1cm4gdGhpcy5fZ2VvbS5nZXRCb3VuZGFyeSgpXG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuYm91bmRhcnlMaW5lU3RyaW5nID0gZnVuY3Rpb24gYm91bmRhcnlMaW5lU3RyaW5nIChsaW5lKSB7XG4gIGlmICh0aGlzLl9nZW9tLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpXG4gIH1cbiAgaWYgKGxpbmUuaXNDbG9zZWQoKSkge1xuICAgIHZhciBjbG9zZWRFbmRwb2ludE9uQm91bmRhcnkgPSB0aGlzLl9iblJ1bGUuaXNJbkJvdW5kYXJ5KDIpO1xuICAgIGlmIChjbG9zZWRFbmRwb2ludE9uQm91bmRhcnkpIHtcbiAgICAgIHJldHVybiBsaW5lLmdldFN0YXJ0UG9pbnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KFtsaW5lLmdldFN0YXJ0UG9pbnQoKSwgbGluZS5nZXRFbmRQb2ludCgpXSlcbn07XG5Cb3VuZGFyeU9wLnByb3RvdHlwZS5nZXRFbXB0eU11bHRpUG9pbnQgPSBmdW5jdGlvbiBnZXRFbXB0eU11bHRpUG9pbnQgKCkge1xuICByZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpXG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBjb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyAobUxpbmUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgYmR5UHRzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9lbmRwb2ludE1hcCA9IG5ldyBUcmVlTWFwKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbUxpbmUuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IG1MaW5lLmdldEdlb21ldHJ5TihpKTtcbiAgICBpZiAobGluZS5nZXROdW1Qb2ludHMoKSA9PT0gMCkgeyBjb250aW51ZSB9XG4gICAgdGhpcyQxLmFkZEVuZHBvaW50KGxpbmUuZ2V0Q29vcmRpbmF0ZU4oMCkpO1xuICAgIHRoaXMkMS5hZGRFbmRwb2ludChsaW5lLmdldENvb3JkaW5hdGVOKGxpbmUuZ2V0TnVtUG9pbnRzKCkgLSAxKSk7XG4gIH1cbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9lbmRwb2ludE1hcC5lbnRyeVNldCgpLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZW50cnkgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGNvdW50ZXIgPSBlbnRyeS5nZXRWYWx1ZSgpO1xuICAgIHZhciB2YWxlbmNlID0gY291bnRlci5jb3VudDtcbiAgICBpZiAodGhpcyQxLl9iblJ1bGUuaXNJbkJvdW5kYXJ5KHZhbGVuY2UpKSB7XG4gICAgICBiZHlQdHMuYWRkKGVudHJ5LmdldEtleSgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheXMudG9Db29yZGluYXRlQXJyYXkoYmR5UHRzKVxufTtcbkJvdW5kYXJ5T3AucHJvdG90eXBlLmFkZEVuZHBvaW50ID0gZnVuY3Rpb24gYWRkRW5kcG9pbnQgKHB0KSB7XG4gIHZhciBjb3VudGVyID0gdGhpcy5fZW5kcG9pbnRNYXAuZ2V0KHB0KTtcbiAgaWYgKGNvdW50ZXIgPT09IG51bGwpIHtcbiAgICBjb3VudGVyID0gbmV3IENvdW50ZXIoKTtcbiAgICB0aGlzLl9lbmRwb2ludE1hcC5wdXQocHQsIGNvdW50ZXIpO1xuICB9XG4gIGNvdW50ZXIuY291bnQrKztcbn07XG5Cb3VuZGFyeU9wLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCb3VuZGFyeU9wXG59O1xuQm91bmRhcnlPcC5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYm9wID0gbmV3IEJvdW5kYXJ5T3AoZyk7XG4gICAgcmV0dXJuIGJvcC5nZXRCb3VuZGFyeSgpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGJuUnVsZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgYm9wJDEgPSBuZXcgQm91bmRhcnlPcChnJDEsIGJuUnVsZSk7XG4gICAgcmV0dXJuIGJvcCQxLmdldEJvdW5kYXJ5KClcbiAgfVxufTtcblxudmFyIENvdW50ZXIgPSBmdW5jdGlvbiBDb3VudGVyICgpIHtcbiAgdGhpcy5jb3VudCA9IG51bGw7XG59O1xuQ291bnRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvdW50ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ291bnRlclxufTtcblxuLy8gYm91bmRhcnlcblxuZnVuY3Rpb24gUHJpbnRTdHJlYW0gKCkge31cblxuZnVuY3Rpb24gU3RyaW5nUmVhZGVyICgpIHt9XG5cbnZhciBEZWNpbWFsRm9ybWF0ID0gZnVuY3Rpb24gRGVjaW1hbEZvcm1hdCAoKSB7fTtcblxuZnVuY3Rpb24gQnl0ZUFycmF5T3V0cHV0U3RyZWFtICgpIHt9XG5cbmZ1bmN0aW9uIElPRXhjZXB0aW9uICgpIHt9XG5cbmZ1bmN0aW9uIExpbmVOdW1iZXJSZWFkZXIgKCkge31cblxudmFyIFN0cmluZ1V0aWwgPSBmdW5jdGlvbiBTdHJpbmdVdGlsICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDE1ID0geyBORVdMSU5FOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNJTVBMRV9PUkRJTkFURV9GT1JNQVQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuU3RyaW5nVXRpbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblN0cmluZ1V0aWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU3RyaW5nVXRpbFxufTtcblN0cmluZ1V0aWwuY2hhcnMgPSBmdW5jdGlvbiBjaGFycyAoYywgbikge1xuICB2YXIgY2ggPSBuZXcgQXJyYXkobikuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICBjaFtpXSA9IGM7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhjaClcbn07XG5TdHJpbmdVdGlsLmdldFN0YWNrVHJhY2UgPSBmdW5jdGlvbiBnZXRTdGFja1RyYWNlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgdCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb3MgPSBuZXcgQnl0ZUFycmF5T3V0cHV0U3RyZWFtKCk7XG4gICAgdmFyIHBzID0gbmV3IFByaW50U3RyZWFtKG9zKTtcbiAgICB0LnByaW50U3RhY2tUcmFjZShwcyk7XG4gICAgcmV0dXJuIG9zLnRvU3RyaW5nKClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHQkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZGVwdGggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHN0YWNrVHJhY2UgPSAnJztcbiAgICB2YXIgc3RyaW5nUmVhZGVyID0gbmV3IFN0cmluZ1JlYWRlcihTdHJpbmdVdGlsLmdldFN0YWNrVHJhY2UodCQxKSk7XG4gICAgdmFyIGxpbmVOdW1iZXJSZWFkZXIgPSBuZXcgTGluZU51bWJlclJlYWRlcihzdHJpbmdSZWFkZXIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwdGg7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhY2tUcmFjZSArPSBsaW5lTnVtYmVyUmVhZGVyLnJlYWRMaW5lKCkgKyBTdHJpbmdVdGlsLk5FV0xJTkU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgSU9FeGNlcHRpb24pIHtcbiAgICAgICAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKTtcbiAgICAgICAgfSBlbHNlIHsgdGhyb3cgZSB9XG4gICAgICB9IGZpbmFsbHkge31cbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrVHJhY2VcbiAgfVxufTtcblN0cmluZ1V0aWwuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAocywgc2VwYXJhdG9yKSB7XG4gIHZhciBzZXBhcmF0b3JsZW4gPSBzZXBhcmF0b3IubGVuZ3RoO1xuICB2YXIgdG9rZW5MaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgdG1wU3RyaW5nID0gJycgKyBzO1xuICB2YXIgcG9zID0gdG1wU3RyaW5nLmluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgd2hpbGUgKHBvcyA+PSAwKSB7XG4gICAgdmFyIHRva2VuID0gdG1wU3RyaW5nLnN1YnN0cmluZygwLCBwb3MpO1xuICAgIHRva2VuTGlzdC5hZGQodG9rZW4pO1xuICAgIHRtcFN0cmluZyA9IHRtcFN0cmluZy5zdWJzdHJpbmcocG9zICsgc2VwYXJhdG9ybGVuKTtcbiAgICBwb3MgPSB0bXBTdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IpO1xuICB9XG4gIGlmICh0bXBTdHJpbmcubGVuZ3RoID4gMCkgeyB0b2tlbkxpc3QuYWRkKHRtcFN0cmluZyk7IH1cbiAgdmFyIHJlcyA9IG5ldyBBcnJheSh0b2tlbkxpc3Quc2l6ZSgpKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgIHJlc1tpXSA9IHRva2VuTGlzdC5nZXQoaSk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufTtcblN0cmluZ1V0aWwudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGQgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIFN0cmluZ1V0aWwuU0lNUExFX09SRElOQVRFX0ZPUk1BVC5mb3JtYXQoZClcbiAgfVxufTtcblN0cmluZ1V0aWwuc3BhY2VzID0gZnVuY3Rpb24gc3BhY2VzIChuKSB7XG4gIHJldHVybiBTdHJpbmdVdGlsLmNoYXJzKCcgJywgbilcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMTUuTkVXTElORS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBTeXN0ZW0uZ2V0UHJvcGVydHkoJ2xpbmUuc2VwYXJhdG9yJykgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNS5TSU1QTEVfT1JESU5BVEVfRk9STUFULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBEZWNpbWFsRm9ybWF0KCcwLiMnKSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU3RyaW5nVXRpbCwgc3RhdGljQWNjZXNzb3JzJDE1ICk7XG5cbnZhciBDb29yZGluYXRlU2VxdWVuY2VzID0gZnVuY3Rpb24gQ29vcmRpbmF0ZVNlcXVlbmNlcyAoKSB7fTtcblxuQ29vcmRpbmF0ZVNlcXVlbmNlcy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlc1xufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuY29weUNvb3JkID0gZnVuY3Rpb24gY29weUNvb3JkIChzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcykge1xuICB2YXIgbWluRGltID0gTWF0aC5taW4oc3JjLmdldERpbWVuc2lvbigpLCBkZXN0LmdldERpbWVuc2lvbigpKTtcbiAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgbWluRGltOyBkaW0rKykge1xuICAgIGRlc3Quc2V0T3JkaW5hdGUoZGVzdFBvcywgZGltLCBzcmMuZ2V0T3JkaW5hdGUoc3JjUG9zLCBkaW0pKTtcbiAgfVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuaXNSaW5nID0gZnVuY3Rpb24gaXNSaW5nIChzZXEpIHtcbiAgdmFyIG4gPSBzZXEuc2l6ZSgpO1xuICBpZiAobiA9PT0gMCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChuIDw9IDMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHNlcS5nZXRPcmRpbmF0ZSgwLCBDb29yZGluYXRlU2VxdWVuY2UuWCkgPT09IHNlcS5nZXRPcmRpbmF0ZShuIC0gMSwgQ29vcmRpbmF0ZVNlcXVlbmNlLlgpICYmIHNlcS5nZXRPcmRpbmF0ZSgwLCBDb29yZGluYXRlU2VxdWVuY2UuWSkgPT09IHNlcS5nZXRPcmRpbmF0ZShuIC0gMSwgQ29vcmRpbmF0ZVNlcXVlbmNlLlkpXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5pc0VxdWFsID0gZnVuY3Rpb24gaXNFcXVhbCAoY3MxLCBjczIpIHtcbiAgdmFyIGNzMVNpemUgPSBjczEuc2l6ZSgpO1xuICB2YXIgY3MyU2l6ZSA9IGNzMi5zaXplKCk7XG4gIGlmIChjczFTaXplICE9PSBjczJTaXplKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBkaW0gPSBNYXRoLm1pbihjczEuZ2V0RGltZW5zaW9uKCksIGNzMi5nZXREaW1lbnNpb24oKSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY3MxU2l6ZTsgaSsrKSB7XG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykge1xuICAgICAgdmFyIHYxID0gY3MxLmdldE9yZGluYXRlKGksIGQpO1xuICAgICAgdmFyIHYyID0gY3MyLmdldE9yZGluYXRlKGksIGQpO1xuICAgICAgaWYgKGNzMS5nZXRPcmRpbmF0ZShpLCBkKSA9PT0gY3MyLmdldE9yZGluYXRlKGksIGQpKSB7IGNvbnRpbnVlIH1cbiAgICAgIGlmIChEb3VibGUuaXNOYU4odjEpICYmIERvdWJsZS5pc05hTih2MikpIHsgY29udGludWUgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKGZhY3QsIHNlcSwgc2l6ZSkge1xuICB2YXIgbmV3c2VxID0gZmFjdC5jcmVhdGUoc2l6ZSwgc2VxLmdldERpbWVuc2lvbigpKTtcbiAgdmFyIG4gPSBzZXEuc2l6ZSgpO1xuICBDb29yZGluYXRlU2VxdWVuY2VzLmNvcHkoc2VxLCAwLCBuZXdzZXEsIDAsIG4pO1xuICBpZiAobiA+IDApIHtcbiAgICBmb3IgKHZhciBpID0gbjsgaSA8IHNpemU7IGkrKykgeyBDb29yZGluYXRlU2VxdWVuY2VzLmNvcHkoc2VxLCBuIC0gMSwgbmV3c2VxLCBpLCAxKTsgfVxuICB9XG4gIHJldHVybiBuZXdzZXFcbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlIChzZXEpIHtcbiAgdmFyIGxhc3QgPSBzZXEuc2l6ZSgpIC0gMTtcbiAgdmFyIG1pZCA9IE1hdGgudHJ1bmMobGFzdCAvIDIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBtaWQ7IGkrKykge1xuICAgIENvb3JkaW5hdGVTZXF1ZW5jZXMuc3dhcChzZXEsIGksIGxhc3QgLSBpKTtcbiAgfVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuc3dhcCA9IGZ1bmN0aW9uIHN3YXAgKHNlcSwgaSwgaikge1xuICBpZiAoaSA9PT0gaikgeyByZXR1cm4gbnVsbCB9XG4gIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IHNlcS5nZXREaW1lbnNpb24oKTsgZGltKyspIHtcbiAgICB2YXIgdG1wID0gc2VxLmdldE9yZGluYXRlKGksIGRpbSk7XG4gICAgc2VxLnNldE9yZGluYXRlKGksIGRpbSwgc2VxLmdldE9yZGluYXRlKGosIGRpbSkpO1xuICAgIHNlcS5zZXRPcmRpbmF0ZShqLCBkaW0sIHRtcCk7XG4gIH1cbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcywgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBDb29yZGluYXRlU2VxdWVuY2VzLmNvcHlDb29yZChzcmMsIHNyY1BvcyArIGksIGRlc3QsIGRlc3RQb3MgKyBpKTtcbiAgfVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGNzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzaXplID0gY3Muc2l6ZSgpO1xuICAgIGlmIChzaXplID09PSAwKSB7IHJldHVybiAnKCknIH1cbiAgICB2YXIgZGltID0gY3MuZ2V0RGltZW5zaW9uKCk7XG4gICAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgICBidWYuYXBwZW5kKCcoJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkgeyBidWYuYXBwZW5kKCcgJyk7IH1cbiAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHtcbiAgICAgICAgaWYgKGQgPiAwKSB7IGJ1Zi5hcHBlbmQoJywnKTsgfVxuICAgICAgICBidWYuYXBwZW5kKFN0cmluZ1V0aWwudG9TdHJpbmcoY3MuZ2V0T3JkaW5hdGUoaSwgZCkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmLmFwcGVuZCgnKScpO1xuICAgIHJldHVybiBidWYudG9TdHJpbmcoKVxuICB9XG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5lbnN1cmVWYWxpZFJpbmcgPSBmdW5jdGlvbiBlbnN1cmVWYWxpZFJpbmcgKGZhY3QsIHNlcSkge1xuICB2YXIgbiA9IHNlcS5zaXplKCk7XG4gIGlmIChuID09PSAwKSB7IHJldHVybiBzZXEgfVxuICBpZiAobiA8PSAzKSB7IHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VzLmNyZWF0ZUNsb3NlZFJpbmcoZmFjdCwgc2VxLCA0KSB9XG4gIHZhciBpc0Nsb3NlZCA9IHNlcS5nZXRPcmRpbmF0ZSgwLCBDb29yZGluYXRlU2VxdWVuY2UuWCkgPT09IHNlcS5nZXRPcmRpbmF0ZShuIC0gMSwgQ29vcmRpbmF0ZVNlcXVlbmNlLlgpICYmIHNlcS5nZXRPcmRpbmF0ZSgwLCBDb29yZGluYXRlU2VxdWVuY2UuWSkgPT09IHNlcS5nZXRPcmRpbmF0ZShuIC0gMSwgQ29vcmRpbmF0ZVNlcXVlbmNlLlkpO1xuICBpZiAoaXNDbG9zZWQpIHsgcmV0dXJuIHNlcSB9XG4gIHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VzLmNyZWF0ZUNsb3NlZFJpbmcoZmFjdCwgc2VxLCBuICsgMSlcbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLmNyZWF0ZUNsb3NlZFJpbmcgPSBmdW5jdGlvbiBjcmVhdGVDbG9zZWRSaW5nIChmYWN0LCBzZXEsIHNpemUpIHtcbiAgdmFyIG5ld3NlcSA9IGZhY3QuY3JlYXRlKHNpemUsIHNlcS5nZXREaW1lbnNpb24oKSk7XG4gIHZhciBuID0gc2VxLnNpemUoKTtcbiAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5jb3B5KHNlcSwgMCwgbmV3c2VxLCAwLCBuKTtcbiAgZm9yICh2YXIgaSA9IG47IGkgPCBzaXplOyBpKyspIHsgQ29vcmRpbmF0ZVNlcXVlbmNlcy5jb3B5KHNlcSwgMCwgbmV3c2VxLCBpLCAxKTsgfVxuICByZXR1cm4gbmV3c2VxXG59O1xuXG52YXIgTGluZVN0cmluZyA9IChmdW5jdGlvbiAoR2VvbWV0cnkkJDEpIHtcbiAgZnVuY3Rpb24gTGluZVN0cmluZyAocG9pbnRzLCBmYWN0b3J5KSB7XG4gICAgR2VvbWV0cnkkJDEuY2FsbCh0aGlzLCBmYWN0b3J5KTtcbiAgICB0aGlzLl9wb2ludHMgPSBudWxsO1xuICAgIHRoaXMuaW5pdChwb2ludHMpO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeSQkMSApIExpbmVTdHJpbmcuX19wcm90b19fID0gR2VvbWV0cnkkJDE7XG4gIExpbmVTdHJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkkJDEgJiYgR2VvbWV0cnkkJDEucHJvdG90eXBlICk7XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZVN0cmluZztcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmNvbXB1dGVFbnZlbG9wZUludGVybmFsID0gZnVuY3Rpb24gY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG5ldyBFbnZlbG9wZSgpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wb2ludHMuZXhwYW5kRW52ZWxvcGUobmV3IEVudmVsb3BlKCkpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmlzUmluZyA9IGZ1bmN0aW9uIGlzUmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDbG9zZWQoKSAmJiB0aGlzLmlzU2ltcGxlKClcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkkJDEuU09SVElOREVYX0xJTkVTVFJJTkdcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cy50b0Nvb3JkaW5hdGVBcnJheSgpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3Mob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdmFyIG90aGVyTGluZVN0cmluZyA9IG90aGVyO1xuICAgICAgaWYgKHRoaXMuX3BvaW50cy5zaXplKCkgIT09IG90aGVyTGluZVN0cmluZy5fcG9pbnRzLnNpemUoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcG9pbnRzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcyQxLmVxdWFsKHRoaXMkMS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaSksIG90aGVyTGluZVN0cmluZy5fcG9pbnRzLmdldENvb3JkaW5hdGUoaSksIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnkkJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLnRydW5jKHRoaXMuX3BvaW50cy5zaXplKCkgLyAyKTsgaSsrKSB7XG4gICAgICB2YXIgaiA9IHRoaXMkMS5fcG9pbnRzLnNpemUoKSAtIDEgLSBpO1xuICAgICAgaWYgKCF0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGkpLmVxdWFscyh0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGopKSkge1xuICAgICAgICBpZiAodGhpcyQxLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKS5jb21wYXJlVG8odGhpcyQxLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShqKSkgPiAwKSB7XG4gICAgICAgICAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5yZXZlcnNlKHRoaXMkMS5fcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKDApXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgIHJldHVybiBEaW1lbnNpb24uRkFMU0VcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZU4oMCkuZXF1YWxzMkQodGhpcy5nZXRDb29yZGluYXRlTih0aGlzLmdldE51bVBvaW50cygpIC0gMSkpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldEVuZFBvaW50ID0gZnVuY3Rpb24gZ2V0RW5kUG9pbnQgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnROKHRoaXMuZ2V0TnVtUG9pbnRzKCkgLSAxKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICAgIHJldHVybiAxXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIENHQWxnb3JpdGhtcy5jb21wdXRlTGVuZ3RoKHRoaXMuX3BvaW50cylcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0TnVtUG9pbnRzID0gZnVuY3Rpb24gZ2V0TnVtUG9pbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzLnNpemUoKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgdmFyIHNlcSA9IHRoaXMuX3BvaW50cy5jb3B5KCk7XG4gICAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5yZXZlcnNlKHNlcSk7XG4gICAgdmFyIHJldkxpbmUgPSB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHNlcSk7XG4gICAgcmV0dXJuIHJldkxpbmVcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuY29tcGFyZVRvU2FtZUNsYXNzID0gZnVuY3Rpb24gY29tcGFyZVRvU2FtZUNsYXNzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgbyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsaW5lID0gbztcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBqID0gMDtcbiAgICAgIHdoaWxlIChpIDwgdGhpcy5fcG9pbnRzLnNpemUoKSAmJiBqIDwgbGluZS5fcG9pbnRzLnNpemUoKSkge1xuICAgICAgICB2YXIgY29tcGFyaXNvbiA9IHRoaXMkMS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaSkuY29tcGFyZVRvKGxpbmUuX3BvaW50cy5nZXRDb29yZGluYXRlKGopKTtcbiAgICAgICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gY29tcGFyaXNvblxuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCB0aGlzLl9wb2ludHMuc2l6ZSgpKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgICBpZiAoaiA8IGxpbmUuX3BvaW50cy5zaXplKCkpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG8kMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjb21wID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGxpbmUkMSA9IG8kMTtcbiAgICAgIHJldHVybiBjb21wLmNvbXBhcmUodGhpcy5fcG9pbnRzLCBsaW5lJDEuX3BvaW50cylcbiAgICB9XG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wb2ludHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgZmlsdGVyLmZpbHRlcih0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICh0aGlzLl9wb2ludHMuc2l6ZSgpID09PSAwKSB7IHJldHVybiBudWxsIH1cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuX3BvaW50cy5zaXplKCk7IGkkMSsrKSB7XG4gICAgICAgIGZpbHRlciQxLmZpbHRlcih0aGlzJDEuX3BvaW50cywgaSQxKTtcbiAgICAgICAgaWYgKGZpbHRlciQxLmlzRG9uZSgpKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXIkMS5pc0dlb21ldHJ5Q2hhbmdlZCgpKSB7IHRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCk7IH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIEdlb21ldHJ5RmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgZmlsdGVyJDIuZmlsdGVyKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyJDMgPSBhcmd1bWVudHNbMF07XG4gICAgICBmaWx0ZXIkMy5maWx0ZXIodGhpcyk7XG4gICAgfVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgICByZXR1cm4gbmV3IEJvdW5kYXJ5T3AodGhpcykuZ2V0Qm91bmRhcnkoKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5pc0VxdWl2YWxlbnRDbGFzcyA9IGZ1bmN0aW9uIGlzRXF1aXZhbGVudENsYXNzIChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIExpbmVTdHJpbmdcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIGxzID0gR2VvbWV0cnkkJDEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XG4gICAgbHMuX3BvaW50cyA9IHRoaXMuX3BvaW50cy5jbG9uZSgpO1xuICAgIHJldHVybiBsc1xuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlTiA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVOIChuKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cy5nZXRDb29yZGluYXRlKG4pXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdMaW5lU3RyaW5nJ1xuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHRoaXMuX3BvaW50cy5jb3B5KCksIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVTZXF1ZW5jZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50c1xuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cy5zaXplKCkgPT09IDBcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKHBvaW50cykge1xuICAgIGlmIChwb2ludHMgPT09IG51bGwpIHtcbiAgICAgIHBvaW50cyA9IHRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pO1xuICAgIH1cbiAgICBpZiAocG9pbnRzLnNpemUoKSA9PT0gMSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVTdHJpbmcgKGZvdW5kICcgKyBwb2ludHMuc2l6ZSgpICsgJyAtIG11c3QgYmUgMCBvciA+PSAyKScpXG4gICAgfVxuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaXNDb29yZGluYXRlID0gZnVuY3Rpb24gaXNDb29yZGluYXRlIChwdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wb2ludHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgIGlmICh0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGkpLmVxdWFscyhwdCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldFN0YXJ0UG9pbnQgPSBmdW5jdGlvbiBnZXRTdGFydFBvaW50ICgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBvaW50TigwKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRQb2ludE4gPSBmdW5jdGlvbiBnZXRQb2ludE4gKG4pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUobikpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbTGluZWFsXVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTGluZVN0cmluZ1xuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzMTEwNjY5ODI4MDY1MzY1NTYwIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExpbmVTdHJpbmcsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBMaW5lU3RyaW5nO1xufShHZW9tZXRyeSkpO1xuXG52YXIgUHVudGFsID0gZnVuY3Rpb24gUHVudGFsICgpIHt9O1xuXG5QdW50YWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5QdW50YWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUHVudGFsXG59O1xuXG52YXIgUG9pbnQgPSAoZnVuY3Rpb24gKEdlb21ldHJ5JCQxKSB7XG4gIGZ1bmN0aW9uIFBvaW50IChjb29yZGluYXRlcywgZmFjdG9yeSkge1xuICAgIEdlb21ldHJ5JCQxLmNhbGwodGhpcywgZmFjdG9yeSk7XG4gICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcyB8fCBudWxsO1xuICAgIHRoaXMuaW5pdCh0aGlzLl9jb29yZGluYXRlcyk7XG4gIH1cblxuICBpZiAoIEdlb21ldHJ5JCQxICkgUG9pbnQuX19wcm90b19fID0gR2VvbWV0cnkkJDE7XG4gIFBvaW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5JCQxICYmIEdlb21ldHJ5JCQxLnByb3RvdHlwZSApO1xuICBQb2ludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQb2ludDtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIFBvaW50LnByb3RvdHlwZS5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCA9IGZ1bmN0aW9uIGNvbXB1dGVFbnZlbG9wZUludGVybmFsICgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBuZXcgRW52ZWxvcGUoKVxuICAgIH1cbiAgICB2YXIgZW52ID0gbmV3IEVudmVsb3BlKCk7XG4gICAgZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLl9jb29yZGluYXRlcy5nZXRYKDApLCB0aGlzLl9jb29yZGluYXRlcy5nZXRZKDApKTtcbiAgICByZXR1cm4gZW52XG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRTb3J0SW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0SW5kZXggKCkge1xuICAgIHJldHVybiBHZW9tZXRyeSQkMS5TT1JUSU5ERVhfUE9JTlRcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IFtdIDogW3RoaXMuZ2V0Q29vcmRpbmF0ZSgpXVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZXF1YWxzRXhhY3QgPSBmdW5jdGlvbiBlcXVhbHNFeGFjdCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3Mob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpICYmIG90aGVyLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpICE9PSBvdGhlci5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lcXVhbChvdGhlci5nZXRDb29yZGluYXRlKCksIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLCB0b2xlcmFuY2UpXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5JCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSAoKSB7fTtcbiAgUG9pbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXMuc2l6ZSgpICE9PSAwID8gdGhpcy5fY29vcmRpbmF0ZXMuZ2V0Q29vcmRpbmF0ZSgwKSA6IG51bGxcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIHJldHVybiBEaW1lbnNpb24uRkFMU0VcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDBcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldE51bVBvaW50cyA9IGZ1bmN0aW9uIGdldE51bVBvaW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gMCA6IDFcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb3B5KClcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYICgpIHtcbiAgICBpZiAodGhpcy5nZXRDb29yZGluYXRlKCkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0WCBjYWxsZWQgb24gZW1wdHkgUG9pbnQnKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueFxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuY29tcGFyZVRvU2FtZUNsYXNzID0gZnVuY3Rpb24gY29tcGFyZVRvU2FtZUNsYXNzICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHBvaW50JDEgPSBvdGhlcjtcbiAgICAgIHJldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8ocG9pbnQkMS5nZXRDb29yZGluYXRlKCkpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjb21wID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHBvaW50ID0gb3RoZXIkMTtcbiAgICAgIHJldHVybiBjb21wLmNvbXBhcmUodGhpcy5fY29vcmRpbmF0ZXMsIHBvaW50Ll9jb29yZGluYXRlcylcbiAgICB9XG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5ICgpIHtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIGZpbHRlci5maWx0ZXIodGhpcy5nZXRDb29yZGluYXRlKCkpO1xuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgICAgIGZpbHRlciQxLmZpbHRlcih0aGlzLl9jb29yZGluYXRlcywgMCk7XG4gICAgICBpZiAoZmlsdGVyJDEuaXNHZW9tZXRyeUNoYW5nZWQoKSkgeyB0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpOyB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBHZW9tZXRyeUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZpbHRlciQyLmZpbHRlcih0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIEdlb21ldHJ5Q29tcG9uZW50RmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQzID0gYXJndW1lbnRzWzBdO1xuICAgICAgZmlsdGVyJDMuZmlsdGVyKHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbClcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciBwID0gR2VvbWV0cnkkJDEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XG4gICAgcC5fY29vcmRpbmF0ZXMgPSB0aGlzLl9jb29yZGluYXRlcy5jbG9uZSgpO1xuICAgIHJldHVybiBwXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnUG9pbnQnXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl9jb29yZGluYXRlcy5jb3B5KCksIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRDb29yZGluYXRlU2VxdWVuY2UgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlU2VxdWVuY2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1xuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkgKCkge1xuICAgIGlmICh0aGlzLmdldENvb3JkaW5hdGUoKSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRZIGNhbGxlZCBvbiBlbXB0eSBQb2ludCcpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS55XG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzLnNpemUoKSA9PT0gMFxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGNvb3JkaW5hdGVzKSB7XG4gICAgaWYgKGNvb3JkaW5hdGVzID09PSBudWxsKSB7XG4gICAgICBjb29yZGluYXRlcyA9IHRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pO1xuICAgIH1cbiAgICBBc3NlcnQuaXNUcnVlKGNvb3JkaW5hdGVzLnNpemUoKSA8PSAxKTtcbiAgICB0aGlzLl9jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuICB9O1xuICBQb2ludC5wcm90b3R5cGUuaXNTaW1wbGUgPSBmdW5jdGlvbiBpc1NpbXBsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbUHVudGFsXVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFBvaW50XG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQ5MDIwMjI3MDI3NDY2MTQ1NzAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggUG9pbnQsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBQb2ludDtcbn0oR2VvbWV0cnkpKTtcblxudmFyIFBvbHlnb25hbCA9IGZ1bmN0aW9uIFBvbHlnb25hbCAoKSB7fTtcblxuUG9seWdvbmFsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9seWdvbmFsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvbHlnb25hbFxufTtcblxudmFyIFBvbHlnb24gPSAoZnVuY3Rpb24gKEdlb21ldHJ5JCQxKSB7XG4gIGZ1bmN0aW9uIFBvbHlnb24gKHNoZWxsLCBob2xlcywgZmFjdG9yeSkge1xuICAgIEdlb21ldHJ5JCQxLmNhbGwodGhpcywgZmFjdG9yeSk7XG4gICAgdGhpcy5fc2hlbGwgPSBudWxsO1xuICAgIHRoaXMuX2hvbGVzID0gbnVsbDtcbiAgICBpZiAoc2hlbGwgPT09IG51bGwpIHtcbiAgICAgIHNoZWxsID0gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZygpO1xuICAgIH1cbiAgICBpZiAoaG9sZXMgPT09IG51bGwpIHtcbiAgICAgIGhvbGVzID0gW107XG4gICAgfVxuICAgIGlmIChHZW9tZXRyeSQkMS5oYXNOdWxsRWxlbWVudHMoaG9sZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdob2xlcyBtdXN0IG5vdCBjb250YWluIG51bGwgZWxlbWVudHMnKVxuICAgIH1cbiAgICBpZiAoc2hlbGwuaXNFbXB0eSgpICYmIEdlb21ldHJ5JCQxLmhhc05vbkVtcHR5RWxlbWVudHMoaG9sZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdzaGVsbCBpcyBlbXB0eSBidXQgaG9sZXMgYXJlIG5vdCcpXG4gICAgfVxuICAgIHRoaXMuX3NoZWxsID0gc2hlbGw7XG4gICAgdGhpcy5faG9sZXMgPSBob2xlcztcbiAgfVxuXG4gIGlmICggR2VvbWV0cnkkJDEgKSBQb2x5Z29uLl9fcHJvdG9fXyA9IEdlb21ldHJ5JCQxO1xuICBQb2x5Z29uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5JCQxICYmIEdlb21ldHJ5JCQxLnByb3RvdHlwZSApO1xuICBQb2x5Z29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvbHlnb247XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5jb21wdXRlRW52ZWxvcGVJbnRlcm5hbCA9IGZ1bmN0aW9uIGNvbXB1dGVFbnZlbG9wZUludGVybmFsICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5JCQxLlNPUlRJTkRFWF9QT0xZR09OXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gbmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCk7XG4gICAgdmFyIGsgPSAtMTtcbiAgICB2YXIgc2hlbGxDb29yZGluYXRlcyA9IHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBzaGVsbENvb3JkaW5hdGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgICBrKys7XG4gICAgICBjb29yZGluYXRlc1trXSA9IHNoZWxsQ29vcmRpbmF0ZXNbeF07XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZENvb3JkaW5hdGVzID0gdGhpcyQxLl9ob2xlc1tpXS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZENvb3JkaW5hdGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGsrKztcbiAgICAgICAgY29vcmRpbmF0ZXNba10gPSBjaGlsZENvb3JkaW5hdGVzW2pdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29vcmRpbmF0ZXNcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uIGdldEFyZWEgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFyZWEgPSAwLjA7XG4gICAgYXJlYSArPSBNYXRoLmFicyhDR0FsZ29yaXRobXMuc2lnbmVkQXJlYSh0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZWEgLT0gTWF0aC5hYnMoQ0dBbGdvcml0aG1zLnNpZ25lZEFyZWEodGhpcyQxLl9ob2xlc1tpXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJlYVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5pc1JlY3RhbmdsZSA9IGZ1bmN0aW9uIGlzUmVjdGFuZ2xlICgpIHtcbiAgICBpZiAodGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSAhPT0gMCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0aGlzLl9zaGVsbCA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0aGlzLl9zaGVsbC5nZXROdW1Qb2ludHMoKSAhPT0gNSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBzZXEgPSB0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKTtcbiAgICB2YXIgZW52ID0gdGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1OyBpKyspIHtcbiAgICAgIHZhciB4ID0gc2VxLmdldFgoaSk7XG4gICAgICBpZiAoISh4ID09PSBlbnYuZ2V0TWluWCgpIHx8IHggPT09IGVudi5nZXRNYXhYKCkpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgeSA9IHNlcS5nZXRZKGkpO1xuICAgICAgaWYgKCEoeSA9PT0gZW52LmdldE1pblkoKSB8fCB5ID09PSBlbnYuZ2V0TWF4WSgpKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIH1cbiAgICB2YXIgcHJldlggPSBzZXEuZ2V0WCgwKTtcbiAgICB2YXIgcHJldlkgPSBzZXEuZ2V0WSgwKTtcbiAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPD0gNDsgaSQxKyspIHtcbiAgICAgIHZhciB4JDEgPSBzZXEuZ2V0WChpJDEpO1xuICAgICAgdmFyIHkkMSA9IHNlcS5nZXRZKGkkMSk7XG4gICAgICB2YXIgeENoYW5nZWQgPSB4JDEgIT09IHByZXZYO1xuICAgICAgdmFyIHlDaGFuZ2VkID0geSQxICE9PSBwcmV2WTtcbiAgICAgIGlmICh4Q2hhbmdlZCA9PT0geUNoYW5nZWQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHByZXZYID0geCQxO1xuICAgICAgcHJldlkgPSB5JDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3Mob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdmFyIG90aGVyUG9seWdvbiA9IG90aGVyO1xuICAgICAgdmFyIHRoaXNTaGVsbCA9IHRoaXMuX3NoZWxsO1xuICAgICAgdmFyIG90aGVyUG9seWdvblNoZWxsID0gb3RoZXJQb2x5Z29uLl9zaGVsbDtcbiAgICAgIGlmICghdGhpc1NoZWxsLmVxdWFsc0V4YWN0KG90aGVyUG9seWdvblNoZWxsLCB0b2xlcmFuY2UpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2hvbGVzLmxlbmd0aCAhPT0gb3RoZXJQb2x5Z29uLl9ob2xlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcyQxLl9ob2xlc1tpXS5lcXVhbHNFeGFjdChvdGhlclBvbHlnb24uX2hvbGVzW2ldLCB0b2xlcmFuY2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5JCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm5vcm1hbGl6ZSh0aGlzLl9zaGVsbCwgdHJ1ZSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS5ub3JtYWxpemUodGhpcyQxLl9ob2xlc1tpXSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgQXJyYXlzLnNvcnQodGhpcy5faG9sZXMpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIHJpbmcgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY2xvY2t3aXNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKHJpbmcuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICB2YXIgdW5pcXVlQ29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkocmluZy5nZXRDb29yZGluYXRlcygpLmxlbmd0aCAtIDEpLmZpbGwobnVsbCk7XG4gICAgICBTeXN0ZW0uYXJyYXljb3B5KHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSwgMCwgdW5pcXVlQ29vcmRpbmF0ZXMsIDAsIHVuaXF1ZUNvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgICB2YXIgbWluQ29vcmRpbmF0ZSA9IENvb3JkaW5hdGVBcnJheXMubWluQ29vcmRpbmF0ZShyaW5nLmdldENvb3JkaW5hdGVzKCkpO1xuICAgICAgQ29vcmRpbmF0ZUFycmF5cy5zY3JvbGwodW5pcXVlQ29vcmRpbmF0ZXMsIG1pbkNvb3JkaW5hdGUpO1xuICAgICAgU3lzdGVtLmFycmF5Y29weSh1bmlxdWVDb29yZGluYXRlcywgMCwgcmluZy5nZXRDb29yZGluYXRlcygpLCAwLCB1bmlxdWVDb29yZGluYXRlcy5sZW5ndGgpO1xuICAgICAgcmluZy5nZXRDb29yZGluYXRlcygpW3VuaXF1ZUNvb3JkaW5hdGVzLmxlbmd0aF0gPSB1bmlxdWVDb29yZGluYXRlc1swXTtcbiAgICAgIGlmIChDR0FsZ29yaXRobXMuaXNDQ1cocmluZy5nZXRDb29yZGluYXRlcygpKSA9PT0gY2xvY2t3aXNlKSB7XG4gICAgICAgIENvb3JkaW5hdGVBcnJheXMucmV2ZXJzZShyaW5nLmdldENvb3JkaW5hdGVzKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zaGVsbC5nZXRDb29yZGluYXRlKClcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0TnVtSW50ZXJpb3JSaW5nID0gZnVuY3Rpb24gZ2V0TnVtSW50ZXJpb3JSaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5faG9sZXMubGVuZ3RoXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIHJldHVybiAxXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDJcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBsZW4gPSAwLjA7XG4gICAgbGVuICs9IHRoaXMuX3NoZWxsLmdldExlbmd0aCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxlbiArPSB0aGlzJDEuX2hvbGVzW2ldLmdldExlbmd0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gbGVuXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldE51bVBvaW50cyA9IGZ1bmN0aW9uIGdldE51bVBvaW50cyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbnVtUG9pbnRzID0gdGhpcy5fc2hlbGwuZ2V0TnVtUG9pbnRzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbnVtUG9pbnRzICs9IHRoaXMkMS5faG9sZXNbaV0uZ2V0TnVtUG9pbnRzKCk7XG4gICAgfVxuICAgIHJldHVybiBudW1Qb2ludHNcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvbHkgPSB0aGlzLmNvcHkoKTtcbiAgICBwb2x5Ll9zaGVsbCA9IHRoaXMuX3NoZWxsLmNvcHkoKS5yZXZlcnNlKCk7XG4gICAgcG9seS5faG9sZXMgPSBuZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvbHkuX2hvbGVzW2ldID0gdGhpcyQxLl9ob2xlc1tpXS5jb3B5KCkucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcG9seVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5jb252ZXhIdWxsID0gZnVuY3Rpb24gY29udmV4SHVsbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RXh0ZXJpb3JSaW5nKCkuY29udmV4SHVsbCgpXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmNvbXBhcmVUb1NhbWVDbGFzcyA9IGZ1bmN0aW9uIGNvbXBhcmVUb1NhbWVDbGFzcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG8gPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdGhpc1NoZWxsID0gdGhpcy5fc2hlbGw7XG4gICAgICB2YXIgb3RoZXJTaGVsbCA9IG8uX3NoZWxsO1xuICAgICAgcmV0dXJuIHRoaXNTaGVsbC5jb21wYXJlVG9TYW1lQ2xhc3Mob3RoZXJTaGVsbClcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY29tcCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBwb2x5ID0gbyQxO1xuICAgICAgdmFyIHRoaXNTaGVsbCQxID0gdGhpcy5fc2hlbGw7XG4gICAgICB2YXIgb3RoZXJTaGVsbCQxID0gcG9seS5fc2hlbGw7XG4gICAgICB2YXIgc2hlbGxDb21wID0gdGhpc1NoZWxsJDEuY29tcGFyZVRvU2FtZUNsYXNzKG90aGVyU2hlbGwkMSwgY29tcCk7XG4gICAgICBpZiAoc2hlbGxDb21wICE9PSAwKSB7IHJldHVybiBzaGVsbENvbXAgfVxuICAgICAgdmFyIG5Ib2xlMSA9IHRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7XG4gICAgICB2YXIgbkhvbGUyID0gcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgbkhvbGUxICYmIGkgPCBuSG9sZTIpIHtcbiAgICAgICAgdmFyIHRoaXNIb2xlID0gdGhpcyQxLmdldEludGVyaW9yUmluZ04oaSk7XG4gICAgICAgIHZhciBvdGhlckhvbGUgPSBwb2x5LmdldEludGVyaW9yUmluZ04oaSk7XG4gICAgICAgIHZhciBob2xlQ29tcCA9IHRoaXNIb2xlLmNvbXBhcmVUb1NhbWVDbGFzcyhvdGhlckhvbGUsIGNvbXApO1xuICAgICAgICBpZiAoaG9sZUNvbXAgIT09IDApIHsgcmV0dXJuIGhvbGVDb21wIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgaWYgKGkgPCBuSG9sZTEpIHsgcmV0dXJuIDEgfVxuICAgICAgaWYgKGkgPCBuSG9sZTIpIHsgcmV0dXJuIC0xIH1cbiAgICAgIHJldHVybiAwXG4gICAgfVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5IChmaWx0ZXIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChoYXNJbnRlcmZhY2UoZmlsdGVyLCBDb29yZGluYXRlRmlsdGVyKSkge1xuICAgICAgdGhpcy5fc2hlbGwuYXBwbHkoZmlsdGVyKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLl9ob2xlc1tpJDFdLmFwcGx5KGZpbHRlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoZmlsdGVyLCBDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXIpKSB7XG4gICAgICB0aGlzLl9zaGVsbC5hcHBseShmaWx0ZXIpO1xuICAgICAgaWYgKCFmaWx0ZXIuaXNEb25lKCkpIHtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgIHRoaXMkMS5faG9sZXNbaSQyXS5hcHBseShmaWx0ZXIpO1xuICAgICAgICAgIGlmIChmaWx0ZXIuaXNEb25lKCkpIHsgYnJlYWsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZmlsdGVyLmlzR2VvbWV0cnlDaGFuZ2VkKCkpIHsgdGhpcy5nZW9tZXRyeUNoYW5nZWQoKTsgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGZpbHRlciwgR2VvbWV0cnlGaWx0ZXIpKSB7XG4gICAgICBmaWx0ZXIuZmlsdGVyKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGZpbHRlciwgR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIpKSB7XG4gICAgICBmaWx0ZXIuZmlsdGVyKHRoaXMpO1xuICAgICAgdGhpcy5fc2hlbGwuYXBwbHkoZmlsdGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLl9ob2xlc1tpXS5hcHBseShmaWx0ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKVxuICAgIH1cbiAgICB2YXIgcmluZ3MgPSBuZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoICsgMSkuZmlsbChudWxsKTtcbiAgICByaW5nc1swXSA9IHRoaXMuX3NoZWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJpbmdzW2kgKyAxXSA9IHRoaXMkMS5faG9sZXNbaV07XG4gICAgfVxuICAgIGlmIChyaW5ncy5sZW5ndGggPD0gMSkgeyByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhyaW5nc1swXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSkgfVxuICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcocmluZ3MpXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvbHkgPSBHZW9tZXRyeSQkMS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBwb2x5Ll9zaGVsbCA9IHRoaXMuX3NoZWxsLmNsb25lKCk7XG4gICAgcG9seS5faG9sZXMgPSBuZXcgQXJyYXkodGhpcy5faG9sZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvbHkuX2hvbGVzW2ldID0gdGhpcyQxLl9ob2xlc1tpXS5jbG9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gcG9seVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnUG9seWdvbidcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNoZWxsID0gdGhpcy5fc2hlbGwuY29weSgpO1xuICAgIHZhciBob2xlcyA9IG5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaG9sZXNbaV0gPSB0aGlzJDEuX2hvbGVzW2ldLmNvcHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHNoZWxsLCBob2xlcywgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0RXh0ZXJpb3JSaW5nID0gZnVuY3Rpb24gZ2V0RXh0ZXJpb3JSaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hlbGxcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICAgIHJldHVybiB0aGlzLl9zaGVsbC5pc0VtcHR5KClcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0SW50ZXJpb3JSaW5nTiA9IGZ1bmN0aW9uIGdldEludGVyaW9yUmluZ04gKG4pIHtcbiAgICByZXR1cm4gdGhpcy5faG9sZXNbbl1cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtQb2x5Z29uYWxdXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBQb2x5Z29uXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0zNDk0NzkyMjAwODIxNzY0NTMzIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFBvbHlnb24sIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBQb2x5Z29uO1xufShHZW9tZXRyeSkpO1xuXG52YXIgTXVsdGlQb2ludCA9IChmdW5jdGlvbiAoR2VvbWV0cnlDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIE11bHRpUG9pbnQgKCkge1xuICAgIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeUNvbGxlY3Rpb24kJDEgKSBNdWx0aVBvaW50Ll9fcHJvdG9fXyA9IEdlb21ldHJ5Q29sbGVjdGlvbiQkMTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeUNvbGxlY3Rpb24kJDEgJiYgR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE11bHRpUG9pbnQ7XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5LlNPUlRJTkRFWF9NVUxUSVBPSU5UXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5lcXVhbHNFeGFjdCA9IGZ1bmN0aW9uIGVxdWFsc0V4YWN0ICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmICghdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyhvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsIG90aGVyLCB0b2xlcmFuY2UpXG4gICAgfSBlbHNlIHsgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1tuXS5nZXRDb29yZGluYXRlKClcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5nZXRDb29yZGluYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gRGltZW5zaW9uLkZBTFNFXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDBcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKVxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnTXVsdGlQb2ludCdcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvaW50cyA9IG5ldyBBcnJheSh0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9pbnRzW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmNvcHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvaW50KHBvaW50cywgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtQdW50YWxdXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBNdWx0aVBvaW50XG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC04MDQ4NDc0ODc0MTc1MzU1NDQ5IH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE11bHRpUG9pbnQsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBNdWx0aVBvaW50O1xufShHZW9tZXRyeUNvbGxlY3Rpb24pKTtcblxudmFyIExpbmVhclJpbmcgPSAoZnVuY3Rpb24gKExpbmVTdHJpbmckJDEpIHtcbiAgZnVuY3Rpb24gTGluZWFyUmluZyAocG9pbnRzLCBmYWN0b3J5KSB7XG4gICAgaWYgKHBvaW50cyBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgZmFjdG9yeSBpbnN0YW5jZW9mIEdlb21ldHJ5RmFjdG9yeSkge1xuICAgICAgcG9pbnRzID0gZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHBvaW50cyk7XG4gICAgfVxuICAgIExpbmVTdHJpbmckJDEuY2FsbCh0aGlzLCBwb2ludHMsIGZhY3RvcnkpO1xuICAgIHRoaXMudmFsaWRhdGVDb25zdHJ1Y3Rpb24oKTtcbiAgfVxuXG4gIGlmICggTGluZVN0cmluZyQkMSApIExpbmVhclJpbmcuX19wcm90b19fID0gTGluZVN0cmluZyQkMTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU3RyaW5nJCQxICYmIExpbmVTdHJpbmckJDEucHJvdG90eXBlICk7XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGluZWFyUmluZztcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBNSU5JTVVNX1ZBTElEX1NJWkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRTb3J0SW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0SW5kZXggKCkge1xuICAgIHJldHVybiBHZW9tZXRyeS5TT1JUSU5ERVhfTElORUFSUklOR1xuICB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gRGltZW5zaW9uLkZBTFNFXG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gaXNDbG9zZWQgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIExpbmVTdHJpbmckJDEucHJvdG90eXBlLmlzQ2xvc2VkLmNhbGwodGhpcylcbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciBzZXEgPSB0aGlzLl9wb2ludHMuY29weSgpO1xuICAgIENvb3JkaW5hdGVTZXF1ZW5jZXMucmV2ZXJzZShzZXEpO1xuICAgIHZhciByZXYgPSB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHNlcSk7XG4gICAgcmV0dXJuIHJldlxuICB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS52YWxpZGF0ZUNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uIHZhbGlkYXRlQ29uc3RydWN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpICYmICFMaW5lU3RyaW5nJCQxLnByb3RvdHlwZS5pc0Nsb3NlZC5jYWxsKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdQb2ludHMgb2YgTGluZWFyUmluZyBkbyBub3QgZm9ybSBhIGNsb3NlZCBsaW5lc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpID49IDEgJiYgdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCkgPCBMaW5lYXJSaW5nLk1JTklNVU1fVkFMSURfU0laRSkge1xuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVhclJpbmcgKGZvdW5kICcgKyB0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKSArICcgLSBtdXN0IGJlIDAgb3IgPj0gNCknKVxuICAgIH1cbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlUeXBlICgpIHtcbiAgICByZXR1cm4gJ0xpbmVhclJpbmcnXG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IExpbmVhclJpbmcodGhpcy5fcG9pbnRzLmNvcHkoKSwgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBMaW5lYXJSaW5nXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5NSU5JTVVNX1ZBTElEX1NJWkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNCB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtNDI2MTE0MjA4NDA4NTg1MTgyOSB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMaW5lYXJSaW5nLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTGluZWFyUmluZztcbn0oTGluZVN0cmluZykpO1xuXG52YXIgTXVsdGlQb2x5Z29uID0gKGZ1bmN0aW9uIChHZW9tZXRyeUNvbGxlY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gTXVsdGlQb2x5Z29uICgpIHtcbiAgICBHZW9tZXRyeUNvbGxlY3Rpb24kJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICggR2VvbWV0cnlDb2xsZWN0aW9uJCQxICkgTXVsdGlQb2x5Z29uLl9fcHJvdG9fXyA9IEdlb21ldHJ5Q29sbGVjdGlvbiQkMTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5Q29sbGVjdGlvbiQkMSAmJiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNdWx0aVBvbHlnb247XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkuU09SVElOREVYX01VTFRJUE9MWUdPTlxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcywgb3RoZXIsIHRvbGVyYW5jZSlcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gMVxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDJcbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbiA9IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO1xuICAgIHZhciByZXZHZW9tcyA9IG5ldyBBcnJheShuKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV2R2VvbXNbaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0ucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKHJldkdlb21zKVxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKClcbiAgICB9XG4gICAgdmFyIGFsbFJpbmdzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBvbHlnb24gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV07XG4gICAgICB2YXIgcmluZ3MgPSBwb2x5Z29uLmdldEJvdW5kYXJ5KCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmdzLmdldE51bUdlb21ldHJpZXMoKTsgaisrKSB7XG4gICAgICAgIGFsbFJpbmdzLmFkZChyaW5ncy5nZXRHZW9tZXRyeU4oaikpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYWxsUmluZ3NBcnJheSA9IG5ldyBBcnJheShhbGxSaW5ncy5zaXplKCkpLmZpbGwobnVsbCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyhhbGxSaW5ncy50b0FycmF5KGFsbFJpbmdzQXJyYXkpKVxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdNdWx0aVBvbHlnb24nXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvbHlnb25zID0gbmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBvbHlnb25zW2ldID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmNvcHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24ocG9seWdvbnMsIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtQb2x5Z29uYWxdXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE11bHRpUG9seWdvblxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtNTUxMDMzNTI5NzY2OTc1ODc1IH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE11bHRpUG9seWdvbiwgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIE11bHRpUG9seWdvbjtcbn0oR2VvbWV0cnlDb2xsZWN0aW9uKSk7XG5cbnZhciBHZW9tZXRyeUVkaXRvciA9IGZ1bmN0aW9uIEdlb21ldHJ5RWRpdG9yIChmYWN0b3J5KSB7XG4gIHRoaXMuX2ZhY3RvcnkgPSBmYWN0b3J5IHx8IG51bGw7XG4gIHRoaXMuX2lzVXNlckRhdGFDb3BpZWQgPSBmYWxzZTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTYgPSB7IE5vT3BHZW9tZXRyeU9wZXJhdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSxDb29yZGluYXRlT3BlcmF0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLnNldENvcHlVc2VyRGF0YSA9IGZ1bmN0aW9uIHNldENvcHlVc2VyRGF0YSAoaXNVc2VyRGF0YUNvcGllZCkge1xuICB0aGlzLl9pc1VzZXJEYXRhQ29waWVkID0gaXNVc2VyRGF0YUNvcGllZDtcbn07XG5HZW9tZXRyeUVkaXRvci5wcm90b3R5cGUuZWRpdCA9IGZ1bmN0aW9uIGVkaXQgKGdlb21ldHJ5LCBvcGVyYXRpb24pIHtcbiAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMuZWRpdEludGVybmFsKGdlb21ldHJ5LCBvcGVyYXRpb24pO1xuICBpZiAodGhpcy5faXNVc2VyRGF0YUNvcGllZCkge1xuICAgIHJlc3VsdC5zZXRVc2VyRGF0YShnZW9tZXRyeS5nZXRVc2VyRGF0YSgpKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLmVkaXRJbnRlcm5hbCA9IGZ1bmN0aW9uIGVkaXRJbnRlcm5hbCAoZ2VvbWV0cnksIG9wZXJhdGlvbikge1xuICBpZiAodGhpcy5fZmFjdG9yeSA9PT0gbnVsbCkgeyB0aGlzLl9mYWN0b3J5ID0gZ2VvbWV0cnkuZ2V0RmFjdG9yeSgpOyB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVkaXRHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cnksIG9wZXJhdGlvbilcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdFBvbHlnb24oZ2VvbWV0cnksIG9wZXJhdGlvbilcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgIHJldHVybiBvcGVyYXRpb24uZWRpdChnZW9tZXRyeSwgdGhpcy5fZmFjdG9yeSlcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgcmV0dXJuIG9wZXJhdGlvbi5lZGl0KGdlb21ldHJ5LCB0aGlzLl9mYWN0b3J5KVxuICB9XG4gIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgnVW5zdXBwb3J0ZWQgR2VvbWV0cnkgY2xhc3M6ICcgKyBnZW9tZXRyeS5nZXRDbGFzcygpLmdldE5hbWUoKSk7XG4gIHJldHVybiBudWxsXG59O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLmVkaXRHZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiBlZGl0R2VvbWV0cnlDb2xsZWN0aW9uIChjb2xsZWN0aW9uLCBvcGVyYXRpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY29sbGVjdGlvbkZvclR5cGUgPSBvcGVyYXRpb24uZWRpdChjb2xsZWN0aW9uLCB0aGlzLl9mYWN0b3J5KTtcbiAgdmFyIGdlb21ldHJpZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbkZvclR5cGUuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzJDEuZWRpdChjb2xsZWN0aW9uRm9yVHlwZS5nZXRHZW9tZXRyeU4oaSksIG9wZXJhdGlvbik7XG4gICAgaWYgKGdlb21ldHJ5ID09PSBudWxsIHx8IGdlb21ldHJ5LmlzRW1wdHkoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZ2VvbWV0cmllcy5hZGQoZ2VvbWV0cnkpO1xuICB9XG4gIGlmIChjb2xsZWN0aW9uRm9yVHlwZS5nZXRDbGFzcygpID09PSBNdWx0aVBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChnZW9tZXRyaWVzLnRvQXJyYXkoW10pKVxuICB9XG4gIGlmIChjb2xsZWN0aW9uRm9yVHlwZS5nZXRDbGFzcygpID09PSBNdWx0aUxpbmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZ2VvbWV0cmllcy50b0FycmF5KFtdKSlcbiAgfVxuICBpZiAoY29sbGVjdGlvbkZvclR5cGUuZ2V0Q2xhc3MoKSA9PT0gTXVsdGlQb2x5Z29uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGdlb21ldHJpZXMudG9BcnJheShbXSkpXG4gIH1cbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMudG9BcnJheShbXSkpXG59O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLmVkaXRQb2x5Z29uID0gZnVuY3Rpb24gZWRpdFBvbHlnb24gKHBvbHlnb24sIG9wZXJhdGlvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBuZXdQb2x5Z29uID0gb3BlcmF0aW9uLmVkaXQocG9seWdvbiwgdGhpcy5fZmFjdG9yeSk7XG4gIGlmIChuZXdQb2x5Z29uID09PSBudWxsKSB7IG5ld1BvbHlnb24gPSB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24obnVsbCk7IH1cbiAgaWYgKG5ld1BvbHlnb24uaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuIG5ld1BvbHlnb25cbiAgfVxuICB2YXIgc2hlbGwgPSB0aGlzLmVkaXQobmV3UG9seWdvbi5nZXRFeHRlcmlvclJpbmcoKSwgb3BlcmF0aW9uKTtcbiAgaWYgKHNoZWxsID09PSBudWxsIHx8IHNoZWxsLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oKVxuICB9XG4gIHZhciBob2xlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQb2x5Z29uLmdldE51bUludGVyaW9yUmluZygpOyBpKyspIHtcbiAgICB2YXIgaG9sZSA9IHRoaXMkMS5lZGl0KG5ld1BvbHlnb24uZ2V0SW50ZXJpb3JSaW5nTihpKSwgb3BlcmF0aW9uKTtcbiAgICBpZiAoaG9sZSA9PT0gbnVsbCB8fCBob2xlLmlzRW1wdHkoKSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaG9sZXMuYWRkKGhvbGUpO1xuICB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oc2hlbGwsIGhvbGVzLnRvQXJyYXkoW10pKVxufTtcbkdlb21ldHJ5RWRpdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlFZGl0b3Jcbn07XG5HZW9tZXRyeUVkaXRvci5HZW9tZXRyeUVkaXRvck9wZXJhdGlvbiA9IGZ1bmN0aW9uIEdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uICgpIHt9O1xuc3RhdGljQWNjZXNzb3JzJDE2Lk5vT3BHZW9tZXRyeU9wZXJhdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBOb09wR2VvbWV0cnlPcGVyYXRpb24gfTtcbnN0YXRpY0FjY2Vzc29ycyQxNi5Db29yZGluYXRlT3BlcmF0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvb3JkaW5hdGVPcGVyYXRpb24gfTtcbnN0YXRpY0FjY2Vzc29ycyQxNi5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBHZW9tZXRyeUVkaXRvciwgc3RhdGljQWNjZXNzb3JzJDE2ICk7XG5cbnZhciBOb09wR2VvbWV0cnlPcGVyYXRpb24gPSBmdW5jdGlvbiBOb09wR2VvbWV0cnlPcGVyYXRpb24gKCkge307XG5cbk5vT3BHZW9tZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuZWRpdCA9IGZ1bmN0aW9uIGVkaXQgKGdlb21ldHJ5LCBmYWN0b3J5KSB7XG4gIHJldHVybiBnZW9tZXRyeVxufTtcbk5vT3BHZW9tZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlFZGl0b3IuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb25dXG59O1xuTm9PcEdlb21ldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vT3BHZW9tZXRyeU9wZXJhdGlvblxufTtcblxudmFyIENvb3JkaW5hdGVPcGVyYXRpb24gPSBmdW5jdGlvbiBDb29yZGluYXRlT3BlcmF0aW9uICgpIHt9O1xuXG5Db29yZGluYXRlT3BlcmF0aW9uLnByb3RvdHlwZS5lZGl0ID0gZnVuY3Rpb24gZWRpdCAoZ2VvbWV0cnksIGZhY3RvcnkpIHtcbiAgdmFyIGNvb3JkcyA9IHRoaXMuZWRpdENvb3JkaW5hdGVzKGdlb21ldHJ5LmdldENvb3JkaW5hdGVzKCksIGdlb21ldHJ5KTtcbiAgaWYgKGNvb3JkcyA9PT0gbnVsbCkgeyByZXR1cm4gZ2VvbWV0cnkgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhjb29yZHMpXG4gIH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoY29vcmRzKVxuICB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgaWYgKGNvb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVQb2ludChjb29yZHNbMF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZVBvaW50KClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdlb21ldHJ5XG59O1xuQ29vcmRpbmF0ZU9wZXJhdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlFZGl0b3IuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb25dXG59O1xuQ29vcmRpbmF0ZU9wZXJhdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlT3BlcmF0aW9uXG59O1xuXG52YXIgQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uID0gZnVuY3Rpb24gQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uICgpIHt9O1xuXG5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb24ucHJvdG90eXBlLmVkaXQgPSBmdW5jdGlvbiBlZGl0IChnZW9tZXRyeSwgZmFjdG9yeSkge1xuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0aGlzLmVkaXQoZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksIGdlb21ldHJ5KSlcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLmVkaXQoZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksIGdlb21ldHJ5KSlcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMuZWRpdChnZW9tZXRyeS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSwgZ2VvbWV0cnkpKVxuICB9XG4gIHJldHVybiBnZW9tZXRyeVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlFZGl0b3IuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb25dXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvblxufTtcblxudmFyIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlID0gZnVuY3Rpb24gQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UgKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl9kaW1lbnNpb24gPSAzO1xuICB0aGlzLl9jb29yZGluYXRlcyA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB0aGlzLl9jb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuX2RpbWVuc2lvbiA9IDM7XG4gICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHZhciBzaXplID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoc2l6ZSkuZmlsbChudWxsKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS5fY29vcmRpbmF0ZXNbaV0gPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAgICAgdmFyIGNvb3JkU2VxID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKGNvb3JkU2VxID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzID0gbmV3IEFycmF5KDApLmZpbGwobnVsbCk7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICB0aGlzLl9kaW1lbnNpb24gPSBjb29yZFNlcS5nZXREaW1lbnNpb24oKTtcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzID0gbmV3IEFycmF5KGNvb3JkU2VxLnNpemUoKSkuZmlsbChudWxsKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLl9jb29yZGluYXRlc1tpJDFdID0gY29vcmRTZXEuZ2V0Q29vcmRpbmF0ZUNvcHkoaSQxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiBOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkaW1lbnNpb24gPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLl9jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xuICAgICAgdGhpcy5fZGltZW5zaW9uID0gZGltZW5zaW9uO1xuICAgICAgaWYgKGNvb3JkaW5hdGVzID09PSBudWxsKSB7IHRoaXMuX2Nvb3JkaW5hdGVzID0gbmV3IEFycmF5KDApLmZpbGwobnVsbCk7IH1cbiAgICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIHZhciBzaXplJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZGltZW5zaW9uJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLl9jb29yZGluYXRlcyA9IG5ldyBBcnJheShzaXplJDEpLmZpbGwobnVsbCk7XG4gICAgICB0aGlzLl9kaW1lbnNpb24gPSBkaW1lbnNpb24kMTtcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHNpemUkMTsgaSQyKyspIHtcbiAgICAgICAgdGhpcyQxLl9jb29yZGluYXRlc1tpJDJdID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTggPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5zZXRPcmRpbmF0ZSA9IGZ1bmN0aW9uIHNldE9yZGluYXRlIChpbmRleCwgb3JkaW5hdGVJbmRleCwgdmFsdWUpIHtcbiAgc3dpdGNoIChvcmRpbmF0ZUluZGV4KSB7XG4gICAgY2FzZSBDb29yZGluYXRlU2VxdWVuY2UuWDpcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS54ID0gdmFsdWU7XG4gICAgICBicmVha1xuICAgIGNhc2UgQ29vcmRpbmF0ZVNlcXVlbmNlLlk6XG4gICAgICB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueSA9IHZhbHVlO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIENvb3JkaW5hdGVTZXF1ZW5jZS5aOlxuICAgICAgdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnogPSB2YWx1ZTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2ludmFsaWQgb3JkaW5hdGVJbmRleCcpXG4gIH1cbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldE9yZGluYXRlID0gZnVuY3Rpb24gZ2V0T3JkaW5hdGUgKGluZGV4LCBvcmRpbmF0ZUluZGV4KSB7XG4gIHN3aXRjaCAob3JkaW5hdGVJbmRleCkge1xuICAgIGNhc2UgQ29vcmRpbmF0ZVNlcXVlbmNlLlg6XG4gICAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnhcbiAgICBjYXNlIENvb3JkaW5hdGVTZXF1ZW5jZS5ZOlxuICAgICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS55XG4gICAgY2FzZSBDb29yZGluYXRlU2VxdWVuY2UuWjpcbiAgICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0uelxuICAgIGRlZmF1bHQ6XG4gIH1cbiAgcmV0dXJuIERvdWJsZS5OYU5cbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBpID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1tpXVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzFdO1xuICAgIGNvb3JkLnggPSB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueDtcbiAgICBjb29yZC55ID0gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnk7XG4gICAgY29vcmQueiA9IHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS56O1xuICB9XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldENvb3JkaW5hdGVDb3B5ID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZUNvcHkgKGkpIHtcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHRoaXMuX2Nvb3JkaW5hdGVzW2ldKVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZGltZW5zaW9uXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYIChpbmRleCkge1xuICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnhcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNsb25lQ29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjbG9uZUNvb3JkaW5hdGVzW2ldID0gdGhpcyQxLl9jb29yZGluYXRlc1tpXS5jbG9uZSgpO1xuICB9XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UoY2xvbmVDb29yZGluYXRlcywgdGhpcy5fZGltZW5zaW9uKVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5leHBhbmRFbnZlbG9wZSA9IGZ1bmN0aW9uIGV4cGFuZEVudmVsb3BlIChlbnYpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzJDEuX2Nvb3JkaW5hdGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZW52XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY2xvbmVDb29yZGluYXRlcyA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNsb25lQ29vcmRpbmF0ZXNbaV0gPSB0aGlzJDEuX2Nvb3JkaW5hdGVzW2ldLmNvcHkoKTtcbiAgfVxuICByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKGNsb25lQ29vcmRpbmF0ZXMsIHRoaXMuX2RpbWVuc2lvbilcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgc3RyQnVmID0gbmV3IFN0cmluZ0J1ZmZlcigxNyAqIHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgc3RyQnVmLmFwcGVuZCgnKCcpO1xuICAgIHN0ckJ1Zi5hcHBlbmQodGhpcy5fY29vcmRpbmF0ZXNbMF0pO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN0ckJ1Zi5hcHBlbmQoJywgJyk7XG4gICAgICBzdHJCdWYuYXBwZW5kKHRoaXMkMS5fY29vcmRpbmF0ZXNbaV0pO1xuICAgIH1cbiAgICBzdHJCdWYuYXBwZW5kKCcpJyk7XG4gICAgcmV0dXJuIHN0ckJ1Zi50b1N0cmluZygpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcoKSdcbiAgfVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSAoaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS55XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLnRvQ29vcmRpbmF0ZUFycmF5ID0gZnVuY3Rpb24gdG9Db29yZGluYXRlQXJyYXkgKCkge1xuICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZVNlcXVlbmNlLCBTZXJpYWxpemFibGVdXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2Vcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMTguc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtOTE1NDM4NTAxNjAxODQwNjUwIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZSwgc3RhdGljQWNjZXNzb3JzJDE4ICk7XG5cbnZhciBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkgPSBmdW5jdGlvbiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTcgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW5zdGFuY2VPYmplY3Q6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5LnByb3RvdHlwZS5yZWFkUmVzb2x2ZSA9IGZ1bmN0aW9uIHJlYWRSZXNvbHZlICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5pbnN0YW5jZSgpXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZShjb29yZGluYXRlcylcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICAgIHZhciBjb29yZFNlcSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UoY29vcmRTZXEpXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2l6ZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZGltZW5zaW9uID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChkaW1lbnNpb24gPiAzKSB7IGRpbWVuc2lvbiA9IDM7IH1cbiAgICBpZiAoZGltZW5zaW9uIDwgMikgeyByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKHNpemUpIH1cbiAgICByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKHNpemUsIGRpbWVuc2lvbilcbiAgfVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSwgU2VyaWFsaXphYmxlXVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3Rvcnlcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkuaW5zdGFuY2UgPSBmdW5jdGlvbiBpbnN0YW5jZSAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkuaW5zdGFuY2VPYmplY3Rcbn07XG5cbnN0YXRpY0FjY2Vzc29ycyQxNy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC00MDk5NTc3MDk5NjA3NTUxNjU3IH07XG5zdGF0aWNBY2Nlc3NvcnMkMTcuaW5zdGFuY2VPYmplY3QuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeSgpIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnksIHN0YXRpY0FjY2Vzc29ycyQxNyApO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL0hhc2hNYXAuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtqYXZhc2NyaXB0LnV0aWwuTWFwfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSGFzaE1hcCA9IChmdW5jdGlvbiAoTWFwSW50ZXJmYWNlKSB7XG4gIGZ1bmN0aW9uIEhhc2hNYXAgKCkge1xuICAgIE1hcEludGVyZmFjZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMubWFwXyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIGlmICggTWFwSW50ZXJmYWNlICkgSGFzaE1hcC5fX3Byb3RvX18gPSBNYXBJbnRlcmZhY2U7XG4gIEhhc2hNYXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWFwSW50ZXJmYWNlICYmIE1hcEludGVyZmFjZS5wcm90b3R5cGUgKTtcbiAgSGFzaE1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBIYXNoTWFwO1xuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGtleSkge1xuICAgIHJldHVybiB0aGlzLm1hcF8uZ2V0KGtleSkgfHwgbnVsbFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIHB1dCAoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMubWFwXy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaE1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzICgpIHtcbiAgICB2YXIgYXJyYXlMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHZhciBpdCA9IHRoaXMubWFwXy52YWx1ZXMoKTtcbiAgICB2YXIgbyA9IGl0Lm5leHQoKTtcbiAgICB3aGlsZSAoIW8uZG9uZSkge1xuICAgICAgYXJyYXlMaXN0LmFkZChvLnZhbHVlKTtcbiAgICAgIG8gPSBpdC5uZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheUxpc3RcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoTWFwLnByb3RvdHlwZS5lbnRyeVNldCA9IGZ1bmN0aW9uIGVudHJ5U2V0ICgpIHtcbiAgICB2YXIgaGFzaFNldCA9IG5ldyBIYXNoU2V0KCk7XG4gICAgdGhpcy5tYXBfLmVudHJpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkgeyByZXR1cm4gaGFzaFNldC5hZGQoZW50cnkpOyB9KTtcbiAgICByZXR1cm4gaGFzaFNldFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hNYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXBfLnNpemUoKVxuICB9O1xuXG4gIHJldHVybiBIYXNoTWFwO1xufShNYXAkMSkpO1xuXG52YXIgUHJlY2lzaW9uTW9kZWwgPSBmdW5jdGlvbiBQcmVjaXNpb25Nb2RlbCAoKSB7XG4gIHRoaXMuX21vZGVsVHlwZSA9IG51bGw7XG4gIHRoaXMuX3NjYWxlID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9tb2RlbFR5cGUgPSBQcmVjaXNpb25Nb2RlbC5GTE9BVElORztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFR5cGUpIHtcbiAgICAgIHZhciBtb2RlbFR5cGUgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLl9tb2RlbFR5cGUgPSBtb2RlbFR5cGU7XG4gICAgICBpZiAobW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkge1xuICAgICAgICB0aGlzLnNldFNjYWxlKDEuMCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHNjYWxlID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5fbW9kZWxUeXBlID0gUHJlY2lzaW9uTW9kZWwuRklYRUQ7XG4gICAgICB0aGlzLnNldFNjYWxlKHNjYWxlKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFByZWNpc2lvbk1vZGVsKSB7XG4gICAgICB2YXIgcG0gPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLl9tb2RlbFR5cGUgPSBwbS5fbW9kZWxUeXBlO1xuICAgICAgdGhpcy5fc2NhbGUgPSBwbS5fc2NhbGU7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDE5ID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LG1heGltdW1QcmVjaXNlVmFsdWU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgUHJlY2lzaW9uTW9kZWwpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIG90aGVyUHJlY2lzaW9uTW9kZWwgPSBvdGhlcjtcbiAgcmV0dXJuIHRoaXMuX21vZGVsVHlwZSA9PT0gb3RoZXJQcmVjaXNpb25Nb2RlbC5fbW9kZWxUeXBlICYmIHRoaXMuX3NjYWxlID09PSBvdGhlclByZWNpc2lvbk1vZGVsLl9zY2FsZVxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgdmFyIG90aGVyID0gbztcbiAgdmFyIHNpZ0RpZ2l0cyA9IHRoaXMuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCk7XG4gIHZhciBvdGhlclNpZ0RpZ2l0cyA9IG90aGVyLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpO1xuICByZXR1cm4gbmV3IEludGVnZXIoc2lnRGlnaXRzKS5jb21wYXJlVG8obmV3IEludGVnZXIob3RoZXJTaWdEaWdpdHMpKVxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5nZXRTY2FsZSA9IGZ1bmN0aW9uIGdldFNjYWxlICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NjYWxlXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLmlzRmxvYXRpbmcgPSBmdW5jdGlvbiBpc0Zsb2F0aW5nICgpIHtcbiAgcmV0dXJuIHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkcgfHwgdGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GTE9BVElOR19TSU5HTEVcbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uIGdldFR5cGUgKCkge1xuICByZXR1cm4gdGhpcy5fbW9kZWxUeXBlXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgZGVzY3JpcHRpb24gPSAnVU5LTk9XTic7XG4gIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HKSB7XG4gICAgZGVzY3JpcHRpb24gPSAnRmxvYXRpbmcnO1xuICB9IGVsc2UgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkdfU0lOR0xFKSB7XG4gICAgZGVzY3JpcHRpb24gPSAnRmxvYXRpbmctU2luZ2xlJztcbiAgfSBlbHNlIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZJWEVEKSB7XG4gICAgZGVzY3JpcHRpb24gPSAnRml4ZWQgKFNjYWxlPScgKyB0aGlzLmdldFNjYWxlKCkgKyAnKSc7XG4gIH1cbiAgcmV0dXJuIGRlc2NyaXB0aW9uXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLm1ha2VQcmVjaXNlID0gZnVuY3Rpb24gbWFrZVByZWNpc2UgKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgdmFsID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChEb3VibGUuaXNOYU4odmFsKSkgeyByZXR1cm4gdmFsIH1cbiAgICBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GTE9BVElOR19TSU5HTEUpIHtcbiAgICAgIHZhciBmbG9hdFNpbmdsZVZhbCA9IHZhbDtcbiAgICAgIHJldHVybiBmbG9hdFNpbmdsZVZhbFxuICAgIH1cbiAgICBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsICogdGhpcy5fc2NhbGUpIC8gdGhpcy5fc2NhbGVcbiAgICB9XG4gICAgcmV0dXJuIHZhbFxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkcpIHsgcmV0dXJuIG51bGwgfVxuICAgIGNvb3JkLnggPSB0aGlzLm1ha2VQcmVjaXNlKGNvb3JkLngpO1xuICAgIGNvb3JkLnkgPSB0aGlzLm1ha2VQcmVjaXNlKGNvb3JkLnkpO1xuICB9XG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cyA9IGZ1bmN0aW9uIGdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cyAoKSB7XG4gIHZhciBtYXhTaWdEaWdpdHMgPSAxNjtcbiAgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkcpIHtcbiAgICBtYXhTaWdEaWdpdHMgPSAxNjtcbiAgfSBlbHNlIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HX1NJTkdMRSkge1xuICAgIG1heFNpZ0RpZ2l0cyA9IDY7XG4gIH0gZWxzZSBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkge1xuICAgIG1heFNpZ0RpZ2l0cyA9IDEgKyBNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLmxvZyh0aGlzLmdldFNjYWxlKCkpIC8gTWF0aC5sb2coMTApKSk7XG4gIH1cbiAgcmV0dXJuIG1heFNpZ0RpZ2l0c1xufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uIHNldFNjYWxlIChzY2FsZSkge1xuICB0aGlzLl9zY2FsZSA9IE1hdGguYWJzKHNjYWxlKTtcbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VyaWFsaXphYmxlLCBDb21wYXJhYmxlXVxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFByZWNpc2lvbk1vZGVsXG59O1xuUHJlY2lzaW9uTW9kZWwubW9zdFByZWNpc2UgPSBmdW5jdGlvbiBtb3N0UHJlY2lzZSAocG0xLCBwbTIpIHtcbiAgaWYgKHBtMS5jb21wYXJlVG8ocG0yKSA+PSAwKSB7IHJldHVybiBwbTEgfVxuICByZXR1cm4gcG0yXG59O1xuc3RhdGljQWNjZXNzb3JzJDE5LnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzc3NzI2MzU3ODc3NzgwMzgzNSB9O1xuc3RhdGljQWNjZXNzb3JzJDE5Lm1heGltdW1QcmVjaXNlVmFsdWUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gOTAwNzE5OTI1NDc0MDk5Mi4wIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQcmVjaXNpb25Nb2RlbCwgc3RhdGljQWNjZXNzb3JzJDE5ICk7XG5cbnZhciBUeXBlID0gZnVuY3Rpb24gVHlwZSAobmFtZSkge1xuICB0aGlzLl9uYW1lID0gbmFtZSB8fCBudWxsO1xuICBUeXBlLm5hbWVUb1R5cGVNYXAucHV0KG5hbWUsIHRoaXMpO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxJDEgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbmFtZVRvVHlwZU1hcDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuVHlwZS5wcm90b3R5cGUucmVhZFJlc29sdmUgPSBmdW5jdGlvbiByZWFkUmVzb2x2ZSAoKSB7XG4gIHJldHVybiBUeXBlLm5hbWVUb1R5cGVNYXAuZ2V0KHRoaXMuX25hbWUpXG59O1xuVHlwZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiB0aGlzLl9uYW1lXG59O1xuVHlwZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VyaWFsaXphYmxlXVxufTtcblR5cGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gVHlwZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQxJDEuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtNTUyODYwMjYzMTczMTU4OTgyMiB9O1xuc3RhdGljQWNjZXNzb3JzJDEkMS5uYW1lVG9UeXBlTWFwLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBIYXNoTWFwKCkgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFR5cGUsIHN0YXRpY0FjY2Vzc29ycyQxJDEgKTtcblxuUHJlY2lzaW9uTW9kZWwuVHlwZSA9IFR5cGU7XG5QcmVjaXNpb25Nb2RlbC5GSVhFRCA9IG5ldyBUeXBlKCdGSVhFRCcpO1xuUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkcgPSBuZXcgVHlwZSgnRkxPQVRJTkcnKTtcblByZWNpc2lvbk1vZGVsLkZMT0FUSU5HX1NJTkdMRSA9IG5ldyBUeXBlKCdGTE9BVElORyBTSU5HTEUnKTtcblxudmFyIEdlb21ldHJ5RmFjdG9yeSA9IGZ1bmN0aW9uIEdlb21ldHJ5RmFjdG9yeSAoKSB7XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gbmV3IFByZWNpc2lvbk1vZGVsKCk7XG4gIHRoaXMuX1NSSUQgPSAwO1xuICB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gR2VvbWV0cnlGYWN0b3J5LmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkpKSB7XG4gICAgICB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUHJlY2lzaW9uTW9kZWwpIHtcbiAgICAgIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gYXJndW1lbnRzWzBdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fU1JJRCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fU1JJRCA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gYXJndW1lbnRzWzJdO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDIgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUudG9HZW9tZXRyeSA9IGZ1bmN0aW9uIHRvR2VvbWV0cnkgKGVudmVsb3BlKSB7XG4gIGlmIChlbnZlbG9wZS5pc051bGwoKSkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBvaW50KG51bGwpXG4gIH1cbiAgaWYgKGVudmVsb3BlLmdldE1pblgoKSA9PT0gZW52ZWxvcGUuZ2V0TWF4WCgpICYmIGVudmVsb3BlLmdldE1pblkoKSA9PT0gZW52ZWxvcGUuZ2V0TWF4WSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQobmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWluWCgpLCBlbnZlbG9wZS5nZXRNaW5ZKCkpKVxuICB9XG4gIGlmIChlbnZlbG9wZS5nZXRNaW5YKCkgPT09IGVudmVsb3BlLmdldE1heFgoKSB8fCBlbnZlbG9wZS5nZXRNaW5ZKCkgPT09IGVudmVsb3BlLmdldE1heFkoKSkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcoW25ldyBDb29yZGluYXRlKGVudmVsb3BlLmdldE1pblgoKSwgZW52ZWxvcGUuZ2V0TWluWSgpKSwgbmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWF4WCgpLCBlbnZlbG9wZS5nZXRNYXhZKCkpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhbbmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWluWCgpLCBlbnZlbG9wZS5nZXRNaW5ZKCkpLCBuZXcgQ29vcmRpbmF0ZShlbnZlbG9wZS5nZXRNaW5YKCksIGVudmVsb3BlLmdldE1heFkoKSksIG5ldyBDb29yZGluYXRlKGVudmVsb3BlLmdldE1heFgoKSwgZW52ZWxvcGUuZ2V0TWF4WSgpKSwgbmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWF4WCgpLCBlbnZlbG9wZS5nZXRNaW5ZKCkpLCBuZXcgQ29vcmRpbmF0ZShlbnZlbG9wZS5nZXRNaW5YKCksIGVudmVsb3BlLmdldE1pblkoKSldKSwgbnVsbClcbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUxpbmVTdHJpbmcgPSBmdW5jdGlvbiBjcmVhdGVMaW5lU3RyaW5nIChjb29yZGluYXRlcykge1xuICBpZiAoIWNvb3JkaW5hdGVzKSB7IHJldHVybiBuZXcgTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pLCB0aGlzKSB9XG4gIGVsc2UgaWYgKGNvb3JkaW5hdGVzIGluc3RhbmNlb2YgQXJyYXkpIHsgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShjb29yZGluYXRlcyksIHRoaXMpIH1cbiAgZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGNvb3JkaW5hdGVzLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7IHJldHVybiBuZXcgTGluZVN0cmluZyhjb29yZGluYXRlcywgdGhpcykgfVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTXVsdGlMaW5lU3RyaW5nID0gZnVuY3Rpb24gY3JlYXRlTXVsdGlMaW5lU3RyaW5nICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IE11bHRpTGluZVN0cmluZyhudWxsLCB0aGlzKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbGluZVN0cmluZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIG5ldyBNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MsIHRoaXMpXG4gIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmJ1aWxkR2VvbWV0cnkgPSBmdW5jdGlvbiBidWlsZEdlb21ldHJ5IChnZW9tTGlzdCkge1xuICB2YXIgZ2VvbUNsYXNzID0gbnVsbDtcbiAgdmFyIGlzSGV0ZXJvZ2VuZW91cyA9IGZhbHNlO1xuICB2YXIgaGFzR2VvbWV0cnlDb2xsZWN0aW9uID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBnZW9tTGlzdC5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZ2VvbSA9IGkubmV4dCgpO1xuICAgIHZhciBwYXJ0Q2xhc3MgPSBnZW9tLmdldENsYXNzKCk7XG4gICAgaWYgKGdlb21DbGFzcyA9PT0gbnVsbCkge1xuICAgICAgZ2VvbUNsYXNzID0gcGFydENsYXNzO1xuICAgIH1cbiAgICBpZiAocGFydENsYXNzICE9PSBnZW9tQ2xhc3MpIHtcbiAgICAgIGlzSGV0ZXJvZ2VuZW91cyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChnZW9tLmlzR2VvbWV0cnlDb2xsZWN0aW9uT3JEZXJpdmVkKCkpIHsgaGFzR2VvbWV0cnlDb2xsZWN0aW9uID0gdHJ1ZTsgfVxuICB9XG4gIGlmIChnZW9tQ2xhc3MgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKVxuICB9XG4gIGlmIChpc0hldGVyb2dlbmVvdXMgfHwgaGFzR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEdlb21ldHJ5RmFjdG9yeS50b0dlb21ldHJ5QXJyYXkoZ2VvbUxpc3QpKVxuICB9XG4gIHZhciBnZW9tMCA9IGdlb21MaXN0Lml0ZXJhdG9yKCkubmV4dCgpO1xuICB2YXIgaXNDb2xsZWN0aW9uID0gZ2VvbUxpc3Quc2l6ZSgpID4gMTtcbiAgaWYgKGlzQ29sbGVjdGlvbikge1xuICAgIGlmIChnZW9tMCBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9seWdvbihHZW9tZXRyeUZhY3RvcnkudG9Qb2x5Z29uQXJyYXkoZ2VvbUxpc3QpKVxuICAgIH0gZWxzZSBpZiAoZ2VvbTAgaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoR2VvbWV0cnlGYWN0b3J5LnRvTGluZVN0cmluZ0FycmF5KGdlb21MaXN0KSlcbiAgICB9IGVsc2UgaWYgKGdlb20wIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoR2VvbWV0cnlGYWN0b3J5LnRvUG9pbnRBcnJheShnZW9tTGlzdCkpXG4gICAgfVxuICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgnVW5oYW5kbGVkIGNsYXNzOiAnICsgZ2VvbTAuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO1xuICB9XG4gIHJldHVybiBnZW9tMFxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMgPSBmdW5jdGlvbiBjcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyAoY29vcmRpbmF0ZXMpIHtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChjb29yZGluYXRlcyAhPT0gbnVsbCA/IHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShjb29yZGluYXRlcykgOiBudWxsKVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlUG9pbnQgPSBmdW5jdGlvbiBjcmVhdGVQb2ludCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBjb29yZGluYXRlID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQoY29vcmRpbmF0ZSAhPT0gbnVsbCA/IHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbY29vcmRpbmF0ZV0pIDogbnVsbClcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBuZXcgUG9pbnQoY29vcmRpbmF0ZXMsIHRoaXMpXG4gICAgfVxuICB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSAoKSB7XG4gIHJldHVybiB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVQb2x5Z29uID0gZnVuY3Rpb24gY3JlYXRlUG9seWdvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKG51bGwsIG51bGwsIHRoaXMpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhjb29yZGluYXRlcykpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhjb29yZGluYXRlcyQxKSlcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVhclJpbmcpIHtcbiAgICAgIHZhciBzaGVsbCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24oc2hlbGwsIG51bGwpXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2hlbGwkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgaG9sZXMgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIG5ldyBQb2x5Z29uKHNoZWxsJDEsIGhvbGVzLCB0aGlzKVxuICB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5nZXRTUklEID0gZnVuY3Rpb24gZ2V0U1JJRCAoKSB7XG4gIHJldHVybiB0aGlzLl9TUklEXG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiBjcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwsIHRoaXMpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tZXRyaWVzID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMsIHRoaXMpXG4gIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUdlb21ldHJ5ID0gZnVuY3Rpb24gY3JlYXRlR2VvbWV0cnkgKGcpIHtcbiAgdmFyIGVkaXRvciA9IG5ldyBHZW9tZXRyeUVkaXRvcih0aGlzKTtcbiAgcmV0dXJuIGVkaXRvci5lZGl0KGcsIHtcbiAgICBlZGl0OiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB2YXIgY29vcmRTZXEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIC8vIGNvbnN0IGdlb21ldHJ5ID0gYXJndW1lbnRzWzFdXG4gICAgICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LmNyZWF0ZShjb29yZFNlcSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5nZXRQcmVjaXNpb25Nb2RlbCA9IGZ1bmN0aW9uIGdldFByZWNpc2lvbk1vZGVsICgpIHtcbiAgcmV0dXJuIHRoaXMuX3ByZWNpc2lvbk1vZGVsXG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVMaW5lYXJSaW5nID0gZnVuY3Rpb24gY3JlYXRlTGluZWFyUmluZyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcoY29vcmRpbmF0ZXMgIT09IG51bGwgPyB0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoY29vcmRpbmF0ZXMpIDogbnVsbClcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIG5ldyBMaW5lYXJSaW5nKGNvb3JkaW5hdGVzJDEsIHRoaXMpXG4gICAgfVxuICB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVNdWx0aVBvbHlnb24gPSBmdW5jdGlvbiBjcmVhdGVNdWx0aVBvbHlnb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgTXVsdGlQb2x5Z29uKG51bGwsIHRoaXMpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwb2x5Z29ucyA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gbmV3IE11bHRpUG9seWdvbihwb2x5Z29ucywgdGhpcylcbiAgfVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTXVsdGlQb2ludCA9IGZ1bmN0aW9uIGNyZWF0ZU11bHRpUG9pbnQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvaW50KG51bGwsIHRoaXMpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFyIHBvaW50ID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIG5ldyBNdWx0aVBvaW50KHBvaW50LCB0aGlzKVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoY29vcmRpbmF0ZXMgIT09IG51bGwgPyB0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoY29vcmRpbmF0ZXMpIDogbnVsbClcbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKGNvb3JkaW5hdGVzJDEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChuZXcgQXJyYXkoMCkuZmlsbChudWxsKSlcbiAgICAgIH1cbiAgICAgIHZhciBwb2ludHMgPSBuZXcgQXJyYXkoY29vcmRpbmF0ZXMkMS5zaXplKCkpLmZpbGwobnVsbCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzJDEuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgdmFyIHB0U2VxID0gdGhpcyQxLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoMSwgY29vcmRpbmF0ZXMkMS5nZXREaW1lbnNpb24oKSk7XG4gICAgICAgIENvb3JkaW5hdGVTZXF1ZW5jZXMuY29weShjb29yZGluYXRlcyQxLCBpLCBwdFNlcSwgMCwgMSk7XG4gICAgICAgIHBvaW50c1tpXSA9IHRoaXMkMS5jcmVhdGVQb2ludChwdFNlcSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KHBvaW50cylcbiAgICB9XG4gIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlcmlhbGl6YWJsZV1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlGYWN0b3J5XG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvTXVsdGlQb2x5Z29uQXJyYXkgPSBmdW5jdGlvbiB0b011bHRpUG9seWdvbkFycmF5IChtdWx0aVBvbHlnb25zKSB7XG4gIHZhciBtdWx0aVBvbHlnb25BcnJheSA9IG5ldyBBcnJheShtdWx0aVBvbHlnb25zLnNpemUoKSkuZmlsbChudWxsKTtcbiAgcmV0dXJuIG11bHRpUG9seWdvbnMudG9BcnJheShtdWx0aVBvbHlnb25BcnJheSlcbn07XG5HZW9tZXRyeUZhY3RvcnkudG9HZW9tZXRyeUFycmF5ID0gZnVuY3Rpb24gdG9HZW9tZXRyeUFycmF5IChnZW9tZXRyaWVzKSB7XG4gIGlmIChnZW9tZXRyaWVzID09PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGdlb21ldHJ5QXJyYXkgPSBuZXcgQXJyYXkoZ2VvbWV0cmllcy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBnZW9tZXRyaWVzLnRvQXJyYXkoZ2VvbWV0cnlBcnJheSlcbn07XG5HZW9tZXRyeUZhY3RvcnkuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkuaW5zdGFuY2UoKVxufTtcbkdlb21ldHJ5RmFjdG9yeS50b011bHRpTGluZVN0cmluZ0FycmF5ID0gZnVuY3Rpb24gdG9NdWx0aUxpbmVTdHJpbmdBcnJheSAobXVsdGlMaW5lU3RyaW5ncykge1xuICB2YXIgbXVsdGlMaW5lU3RyaW5nQXJyYXkgPSBuZXcgQXJyYXkobXVsdGlMaW5lU3RyaW5ncy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBtdWx0aUxpbmVTdHJpbmdzLnRvQXJyYXkobXVsdGlMaW5lU3RyaW5nQXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvTGluZVN0cmluZ0FycmF5ID0gZnVuY3Rpb24gdG9MaW5lU3RyaW5nQXJyYXkgKGxpbmVTdHJpbmdzKSB7XG4gIHZhciBsaW5lU3RyaW5nQXJyYXkgPSBuZXcgQXJyYXkobGluZVN0cmluZ3Muc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gbGluZVN0cmluZ3MudG9BcnJheShsaW5lU3RyaW5nQXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvTXVsdGlQb2ludEFycmF5ID0gZnVuY3Rpb24gdG9NdWx0aVBvaW50QXJyYXkgKG11bHRpUG9pbnRzKSB7XG4gIHZhciBtdWx0aVBvaW50QXJyYXkgPSBuZXcgQXJyYXkobXVsdGlQb2ludHMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gbXVsdGlQb2ludHMudG9BcnJheShtdWx0aVBvaW50QXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvTGluZWFyUmluZ0FycmF5ID0gZnVuY3Rpb24gdG9MaW5lYXJSaW5nQXJyYXkgKGxpbmVhclJpbmdzKSB7XG4gIHZhciBsaW5lYXJSaW5nQXJyYXkgPSBuZXcgQXJyYXkobGluZWFyUmluZ3Muc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gbGluZWFyUmluZ3MudG9BcnJheShsaW5lYXJSaW5nQXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvUG9pbnRBcnJheSA9IGZ1bmN0aW9uIHRvUG9pbnRBcnJheSAocG9pbnRzKSB7XG4gIHZhciBwb2ludEFycmF5ID0gbmV3IEFycmF5KHBvaW50cy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBwb2ludHMudG9BcnJheShwb2ludEFycmF5KVxufTtcbkdlb21ldHJ5RmFjdG9yeS50b1BvbHlnb25BcnJheSA9IGZ1bmN0aW9uIHRvUG9seWdvbkFycmF5IChwb2x5Z29ucykge1xuICB2YXIgcG9seWdvbkFycmF5ID0gbmV3IEFycmF5KHBvbHlnb25zLnNpemUoKSkuZmlsbChudWxsKTtcbiAgcmV0dXJuIHBvbHlnb25zLnRvQXJyYXkocG9seWdvbkFycmF5KVxufTtcbkdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkID0gZnVuY3Rpb24gY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCAoY29vcmQsIGV4ZW1wbGFyKSB7XG4gIGV4ZW1wbGFyLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UoY29vcmQpO1xuICByZXR1cm4gZXhlbXBsYXIuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KGNvb3JkKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQyLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTY4MjA1MjQ3NTMwOTQwOTU2MzUgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEdlb21ldHJ5RmFjdG9yeSwgc3RhdGljQWNjZXNzb3JzJDIgKTtcblxudmFyIGdlb21ldHJ5VHlwZXMgPSBbJ1BvaW50JywgJ011bHRpUG9pbnQnLCAnTGluZVN0cmluZycsICdNdWx0aUxpbmVTdHJpbmcnLCAnUG9seWdvbicsICdNdWx0aVBvbHlnb24nXTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBXZWxsLUtub3duIFRleHQuQ3JlYXRlIGEgbmV3IHBhcnNlciBmb3IgR2VvSlNPTlxuICogTk9URTogQWRhcHRlZCBmcm9tIE9wZW5MYXllcnMgMi4xMSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBwYXJzZXIgZm9yIEdlb0pTT05cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5RmFjdG9yeX0gZ2VvbWV0cnlGYWN0b3J5XG4gKiBAcmV0dXJuIEFuIGluc3RhbmNlIG9mIEdlb0pzb25QYXJzZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBHZW9KU09OUGFyc2VyID0gZnVuY3Rpb24gR2VvSlNPTlBhcnNlciAoZ2VvbWV0cnlGYWN0b3J5KSB7XG4gIHRoaXMuZ2VvbWV0cnlGYWN0b3J5ID0gZ2VvbWV0cnlGYWN0b3J5IHx8IG5ldyBHZW9tZXRyeUZhY3RvcnkoKTtcbn07XG4vKipcbiAqIERlc2VyaWFsaXplIGEgR2VvSlNPTiBvYmplY3QgYW5kIHJldHVybiB0aGUgR2VvbWV0cnkgb3IgRmVhdHVyZShDb2xsZWN0aW9uKSB3aXRoIEpTVFMgR2VvbWV0cmllc1xuICpcbiAqIEBwYXJhbSB7fVxuICogICAgICAgIEEgR2VvSlNPTiBvYmplY3QuXG4gKiBAcmV0dXJuIHt9IEEgR2VvbWV0cnkgaW5zdGFuY2Ugb3Igb2JqZWN0IHJlcHJlc2VudGluZyBhIEZlYXR1cmUoQ29sbGVjdGlvbikgd2l0aCBHZW9tZXRyeSBpbnN0YW5jZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5HZW9KU09OUGFyc2VyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gcmVhZCAoanNvbikge1xuICB2YXIgb2JqO1xuICBpZiAodHlwZW9mIGpzb24gPT09ICdzdHJpbmcnKSB7XG4gICAgb2JqID0gSlNPTi5wYXJzZShqc29uKTtcbiAgfSBlbHNlIHtcbiAgICBvYmogPSBqc29uO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBvYmoudHlwZTtcblxuICBpZiAoIXBhcnNlW3R5cGVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIEdlb0pTT04gdHlwZTogJyArIG9iai50eXBlKVxuICB9XG5cbiAgaWYgKGdlb21ldHJ5VHlwZXMuaW5kZXhPZih0eXBlKSAhPT0gLTEpIHtcbiAgICByZXR1cm4gcGFyc2VbdHlwZV0uYXBwbHkodGhpcywgW29iai5jb29yZGluYXRlc10pXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICByZXR1cm4gcGFyc2VbdHlwZV0uYXBwbHkodGhpcywgW29iai5nZW9tZXRyaWVzXSlcbiAgfVxuXG4gIC8vIGZlYXR1cmUgb3IgZmVhdHVyZSBjb2xsZWN0aW9uXG4gIHJldHVybiBwYXJzZVt0eXBlXS5hcHBseSh0aGlzLCBbb2JqXSlcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGEgR2VvbWV0cnkgb2JqZWN0IGludG8gR2VvSlNPTlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnl9XG4gKiAgICAgICAgZ2VvbWV0cnkgQSBHZW9tZXRyeSBvciBhcnJheSBvZiBHZW9tZXRyaWVzLlxuICogQHJldHVybiB7T2JqZWN0fSBBIEdlb0pTT04gb2JqZWN0IHJlcHJlc3RpbmcgdGhlIGlucHV0IEdlb21ldHJ5L0dlb21ldHJpZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5HZW9KU09OUGFyc2VyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChnZW9tZXRyeSkge1xuICB2YXIgdHlwZSA9IGdlb21ldHJ5LmdldEdlb21ldHJ5VHlwZSgpO1xuXG4gIGlmICghZXh0cmFjdFt0eXBlXSkge1xuICAgIHRocm93IG5ldyBFcnJvcignR2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZCcpXG4gIH1cblxuICByZXR1cm4gZXh0cmFjdFt0eXBlXS5hcHBseSh0aGlzLCBbZ2VvbWV0cnldKVxufTtcblxudmFyIHBhcnNlID0ge1xuICAvKipcbiAgICogUGFyc2UgYSBHZW9KU09OIEZlYXR1cmUgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fVxuICAgKiAgICAgICAgICBvYmogT2JqZWN0IHRvIHBhcnNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEZlYXR1cmUgd2l0aCBnZW9tZXRyeS9iYm94IGNvbnZlcnRlZCB0byBKU1RTIEdlb21ldHJpZXMuXG4gICAqL1xuICBGZWF0dXJlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGZlYXR1cmUgPSB7fTtcblxuICAgIC8vIGNvcHkgZmVhdHVyZXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBmZWF0dXJlW2tleV0gPSBvYmpba2V5XTtcbiAgICB9XG5cbiAgICAvLyBwYXJzZSBnZW9tZXRyeVxuICAgIGlmIChvYmouZ2VvbWV0cnkpIHtcbiAgICAgIHZhciB0eXBlID0gb2JqLmdlb21ldHJ5LnR5cGU7XG4gICAgICBpZiAoIXBhcnNlW3R5cGVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBHZW9KU09OIHR5cGU6ICcgKyBvYmoudHlwZSlcbiAgICAgIH1cbiAgICAgIGZlYXR1cmUuZ2VvbWV0cnkgPSB0aGlzLnJlYWQob2JqLmdlb21ldHJ5KTtcbiAgICB9XG5cbiAgICAvLyBiYm94XG4gICAgaWYgKG9iai5iYm94KSB7XG4gICAgICBmZWF0dXJlLmJib3ggPSBwYXJzZS5iYm94LmFwcGx5KHRoaXMsIFtvYmouYmJveF0pO1xuICAgIH1cblxuICAgIHJldHVybiBmZWF0dXJlXG4gIH0sXG5cbiAgLyoqXG4gICAqIFBhcnNlIGEgR2VvSlNPTiBGZWF0dXJlQ29sbGVjdGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9XG4gICAqICAgICAgICAgIG9iaiBPYmplY3QgdG8gcGFyc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gRmVhdHVyZUNvbGxlY3Rpb24gd2l0aCBnZW9tZXRyeS9iYm94IGNvbnZlcnRlZCB0byBKU1RTIEdlb21ldHJpZXMuXG4gICAqL1xuICBGZWF0dXJlQ29sbGVjdGlvbjogZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGZlYXR1cmVDb2xsZWN0aW9uID0ge307XG5cbiAgICBpZiAob2JqLmZlYXR1cmVzKSB7XG4gICAgICBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5mZWF0dXJlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcy5wdXNoKHRoaXMkMS5yZWFkKG9iai5mZWF0dXJlc1tpXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvYmouYmJveCkge1xuICAgICAgZmVhdHVyZUNvbGxlY3Rpb24uYmJveCA9IHRoaXMucGFyc2UuYmJveC5hcHBseSh0aGlzLCBbb2JqLmJib3hdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb25cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCB0aGUgb3JkaW5hdGVzIGluIGFuIGFycmF5IHRvIGFuIGFycmF5IG9mIENvb3JkaW5hdGVzXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IHdpdGgge051bWJlcn1zLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgd2l0aCBDb29yZGluYXRlcy5cbiAgICovXG4gIGNvb3JkaW5hdGVzOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViID0gYXJyYXlbaV07XG4gICAgICBjb29yZGluYXRlcy5wdXNoKG5ldyBDb29yZGluYXRlKHN1YlswXSwgc3ViWzFdKSk7XG4gICAgfVxuICAgIHJldHVybiBjb29yZGluYXRlc1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBiYm94IHRvIGEgTGluZWFyUmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIFt4TWluLCB5TWluLCB4TWF4LCB5TWF4XS5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHdpdGggQ29vcmRpbmF0ZXMuXG4gICAqL1xuICBiYm94OiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhbXG4gICAgICBuZXcgQ29vcmRpbmF0ZShhcnJheVswXSwgYXJyYXlbMV0pLFxuICAgICAgbmV3IENvb3JkaW5hdGUoYXJyYXlbMl0sIGFycmF5WzFdKSxcbiAgICAgIG5ldyBDb29yZGluYXRlKGFycmF5WzJdLCBhcnJheVszXSksXG4gICAgICBuZXcgQ29vcmRpbmF0ZShhcnJheVswXSwgYXJyYXlbM10pLFxuICAgICAgbmV3IENvb3JkaW5hdGUoYXJyYXlbMF0sIGFycmF5WzFdKVxuICAgIF0pXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXkgd2l0aCBvcmRpbmF0ZXMgdG8gYSBQb2ludFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIG9yZGluYXRlcy5cbiAgICpcbiAgICogQHJldHVybiB7UG9pbnR9IFBvaW50LlxuICAgKi9cbiAgUG9pbnQ6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciBjb29yZGluYXRlID0gbmV3IENvb3JkaW5hdGUoYXJyYXlbMF0sIGFycmF5WzFdKTtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoY29vcmRpbmF0ZSlcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB3aXRoIGNvb3JkaW5hdGVzIHRvIGEgTXVsdGlQb2ludFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtNdWx0aVBvaW50fSBNdWx0aVBvaW50LlxuICAgKi9cbiAgTXVsdGlQb2ludDogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgcG9pbnRzLnB1c2gocGFyc2UuUG9pbnQuYXBwbHkodGhpcyQxLCBbYXJyYXlbaV1dKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KHBvaW50cylcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB3aXRoIGNvb3JkaW5hdGVzIHRvIGEgTGluZVN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtMaW5lU3RyaW5nfSBMaW5lU3RyaW5nLlxuICAgKi9cbiAgTGluZVN0cmluZzogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gcGFyc2UuY29vcmRpbmF0ZXMuYXBwbHkodGhpcywgW2FycmF5XSk7XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoY29vcmRpbmF0ZXMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXkgd2l0aCBjb29yZGluYXRlcyB0byBhIE11bHRpTGluZVN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSB3aXRoIGNvb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtNdWx0aUxpbmVTdHJpbmd9IE11bHRpTGluZVN0cmluZy5cbiAgICovXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbGluZVN0cmluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsaW5lU3RyaW5ncy5wdXNoKHBhcnNlLkxpbmVTdHJpbmcuYXBwbHkodGhpcyQxLCBbYXJyYXlbaV1dKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobGluZVN0cmluZ3MpXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gQXJyYXkgdG8gYSBQb2x5Z29uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IHdpdGggc2hlbGwgYW5kIGhvbGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQb2x5Z29ufSBQb2x5Z29uLlxuICAgKi9cbiAgUG9seWdvbjogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2hlbGxDb29yZGluYXRlcyA9IHBhcnNlLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMsIFthcnJheVswXV0pO1xuICAgIHZhciBzaGVsbCA9IHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoc2hlbGxDb29yZGluYXRlcyk7XG4gICAgdmFyIGhvbGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGhvbGUgPSBhcnJheVtpXTtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IHBhcnNlLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMkMSwgW2hvbGVdKTtcbiAgICAgIHZhciBsaW5lYXJSaW5nID0gdGhpcyQxLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGNvb3JkaW5hdGVzKTtcbiAgICAgIGhvbGVzLnB1c2gobGluZWFyUmluZyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKHNoZWxsLCBob2xlcylcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB0byBhIE11bHRpUG9seWdvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSBvZiBhcnJheXMgd2l0aCBzaGVsbCBhbmQgcmluZ3MuXG4gICAqXG4gICAqIEByZXR1cm4ge011bHRpUG9seWdvbn0gTXVsdGlQb2x5Z29uLlxuICAgKi9cbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBwb2x5Z29ucyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBwb2x5Z29uID0gYXJyYXlbaV07XG4gICAgICBwb2x5Z29ucy5wdXNoKHBhcnNlLlBvbHlnb24uYXBwbHkodGhpcyQxLCBbcG9seWdvbl0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbihwb2x5Z29ucylcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB0byBhIEdlb21ldHJ5Q29sbGVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fVxuICAgKiAgICAgICAgICBhcnJheSBBcnJheSBvZiBHZW9KU09OIGdlb21ldHJpZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge0dlb21ldHJ5Q29sbGVjdGlvbn0gR2VvbWV0cnlDb2xsZWN0aW9uLlxuICAgKi9cbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBnZW9tZXRyaWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGdlb21ldHJ5ID0gYXJyYXlbaV07XG4gICAgICBnZW9tZXRyaWVzLnB1c2godGhpcyQxLnJlYWQoZ2VvbWV0cnkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyaWVzKVxuICB9XG59O1xuXG52YXIgZXh0cmFjdCA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnQgYSBDb29yZGluYXRlIHRvIGFuIEFycmF5XG4gICAqXG4gICAqIEBwYXJhbSB7Q29vcmRpbmF0ZX1cbiAgICogICAgICAgICAgY29vcmRpbmF0ZSBDb29yZGluYXRlIHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBvcmRpbmF0ZXMuXG4gICAqL1xuICBjb29yZGluYXRlOiBmdW5jdGlvbiAoY29vcmRpbmF0ZSkge1xuICAgIHJldHVybiBbY29vcmRpbmF0ZS54LCBjb29yZGluYXRlLnldXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBQb2ludCB0byBhIEdlb0pTT04gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnR9XG4gICAqICAgICAgICAgIHBvaW50IFBvaW50IHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiAyIG9yZGluYXRlcyAocGFpcmVkIHRvIGEgY29vcmRpbmF0ZSkuXG4gICAqL1xuICBQb2ludDogZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgdmFyIGFycmF5ID0gZXh0cmFjdC5jb29yZGluYXRlLmFwcGx5KHRoaXMsIFtwb2ludC5nZXRDb29yZGluYXRlKCldKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1BvaW50JyxcbiAgICAgIGNvb3JkaW5hdGVzOiBhcnJheVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIE11bHRpUG9pbnQgdG8gYSBHZW9KU09OIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpUG9pbnR9XG4gICAqICAgICAgICAgIG11bHRpcG9pbnQgTXVsdGlQb2ludCB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBNdWx0aVBvaW50OiBmdW5jdGlvbiAobXVsdGlwb2ludCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aXBvaW50Ll9nZW9tZXRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcG9pbnQgPSBtdWx0aXBvaW50Ll9nZW9tZXRyaWVzW2ldO1xuICAgICAgdmFyIGdlb0pzb24gPSBleHRyYWN0LlBvaW50LmFwcGx5KHRoaXMkMSwgW3BvaW50XSk7XG4gICAgICBhcnJheS5wdXNoKGdlb0pzb24uY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ011bHRpUG9pbnQnLFxuICAgICAgY29vcmRpbmF0ZXM6IGFycmF5XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgTGluZVN0cmluZyB0byBhIEdlb0pTT04gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7TGluZVN0cmluZ31cbiAgICogICAgICAgICAgbGluZXN0cmluZyBMaW5lU3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBjb29yZGluYXRlcy5cbiAgICovXG4gIExpbmVTdHJpbmc6IGZ1bmN0aW9uIChsaW5lc3RyaW5nKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBsaW5lc3RyaW5nLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgIGFycmF5LnB1c2goZXh0cmFjdC5jb29yZGluYXRlLmFwcGx5KHRoaXMkMSwgW2Nvb3JkaW5hdGVdKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgICBjb29yZGluYXRlczogYXJyYXlcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBNdWx0aUxpbmVTdHJpbmcgdG8gYSBHZW9KU09OIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpTGluZVN0cmluZ31cbiAgICogICAgICAgICAgbXVsdGlsaW5lc3RyaW5nIE11bHRpTGluZVN0cmluZyB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgQXJyYXkgb2YgY29vcmRpbmF0ZXMuXG4gICAqL1xuICBNdWx0aUxpbmVTdHJpbmc6IGZ1bmN0aW9uIChtdWx0aWxpbmVzdHJpbmcpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXVsdGlsaW5lc3RyaW5nLl9nZW9tZXRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgbGluZXN0cmluZyA9IG11bHRpbGluZXN0cmluZy5fZ2VvbWV0cmllc1tpXTtcbiAgICAgIHZhciBnZW9Kc29uID0gZXh0cmFjdC5MaW5lU3RyaW5nLmFwcGx5KHRoaXMkMSwgW2xpbmVzdHJpbmddKTtcbiAgICAgIGFycmF5LnB1c2goZ2VvSnNvbi5jb29yZGluYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgICAgIGNvb3JkaW5hdGVzOiBhcnJheVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIFBvbHlnb24gdG8gYSBHZW9KU09OIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHlnb259XG4gICAqICAgICAgICAgIHBvbHlnb24gUG9seWdvbiB0byBjb252ZXJ0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgd2l0aCBzaGVsbCwgaG9sZXMuXG4gICAqL1xuICBQb2x5Z29uOiBmdW5jdGlvbiAocG9seWdvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIHNoZWxsR2VvSnNvbiA9IGV4dHJhY3QuTGluZVN0cmluZy5hcHBseSh0aGlzLCBbcG9seWdvbi5fc2hlbGxdKTtcbiAgICBhcnJheS5wdXNoKHNoZWxsR2VvSnNvbi5jb29yZGluYXRlcyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29uLl9ob2xlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGhvbGUgPSBwb2x5Z29uLl9ob2xlc1tpXTtcbiAgICAgIHZhciBob2xlR2VvSnNvbiA9IGV4dHJhY3QuTGluZVN0cmluZy5hcHBseSh0aGlzJDEsIFtob2xlXSk7XG4gICAgICBhcnJheS5wdXNoKGhvbGVHZW9Kc29uLmNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgIGNvb3JkaW5hdGVzOiBhcnJheVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIE11bHRpUG9seWdvbiB0byBhIEdlb0pTT04gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlQb2x5Z29ufVxuICAgKiAgICAgICAgICBtdWx0aXBvbHlnb24gTXVsdGlQb2x5Z29uIHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBwb2x5Z29ucy5cbiAgICovXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24gKG11bHRpcG9seWdvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aXBvbHlnb24uX2dlb21ldHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBwb2x5Z29uID0gbXVsdGlwb2x5Z29uLl9nZW9tZXRyaWVzW2ldO1xuICAgICAgdmFyIGdlb0pzb24gPSBleHRyYWN0LlBvbHlnb24uYXBwbHkodGhpcyQxLCBbcG9seWdvbl0pO1xuICAgICAgYXJyYXkucHVzaChnZW9Kc29uLmNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdNdWx0aVBvbHlnb24nLFxuICAgICAgY29vcmRpbmF0ZXM6IGFycmF5XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgR2VvbWV0cnlDb2xsZWN0aW9uIHRvIGEgR2VvSlNPTiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtHZW9tZXRyeUNvbGxlY3Rpb259XG4gICAqICAgICAgICAgIGNvbGxlY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uIHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBnZW9tZXRyaWVzLlxuICAgKi9cbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uLl9nZW9tZXRyaWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBjb2xsZWN0aW9uLl9nZW9tZXRyaWVzW2ldO1xuICAgICAgdmFyIHR5cGUgPSBnZW9tZXRyeS5nZXRHZW9tZXRyeVR5cGUoKTtcbiAgICAgIGFycmF5LnB1c2goZXh0cmFjdFt0eXBlXS5hcHBseSh0aGlzJDEsIFtnZW9tZXRyeV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdHZW9tZXRyeUNvbGxlY3Rpb24nLFxuICAgICAgZ2VvbWV0cmllczogYXJyYXlcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBnZW9tZXRyeSBpbiBHZW9KU09OIHRvIGEge0BsaW5rIEdlb21ldHJ5fS5cbiAqL1xuXG4vKipcbiAqIEEgPGNvZGU+R2VvSlNPTlJlYWRlcjwvY29kZT4gaXMgcGFyYW1ldGVyaXplZCBieSBhIDxjb2RlPkdlb21ldHJ5RmFjdG9yeTwvY29kZT4sXG4gKiB0byBhbGxvdyBpdCB0byBjcmVhdGUgPGNvZGU+R2VvbWV0cnk8L2NvZGU+IG9iamVjdHMgb2YgdGhlIGFwcHJvcHJpYXRlXG4gKiBpbXBsZW1lbnRhdGlvbi4gSW4gcGFydGljdWxhciwgdGhlIDxjb2RlPkdlb21ldHJ5RmFjdG9yeTwvY29kZT4gZGV0ZXJtaW5lc1xuICogdGhlIDxjb2RlPlByZWNpc2lvbk1vZGVsPC9jb2RlPiBhbmQgPGNvZGU+U1JJRDwvY29kZT4gdGhhdCBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnlGYWN0b3J5fSBnZW9tZXRyeUZhY3RvcnlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgR2VvSlNPTlJlYWRlciA9IGZ1bmN0aW9uIEdlb0pTT05SZWFkZXIgKGdlb21ldHJ5RmFjdG9yeSkge1xuICB0aGlzLmdlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeSB8fCBuZXcgR2VvbWV0cnlGYWN0b3J5KCk7XG4gIHRoaXMucHJlY2lzaW9uTW9kZWwgPSB0aGlzLmdlb21ldHJ5RmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpO1xuICB0aGlzLnBhcnNlciA9IG5ldyBHZW9KU09OUGFyc2VyKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTtcbn07XG4vKipcbiAqIFJlYWRzIGEgR2VvSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHtAbGluayBHZW9tZXRyeX1cbiAqXG4gKiBXaWxsIGFsc28gcGFyc2UgR2VvSlNPTiBGZWF0dXJlcy9GZWF0dXJlQ29sbGVjdGlvbnMgYXMgY3VzdG9tIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBnZW9Kc29uIGEgR2VvSlNPTiBPYmplY3Qgb3IgU3RyaW5nLlxuICogQHJldHVybiB7R2VvbWV0cnl8T2JqZWN0fSBhIDxjb2RlPkdlb21ldHJ5IG9yIEZlYXR1cmUvRmVhdHVyZUNvbGxlY3Rpb24gcmVwcmVzZW50YXRpb24uPC9jb2RlPlxuICogQG1lbWJlcm9mIEdlb0pTT05SZWFkZXJcbiAqL1xuR2VvSlNPTlJlYWRlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIHJlYWQgKGdlb0pzb24pIHtcbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5wYXJzZXIucmVhZChnZW9Kc29uKTtcblxuICBpZiAodGhpcy5wcmVjaXNpb25Nb2RlbC5nZXRUeXBlKCkgPT09IFByZWNpc2lvbk1vZGVsLkZJWEVEKSB7XG4gICAgdGhpcy5yZWR1Y2VQcmVjaXNpb24oZ2VvbWV0cnkpO1xuICB9XG5cbiAgcmV0dXJuIGdlb21ldHJ5XG59O1xuXG4vLyBOT1RFOiB0aGlzIGlzIGEgaGFja1xuR2VvSlNPTlJlYWRlci5wcm90b3R5cGUucmVkdWNlUHJlY2lzaW9uID0gZnVuY3Rpb24gcmVkdWNlUHJlY2lzaW9uIChnZW9tZXRyeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpLCBsZW47XG5cbiAgaWYgKGdlb21ldHJ5LmNvb3JkaW5hdGUpIHtcbiAgICB0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGdlb21ldHJ5LmNvb3JkaW5hdGUpO1xuICB9IGVsc2UgaWYgKGdlb21ldHJ5LnBvaW50cykge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5LnBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcyQxLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGdlb21ldHJ5LnBvaW50c1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGdlb21ldHJ5Lmdlb21ldHJpZXMpIHtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzJDEucmVkdWNlUHJlY2lzaW9uKGdlb21ldHJ5Lmdlb21ldHJpZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBAbW9kdWxlIEdlb0pTT05Xcml0ZXJcbiAqL1xuXG4vKipcbiAqIFdyaXRlcyB0aGUgR2VvSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHtAbGluayBHZW9tZXRyeX0uIFRoZVxuICogVGhlIEdlb0pTT04gZm9ybWF0IGlzIGRlZmluZWQgPEFcbiAqIEhSRUY9XCJodHRwOi8vZ2VvanNvbi5vcmcvZ2VvanNvbi1zcGVjLmh0bWxcIj5oZXJlPC9BPi5cbiAqL1xuXG4vKipcbiAqIFRoZSA8Y29kZT5HZW9KU09OV3JpdGVyPC9jb2RlPiBvdXRwdXRzIGNvb3JkaW5hdGVzIHJvdW5kZWQgdG8gdGhlIHByZWNpc2lvblxuICogbW9kZWwuIE9ubHkgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlXG4gKiBvcmRpbmF0ZXMgdG8gdGhlIHJlcXVpcmVkIHByZWNpc2lvbiB3aWxsIGJlIG91dHB1dC5cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5RmFjdG9yeX0gZ2VvbWV0cnlGYWN0b3J5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEdlb0pTT05Xcml0ZXIgPSBmdW5jdGlvbiBHZW9KU09OV3JpdGVyICgpIHtcbiAgdGhpcy5wYXJzZXIgPSBuZXcgR2VvSlNPTlBhcnNlcih0aGlzLmdlb21ldHJ5RmFjdG9yeSk7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIDxjb2RlPkdlb21ldHJ5PC9jb2RlPiB0byBpdHMgR2VvSlNPTiByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5fVxuICogICAgICAgIGdlb21ldHJ5IGEgPGNvZGU+R2VvbWV0cnk8L2NvZGU+IHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBHZW9KU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBHZW9tZXRyeS5cbiAqIEBtZW1iZXJvZiBHZW9KU09OV3JpdGVyXG4gKi9cbkdlb0pTT05Xcml0ZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKGdlb21ldHJ5KSB7XG4gIHJldHVybiB0aGlzLnBhcnNlci53cml0ZShnZW9tZXRyeSlcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVmICovXG5cbi8vIGlvXG5cbnZhciBQb3NpdGlvbiA9IGZ1bmN0aW9uIFBvc2l0aW9uICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDIwID0geyBPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxMRUZUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFJJR0hUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblBvc2l0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9zaXRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9zaXRpb25cbn07XG5Qb3NpdGlvbi5vcHBvc2l0ZSA9IGZ1bmN0aW9uIG9wcG9zaXRlIChwb3NpdGlvbikge1xuICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLkxFRlQpIHsgcmV0dXJuIFBvc2l0aW9uLlJJR0hUIH1cbiAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5SSUdIVCkgeyByZXR1cm4gUG9zaXRpb24uTEVGVCB9XG4gIHJldHVybiBwb3NpdGlvblxufTtcbnN0YXRpY0FjY2Vzc29ycyQyMC5PTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjAuTEVGVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjAuUklHSFQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggUG9zaXRpb24sIHN0YXRpY0FjY2Vzc29ycyQyMCApO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBPcHRpb25hbCBtZXNzYWdlXG4gKiBAZXh0ZW5kcyB7RXJyb3J9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVtcHR5U3RhY2tFeGNlcHRpb24gKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbn1cbkVtcHR5U3RhY2tFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuRW1wdHlTdGFja0V4Y2VwdGlvbi5wcm90b3R5cGUubmFtZSA9ICdFbXB0eVN0YWNrRXhjZXB0aW9uJztcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9TdGFjay5odG1sXG4gKlxuICogQGV4dGVuZHMge0xpc3R9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFN0YWNrICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMuYXJyYXlfID0gW107XG59XG5TdGFjay5wcm90b3R5cGUgPSBuZXcgTGlzdCgpO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TdGFjay5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGUpIHtcbiAgdGhpcy5hcnJheV8ucHVzaChlKTtcbiAgcmV0dXJuIHRydWVcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblN0YWNrLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLnNpemUoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigpXG4gIH1cblxuICByZXR1cm4gdGhpcy5hcnJheV9baW5kZXhdXG59O1xuXG4vKipcbiAqIFB1c2hlcyBhbiBpdGVtIG9udG8gdGhlIHRvcCBvZiB0aGlzIHN0YWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU3RhY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZSkge1xuICB0aGlzLmFycmF5Xy5wdXNoKGUpO1xuICByZXR1cm4gZVxufTtcblxuLyoqXG4gKiBQdXNoZXMgYW4gaXRlbSBvbnRvIHRoZSB0b3Agb2YgdGhpcyBzdGFjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoZSkge1xuICBpZiAodGhpcy5hcnJheV8ubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5U3RhY2tFeGNlcHRpb24oKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXJyYXlfLnBvcCgpXG59O1xuXG4vKipcbiAqIExvb2tzIGF0IHRoZSBvYmplY3QgYXQgdGhlIHRvcCBvZiB0aGlzIHN0YWNrIHdpdGhvdXQgcmVtb3ZpbmcgaXQgZnJvbSB0aGVcbiAqIHN0YWNrLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5TdGFjay5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYXJyYXlfLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFbXB0eVN0YWNrRXhjZXB0aW9uKClcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFycmF5X1t0aGlzLmFycmF5Xy5sZW5ndGggLSAxXVxufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGlzIHN0YWNrIGlzIGVtcHR5LlxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhbmQgb25seSBpZiB0aGlzIHN0YWNrIGNvbnRhaW5zIG5vIGl0ZW1zOyBmYWxzZVxuICogICAgICAgICBvdGhlcndpc2UuXG4gKi9cblN0YWNrLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuYXJyYXlfLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuU3RhY2sucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmVtcHR5KClcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgMS1iYXNlZCBwb3NpdGlvbiB3aGVyZSBhbiBvYmplY3QgaXMgb24gdGhpcyBzdGFjay4gSWYgdGhlIG9iamVjdFxuICogbyBvY2N1cnMgYXMgYW4gaXRlbSBpbiB0aGlzIHN0YWNrLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBkaXN0YW5jZSBmcm9tIHRoZVxuICogdG9wIG9mIHRoZSBzdGFjayBvZiB0aGUgb2NjdXJyZW5jZSBuZWFyZXN0IHRoZSB0b3Agb2YgdGhlIHN0YWNrOyB0aGUgdG9wbW9zdFxuICogaXRlbSBvbiB0aGUgc3RhY2sgaXMgY29uc2lkZXJlZCB0byBiZSBhdCBkaXN0YW5jZSAxLiBUaGUgZXF1YWxzIG1ldGhvZCBpc1xuICogdXNlZCB0byBjb21wYXJlIG8gdG8gdGhlIGl0ZW1zIGluIHRoaXMgc3RhY2suXG4gKlxuICogTk9URTogZG9lcyBub3QgY3VycmVudGx5IGFjdHVhbGx5IHVzZSBlcXVhbHMuICg9PT0gaXMgdXNlZClcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb1xuICogQHJldHVybiB7bnVtYmVyfSB0aGUgMS1iYXNlZCBwb3NpdGlvbiBmcm9tIHRoZSB0b3Agb2YgdGhlIHN0YWNrIHdoZXJlIHRoZVxuICogICAgICAgICBvYmplY3QgaXMgbG9jYXRlZDsgdGhlIHJldHVybiB2YWx1ZSAtMSBpbmRpY2F0ZXMgdGhhdCB0aGUgb2JqZWN0IGlzXG4gKiAgICAgICAgIG5vdCBvbiB0aGUgc3RhY2suXG4gKi9cblN0YWNrLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobykge1xuICByZXR1cm4gdGhpcy5hcnJheV8uaW5kZXhPZihvKVxufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKiBAZXhwb3J0XG4gKi9cblN0YWNrLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoXG59O1xuXG4vKipcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TdGFjay5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyYXkucHVzaCh0aGlzJDEuYXJyYXlfW2ldKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheVxufTtcblxudmFyIFJpZ2h0bW9zdEVkZ2VGaW5kZXIgPSBmdW5jdGlvbiBSaWdodG1vc3RFZGdlRmluZGVyICgpIHtcbiAgdGhpcy5fbWluSW5kZXggPSAtMTtcbiAgdGhpcy5fbWluQ29vcmQgPSBudWxsO1xuICB0aGlzLl9taW5EZSA9IG51bGw7XG4gIHRoaXMuX29yaWVudGVkRGUgPSBudWxsO1xufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX21pbkNvb3JkXG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZ2V0UmlnaHRtb3N0U2lkZSA9IGZ1bmN0aW9uIGdldFJpZ2h0bW9zdFNpZGUgKGRlLCBpbmRleCkge1xuICB2YXIgc2lkZSA9IHRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudChkZSwgaW5kZXgpO1xuICBpZiAoc2lkZSA8IDApIHsgc2lkZSA9IHRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudChkZSwgaW5kZXggLSAxKTsgfVxuICBpZiAoc2lkZSA8IDApIHtcbiAgICB0aGlzLl9taW5Db29yZCA9IG51bGw7XG4gICAgdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUoZGUpO1xuICB9XG4gIHJldHVybiBzaWRlXG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCA9IGZ1bmN0aW9uIGZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXggKCkge1xuICB2YXIgcHRzID0gdGhpcy5fbWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7XG4gIEFzc2VydC5pc1RydWUodGhpcy5fbWluSW5kZXggPiAwICYmIHRoaXMuX21pbkluZGV4IDwgcHRzLmxlbmd0aCwgJ3JpZ2h0bW9zdCBwb2ludCBleHBlY3RlZCB0byBiZSBpbnRlcmlvciB2ZXJ0ZXggb2YgZWRnZScpO1xuICB2YXIgcFByZXYgPSBwdHNbdGhpcy5fbWluSW5kZXggLSAxXTtcbiAgdmFyIHBOZXh0ID0gcHRzW3RoaXMuX21pbkluZGV4ICsgMV07XG4gIHZhciBvcmllbnRhdGlvbiA9IENHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24odGhpcy5fbWluQ29vcmQsIHBOZXh0LCBwUHJldik7XG4gIHZhciB1c2VQcmV2ID0gZmFsc2U7XG4gIGlmIChwUHJldi55IDwgdGhpcy5fbWluQ29vcmQueSAmJiBwTmV4dC55IDwgdGhpcy5fbWluQ29vcmQueSAmJiBvcmllbnRhdGlvbiA9PT0gQ0dBbGdvcml0aG1zLkNPVU5URVJDTE9DS1dJU0UpIHtcbiAgICB1c2VQcmV2ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChwUHJldi55ID4gdGhpcy5fbWluQ29vcmQueSAmJiBwTmV4dC55ID4gdGhpcy5fbWluQ29vcmQueSAmJiBvcmllbnRhdGlvbiA9PT0gQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSkge1xuICAgIHVzZVByZXYgPSB0cnVlO1xuICB9XG4gIGlmICh1c2VQcmV2KSB7XG4gICAgdGhpcy5fbWluSW5kZXggPSB0aGlzLl9taW5JbmRleCAtIDE7XG4gIH1cbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50ID0gZnVuY3Rpb24gZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCAoZGUsIGkpIHtcbiAgdmFyIGUgPSBkZS5nZXRFZGdlKCk7XG4gIHZhciBjb29yZCA9IGUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgaWYgKGkgPCAwIHx8IGkgKyAxID49IGNvb3JkLmxlbmd0aCkgeyByZXR1cm4gLTEgfVxuICBpZiAoY29vcmRbaV0ueSA9PT0gY29vcmRbaSArIDFdLnkpIHsgcmV0dXJuIC0xIH1cbiAgdmFyIHBvcyA9IFBvc2l0aW9uLkxFRlQ7XG4gIGlmIChjb29yZFtpXS55IDwgY29vcmRbaSArIDFdLnkpIHsgcG9zID0gUG9zaXRpb24uUklHSFQ7IH1cbiAgcmV0dXJuIHBvc1xufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmdldEVkZ2UgPSBmdW5jdGlvbiBnZXRFZGdlICgpIHtcbiAgcmV0dXJuIHRoaXMuX29yaWVudGVkRGVcbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBjaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUgKGRlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvb3JkID0gZGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5fbWluQ29vcmQgPT09IG51bGwgfHwgY29vcmRbaV0ueCA+IHRoaXMkMS5fbWluQ29vcmQueCkge1xuICAgICAgdGhpcyQxLl9taW5EZSA9IGRlO1xuICAgICAgdGhpcyQxLl9taW5JbmRleCA9IGk7XG4gICAgICB0aGlzJDEuX21pbkNvb3JkID0gY29vcmRbaV07XG4gICAgfVxuICB9XG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUgPSBmdW5jdGlvbiBmaW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSAoKSB7XG4gIHZhciBub2RlID0gdGhpcy5fbWluRGUuZ2V0Tm9kZSgpO1xuICB2YXIgc3RhciA9IG5vZGUuZ2V0RWRnZXMoKTtcbiAgdGhpcy5fbWluRGUgPSBzdGFyLmdldFJpZ2h0bW9zdEVkZ2UoKTtcbiAgaWYgKCF0aGlzLl9taW5EZS5pc0ZvcndhcmQoKSkge1xuICAgIHRoaXMuX21pbkRlID0gdGhpcy5fbWluRGUuZ2V0U3ltKCk7XG4gICAgdGhpcy5fbWluSW5kZXggPSB0aGlzLl9taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGggLSAxO1xuICB9XG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZmluZEVkZ2UgPSBmdW5jdGlvbiBmaW5kRWRnZSAoZGlyRWRnZUxpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaS5uZXh0KCk7XG4gICAgaWYgKCFkZS5pc0ZvcndhcmQoKSkgeyBjb250aW51ZSB9XG4gICAgdGhpcyQxLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZShkZSk7XG4gIH1cbiAgQXNzZXJ0LmlzVHJ1ZSh0aGlzLl9taW5JbmRleCAhPT0gMCB8fCB0aGlzLl9taW5Db29yZC5lcXVhbHModGhpcy5fbWluRGUuZ2V0Q29vcmRpbmF0ZSgpKSwgJ2luY29uc2lzdGVuY3kgaW4gcmlnaHRtb3N0IHByb2Nlc3NpbmcnKTtcbiAgaWYgKHRoaXMuX21pbkluZGV4ID09PSAwKSB7XG4gICAgdGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCgpO1xuICB9XG4gIHRoaXMuX29yaWVudGVkRGUgPSB0aGlzLl9taW5EZTtcbiAgdmFyIHJpZ2h0bW9zdFNpZGUgPSB0aGlzLmdldFJpZ2h0bW9zdFNpZGUodGhpcy5fbWluRGUsIHRoaXMuX21pbkluZGV4KTtcbiAgaWYgKHJpZ2h0bW9zdFNpZGUgPT09IFBvc2l0aW9uLkxFRlQpIHtcbiAgICB0aGlzLl9vcmllbnRlZERlID0gdGhpcy5fbWluRGUuZ2V0U3ltKCk7XG4gIH1cbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBSaWdodG1vc3RFZGdlRmluZGVyXG59O1xuXG52YXIgVG9wb2xvZ3lFeGNlcHRpb24gPSAoZnVuY3Rpb24gKFJ1bnRpbWVFeGNlcHRpb24kJDEpIHtcbiAgZnVuY3Rpb24gVG9wb2xvZ3lFeGNlcHRpb24gKG1zZywgcHQpIHtcbiAgICBSdW50aW1lRXhjZXB0aW9uJCQxLmNhbGwodGhpcywgVG9wb2xvZ3lFeGNlcHRpb24ubXNnV2l0aENvb3JkKG1zZywgcHQpKTtcbiAgICB0aGlzLnB0ID0gcHQgPyBuZXcgQ29vcmRpbmF0ZShwdCkgOiBudWxsO1xuICAgIHRoaXMubmFtZSA9ICdUb3BvbG9neUV4Y2VwdGlvbic7XG4gIH1cblxuICBpZiAoIFJ1bnRpbWVFeGNlcHRpb24kJDEgKSBUb3BvbG9neUV4Y2VwdGlvbi5fX3Byb3RvX18gPSBSdW50aW1lRXhjZXB0aW9uJCQxO1xuICBUb3BvbG9neUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBSdW50aW1lRXhjZXB0aW9uJCQxICYmIFJ1bnRpbWVFeGNlcHRpb24kJDEucHJvdG90eXBlICk7XG4gIFRvcG9sb2d5RXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcG9sb2d5RXhjZXB0aW9uO1xuICBUb3BvbG9neUV4Y2VwdGlvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIHJldHVybiB0aGlzLnB0XG4gIH07XG4gIFRvcG9sb2d5RXhjZXB0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgVG9wb2xvZ3lFeGNlcHRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBUb3BvbG9neUV4Y2VwdGlvblxuICB9O1xuICBUb3BvbG9neUV4Y2VwdGlvbi5tc2dXaXRoQ29vcmQgPSBmdW5jdGlvbiBtc2dXaXRoQ29vcmQgKG1zZywgcHQpIHtcbiAgICBpZiAoIXB0KSB7IHJldHVybiBtc2cgKyAnIFsgJyArIHB0ICsgJyBdJyB9XG4gICAgcmV0dXJuIG1zZ1xuICB9O1xuXG4gIHJldHVybiBUb3BvbG9neUV4Y2VwdGlvbjtcbn0oUnVudGltZUV4Y2VwdGlvbikpO1xuXG52YXIgTGlua2VkTGlzdCA9IGZ1bmN0aW9uIExpbmtlZExpc3QgKCkge1xuICB0aGlzLmFycmF5XyA9IFtdO1xufTtcbkxpbmtlZExpc3QucHJvdG90eXBlLmFkZExhc3QgPSBmdW5jdGlvbiBhZGRMYXN0IChlKSB7XG4gIHRoaXMuYXJyYXlfLnB1c2goZSk7XG59O1xuTGlua2VkTGlzdC5wcm90b3R5cGUucmVtb3ZlRmlyc3QgPSBmdW5jdGlvbiByZW1vdmVGaXJzdCAoKSB7XG4gIHJldHVybiB0aGlzLmFycmF5Xy5zaGlmdCgpXG59O1xuTGlua2VkTGlzdC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICByZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RoID09PSAwXG59O1xuXG52YXIgQnVmZmVyU3ViZ3JhcGggPSBmdW5jdGlvbiBCdWZmZXJTdWJncmFwaCAoKSB7XG4gIHRoaXMuX2ZpbmRlciA9IG51bGw7XG4gIHRoaXMuX2RpckVkZ2VMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9ub2RlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fcmlnaHRNb3N0Q29vcmQgPSBudWxsO1xuICB0aGlzLl9lbnYgPSBudWxsO1xuICB0aGlzLl9maW5kZXIgPSBuZXcgUmlnaHRtb3N0RWRnZUZpbmRlcigpO1xufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5jbGVhclZpc2l0ZWRFZGdlcyA9IGZ1bmN0aW9uIGNsZWFyVmlzaXRlZEVkZ2VzICgpIHtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgIGRlLnNldFZpc2l0ZWQoZmFsc2UpO1xuICB9XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmdldFJpZ2h0bW9zdENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRSaWdodG1vc3RDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JpZ2h0TW9zdENvb3JkXG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmNvbXB1dGVOb2RlRGVwdGggPSBmdW5jdGlvbiBjb21wdXRlTm9kZURlcHRoIChuKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0RWRnZSA9IG51bGw7XG4gIGZvciAodmFyIGkgPSBuLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaS5uZXh0KCk7XG4gICAgaWYgKGRlLmlzVmlzaXRlZCgpIHx8IGRlLmdldFN5bSgpLmlzVmlzaXRlZCgpKSB7XG4gICAgICBzdGFydEVkZ2UgPSBkZTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIGlmIChzdGFydEVkZ2UgPT09IG51bGwpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCd1bmFibGUgdG8gZmluZCBlZGdlIHRvIGNvbXB1dGUgZGVwdGhzIGF0ICcgKyBuLmdldENvb3JkaW5hdGUoKSkgfVxuICBuLmdldEVkZ2VzKCkuY29tcHV0ZURlcHRocyhzdGFydEVkZ2UpO1xuICBmb3IgKHZhciBpJDEgPSBuLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTsgaSQxLmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUkMSA9IGkkMS5uZXh0KCk7XG4gICAgZGUkMS5zZXRWaXNpdGVkKHRydWUpO1xuICAgIHRoaXMkMS5jb3B5U3ltRGVwdGhzKGRlJDEpO1xuICB9XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmNvbXB1dGVEZXB0aCA9IGZ1bmN0aW9uIGNvbXB1dGVEZXB0aCAob3V0c2lkZURlcHRoKSB7XG4gIHRoaXMuY2xlYXJWaXNpdGVkRWRnZXMoKTtcbiAgdmFyIGRlID0gdGhpcy5fZmluZGVyLmdldEVkZ2UoKTtcbiAgLy8gY29uc3QgbiA9IGRlLmdldE5vZGUoKVxuICAvLyBjb25zdCBsYWJlbCA9IGRlLmdldExhYmVsKClcbiAgZGUuc2V0RWRnZURlcHRocyhQb3NpdGlvbi5SSUdIVCwgb3V0c2lkZURlcHRoKTtcbiAgdGhpcy5jb3B5U3ltRGVwdGhzKGRlKTtcbiAgdGhpcy5jb21wdXRlRGVwdGhzKGRlKTtcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlIChub2RlKSB7XG4gIHRoaXMuYWRkUmVhY2hhYmxlKG5vZGUpO1xuICB0aGlzLl9maW5kZXIuZmluZEVkZ2UodGhpcy5fZGlyRWRnZUxpc3QpO1xuICB0aGlzLl9yaWdodE1vc3RDb29yZCA9IHRoaXMuX2ZpbmRlci5nZXRDb29yZGluYXRlKCk7XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmZpbmRSZXN1bHRFZGdlcyA9IGZ1bmN0aW9uIGZpbmRSZXN1bHRFZGdlcyAoKSB7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICBpZiAoZGUuZ2V0RGVwdGgoUG9zaXRpb24uUklHSFQpID49IDEgJiYgZGUuZ2V0RGVwdGgoUG9zaXRpb24uTEVGVCkgPD0gMCAmJiAhZGUuaXNJbnRlcmlvckFyZWFFZGdlKCkpIHtcbiAgICAgIGRlLnNldEluUmVzdWx0KHRydWUpO1xuICAgIH1cbiAgfVxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5jb21wdXRlRGVwdGhzID0gZnVuY3Rpb24gY29tcHV0ZURlcHRocyAoc3RhcnRFZGdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5vZGVzVmlzaXRlZCA9IG5ldyBIYXNoU2V0KCk7XG4gIHZhciBub2RlUXVldWUgPSBuZXcgTGlua2VkTGlzdCgpO1xuICB2YXIgc3RhcnROb2RlID0gc3RhcnRFZGdlLmdldE5vZGUoKTtcbiAgbm9kZVF1ZXVlLmFkZExhc3Qoc3RhcnROb2RlKTtcbiAgbm9kZXNWaXNpdGVkLmFkZChzdGFydE5vZGUpO1xuICBzdGFydEVkZ2Uuc2V0VmlzaXRlZCh0cnVlKTtcbiAgd2hpbGUgKCFub2RlUXVldWUuaXNFbXB0eSgpKSB7XG4gICAgdmFyIG4gPSBub2RlUXVldWUucmVtb3ZlRmlyc3QoKTtcbiAgICBub2Rlc1Zpc2l0ZWQuYWRkKG4pO1xuICAgIHRoaXMkMS5jb21wdXRlTm9kZURlcHRoKG4pO1xuICAgIGZvciAodmFyIGkgPSBuLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGUgPSBpLm5leHQoKTtcbiAgICAgIHZhciBzeW0gPSBkZS5nZXRTeW0oKTtcbiAgICAgIGlmIChzeW0uaXNWaXNpdGVkKCkpIHsgY29udGludWUgfVxuICAgICAgdmFyIGFkak5vZGUgPSBzeW0uZ2V0Tm9kZSgpO1xuICAgICAgaWYgKCFub2Rlc1Zpc2l0ZWQuY29udGFpbnMoYWRqTm9kZSkpIHtcbiAgICAgICAgbm9kZVF1ZXVlLmFkZExhc3QoYWRqTm9kZSk7XG4gICAgICAgIG5vZGVzVmlzaXRlZC5hZGQoYWRqTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgZ3JhcGggPSBvO1xuICBpZiAodGhpcy5fcmlnaHRNb3N0Q29vcmQueCA8IGdyYXBoLl9yaWdodE1vc3RDb29yZC54KSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHRoaXMuX3JpZ2h0TW9zdENvb3JkLnggPiBncmFwaC5fcmlnaHRNb3N0Q29vcmQueCkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgcmV0dXJuIDBcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuZ2V0RW52ZWxvcGUgPSBmdW5jdGlvbiBnZXRFbnZlbG9wZSAoKSB7XG4gIGlmICh0aGlzLl9lbnYgPT09IG51bGwpIHtcbiAgICB2YXIgZWRnZUVudiA9IG5ldyBFbnZlbG9wZSgpO1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5fZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRpckVkZ2UgPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgcHRzID0gZGlyRWRnZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBlZGdlRW52LmV4cGFuZFRvSW5jbHVkZShwdHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9lbnYgPSBlZGdlRW52O1xuICB9XG4gIHJldHVybiB0aGlzLl9lbnZcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuYWRkUmVhY2hhYmxlID0gZnVuY3Rpb24gYWRkUmVhY2hhYmxlIChzdGFydE5vZGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbm9kZVN0YWNrID0gbmV3IFN0YWNrKCk7XG4gIG5vZGVTdGFjay5hZGQoc3RhcnROb2RlKTtcbiAgd2hpbGUgKCFub2RlU3RhY2suZW1wdHkoKSkge1xuICAgIHZhciBub2RlID0gbm9kZVN0YWNrLnBvcCgpO1xuICAgIHRoaXMkMS5hZGQobm9kZSwgbm9kZVN0YWNrKTtcbiAgfVxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5jb3B5U3ltRGVwdGhzID0gZnVuY3Rpb24gY29weVN5bURlcHRocyAoZGUpIHtcbiAgdmFyIHN5bSA9IGRlLmdldFN5bSgpO1xuICBzeW0uc2V0RGVwdGgoUG9zaXRpb24uTEVGVCwgZGUuZ2V0RGVwdGgoUG9zaXRpb24uUklHSFQpKTtcbiAgc3ltLnNldERlcHRoKFBvc2l0aW9uLlJJR0hULCBkZS5nZXREZXB0aChQb3NpdGlvbi5MRUZUKSk7XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobm9kZSwgbm9kZVN0YWNrKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgbm9kZS5zZXRWaXNpdGVkKHRydWUpO1xuICB0aGlzLl9ub2Rlcy5hZGQobm9kZSk7XG4gIGZvciAodmFyIGkgPSBub2RlLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaS5uZXh0KCk7XG4gICAgdGhpcyQxLl9kaXJFZGdlTGlzdC5hZGQoZGUpO1xuICAgIHZhciBzeW0gPSBkZS5nZXRTeW0oKTtcbiAgICB2YXIgc3ltTm9kZSA9IHN5bS5nZXROb2RlKCk7XG4gICAgaWYgKCFzeW1Ob2RlLmlzVmlzaXRlZCgpKSB7IG5vZGVTdGFjay5wdXNoKHN5bU5vZGUpOyB9XG4gIH1cbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiBnZXROb2RlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2Rlc1xufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5nZXREaXJlY3RlZEVkZ2VzID0gZnVuY3Rpb24gZ2V0RGlyZWN0ZWRFZGdlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9kaXJFZGdlTGlzdFxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJ1ZmZlclN1YmdyYXBoXG59O1xuXG52YXIgVG9wb2xvZ3lMb2NhdGlvbiA9IGZ1bmN0aW9uIFRvcG9sb2d5TG9jYXRpb24gKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmxvY2F0aW9uID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuaW5pdChsb2NhdGlvbi5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKSB7XG4gICAgICB2YXIgb24gPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQoMSk7XG4gICAgICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLk9OXSA9IG9uO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgVG9wb2xvZ3lMb2NhdGlvbikge1xuICAgICAgdmFyIGdsID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KGdsLmxvY2F0aW9uLmxlbmd0aCk7XG4gICAgICBpZiAoZ2wgIT09IG51bGwpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcyQxLmxvY2F0aW9uW2ldID0gZ2wubG9jYXRpb25baV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBvbiQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsZWZ0ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciByaWdodCA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLmluaXQoMyk7XG4gICAgdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5PTl0gPSBvbiQxO1xuICAgIHRoaXMubG9jYXRpb25bUG9zaXRpb24uTEVGVF0gPSBsZWZ0O1xuICAgIHRoaXMubG9jYXRpb25bUG9zaXRpb24uUklHSFRdID0gcmlnaHQ7XG4gIH1cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5zZXRBbGxMb2NhdGlvbnMgPSBmdW5jdGlvbiBzZXRBbGxMb2NhdGlvbnMgKGxvY1ZhbHVlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcyQxLmxvY2F0aW9uW2ldID0gbG9jVmFsdWU7XG4gIH1cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbiBpc051bGwgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzJDEubG9jYXRpb25baV0gIT09IExvY2F0aW9uLk5PTkUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLnNldEFsbExvY2F0aW9uc0lmTnVsbCA9IGZ1bmN0aW9uIHNldEFsbExvY2F0aW9uc0lmTnVsbCAobG9jVmFsdWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLmxvY2F0aW9uW2ldID09PSBMb2NhdGlvbi5OT05FKSB7IHRoaXMkMS5sb2NhdGlvbltpXSA9IGxvY1ZhbHVlOyB9XG4gIH1cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pc0xpbmUgPSBmdW5jdGlvbiBpc0xpbmUgKCkge1xuICByZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGggPT09IDFcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIG1lcmdlIChnbCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChnbC5sb2NhdGlvbi5sZW5ndGggPiB0aGlzLmxvY2F0aW9uLmxlbmd0aCkge1xuICAgIHZhciBuZXdMb2MgPSBuZXcgQXJyYXkoMykuZmlsbChudWxsKTtcbiAgICBuZXdMb2NbUG9zaXRpb24uT05dID0gdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5PTl07XG4gICAgbmV3TG9jW1Bvc2l0aW9uLkxFRlRdID0gTG9jYXRpb24uTk9ORTtcbiAgICBuZXdMb2NbUG9zaXRpb24uUklHSFRdID0gTG9jYXRpb24uTk9ORTtcbiAgICB0aGlzLmxvY2F0aW9uID0gbmV3TG9jO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzJDEubG9jYXRpb25baV0gPT09IExvY2F0aW9uLk5PTkUgJiYgaSA8IGdsLmxvY2F0aW9uLmxlbmd0aCkgeyB0aGlzJDEubG9jYXRpb25baV0gPSBnbC5sb2NhdGlvbltpXTsgfVxuICB9XG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuZ2V0TG9jYXRpb25zID0gZnVuY3Rpb24gZ2V0TG9jYXRpb25zICgpIHtcbiAgcmV0dXJuIHRoaXMubG9jYXRpb25cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24gZmxpcCAoKSB7XG4gIGlmICh0aGlzLmxvY2F0aW9uLmxlbmd0aCA8PSAxKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHRlbXAgPSB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLkxFRlRdO1xuICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLkxFRlRdID0gdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5SSUdIVF07XG4gIHRoaXMubG9jYXRpb25bUG9zaXRpb24uUklHSFRdID0gdGVtcDtcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgaWYgKHRoaXMubG9jYXRpb24ubGVuZ3RoID4gMSkgeyBidWYuYXBwZW5kKExvY2F0aW9uLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltQb3NpdGlvbi5MRUZUXSkpOyB9XG4gIGJ1Zi5hcHBlbmQoTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLk9OXSkpO1xuICBpZiAodGhpcy5sb2NhdGlvbi5sZW5ndGggPiAxKSB7IGJ1Zi5hcHBlbmQoTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLlJJR0hUXSkpOyB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoKVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLnNldExvY2F0aW9ucyA9IGZ1bmN0aW9uIHNldExvY2F0aW9ucyAob24sIGxlZnQsIHJpZ2h0KSB7XG4gIHRoaXMubG9jYXRpb25bUG9zaXRpb24uT05dID0gb247XG4gIHRoaXMubG9jYXRpb25bUG9zaXRpb24uTEVGVF0gPSBsZWZ0O1xuICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLlJJR0hUXSA9IHJpZ2h0O1xufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAocG9zSW5kZXgpIHtcbiAgaWYgKHBvc0luZGV4IDwgdGhpcy5sb2NhdGlvbi5sZW5ndGgpIHsgcmV0dXJuIHRoaXMubG9jYXRpb25bcG9zSW5kZXhdIH1cbiAgcmV0dXJuIExvY2F0aW9uLk5PTkVcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pc0FyZWEgPSBmdW5jdGlvbiBpc0FyZWEgKCkge1xuICByZXR1cm4gdGhpcy5sb2NhdGlvbi5sZW5ndGggPiAxXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuaXNBbnlOdWxsID0gZnVuY3Rpb24gaXNBbnlOdWxsICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLmxvY2F0aW9uW2ldID09PSBMb2NhdGlvbi5OT05FKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIHNldExvY2F0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbG9jVmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRMb2NhdGlvbihQb3NpdGlvbi5PTiwgbG9jVmFsdWUpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgbG9jSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvY1ZhbHVlJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5sb2NhdGlvbltsb2NJbmRleF0gPSBsb2NWYWx1ZSQxO1xuICB9XG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKHNpemUpIHtcbiAgdGhpcy5sb2NhdGlvbiA9IG5ldyBBcnJheShzaXplKS5maWxsKG51bGwpO1xuICB0aGlzLnNldEFsbExvY2F0aW9ucyhMb2NhdGlvbi5OT05FKTtcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pc0VxdWFsT25TaWRlID0gZnVuY3Rpb24gaXNFcXVhbE9uU2lkZSAobGUsIGxvY0luZGV4KSB7XG4gIHJldHVybiB0aGlzLmxvY2F0aW9uW2xvY0luZGV4XSA9PT0gbGUubG9jYXRpb25bbG9jSW5kZXhdXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuYWxsUG9zaXRpb25zRXF1YWwgPSBmdW5jdGlvbiBhbGxQb3NpdGlvbnNFcXVhbCAobG9jKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5sb2NhdGlvbltpXSAhPT0gbG9jKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBUb3BvbG9neUxvY2F0aW9uXG59O1xuXG52YXIgTGFiZWwgPSBmdW5jdGlvbiBMYWJlbCAoKSB7XG4gIHRoaXMuZWx0ID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSkge1xuICAgICAgdmFyIG9uTG9jID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5lbHRbMF0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihvbkxvYyk7XG4gICAgICB0aGlzLmVsdFsxXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKG9uTG9jKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExhYmVsKSB7XG4gICAgICB2YXIgbGJsID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5lbHRbMF0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihsYmwuZWx0WzBdKTtcbiAgICAgIHRoaXMuZWx0WzFdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24obGJsLmVsdFsxXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvbkxvYyQxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuZWx0WzBdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24oTG9jYXRpb24uTk9ORSk7XG4gICAgdGhpcy5lbHRbMV0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihMb2NhdGlvbi5OT05FKTtcbiAgICB0aGlzLmVsdFtnZW9tSW5kZXhdLnNldExvY2F0aW9uKG9uTG9jJDEpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgb25Mb2MkMiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGVmdExvYyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcmlnaHRMb2MgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5lbHRbMF0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihvbkxvYyQyLCBsZWZ0TG9jLCByaWdodExvYyk7XG4gICAgdGhpcy5lbHRbMV0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihvbkxvYyQyLCBsZWZ0TG9jLCByaWdodExvYyk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBnZW9tSW5kZXgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb25Mb2MkMyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbGVmdExvYyQxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciByaWdodExvYyQxID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuZWx0WzBdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24oTG9jYXRpb24uTk9ORSwgTG9jYXRpb24uTk9ORSwgTG9jYXRpb24uTk9ORSk7XG4gICAgdGhpcy5lbHRbMV0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihMb2NhdGlvbi5OT05FLCBMb2NhdGlvbi5OT05FLCBMb2NhdGlvbi5OT05FKTtcbiAgICB0aGlzLmVsdFtnZW9tSW5kZXgkMV0uc2V0TG9jYXRpb25zKG9uTG9jJDMsIGxlZnRMb2MkMSwgcmlnaHRMb2MkMSk7XG4gIH1cbn07XG5MYWJlbC5wcm90b3R5cGUuZ2V0R2VvbWV0cnlDb3VudCA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5Q291bnQgKCkge1xuICB2YXIgY291bnQgPSAwO1xuICBpZiAoIXRoaXMuZWx0WzBdLmlzTnVsbCgpKSB7IGNvdW50Kys7IH1cbiAgaWYgKCF0aGlzLmVsdFsxXS5pc051bGwoKSkgeyBjb3VudCsrOyB9XG4gIHJldHVybiBjb3VudFxufTtcbkxhYmVsLnByb3RvdHlwZS5zZXRBbGxMb2NhdGlvbnMgPSBmdW5jdGlvbiBzZXRBbGxMb2NhdGlvbnMgKGdlb21JbmRleCwgbG9jYXRpb24pIHtcbiAgdGhpcy5lbHRbZ2VvbUluZGV4XS5zZXRBbGxMb2NhdGlvbnMobG9jYXRpb24pO1xufTtcbkxhYmVsLnByb3RvdHlwZS5pc051bGwgPSBmdW5jdGlvbiBpc051bGwgKGdlb21JbmRleCkge1xuICByZXR1cm4gdGhpcy5lbHRbZ2VvbUluZGV4XS5pc051bGwoKVxufTtcbkxhYmVsLnByb3RvdHlwZS5zZXRBbGxMb2NhdGlvbnNJZk51bGwgPSBmdW5jdGlvbiBzZXRBbGxMb2NhdGlvbnNJZk51bGwgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsb2NhdGlvbiA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLCBsb2NhdGlvbik7XG4gICAgdGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSwgbG9jYXRpb24pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsb2NhdGlvbiQxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuZWx0W2dlb21JbmRleF0uc2V0QWxsTG9jYXRpb25zSWZOdWxsKGxvY2F0aW9uJDEpO1xuICB9XG59O1xuTGFiZWwucHJvdG90eXBlLmlzTGluZSA9IGZ1bmN0aW9uIGlzTGluZSAoZ2VvbUluZGV4KSB7XG4gIHJldHVybiB0aGlzLmVsdFtnZW9tSW5kZXhdLmlzTGluZSgpXG59O1xuTGFiZWwucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UgKGxibCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5lbHRbaV0gPT09IG51bGwgJiYgbGJsLmVsdFtpXSAhPT0gbnVsbCkge1xuICAgICAgdGhpcyQxLmVsdFtpXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKGxibC5lbHRbaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzJDEuZWx0W2ldLm1lcmdlKGxibC5lbHRbaV0pO1xuICAgIH1cbiAgfVxufTtcbkxhYmVsLnByb3RvdHlwZS5mbGlwID0gZnVuY3Rpb24gZmxpcCAoKSB7XG4gIHRoaXMuZWx0WzBdLmZsaXAoKTtcbiAgdGhpcy5lbHRbMV0uZmxpcCgpO1xufTtcbkxhYmVsLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLmVsdFtnZW9tSW5kZXhdLmdldChQb3NpdGlvbi5PTilcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb21JbmRleCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwb3NJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICByZXR1cm4gdGhpcy5lbHRbZ2VvbUluZGV4JDFdLmdldChwb3NJbmRleClcbiAgfVxufTtcbkxhYmVsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgaWYgKHRoaXMuZWx0WzBdICE9PSBudWxsKSB7XG4gICAgYnVmLmFwcGVuZCgnQTonKTtcbiAgICBidWYuYXBwZW5kKHRoaXMuZWx0WzBdLnRvU3RyaW5nKCkpO1xuICB9XG4gIGlmICh0aGlzLmVsdFsxXSAhPT0gbnVsbCkge1xuICAgIGJ1Zi5hcHBlbmQoJyBCOicpO1xuICAgIGJ1Zi5hcHBlbmQodGhpcy5lbHRbMV0udG9TdHJpbmcoKSk7XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG59O1xuTGFiZWwucHJvdG90eXBlLmlzQXJlYSA9IGZ1bmN0aW9uIGlzQXJlYSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuZWx0WzBdLmlzQXJlYSgpIHx8IHRoaXMuZWx0WzFdLmlzQXJlYSgpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuZWx0W2dlb21JbmRleF0uaXNBcmVhKClcbiAgfVxufTtcbkxhYmVsLnByb3RvdHlwZS5pc0FueU51bGwgPSBmdW5jdGlvbiBpc0FueU51bGwgKGdlb21JbmRleCkge1xuICByZXR1cm4gdGhpcy5lbHRbZ2VvbUluZGV4XS5pc0FueU51bGwoKVxufTtcbkxhYmVsLnByb3RvdHlwZS5zZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIHNldExvY2F0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsb2NhdGlvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmVsdFtnZW9tSW5kZXhdLnNldExvY2F0aW9uKFBvc2l0aW9uLk9OLCBsb2NhdGlvbik7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnZW9tSW5kZXgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcG9zSW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGxvY2F0aW9uJDEgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5lbHRbZ2VvbUluZGV4JDFdLnNldExvY2F0aW9uKHBvc0luZGV4LCBsb2NhdGlvbiQxKTtcbiAgfVxufTtcbkxhYmVsLnByb3RvdHlwZS5pc0VxdWFsT25TaWRlID0gZnVuY3Rpb24gaXNFcXVhbE9uU2lkZSAobGJsLCBzaWRlKSB7XG4gIHJldHVybiB0aGlzLmVsdFswXS5pc0VxdWFsT25TaWRlKGxibC5lbHRbMF0sIHNpZGUpICYmIHRoaXMuZWx0WzFdLmlzRXF1YWxPblNpZGUobGJsLmVsdFsxXSwgc2lkZSlcbn07XG5MYWJlbC5wcm90b3R5cGUuYWxsUG9zaXRpb25zRXF1YWwgPSBmdW5jdGlvbiBhbGxQb3NpdGlvbnNFcXVhbCAoZ2VvbUluZGV4LCBsb2MpIHtcbiAgcmV0dXJuIHRoaXMuZWx0W2dlb21JbmRleF0uYWxsUG9zaXRpb25zRXF1YWwobG9jKVxufTtcbkxhYmVsLnByb3RvdHlwZS50b0xpbmUgPSBmdW5jdGlvbiB0b0xpbmUgKGdlb21JbmRleCkge1xuICBpZiAodGhpcy5lbHRbZ2VvbUluZGV4XS5pc0FyZWEoKSkgeyB0aGlzLmVsdFtnZW9tSW5kZXhdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24odGhpcy5lbHRbZ2VvbUluZGV4XS5sb2NhdGlvblswXSk7IH1cbn07XG5MYWJlbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkxhYmVsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExhYmVsXG59O1xuTGFiZWwudG9MaW5lTGFiZWwgPSBmdW5jdGlvbiB0b0xpbmVMYWJlbCAobGFiZWwpIHtcbiAgdmFyIGxpbmVMYWJlbCA9IG5ldyBMYWJlbChMb2NhdGlvbi5OT05FKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICBsaW5lTGFiZWwuc2V0TG9jYXRpb24oaSwgbGFiZWwuZ2V0TG9jYXRpb24oaSkpO1xuICB9XG4gIHJldHVybiBsaW5lTGFiZWxcbn07XG5cbnZhciBFZGdlUmluZyA9IGZ1bmN0aW9uIEVkZ2VSaW5nICgpIHtcbiAgdGhpcy5fc3RhcnREZSA9IG51bGw7XG4gIHRoaXMuX21heE5vZGVEZWdyZWUgPSAtMTtcbiAgdGhpcy5fZWRnZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX3B0cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fbGFiZWwgPSBuZXcgTGFiZWwoTG9jYXRpb24uTk9ORSk7XG4gIHRoaXMuX3JpbmcgPSBudWxsO1xuICB0aGlzLl9pc0hvbGUgPSBudWxsO1xuICB0aGlzLl9zaGVsbCA9IG51bGw7XG4gIHRoaXMuX2hvbGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBudWxsO1xuICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciBnZW9tZXRyeUZhY3RvcnkgPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeTtcbiAgdGhpcy5jb21wdXRlUG9pbnRzKHN0YXJ0KTtcbiAgdGhpcy5jb21wdXRlUmluZygpO1xufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5jb21wdXRlUmluZyA9IGZ1bmN0aW9uIGNvbXB1dGVSaW5nICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5fcmluZyAhPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBjb29yZCA9IG5ldyBBcnJheSh0aGlzLl9wdHMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3B0cy5zaXplKCk7IGkrKykge1xuICAgIGNvb3JkW2ldID0gdGhpcyQxLl9wdHMuZ2V0KGkpO1xuICB9XG4gIHRoaXMuX3JpbmcgPSB0aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhjb29yZCk7XG4gIHRoaXMuX2lzSG9sZSA9IENHQWxnb3JpdGhtcy5pc0NDVyh0aGlzLl9yaW5nLmdldENvb3JkaW5hdGVzKCkpO1xufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5pc0lzb2xhdGVkID0gZnVuY3Rpb24gaXNJc29sYXRlZCAoKSB7XG4gIHJldHVybiB0aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCkgPT09IDFcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuY29tcHV0ZVBvaW50cyA9IGZ1bmN0aW9uIGNvbXB1dGVQb2ludHMgKHN0YXJ0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fc3RhcnREZSA9IHN0YXJ0O1xuICB2YXIgZGUgPSBzdGFydDtcbiAgdmFyIGlzRmlyc3RFZGdlID0gdHJ1ZTtcbiAgZG8ge1xuICAgIGlmIChkZSA9PT0gbnVsbCkgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24oJ0ZvdW5kIG51bGwgRGlyZWN0ZWRFZGdlJykgfVxuICAgIGlmIChkZS5nZXRFZGdlUmluZygpID09PSB0aGlzJDEpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCdEaXJlY3RlZCBFZGdlIHZpc2l0ZWQgdHdpY2UgZHVyaW5nIHJpbmctYnVpbGRpbmcgYXQgJyArIGRlLmdldENvb3JkaW5hdGUoKSkgfVxuICAgIHRoaXMkMS5fZWRnZXMuYWRkKGRlKTtcbiAgICB2YXIgbGFiZWwgPSBkZS5nZXRMYWJlbCgpO1xuICAgIEFzc2VydC5pc1RydWUobGFiZWwuaXNBcmVhKCkpO1xuICAgIHRoaXMkMS5tZXJnZUxhYmVsKGxhYmVsKTtcbiAgICB0aGlzJDEuYWRkUG9pbnRzKGRlLmdldEVkZ2UoKSwgZGUuaXNGb3J3YXJkKCksIGlzRmlyc3RFZGdlKTtcbiAgICBpc0ZpcnN0RWRnZSA9IGZhbHNlO1xuICAgIHRoaXMkMS5zZXRFZGdlUmluZyhkZSwgdGhpcyQxKTtcbiAgICBkZSA9IHRoaXMkMS5nZXROZXh0KGRlKTtcbiAgfSB3aGlsZSAoZGUgIT09IHRoaXMuX3N0YXJ0RGUpXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmdldExpbmVhclJpbmcgPSBmdW5jdGlvbiBnZXRMaW5lYXJSaW5nICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jpbmdcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHtcbiAgcmV0dXJuIHRoaXMuX3B0cy5nZXQoaSlcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuY29tcHV0ZU1heE5vZGVEZWdyZWUgPSBmdW5jdGlvbiBjb21wdXRlTWF4Tm9kZURlZ3JlZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fbWF4Tm9kZURlZ3JlZSA9IDA7XG4gIHZhciBkZSA9IHRoaXMuX3N0YXJ0RGU7XG4gIGRvIHtcbiAgICB2YXIgbm9kZSA9IGRlLmdldE5vZGUoKTtcbiAgICB2YXIgZGVncmVlID0gbm9kZS5nZXRFZGdlcygpLmdldE91dGdvaW5nRGVncmVlKHRoaXMkMSk7XG4gICAgaWYgKGRlZ3JlZSA+IHRoaXMkMS5fbWF4Tm9kZURlZ3JlZSkgeyB0aGlzJDEuX21heE5vZGVEZWdyZWUgPSBkZWdyZWU7IH1cbiAgICBkZSA9IHRoaXMkMS5nZXROZXh0KGRlKTtcbiAgfSB3aGlsZSAoZGUgIT09IHRoaXMuX3N0YXJ0RGUpXG4gIHRoaXMuX21heE5vZGVEZWdyZWUgKj0gMjtcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuYWRkUG9pbnRzID0gZnVuY3Rpb24gYWRkUG9pbnRzIChlZGdlLCBpc0ZvcndhcmQsIGlzRmlyc3RFZGdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVkZ2VQdHMgPSBlZGdlLmdldENvb3JkaW5hdGVzKCk7XG4gIGlmIChpc0ZvcndhcmQpIHtcbiAgICB2YXIgc3RhcnRJbmRleCA9IDE7XG4gICAgaWYgKGlzRmlyc3RFZGdlKSB7IHN0YXJ0SW5kZXggPSAwOyB9XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlZGdlUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzJDEuX3B0cy5hZGQoZWRnZVB0c1tpXSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzdGFydEluZGV4JDEgPSBlZGdlUHRzLmxlbmd0aCAtIDI7XG4gICAgaWYgKGlzRmlyc3RFZGdlKSB7IHN0YXJ0SW5kZXgkMSA9IGVkZ2VQdHMubGVuZ3RoIC0gMTsgfVxuICAgIGZvciAodmFyIGkkMSA9IHN0YXJ0SW5kZXgkMTsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgICB0aGlzJDEuX3B0cy5hZGQoZWRnZVB0c1tpJDFdKTtcbiAgICB9XG4gIH1cbn07XG5FZGdlUmluZy5wcm90b3R5cGUuaXNIb2xlID0gZnVuY3Rpb24gaXNIb2xlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzSG9sZVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5zZXRJblJlc3VsdCA9IGZ1bmN0aW9uIHNldEluUmVzdWx0ICgpIHtcbiAgdmFyIGRlID0gdGhpcy5fc3RhcnREZTtcbiAgZG8ge1xuICAgIGRlLmdldEVkZ2UoKS5zZXRJblJlc3VsdCh0cnVlKTtcbiAgICBkZSA9IGRlLmdldE5leHQoKTtcbiAgfSB3aGlsZSAoZGUgIT09IHRoaXMuX3N0YXJ0RGUpXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiBjb250YWluc1BvaW50IChwKSB7XG4gIHZhciBzaGVsbCA9IHRoaXMuZ2V0TGluZWFyUmluZygpO1xuICB2YXIgZW52ID0gc2hlbGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICBpZiAoIWVudi5jb250YWlucyhwKSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoIUNHQWxnb3JpdGhtcy5pc1BvaW50SW5SaW5nKHAsIHNoZWxsLmdldENvb3JkaW5hdGVzKCkpKSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAodmFyIGkgPSB0aGlzLl9ob2xlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgaG9sZSA9IGkubmV4dCgpO1xuICAgIGlmIChob2xlLmNvbnRhaW5zUG9pbnQocCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5hZGRIb2xlID0gZnVuY3Rpb24gYWRkSG9sZSAocmluZykge1xuICB0aGlzLl9ob2xlcy5hZGQocmluZyk7XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmlzU2hlbGwgPSBmdW5jdGlvbiBpc1NoZWxsICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NoZWxsID09PSBudWxsXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gZ2V0TGFiZWwgKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWxcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiBnZXRFZGdlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlc1xufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5nZXRNYXhOb2RlRGVncmVlID0gZnVuY3Rpb24gZ2V0TWF4Tm9kZURlZ3JlZSAoKSB7XG4gIGlmICh0aGlzLl9tYXhOb2RlRGVncmVlIDwgMCkgeyB0aGlzLmNvbXB1dGVNYXhOb2RlRGVncmVlKCk7IH1cbiAgcmV0dXJuIHRoaXMuX21heE5vZGVEZWdyZWVcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuZ2V0U2hlbGwgPSBmdW5jdGlvbiBnZXRTaGVsbCAoKSB7XG4gIHJldHVybiB0aGlzLl9zaGVsbFxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5tZXJnZUxhYmVsID0gZnVuY3Rpb24gbWVyZ2VMYWJlbCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGRlTGFiZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5tZXJnZUxhYmVsKGRlTGFiZWwsIDApO1xuICAgIHRoaXMubWVyZ2VMYWJlbChkZUxhYmVsLCAxKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGRlTGFiZWwkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBsb2MgPSBkZUxhYmVsJDEuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5SSUdIVCk7XG4gICAgaWYgKGxvYyA9PT0gTG9jYXRpb24uTk9ORSkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGdlb21JbmRleCkgPT09IExvY2F0aW9uLk5PTkUpIHtcbiAgICAgIHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKGdlb21JbmRleCwgbG9jKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLnNldFNoZWxsID0gZnVuY3Rpb24gc2V0U2hlbGwgKHNoZWxsKSB7XG4gIHRoaXMuX3NoZWxsID0gc2hlbGw7XG4gIGlmIChzaGVsbCAhPT0gbnVsbCkgeyBzaGVsbC5hZGRIb2xlKHRoaXMpOyB9XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLnRvUG9seWdvbiA9IGZ1bmN0aW9uIHRvUG9seWdvbiAoZ2VvbWV0cnlGYWN0b3J5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGhvbGVMUiA9IG5ldyBBcnJheSh0aGlzLl9ob2xlcy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMuc2l6ZSgpOyBpKyspIHtcbiAgICBob2xlTFJbaV0gPSB0aGlzJDEuX2hvbGVzLmdldChpKS5nZXRMaW5lYXJSaW5nKCk7XG4gIH1cbiAgdmFyIHBvbHkgPSBnZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbih0aGlzLmdldExpbmVhclJpbmcoKSwgaG9sZUxSKTtcbiAgcmV0dXJuIHBvbHlcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVkZ2VSaW5nXG59O1xuXG52YXIgTWluaW1hbEVkZ2VSaW5nID0gKGZ1bmN0aW9uIChFZGdlUmluZyQkMSkge1xuICBmdW5jdGlvbiBNaW5pbWFsRWRnZVJpbmcgKCkge1xuICAgIHZhciBzdGFydCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZ2VvbWV0cnlGYWN0b3J5ID0gYXJndW1lbnRzWzFdO1xuICAgIEVkZ2VSaW5nJCQxLmNhbGwodGhpcywgc3RhcnQsIGdlb21ldHJ5RmFjdG9yeSk7XG4gIH1cblxuICBpZiAoIEVkZ2VSaW5nJCQxICkgTWluaW1hbEVkZ2VSaW5nLl9fcHJvdG9fXyA9IEVkZ2VSaW5nJCQxO1xuICBNaW5pbWFsRWRnZVJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRWRnZVJpbmckJDEgJiYgRWRnZVJpbmckJDEucHJvdG90eXBlICk7XG4gIE1pbmltYWxFZGdlUmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNaW5pbWFsRWRnZVJpbmc7XG4gIE1pbmltYWxFZGdlUmluZy5wcm90b3R5cGUuc2V0RWRnZVJpbmcgPSBmdW5jdGlvbiBzZXRFZGdlUmluZyAoZGUsIGVyKSB7XG4gICAgZGUuc2V0TWluRWRnZVJpbmcoZXIpO1xuICB9O1xuICBNaW5pbWFsRWRnZVJpbmcucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiBnZXROZXh0IChkZSkge1xuICAgIHJldHVybiBkZS5nZXROZXh0TWluKClcbiAgfTtcbiAgTWluaW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgTWluaW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTWluaW1hbEVkZ2VSaW5nXG4gIH07XG5cbiAgcmV0dXJuIE1pbmltYWxFZGdlUmluZztcbn0oRWRnZVJpbmcpKTtcblxudmFyIE1heGltYWxFZGdlUmluZyA9IChmdW5jdGlvbiAoRWRnZVJpbmckJDEpIHtcbiAgZnVuY3Rpb24gTWF4aW1hbEVkZ2VSaW5nICgpIHtcbiAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGdlb21ldHJ5RmFjdG9yeSA9IGFyZ3VtZW50c1sxXTtcbiAgICBFZGdlUmluZyQkMS5jYWxsKHRoaXMsIHN0YXJ0LCBnZW9tZXRyeUZhY3RvcnkpO1xuICB9XG5cbiAgaWYgKCBFZGdlUmluZyQkMSApIE1heGltYWxFZGdlUmluZy5fX3Byb3RvX18gPSBFZGdlUmluZyQkMTtcbiAgTWF4aW1hbEVkZ2VSaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVkZ2VSaW5nJCQxICYmIEVkZ2VSaW5nJCQxLnByb3RvdHlwZSApO1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWF4aW1hbEVkZ2VSaW5nO1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmJ1aWxkTWluaW1hbFJpbmdzID0gZnVuY3Rpb24gYnVpbGRNaW5pbWFsUmluZ3MgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG1pbkVkZ2VSaW5ncyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB2YXIgZGUgPSB0aGlzLl9zdGFydERlO1xuICAgIGRvIHtcbiAgICAgIGlmIChkZS5nZXRNaW5FZGdlUmluZygpID09PSBudWxsKSB7XG4gICAgICAgIHZhciBtaW5FciA9IG5ldyBNaW5pbWFsRWRnZVJpbmcoZGUsIHRoaXMkMS5fZ2VvbWV0cnlGYWN0b3J5KTtcbiAgICAgICAgbWluRWRnZVJpbmdzLmFkZChtaW5Fcik7XG4gICAgICB9XG4gICAgICBkZSA9IGRlLmdldE5leHQoKTtcbiAgICB9IHdoaWxlIChkZSAhPT0gdGhpcy5fc3RhcnREZSlcbiAgICByZXR1cm4gbWluRWRnZVJpbmdzXG4gIH07XG4gIE1heGltYWxFZGdlUmluZy5wcm90b3R5cGUuc2V0RWRnZVJpbmcgPSBmdW5jdGlvbiBzZXRFZGdlUmluZyAoZGUsIGVyKSB7XG4gICAgZGUuc2V0RWRnZVJpbmcoZXIpO1xuICB9O1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncyA9IGZ1bmN0aW9uIGxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZGUgPSB0aGlzLl9zdGFydERlO1xuICAgIGRvIHtcbiAgICAgIHZhciBub2RlID0gZGUuZ2V0Tm9kZSgpO1xuICAgICAgbm9kZS5nZXRFZGdlcygpLmxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlcyh0aGlzJDEpO1xuICAgICAgZGUgPSBkZS5nZXROZXh0KCk7XG4gICAgfSB3aGlsZSAoZGUgIT09IHRoaXMuX3N0YXJ0RGUpXG4gIH07XG4gIE1heGltYWxFZGdlUmluZy5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uIGdldE5leHQgKGRlKSB7XG4gICAgcmV0dXJuIGRlLmdldE5leHQoKVxuICB9O1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBNYXhpbWFsRWRnZVJpbmdcbiAgfTtcblxuICByZXR1cm4gTWF4aW1hbEVkZ2VSaW5nO1xufShFZGdlUmluZykpO1xuXG52YXIgR3JhcGhDb21wb25lbnQgPSBmdW5jdGlvbiBHcmFwaENvbXBvbmVudCAoKSB7XG4gIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgdGhpcy5faXNJblJlc3VsdCA9IGZhbHNlO1xuICB0aGlzLl9pc0NvdmVyZWQgPSBmYWxzZTtcbiAgdGhpcy5faXNDb3ZlcmVkU2V0ID0gZmFsc2U7XG4gIHRoaXMuX2lzVmlzaXRlZCA9IGZhbHNlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge30gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsYWJlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICB9XG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLnNldFZpc2l0ZWQgPSBmdW5jdGlvbiBzZXRWaXNpdGVkIChpc1Zpc2l0ZWQpIHtcbiAgdGhpcy5faXNWaXNpdGVkID0gaXNWaXNpdGVkO1xufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5zZXRJblJlc3VsdCA9IGZ1bmN0aW9uIHNldEluUmVzdWx0IChpc0luUmVzdWx0KSB7XG4gIHRoaXMuX2lzSW5SZXN1bHQgPSBpc0luUmVzdWx0O1xufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5pc0NvdmVyZWQgPSBmdW5jdGlvbiBpc0NvdmVyZWQgKCkge1xuICByZXR1cm4gdGhpcy5faXNDb3ZlcmVkXG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmlzQ292ZXJlZFNldCA9IGZ1bmN0aW9uIGlzQ292ZXJlZFNldCAoKSB7XG4gIHJldHVybiB0aGlzLl9pc0NvdmVyZWRTZXRcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuc2V0TGFiZWwgPSBmdW5jdGlvbiBzZXRMYWJlbCAobGFiZWwpIHtcbiAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiBnZXRMYWJlbCAoKSB7XG4gIHJldHVybiB0aGlzLl9sYWJlbFxufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5zZXRDb3ZlcmVkID0gZnVuY3Rpb24gc2V0Q292ZXJlZCAoaXNDb3ZlcmVkKSB7XG4gIHRoaXMuX2lzQ292ZXJlZCA9IGlzQ292ZXJlZDtcbiAgdGhpcy5faXNDb3ZlcmVkU2V0ID0gdHJ1ZTtcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlSU0gPSBmdW5jdGlvbiB1cGRhdGVJTSAoaW0pIHtcbiAgQXNzZXJ0LmlzVHJ1ZSh0aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCkgPj0gMiwgJ2ZvdW5kIHBhcnRpYWwgbGFiZWwnKTtcbiAgdGhpcy5jb21wdXRlSU0oaW0pO1xufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5pc0luUmVzdWx0ID0gZnVuY3Rpb24gaXNJblJlc3VsdCAoKSB7XG4gIHJldHVybiB0aGlzLl9pc0luUmVzdWx0XG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmlzVmlzaXRlZCA9IGZ1bmN0aW9uIGlzVmlzaXRlZCAoKSB7XG4gIHJldHVybiB0aGlzLl9pc1Zpc2l0ZWRcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdyYXBoQ29tcG9uZW50XG59O1xuXG52YXIgTm9kZSA9IChmdW5jdGlvbiAoR3JhcGhDb21wb25lbnQkJDEpIHtcbiAgZnVuY3Rpb24gTm9kZSAoKSB7XG4gICAgR3JhcGhDb21wb25lbnQkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9jb29yZCA9IG51bGw7XG4gICAgdGhpcy5fZWRnZXMgPSBudWxsO1xuICAgIHZhciBjb29yZCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZWRnZXMgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fY29vcmQgPSBjb29yZDtcbiAgICB0aGlzLl9lZGdlcyA9IGVkZ2VzO1xuICAgIHRoaXMuX2xhYmVsID0gbmV3IExhYmVsKDAsIExvY2F0aW9uLk5PTkUpO1xuICB9XG5cbiAgaWYgKCBHcmFwaENvbXBvbmVudCQkMSApIE5vZGUuX19wcm90b19fID0gR3JhcGhDb21wb25lbnQkJDE7XG4gIE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR3JhcGhDb21wb25lbnQkJDEgJiYgR3JhcGhDb21wb25lbnQkJDEucHJvdG90eXBlICk7XG4gIE5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTm9kZTtcbiAgTm9kZS5wcm90b3R5cGUuaXNJbmNpZGVudEVkZ2VJblJlc3VsdCA9IGZ1bmN0aW9uIGlzSW5jaWRlbnRFZGdlSW5SZXN1bHQgKCkge1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5nZXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgaWYgKGRlLmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuaXNJc29sYXRlZCA9IGZ1bmN0aW9uIGlzSXNvbGF0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCkgPT09IDFcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29yZFxuICB9O1xuICBOb2RlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgICBvdXQucHJpbnRsbignbm9kZSAnICsgdGhpcy5fY29vcmQgKyAnIGxibDogJyArIHRoaXMuX2xhYmVsKTtcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuY29tcHV0ZUlNID0gZnVuY3Rpb24gY29tcHV0ZUlNIChpbSkge307XG4gIE5vZGUucHJvdG90eXBlLmNvbXB1dGVNZXJnZWRMb2NhdGlvbiA9IGZ1bmN0aW9uIGNvbXB1dGVNZXJnZWRMb2NhdGlvbiAobGFiZWwyLCBlbHRJbmRleCkge1xuICAgIHZhciBsb2MgPSBMb2NhdGlvbi5OT05FO1xuICAgIGxvYyA9IHRoaXMuX2xhYmVsLmdldExvY2F0aW9uKGVsdEluZGV4KTtcbiAgICBpZiAoIWxhYmVsMi5pc051bGwoZWx0SW5kZXgpKSB7XG4gICAgICB2YXIgbkxvYyA9IGxhYmVsMi5nZXRMb2NhdGlvbihlbHRJbmRleCk7XG4gICAgICBpZiAobG9jICE9PSBMb2NhdGlvbi5CT1VOREFSWSkgeyBsb2MgPSBuTG9jOyB9XG4gICAgfVxuICAgIHJldHVybiBsb2NcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuc2V0TGFiZWwgPSBmdW5jdGlvbiBzZXRMYWJlbCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBvbkxvY2F0aW9uID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKHRoaXMuX2xhYmVsID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2xhYmVsID0gbmV3IExhYmVsKGFyZ0luZGV4LCBvbkxvY2F0aW9uKTtcbiAgICAgIH0gZWxzZSB7IHRoaXMuX2xhYmVsLnNldExvY2F0aW9uKGFyZ0luZGV4LCBvbkxvY2F0aW9uKTsgfVxuICAgIH0gZWxzZSB7IHJldHVybiBHcmFwaENvbXBvbmVudCQkMS5wcm90b3R5cGUuc2V0TGFiZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIE5vZGUucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gZ2V0RWRnZXMgKCkge1xuICAgIHJldHVybiB0aGlzLl9lZGdlc1xuICB9O1xuICBOb2RlLnByb3RvdHlwZS5tZXJnZUxhYmVsID0gZnVuY3Rpb24gbWVyZ2VMYWJlbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgdmFyIG4gPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLm1lcmdlTGFiZWwobi5fbGFiZWwpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGFiZWwpIHtcbiAgICAgIHZhciBsYWJlbDIgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICB2YXIgbG9jID0gdGhpcyQxLmNvbXB1dGVNZXJnZWRMb2NhdGlvbihsYWJlbDIsIGkpO1xuICAgICAgICB2YXIgdGhpc0xvYyA9IHRoaXMkMS5fbGFiZWwuZ2V0TG9jYXRpb24oaSk7XG4gICAgICAgIGlmICh0aGlzTG9jID09PSBMb2NhdGlvbi5OT05FKSB7IHRoaXMkMS5fbGFiZWwuc2V0TG9jYXRpb24oaSwgbG9jKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChlKSB7XG4gICAgdGhpcy5fZWRnZXMuaW5zZXJ0KGUpO1xuICAgIGUuc2V0Tm9kZSh0aGlzKTtcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuc2V0TGFiZWxCb3VuZGFyeSA9IGZ1bmN0aW9uIHNldExhYmVsQm91bmRhcnkgKGFyZ0luZGV4KSB7XG4gICAgaWYgKHRoaXMuX2xhYmVsID09PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgbG9jID0gTG9jYXRpb24uTk9ORTtcbiAgICBpZiAodGhpcy5fbGFiZWwgIT09IG51bGwpIHsgbG9jID0gdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oYXJnSW5kZXgpOyB9XG4gICAgdmFyIG5ld0xvYyA9IG51bGw7XG4gICAgc3dpdGNoIChsb2MpIHtcbiAgICAgIGNhc2UgTG9jYXRpb24uQk9VTkRBUlk6XG4gICAgICAgIG5ld0xvYyA9IExvY2F0aW9uLklOVEVSSU9SO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSBMb2NhdGlvbi5JTlRFUklPUjpcbiAgICAgICAgbmV3TG9jID0gTG9jYXRpb24uQk9VTkRBUlk7XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBuZXdMb2MgPSBMb2NhdGlvbi5CT1VOREFSWTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24oYXJnSW5kZXgsIG5ld0xvYyk7XG4gIH07XG4gIE5vZGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBOb2RlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTm9kZVxuICB9O1xuXG4gIHJldHVybiBOb2RlO1xufShHcmFwaENvbXBvbmVudCkpO1xuXG52YXIgTm9kZU1hcCA9IGZ1bmN0aW9uIE5vZGVNYXAgKCkge1xuICB0aGlzLm5vZGVNYXAgPSBuZXcgVHJlZU1hcCgpO1xuICB0aGlzLm5vZGVGYWN0ID0gbnVsbDtcbiAgdmFyIG5vZGVGYWN0ID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLm5vZGVGYWN0ID0gbm9kZUZhY3Q7XG59O1xuTm9kZU1hcC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQgKGNvb3JkKSB7XG4gIHJldHVybiB0aGlzLm5vZGVNYXAuZ2V0KGNvb3JkKVxufTtcbk5vZGVNYXAucHJvdG90eXBlLmFkZE5vZGUgPSBmdW5jdGlvbiBhZGROb2RlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVNYXAuZ2V0KGNvb3JkKTtcbiAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgbm9kZSA9IHRoaXMubm9kZUZhY3QuY3JlYXRlTm9kZShjb29yZCk7XG4gICAgICB0aGlzLm5vZGVNYXAucHV0KGNvb3JkLCBub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgdmFyIG4gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5vZGUkMSA9IHRoaXMubm9kZU1hcC5nZXQobi5nZXRDb29yZGluYXRlKCkpO1xuICAgIGlmIChub2RlJDEgPT09IG51bGwpIHtcbiAgICAgIHRoaXMubm9kZU1hcC5wdXQobi5nZXRDb29yZGluYXRlKCksIG4pO1xuICAgICAgcmV0dXJuIG5cbiAgICB9XG4gICAgbm9kZSQxLm1lcmdlTGFiZWwobik7XG4gICAgcmV0dXJuIG5vZGUkMVxuICB9XG59O1xuTm9kZU1hcC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG4gPSBpdC5uZXh0KCk7XG4gICAgbi5wcmludChvdXQpO1xuICB9XG59O1xuTm9kZU1hcC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKVxufTtcbk5vZGVNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uIHZhbHVlcyAoKSB7XG4gIHJldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKClcbn07XG5Ob2RlTWFwLnByb3RvdHlwZS5nZXRCb3VuZGFyeU5vZGVzID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlOb2RlcyAoZ2VvbUluZGV4KSB7XG4gIHZhciBiZHlOb2RlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IHRoaXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG5vZGUgPSBpLm5leHQoKTtcbiAgICBpZiAobm9kZS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGdlb21JbmRleCkgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IGJkeU5vZGVzLmFkZChub2RlKTsgfVxuICB9XG4gIHJldHVybiBiZHlOb2Rlc1xufTtcbk5vZGVNYXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZSkge1xuICB2YXIgcCA9IGUuZ2V0Q29vcmRpbmF0ZSgpO1xuICB2YXIgbiA9IHRoaXMuYWRkTm9kZShwKTtcbiAgbi5hZGQoZSk7XG59O1xuTm9kZU1hcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk5vZGVNYXAucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9kZU1hcFxufTtcblxudmFyIFF1YWRyYW50ID0gZnVuY3Rpb24gUXVhZHJhbnQgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjEgPSB7IE5FOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE5XOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNXOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cblF1YWRyYW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUXVhZHJhbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUXVhZHJhbnRcbn07XG5RdWFkcmFudC5pc05vcnRoZXJuID0gZnVuY3Rpb24gaXNOb3J0aGVybiAocXVhZCkge1xuICByZXR1cm4gcXVhZCA9PT0gUXVhZHJhbnQuTkUgfHwgcXVhZCA9PT0gUXVhZHJhbnQuTldcbn07XG5RdWFkcmFudC5pc09wcG9zaXRlID0gZnVuY3Rpb24gaXNPcHBvc2l0ZSAocXVhZDEsIHF1YWQyKSB7XG4gIGlmIChxdWFkMSA9PT0gcXVhZDIpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGRpZmYgPSAocXVhZDEgLSBxdWFkMiArIDQpICUgNDtcbiAgaWYgKGRpZmYgPT09IDIpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5RdWFkcmFudC5jb21tb25IYWxmUGxhbmUgPSBmdW5jdGlvbiBjb21tb25IYWxmUGxhbmUgKHF1YWQxLCBxdWFkMikge1xuICBpZiAocXVhZDEgPT09IHF1YWQyKSB7IHJldHVybiBxdWFkMSB9XG4gIHZhciBkaWZmID0gKHF1YWQxIC0gcXVhZDIgKyA0KSAlIDQ7XG4gIGlmIChkaWZmID09PSAyKSB7IHJldHVybiAtMSB9XG4gIHZhciBtaW4gPSBxdWFkMSA8IHF1YWQyID8gcXVhZDEgOiBxdWFkMjtcbiAgdmFyIG1heCA9IHF1YWQxID4gcXVhZDIgPyBxdWFkMSA6IHF1YWQyO1xuICBpZiAobWluID09PSAwICYmIG1heCA9PT0gMykgeyByZXR1cm4gMyB9XG4gIHJldHVybiBtaW5cbn07XG5RdWFkcmFudC5pc0luSGFsZlBsYW5lID0gZnVuY3Rpb24gaXNJbkhhbGZQbGFuZSAocXVhZCwgaGFsZlBsYW5lKSB7XG4gIGlmIChoYWxmUGxhbmUgPT09IFF1YWRyYW50LlNFKSB7XG4gICAgcmV0dXJuIHF1YWQgPT09IFF1YWRyYW50LlNFIHx8IHF1YWQgPT09IFF1YWRyYW50LlNXXG4gIH1cbiAgcmV0dXJuIHF1YWQgPT09IGhhbGZQbGFuZSB8fCBxdWFkID09PSBoYWxmUGxhbmUgKyAxXG59O1xuUXVhZHJhbnQucXVhZHJhbnQgPSBmdW5jdGlvbiBxdWFkcmFudCAoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgIHZhciBkeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZHkgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGR4ID09PSAwLjAgJiYgZHkgPT09IDAuMCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHBvaW50ICggJyArIGR4ICsgJywgJyArIGR5ICsgJyApJykgfVxuICAgIGlmIChkeCA+PSAwLjApIHtcbiAgICAgIGlmIChkeSA+PSAwLjApIHsgcmV0dXJuIFF1YWRyYW50Lk5FOyB9IGVsc2UgeyByZXR1cm4gUXVhZHJhbnQuU0UgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHkgPj0gMC4wKSB7IHJldHVybiBRdWFkcmFudC5OVzsgfSBlbHNlIHsgcmV0dXJuIFF1YWRyYW50LlNXIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAocDEueCA9PT0gcDAueCAmJiBwMS55ID09PSBwMC55KSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0Nhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgJyArIHAwKSB9XG4gICAgaWYgKHAxLnggPj0gcDAueCkge1xuICAgICAgaWYgKHAxLnkgPj0gcDAueSkgeyByZXR1cm4gUXVhZHJhbnQuTkU7IH0gZWxzZSB7IHJldHVybiBRdWFkcmFudC5TRSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwMS55ID49IHAwLnkpIHsgcmV0dXJuIFF1YWRyYW50Lk5XOyB9IGVsc2UgeyByZXR1cm4gUXVhZHJhbnQuU1cgfVxuICAgIH1cbiAgfVxufTtcbnN0YXRpY0FjY2Vzc29ycyQyMS5ORS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjEuTlcuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDIxLlNXLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQyMS5TRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBRdWFkcmFudCwgc3RhdGljQWNjZXNzb3JzJDIxICk7XG5cbnZhciBFZGdlRW5kID0gZnVuY3Rpb24gRWRnZUVuZCAoKSB7XG4gIHRoaXMuX2VkZ2UgPSBudWxsO1xuICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gIHRoaXMuX25vZGUgPSBudWxsO1xuICB0aGlzLl9wMCA9IG51bGw7XG4gIHRoaXMuX3AxID0gbnVsbDtcbiAgdGhpcy5fZHggPSBudWxsO1xuICB0aGlzLl9keSA9IG51bGw7XG4gIHRoaXMuX3F1YWRyYW50ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZWRnZSA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9lZGdlID0gZWRnZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGVkZ2UkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBsYWJlbCA9IG51bGw7XG4gICAgdGhpcy5fZWRnZSA9IGVkZ2UkMTtcbiAgICB0aGlzLmluaXQocDAsIHAxKTtcbiAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgZWRnZSQyID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwMSQxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBsYWJlbCQxID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuX2VkZ2UgPSBlZGdlJDI7XG4gICAgdGhpcy5pbml0KHAwJDEsIHAxJDEpO1xuICAgIHRoaXMuX2xhYmVsID0gbGFiZWwkMTtcbiAgfVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmNvbXBhcmVEaXJlY3Rpb24gPSBmdW5jdGlvbiBjb21wYXJlRGlyZWN0aW9uIChlKSB7XG4gIGlmICh0aGlzLl9keCA9PT0gZS5fZHggJiYgdGhpcy5fZHkgPT09IGUuX2R5KSB7IHJldHVybiAwIH1cbiAgaWYgKHRoaXMuX3F1YWRyYW50ID4gZS5fcXVhZHJhbnQpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fcXVhZHJhbnQgPCBlLl9xdWFkcmFudCkgeyByZXR1cm4gLTEgfVxuICByZXR1cm4gQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbihlLl9wMCwgZS5fcDEsIHRoaXMuX3AxKVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldER5ID0gZnVuY3Rpb24gZ2V0RHkgKCkge1xuICByZXR1cm4gdGhpcy5fZHlcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9wMFxufTtcbkVkZ2VFbmQucHJvdG90eXBlLnNldE5vZGUgPSBmdW5jdGlvbiBzZXROb2RlIChub2RlKSB7XG4gIHRoaXMuX25vZGUgPSBub2RlO1xufTtcbkVkZ2VFbmQucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMuX2R5LCB0aGlzLl9keCk7XG4gIHZhciBjbGFzc05hbWUgPSB0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpO1xuICB2YXIgbGFzdERvdFBvcyA9IGNsYXNzTmFtZS5sYXN0SW5kZXhPZignLicpO1xuICB2YXIgbmFtZSA9IGNsYXNzTmFtZS5zdWJzdHJpbmcobGFzdERvdFBvcyArIDEpO1xuICBvdXQucHJpbnQoJyAgJyArIG5hbWUgKyAnOiAnICsgdGhpcy5fcDAgKyAnIC0gJyArIHRoaXMuX3AxICsgJyAnICsgdGhpcy5fcXVhZHJhbnQgKyAnOicgKyBhbmdsZSArICcgICAnICsgdGhpcy5fbGFiZWwpO1xufTtcbkVkZ2VFbmQucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAob2JqKSB7XG4gIHZhciBlID0gb2JqO1xuICByZXR1cm4gdGhpcy5jb21wYXJlRGlyZWN0aW9uKGUpXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0RGlyZWN0ZWRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0RGlyZWN0ZWRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX3AxXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0RHggPSBmdW5jdGlvbiBnZXREeCAoKSB7XG4gIHJldHVybiB0aGlzLl9keFxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gZ2V0TGFiZWwgKCkge1xuICByZXR1cm4gdGhpcy5fbGFiZWxcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXRFZGdlID0gZnVuY3Rpb24gZ2V0RWRnZSAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0UXVhZHJhbnQgPSBmdW5jdGlvbiBnZXRRdWFkcmFudCAoKSB7XG4gIHJldHVybiB0aGlzLl9xdWFkcmFudFxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiBnZXROb2RlICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVcbn07XG5FZGdlRW5kLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih0aGlzLl9keSwgdGhpcy5fZHgpO1xuICB2YXIgY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKTtcbiAgdmFyIGxhc3REb3RQb3MgPSBjbGFzc05hbWUubGFzdEluZGV4T2YoJy4nKTtcbiAgdmFyIG5hbWUgPSBjbGFzc05hbWUuc3Vic3RyaW5nKGxhc3REb3RQb3MgKyAxKTtcbiAgcmV0dXJuICcgICcgKyBuYW1lICsgJzogJyArIHRoaXMuX3AwICsgJyAtICcgKyB0aGlzLl9wMSArICcgJyArIHRoaXMuX3F1YWRyYW50ICsgJzonICsgYW5nbGUgKyAnICAgJyArIHRoaXMuX2xhYmVsXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuY29tcHV0ZUxhYmVsID0gZnVuY3Rpb24gY29tcHV0ZUxhYmVsIChib3VuZGFyeU5vZGVSdWxlKSB7fTtcbkVkZ2VFbmQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChwMCwgcDEpIHtcbiAgdGhpcy5fcDAgPSBwMDtcbiAgdGhpcy5fcDEgPSBwMTtcbiAgdGhpcy5fZHggPSBwMS54IC0gcDAueDtcbiAgdGhpcy5fZHkgPSBwMS55IC0gcDAueTtcbiAgdGhpcy5fcXVhZHJhbnQgPSBRdWFkcmFudC5xdWFkcmFudCh0aGlzLl9keCwgdGhpcy5fZHkpO1xuICBBc3NlcnQuaXNUcnVlKCEodGhpcy5fZHggPT09IDAgJiYgdGhpcy5fZHkgPT09IDApLCAnRWRnZUVuZCB3aXRoIGlkZW50aWNhbCBlbmRwb2ludHMgZm91bmQnKTtcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZUVuZFxufTtcblxudmFyIERpcmVjdGVkRWRnZSA9IChmdW5jdGlvbiAoRWRnZUVuZCQkMSkge1xuICBmdW5jdGlvbiBEaXJlY3RlZEVkZ2UgKCkge1xuICAgIHZhciBlZGdlID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBpc0ZvcndhcmQgPSBhcmd1bWVudHNbMV07XG4gICAgRWRnZUVuZCQkMS5jYWxsKHRoaXMsIGVkZ2UpO1xuICAgIHRoaXMuX2lzRm9yd2FyZCA9IG51bGw7XG4gICAgdGhpcy5faXNJblJlc3VsdCA9IGZhbHNlO1xuICAgIHRoaXMuX2lzVmlzaXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3N5bSA9IG51bGw7XG4gICAgdGhpcy5fbmV4dCA9IG51bGw7XG4gICAgdGhpcy5fbmV4dE1pbiA9IG51bGw7XG4gICAgdGhpcy5fZWRnZVJpbmcgPSBudWxsO1xuICAgIHRoaXMuX21pbkVkZ2VSaW5nID0gbnVsbDtcbiAgICB0aGlzLl9kZXB0aCA9IFswLCAtOTk5LCAtOTk5XTtcbiAgICB0aGlzLl9pc0ZvcndhcmQgPSBpc0ZvcndhcmQ7XG4gICAgaWYgKGlzRm9yd2FyZCkge1xuICAgICAgdGhpcy5pbml0KGVkZ2UuZ2V0Q29vcmRpbmF0ZSgwKSwgZWRnZS5nZXRDb29yZGluYXRlKDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG4gPSBlZGdlLmdldE51bVBvaW50cygpIC0gMTtcbiAgICAgIHRoaXMuaW5pdChlZGdlLmdldENvb3JkaW5hdGUobiksIGVkZ2UuZ2V0Q29vcmRpbmF0ZShuIC0gMSkpO1xuICAgIH1cbiAgICB0aGlzLmNvbXB1dGVEaXJlY3RlZExhYmVsKCk7XG4gIH1cblxuICBpZiAoIEVkZ2VFbmQkJDEgKSBEaXJlY3RlZEVkZ2UuX19wcm90b19fID0gRWRnZUVuZCQkMTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVkZ2VFbmQkJDEgJiYgRWRnZUVuZCQkMS5wcm90b3R5cGUgKTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpcmVjdGVkRWRnZTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXROZXh0TWluID0gZnVuY3Rpb24gZ2V0TmV4dE1pbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRNaW5cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXREZXB0aCA9IGZ1bmN0aW9uIGdldERlcHRoIChwb3NpdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9kZXB0aFtwb3NpdGlvbl1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXRWaXNpdGVkID0gZnVuY3Rpb24gc2V0VmlzaXRlZCAoaXNWaXNpdGVkKSB7XG4gICAgdGhpcy5faXNWaXNpdGVkID0gaXNWaXNpdGVkO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmNvbXB1dGVEaXJlY3RlZExhYmVsID0gZnVuY3Rpb24gY29tcHV0ZURpcmVjdGVkTGFiZWwgKCkge1xuICAgIHRoaXMuX2xhYmVsID0gbmV3IExhYmVsKHRoaXMuX2VkZ2UuZ2V0TGFiZWwoKSk7XG4gICAgaWYgKCF0aGlzLl9pc0ZvcndhcmQpIHsgdGhpcy5fbGFiZWwuZmxpcCgpOyB9XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uIGdldE5leHQgKCkge1xuICAgIHJldHVybiB0aGlzLl9uZXh0XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0RGVwdGggPSBmdW5jdGlvbiBzZXREZXB0aCAocG9zaXRpb24sIGRlcHRoVmFsKSB7XG4gICAgaWYgKHRoaXMuX2RlcHRoW3Bvc2l0aW9uXSAhPT0gLTk5OSkge1xuICAgICAgaWYgKHRoaXMuX2RlcHRoW3Bvc2l0aW9uXSAhPT0gZGVwdGhWYWwpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCdhc3NpZ25lZCBkZXB0aHMgZG8gbm90IG1hdGNoJywgdGhpcy5nZXRDb29yZGluYXRlKCkpIH1cbiAgICB9XG4gICAgdGhpcy5fZGVwdGhbcG9zaXRpb25dID0gZGVwdGhWYWw7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuaXNJbnRlcmlvckFyZWFFZGdlID0gZnVuY3Rpb24gaXNJbnRlcmlvckFyZWFFZGdlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpc0ludGVyaW9yQXJlYUVkZ2UgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBpZiAoISh0aGlzJDEuX2xhYmVsLmlzQXJlYShpKSAmJiB0aGlzJDEuX2xhYmVsLmdldExvY2F0aW9uKGksIFBvc2l0aW9uLkxFRlQpID09PSBMb2NhdGlvbi5JTlRFUklPUiAmJiB0aGlzJDEuX2xhYmVsLmdldExvY2F0aW9uKGksIFBvc2l0aW9uLlJJR0hUKSA9PT0gTG9jYXRpb24uSU5URVJJT1IpKSB7XG4gICAgICAgIGlzSW50ZXJpb3JBcmVhRWRnZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXNJbnRlcmlvckFyZWFFZGdlXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0TmV4dE1pbiA9IGZ1bmN0aW9uIHNldE5leHRNaW4gKG5leHRNaW4pIHtcbiAgICB0aGlzLl9uZXh0TWluID0gbmV4dE1pbjtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgICBFZGdlRW5kJCQxLnByb3RvdHlwZS5wcmludC5jYWxsKHRoaXMsIG91dCk7XG4gICAgb3V0LnByaW50KCcgJyArIHRoaXMuX2RlcHRoW1Bvc2l0aW9uLkxFRlRdICsgJy8nICsgdGhpcy5fZGVwdGhbUG9zaXRpb24uUklHSFRdKTtcbiAgICBvdXQucHJpbnQoJyAoJyArIHRoaXMuZ2V0RGVwdGhEZWx0YSgpICsgJyknKTtcbiAgICBpZiAodGhpcy5faXNJblJlc3VsdCkgeyBvdXQucHJpbnQoJyBpblJlc3VsdCcpOyB9XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0TWluRWRnZVJpbmcgPSBmdW5jdGlvbiBzZXRNaW5FZGdlUmluZyAobWluRWRnZVJpbmcpIHtcbiAgICB0aGlzLl9taW5FZGdlUmluZyA9IG1pbkVkZ2VSaW5nO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmlzTGluZUVkZ2UgPSBmdW5jdGlvbiBpc0xpbmVFZGdlICgpIHtcbiAgICB2YXIgaXNMaW5lID0gdGhpcy5fbGFiZWwuaXNMaW5lKDApIHx8IHRoaXMuX2xhYmVsLmlzTGluZSgxKTtcbiAgICB2YXIgaXNFeHRlcmlvcklmQXJlYTAgPSAhdGhpcy5fbGFiZWwuaXNBcmVhKDApIHx8IHRoaXMuX2xhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDAsIExvY2F0aW9uLkVYVEVSSU9SKTtcbiAgICB2YXIgaXNFeHRlcmlvcklmQXJlYTEgPSAhdGhpcy5fbGFiZWwuaXNBcmVhKDEpIHx8IHRoaXMuX2xhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDEsIExvY2F0aW9uLkVYVEVSSU9SKTtcbiAgICByZXR1cm4gaXNMaW5lICYmIGlzRXh0ZXJpb3JJZkFyZWEwICYmIGlzRXh0ZXJpb3JJZkFyZWExXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0RWRnZVJpbmcgPSBmdW5jdGlvbiBzZXRFZGdlUmluZyAoZWRnZVJpbmcpIHtcbiAgICB0aGlzLl9lZGdlUmluZyA9IGVkZ2VSaW5nO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldE1pbkVkZ2VSaW5nID0gZnVuY3Rpb24gZ2V0TWluRWRnZVJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9taW5FZGdlUmluZ1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldERlcHRoRGVsdGEgPSBmdW5jdGlvbiBnZXREZXB0aERlbHRhICgpIHtcbiAgICB2YXIgZGVwdGhEZWx0YSA9IHRoaXMuX2VkZ2UuZ2V0RGVwdGhEZWx0YSgpO1xuICAgIGlmICghdGhpcy5faXNGb3J3YXJkKSB7IGRlcHRoRGVsdGEgPSAtZGVwdGhEZWx0YTsgfVxuICAgIHJldHVybiBkZXB0aERlbHRhXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0SW5SZXN1bHQgPSBmdW5jdGlvbiBzZXRJblJlc3VsdCAoaXNJblJlc3VsdCkge1xuICAgIHRoaXMuX2lzSW5SZXN1bHQgPSBpc0luUmVzdWx0O1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldFN5bSA9IGZ1bmN0aW9uIGdldFN5bSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N5bVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmlzRm9yd2FyZCA9IGZ1bmN0aW9uIGlzRm9yd2FyZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzRm9yd2FyZFxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldEVkZ2UgPSBmdW5jdGlvbiBnZXRFZGdlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWRnZVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnByaW50RWRnZSA9IGZ1bmN0aW9uIHByaW50RWRnZSAob3V0KSB7XG4gICAgdGhpcy5wcmludChvdXQpO1xuICAgIG91dC5wcmludCgnICcpO1xuICAgIGlmICh0aGlzLl9pc0ZvcndhcmQpIHsgdGhpcy5fZWRnZS5wcmludChvdXQpOyB9IGVsc2UgeyB0aGlzLl9lZGdlLnByaW50UmV2ZXJzZShvdXQpOyB9XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0U3ltID0gZnVuY3Rpb24gc2V0U3ltIChkZSkge1xuICAgIHRoaXMuX3N5bSA9IGRlO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldFZpc2l0ZWRFZGdlID0gZnVuY3Rpb24gc2V0VmlzaXRlZEVkZ2UgKGlzVmlzaXRlZCkge1xuICAgIHRoaXMuc2V0VmlzaXRlZChpc1Zpc2l0ZWQpO1xuICAgIHRoaXMuX3N5bS5zZXRWaXNpdGVkKGlzVmlzaXRlZCk7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0RWRnZURlcHRocyA9IGZ1bmN0aW9uIHNldEVkZ2VEZXB0aHMgKHBvc2l0aW9uLCBkZXB0aCkge1xuICAgIHZhciBkZXB0aERlbHRhID0gdGhpcy5nZXRFZGdlKCkuZ2V0RGVwdGhEZWx0YSgpO1xuICAgIGlmICghdGhpcy5faXNGb3J3YXJkKSB7IGRlcHRoRGVsdGEgPSAtZGVwdGhEZWx0YTsgfVxuICAgIHZhciBkaXJlY3Rpb25GYWN0b3IgPSAxO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uTEVGVCkgeyBkaXJlY3Rpb25GYWN0b3IgPSAtMTsgfVxuICAgIHZhciBvcHBvc2l0ZVBvcyA9IFBvc2l0aW9uLm9wcG9zaXRlKHBvc2l0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBkZXB0aERlbHRhICogZGlyZWN0aW9uRmFjdG9yO1xuICAgIHZhciBvcHBvc2l0ZURlcHRoID0gZGVwdGggKyBkZWx0YTtcbiAgICB0aGlzLnNldERlcHRoKHBvc2l0aW9uLCBkZXB0aCk7XG4gICAgdGhpcy5zZXREZXB0aChvcHBvc2l0ZVBvcywgb3Bwb3NpdGVEZXB0aCk7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0RWRnZVJpbmcgPSBmdW5jdGlvbiBnZXRFZGdlUmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkZ2VSaW5nXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuaXNJblJlc3VsdCA9IGZ1bmN0aW9uIGlzSW5SZXN1bHQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0luUmVzdWx0XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uIHNldE5leHQgKG5leHQpIHtcbiAgICB0aGlzLl9uZXh0ID0gbmV4dDtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5pc1Zpc2l0ZWQgPSBmdW5jdGlvbiBpc1Zpc2l0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Zpc2l0ZWRcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gRGlyZWN0ZWRFZGdlXG4gIH07XG4gIERpcmVjdGVkRWRnZS5kZXB0aEZhY3RvciA9IGZ1bmN0aW9uIGRlcHRoRmFjdG9yIChjdXJyTG9jYXRpb24sIG5leHRMb2NhdGlvbikge1xuICAgIGlmIChjdXJyTG9jYXRpb24gPT09IExvY2F0aW9uLkVYVEVSSU9SICYmIG5leHRMb2NhdGlvbiA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgcmV0dXJuIDE7IH0gZWxzZSBpZiAoY3VyckxvY2F0aW9uID09PSBMb2NhdGlvbi5JTlRFUklPUiAmJiBuZXh0TG9jYXRpb24gPT09IExvY2F0aW9uLkVYVEVSSU9SKSB7IHJldHVybiAtMSB9XG4gICAgcmV0dXJuIDBcbiAgfTtcblxuICByZXR1cm4gRGlyZWN0ZWRFZGdlO1xufShFZGdlRW5kKSk7XG5cbnZhciBOb2RlRmFjdG9yeSA9IGZ1bmN0aW9uIE5vZGVGYWN0b3J5ICgpIHt9O1xuXG5Ob2RlRmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5vZGUgKGNvb3JkKSB7XG4gIHJldHVybiBuZXcgTm9kZShjb29yZCwgbnVsbClcbn07XG5Ob2RlRmFjdG9yeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk5vZGVGYWN0b3J5LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGVGYWN0b3J5XG59O1xuXG52YXIgUGxhbmFyR3JhcGggPSBmdW5jdGlvbiBQbGFuYXJHcmFwaCAoKSB7XG4gIHRoaXMuX2VkZ2VzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9ub2RlcyA9IG51bGw7XG4gIHRoaXMuX2VkZ2VFbmRMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX25vZGVzID0gbmV3IE5vZGVNYXAobmV3IE5vZGVGYWN0b3J5KCkpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbm9kZUZhY3QgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fbm9kZXMgPSBuZXcgTm9kZU1hcChub2RlRmFjdCk7XG4gIH1cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUucHJpbnRFZGdlcyA9IGZ1bmN0aW9uIHByaW50RWRnZXMgKG91dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIG91dC5wcmludGxuKCdFZGdlczonKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9lZGdlcy5zaXplKCk7IGkrKykge1xuICAgIG91dC5wcmludGxuKCdlZGdlICcgKyBpICsgJzonKTtcbiAgICB2YXIgZSA9IHRoaXMkMS5fZWRnZXMuZ2V0KGkpO1xuICAgIGUucHJpbnQob3V0KTtcbiAgICBlLmVpTGlzdC5wcmludChvdXQpO1xuICB9XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiBmaW5kIChjb29yZCkge1xuICByZXR1cm4gdGhpcy5fbm9kZXMuZmluZChjb29yZClcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuYWRkTm9kZSA9IGZ1bmN0aW9uIGFkZE5vZGUgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTm9kZSkge1xuICAgIHZhciBub2RlID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLl9ub2Rlcy5hZGROb2RlKG5vZGUpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBjb29yZCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuYWRkTm9kZShjb29yZClcbiAgfVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5nZXROb2RlSXRlcmF0b3IgPSBmdW5jdGlvbiBnZXROb2RlSXRlcmF0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uIGxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzICgpIHtcbiAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgbm9kZS5nZXRFZGdlcygpLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKCk7XG4gIH1cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZGVidWdQcmludGxuID0gZnVuY3Rpb24gZGVidWdQcmludGxuIChvKSB7XG4gIFN5c3RlbS5vdXQucHJpbnRsbihvKTtcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuaXNCb3VuZGFyeU5vZGUgPSBmdW5jdGlvbiBpc0JvdW5kYXJ5Tm9kZSAoZ2VvbUluZGV4LCBjb29yZCkge1xuICB2YXIgbm9kZSA9IHRoaXMuX25vZGVzLmZpbmQoY29vcmQpO1xuICBpZiAobm9kZSA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgbGFiZWwgPSBub2RlLmdldExhYmVsKCk7XG4gIGlmIChsYWJlbCAhPT0gbnVsbCAmJiBsYWJlbC5nZXRMb2NhdGlvbihnZW9tSW5kZXgpID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5saW5rQWxsRGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uIGxpbmtBbGxEaXJlY3RlZEVkZ2VzICgpIHtcbiAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fbm9kZXMuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgbm9kZS5nZXRFZGdlcygpLmxpbmtBbGxEaXJlY3RlZEVkZ2VzKCk7XG4gIH1cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUubWF0Y2hJblNhbWVEaXJlY3Rpb24gPSBmdW5jdGlvbiBtYXRjaEluU2FtZURpcmVjdGlvbiAocDAsIHAxLCBlcDAsIGVwMSkge1xuICBpZiAoIXAwLmVxdWFscyhlcDApKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmIChDR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uKHAwLCBwMSwgZXAxKSA9PT0gQ0dBbGdvcml0aG1zLkNPTExJTkVBUiAmJiBRdWFkcmFudC5xdWFkcmFudChwMCwgcDEpID09PSBRdWFkcmFudC5xdWFkcmFudChlcDAsIGVwMSkpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZ2V0RWRnZUVuZHMgPSBmdW5jdGlvbiBnZXRFZGdlRW5kcyAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlRW5kTGlzdFxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5kZWJ1Z1ByaW50ID0gZnVuY3Rpb24gZGVidWdQcmludCAobykge1xuICBTeXN0ZW0ub3V0LnByaW50KG8pO1xufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5nZXRFZGdlSXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRFZGdlSXRlcmF0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5maW5kRWRnZUluU2FtZURpcmVjdGlvbiA9IGZ1bmN0aW9uIGZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uIChwMCwgcDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2VkZ2VzLnNpemUoKTsgaSsrKSB7XG4gICAgdmFyIGUgPSB0aGlzJDEuX2VkZ2VzLmdldChpKTtcbiAgICB2YXIgZUNvb3JkID0gZS5nZXRDb29yZGluYXRlcygpO1xuICAgIGlmICh0aGlzJDEubWF0Y2hJblNhbWVEaXJlY3Rpb24ocDAsIHAxLCBlQ29vcmRbMF0sIGVDb29yZFsxXSkpIHsgcmV0dXJuIGUgfVxuICAgIGlmICh0aGlzJDEubWF0Y2hJblNhbWVEaXJlY3Rpb24ocDAsIHAxLCBlQ29vcmRbZUNvb3JkLmxlbmd0aCAtIDFdLCBlQ29vcmRbZUNvb3JkLmxlbmd0aCAtIDJdKSkgeyByZXR1cm4gZSB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuaW5zZXJ0RWRnZSA9IGZ1bmN0aW9uIGluc2VydEVkZ2UgKGUpIHtcbiAgdGhpcy5fZWRnZXMuYWRkKGUpO1xufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5maW5kRWRnZUVuZCA9IGZ1bmN0aW9uIGZpbmRFZGdlRW5kIChlKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVlID0gaS5uZXh0KCk7XG4gICAgaWYgKGVlLmdldEVkZ2UoKSA9PT0gZSkgeyByZXR1cm4gZWUgfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmFkZEVkZ2VzID0gZnVuY3Rpb24gYWRkRWRnZXMgKGVkZ2VzVG9BZGQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpdCA9IGVkZ2VzVG9BZGQuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIHRoaXMkMS5fZWRnZXMuYWRkKGUpO1xuICAgIHZhciBkZTEgPSBuZXcgRGlyZWN0ZWRFZGdlKGUsIHRydWUpO1xuICAgIHZhciBkZTIgPSBuZXcgRGlyZWN0ZWRFZGdlKGUsIGZhbHNlKTtcbiAgICBkZTEuc2V0U3ltKGRlMik7XG4gICAgZGUyLnNldFN5bShkZTEpO1xuICAgIHRoaXMkMS5hZGQoZGUxKTtcbiAgICB0aGlzJDEuYWRkKGRlMik7XG4gIH1cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChlKSB7XG4gIHRoaXMuX25vZGVzLmFkZChlKTtcbiAgdGhpcy5fZWRnZUVuZExpc3QuYWRkKGUpO1xufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uIGdldE5vZGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVzLnZhbHVlcygpXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmZpbmRFZGdlID0gZnVuY3Rpb24gZmluZEVkZ2UgKHAwLCBwMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZWRnZXMuc2l6ZSgpOyBpKyspIHtcbiAgICB2YXIgZSA9IHRoaXMkMS5fZWRnZXMuZ2V0KGkpO1xuICAgIHZhciBlQ29vcmQgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKHAwLmVxdWFscyhlQ29vcmRbMF0pICYmIHAxLmVxdWFscyhlQ29vcmRbMV0pKSB7IHJldHVybiBlIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUGxhbmFyR3JhcGhcbn07XG5QbGFuYXJHcmFwaC5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uIGxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzIChub2Rlcykge1xuICBmb3IgKHZhciBub2RlaXQgPSBub2Rlcy5pdGVyYXRvcigpOyBub2RlaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBub2RlID0gbm9kZWl0Lm5leHQoKTtcbiAgICBub2RlLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKTtcbiAgfVxufTtcblxudmFyIFBvbHlnb25CdWlsZGVyID0gZnVuY3Rpb24gUG9seWdvbkJ1aWxkZXIgKCkge1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBudWxsO1xuICB0aGlzLl9zaGVsbExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBnZW9tZXRyeUZhY3RvcnkgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeTtcbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuc29ydFNoZWxsc0FuZEhvbGVzID0gZnVuY3Rpb24gc29ydFNoZWxsc0FuZEhvbGVzIChlZGdlUmluZ3MsIHNoZWxsTGlzdCwgZnJlZUhvbGVMaXN0KSB7XG4gIGZvciAodmFyIGl0ID0gZWRnZVJpbmdzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZXIgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGVyLmlzSG9sZSgpKSB7XG4gICAgICBmcmVlSG9sZUxpc3QuYWRkKGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hlbGxMaXN0LmFkZChlcik7XG4gICAgfVxuICB9XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmNvbXB1dGVQb2x5Z29ucyA9IGZ1bmN0aW9uIGNvbXB1dGVQb2x5Z29ucyAoc2hlbGxMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHJlc3VsdFBvbHlMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpdCA9IHNoZWxsTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVyID0gaXQubmV4dCgpO1xuICAgIHZhciBwb2x5ID0gZXIudG9Qb2x5Z29uKHRoaXMkMS5fZ2VvbWV0cnlGYWN0b3J5KTtcbiAgICByZXN1bHRQb2x5TGlzdC5hZGQocG9seSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFBvbHlMaXN0XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLnBsYWNlRnJlZUhvbGVzID0gZnVuY3Rpb24gcGxhY2VGcmVlSG9sZXMgKHNoZWxsTGlzdCwgZnJlZUhvbGVMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaXQgPSBmcmVlSG9sZUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBob2xlID0gaXQubmV4dCgpO1xuICAgIGlmIChob2xlLmdldFNoZWxsKCkgPT09IG51bGwpIHtcbiAgICAgIHZhciBzaGVsbCA9IHRoaXMkMS5maW5kRWRnZVJpbmdDb250YWluaW5nKGhvbGUsIHNoZWxsTGlzdCk7XG4gICAgICBpZiAoc2hlbGwgPT09IG51bGwpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCd1bmFibGUgdG8gYXNzaWduIGhvbGUgdG8gYSBzaGVsbCcsIGhvbGUuZ2V0Q29vcmRpbmF0ZSgwKSkgfVxuICAgICAgaG9sZS5zZXRTaGVsbChzaGVsbCk7XG4gICAgfVxuICB9XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTWluaW1hbEVkZ2VSaW5ncyA9IGZ1bmN0aW9uIGJ1aWxkTWluaW1hbEVkZ2VSaW5ncyAobWF4RWRnZVJpbmdzLCBzaGVsbExpc3QsIGZyZWVIb2xlTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlZGdlUmluZ3MgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGl0ID0gbWF4RWRnZVJpbmdzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZXIgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGVyLmdldE1heE5vZGVEZWdyZWUoKSA+IDIpIHtcbiAgICAgIGVyLmxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5ncygpO1xuICAgICAgdmFyIG1pbkVkZ2VSaW5ncyA9IGVyLmJ1aWxkTWluaW1hbFJpbmdzKCk7XG4gICAgICB2YXIgc2hlbGwgPSB0aGlzJDEuZmluZFNoZWxsKG1pbkVkZ2VSaW5ncyk7XG4gICAgICBpZiAoc2hlbGwgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcyQxLnBsYWNlUG9seWdvbkhvbGVzKHNoZWxsLCBtaW5FZGdlUmluZ3MpO1xuICAgICAgICBzaGVsbExpc3QuYWRkKHNoZWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyZWVIb2xlTGlzdC5hZGRBbGwobWluRWRnZVJpbmdzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWRnZVJpbmdzLmFkZChlcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBlZGdlUmluZ3Ncbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQgKHApIHtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9zaGVsbExpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlciA9IGl0Lm5leHQoKTtcbiAgICBpZiAoZXIuY29udGFpbnNQb2ludChwKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyA9IGZ1bmN0aW9uIGJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyAoZGlyRWRnZXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbWF4RWRnZVJpbmdzID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpdCA9IGRpckVkZ2VzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGRlLmlzSW5SZXN1bHQoKSAmJiBkZS5nZXRMYWJlbCgpLmlzQXJlYSgpKSB7XG4gICAgICBpZiAoZGUuZ2V0RWRnZVJpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgZXIgPSBuZXcgTWF4aW1hbEVkZ2VSaW5nKGRlLCB0aGlzJDEuX2dlb21ldHJ5RmFjdG9yeSk7XG4gICAgICAgIG1heEVkZ2VSaW5ncy5hZGQoZXIpO1xuICAgICAgICBlci5zZXRJblJlc3VsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4RWRnZVJpbmdzXG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLnBsYWNlUG9seWdvbkhvbGVzID0gZnVuY3Rpb24gcGxhY2VQb2x5Z29uSG9sZXMgKHNoZWxsLCBtaW5FZGdlUmluZ3MpIHtcbiAgZm9yICh2YXIgaXQgPSBtaW5FZGdlUmluZ3MuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlciA9IGl0Lm5leHQoKTtcbiAgICBpZiAoZXIuaXNIb2xlKCkpIHtcbiAgICAgIGVyLnNldFNoZWxsKHNoZWxsKTtcbiAgICB9XG4gIH1cbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuZ2V0UG9seWdvbnMgPSBmdW5jdGlvbiBnZXRQb2x5Z29ucyAoKSB7XG4gIHZhciByZXN1bHRQb2x5TGlzdCA9IHRoaXMuY29tcHV0ZVBvbHlnb25zKHRoaXMuX3NoZWxsTGlzdCk7XG4gIHJldHVybiByZXN1bHRQb2x5TGlzdFxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5maW5kRWRnZVJpbmdDb250YWluaW5nID0gZnVuY3Rpb24gZmluZEVkZ2VSaW5nQ29udGFpbmluZyAodGVzdEVyLCBzaGVsbExpc3QpIHtcbiAgdmFyIHRlc3RSaW5nID0gdGVzdEVyLmdldExpbmVhclJpbmcoKTtcbiAgdmFyIHRlc3RFbnYgPSB0ZXN0UmluZy5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gIHZhciB0ZXN0UHQgPSB0ZXN0UmluZy5nZXRDb29yZGluYXRlTigwKTtcbiAgdmFyIG1pblNoZWxsID0gbnVsbDtcbiAgdmFyIG1pbkVudiA9IG51bGw7XG4gIGZvciAodmFyIGl0ID0gc2hlbGxMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgdHJ5U2hlbGwgPSBpdC5uZXh0KCk7XG4gICAgdmFyIHRyeVJpbmcgPSB0cnlTaGVsbC5nZXRMaW5lYXJSaW5nKCk7XG4gICAgdmFyIHRyeUVudiA9IHRyeVJpbmcuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICAgIGlmIChtaW5TaGVsbCAhPT0gbnVsbCkgeyBtaW5FbnYgPSBtaW5TaGVsbC5nZXRMaW5lYXJSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpOyB9XG4gICAgdmFyIGlzQ29udGFpbmVkID0gZmFsc2U7XG4gICAgaWYgKHRyeUVudi5jb250YWlucyh0ZXN0RW52KSAmJiBDR0FsZ29yaXRobXMuaXNQb2ludEluUmluZyh0ZXN0UHQsIHRyeVJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSkpIHsgaXNDb250YWluZWQgPSB0cnVlOyB9XG4gICAgaWYgKGlzQ29udGFpbmVkKSB7XG4gICAgICBpZiAobWluU2hlbGwgPT09IG51bGwgfHwgbWluRW52LmNvbnRhaW5zKHRyeUVudikpIHtcbiAgICAgICAgbWluU2hlbGwgPSB0cnlTaGVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1pblNoZWxsXG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmZpbmRTaGVsbCA9IGZ1bmN0aW9uIGZpbmRTaGVsbCAobWluRWRnZVJpbmdzKSB7XG4gIHZhciBzaGVsbENvdW50ID0gMDtcbiAgdmFyIHNoZWxsID0gbnVsbDtcbiAgZm9yICh2YXIgaXQgPSBtaW5FZGdlUmluZ3MuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlciA9IGl0Lm5leHQoKTtcbiAgICBpZiAoIWVyLmlzSG9sZSgpKSB7XG4gICAgICBzaGVsbCA9IGVyO1xuICAgICAgc2hlbGxDb3VudCsrO1xuICAgIH1cbiAgfVxuICBBc3NlcnQuaXNUcnVlKHNoZWxsQ291bnQgPD0gMSwgJ2ZvdW5kIHR3byBzaGVsbHMgaW4gTWluaW1hbEVkZ2VSaW5nIGxpc3QnKTtcbiAgcmV0dXJuIHNoZWxsXG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdyYXBoID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuYWRkKGdyYXBoLmdldEVkZ2VFbmRzKCksIGdyYXBoLmdldE5vZGVzKCkpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZGlyRWRnZXMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5vZGVzID0gYXJndW1lbnRzWzFdO1xuICAgIFBsYW5hckdyYXBoLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKG5vZGVzKTtcbiAgICB2YXIgbWF4RWRnZVJpbmdzID0gdGhpcy5idWlsZE1heGltYWxFZGdlUmluZ3MoZGlyRWRnZXMpO1xuICAgIHZhciBmcmVlSG9sZUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdmFyIGVkZ2VSaW5ncyA9IHRoaXMuYnVpbGRNaW5pbWFsRWRnZVJpbmdzKG1heEVkZ2VSaW5ncywgdGhpcy5fc2hlbGxMaXN0LCBmcmVlSG9sZUxpc3QpO1xuICAgIHRoaXMuc29ydFNoZWxsc0FuZEhvbGVzKGVkZ2VSaW5ncywgdGhpcy5fc2hlbGxMaXN0LCBmcmVlSG9sZUxpc3QpO1xuICAgIHRoaXMucGxhY2VGcmVlSG9sZXModGhpcy5fc2hlbGxMaXN0LCBmcmVlSG9sZUxpc3QpO1xuICB9XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2x5Z29uQnVpbGRlclxufTtcblxudmFyIEJvdW5kYWJsZSA9IGZ1bmN0aW9uIEJvdW5kYWJsZSAoKSB7fTtcblxuQm91bmRhYmxlLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbiBnZXRCb3VuZHMgKCkge307XG5Cb3VuZGFibGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Cb3VuZGFibGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQm91bmRhYmxlXG59O1xuXG52YXIgSXRlbUJvdW5kYWJsZSA9IGZ1bmN0aW9uIEl0ZW1Cb3VuZGFibGUgKCkge1xuICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICB0aGlzLl9pdGVtID0gbnVsbDtcbiAgdmFyIGJvdW5kcyA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX2JvdW5kcyA9IGJvdW5kcztcbiAgdGhpcy5faXRlbSA9IGl0ZW07XG59O1xuSXRlbUJvdW5kYWJsZS5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIGdldEl0ZW0gKCkge1xuICByZXR1cm4gdGhpcy5faXRlbVxufTtcbkl0ZW1Cb3VuZGFibGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyAoKSB7XG4gIHJldHVybiB0aGlzLl9ib3VuZHNcbn07XG5JdGVtQm91bmRhYmxlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtCb3VuZGFibGUsIFNlcmlhbGl6YWJsZV1cbn07XG5JdGVtQm91bmRhYmxlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEl0ZW1Cb3VuZGFibGVcbn07XG5cbnZhciBQcmlvcml0eVF1ZXVlID0gZnVuY3Rpb24gUHJpb3JpdHlRdWV1ZSAoKSB7XG4gIHRoaXMuX3NpemUgPSBudWxsO1xuICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gIHRoaXMuX3NpemUgPSAwO1xuICB0aGlzLl9pdGVtcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5faXRlbXMuYWRkKG51bGwpO1xufTtcblByaW9yaXR5UXVldWUucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbiBwb2xsICgpIHtcbiAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG1pbkl0ZW0gPSB0aGlzLl9pdGVtcy5nZXQoMSk7XG4gIHRoaXMuX2l0ZW1zLnNldCgxLCB0aGlzLl9pdGVtcy5nZXQodGhpcy5fc2l6ZSkpO1xuICB0aGlzLl9zaXplIC09IDE7XG4gIHRoaXMucmVvcmRlcigxKTtcbiAgcmV0dXJuIG1pbkl0ZW1cbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9zaXplXG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucmVvcmRlciA9IGZ1bmN0aW9uIHJlb3JkZXIgKGhvbGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY2hpbGQgPSBudWxsO1xuICB2YXIgdG1wID0gdGhpcy5faXRlbXMuZ2V0KGhvbGUpO1xuICBmb3IgKDsgaG9sZSAqIDIgPD0gdGhpcy5fc2l6ZTsgaG9sZSA9IGNoaWxkKSB7XG4gICAgY2hpbGQgPSBob2xlICogMjtcbiAgICBpZiAoY2hpbGQgIT09IHRoaXMkMS5fc2l6ZSAmJiB0aGlzJDEuX2l0ZW1zLmdldChjaGlsZCArIDEpLmNvbXBhcmVUbyh0aGlzJDEuX2l0ZW1zLmdldChjaGlsZCkpIDwgMCkgeyBjaGlsZCsrOyB9XG4gICAgaWYgKHRoaXMkMS5faXRlbXMuZ2V0KGNoaWxkKS5jb21wYXJlVG8odG1wKSA8IDApIHsgdGhpcyQxLl9pdGVtcy5zZXQoaG9sZSwgdGhpcyQxLl9pdGVtcy5nZXQoY2hpbGQpKTsgfSBlbHNlIHsgYnJlYWsgfVxuICB9XG4gIHRoaXMuX2l0ZW1zLnNldChob2xlLCB0bXApO1xufTtcblByaW9yaXR5UXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICB0aGlzLl9zaXplID0gMDtcbiAgdGhpcy5faXRlbXMuY2xlYXIoKTtcbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gIHJldHVybiB0aGlzLl9zaXplID09PSAwXG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICh4KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5faXRlbXMuYWRkKG51bGwpO1xuICB0aGlzLl9zaXplICs9IDE7XG4gIHZhciBob2xlID0gdGhpcy5fc2l6ZTtcbiAgdGhpcy5faXRlbXMuc2V0KDAsIHgpO1xuICBmb3IgKDsgeC5jb21wYXJlVG8odGhpcy5faXRlbXMuZ2V0KE1hdGgudHJ1bmMoaG9sZSAvIDIpKSkgPCAwOyBob2xlIC89IDIpIHtcbiAgICB0aGlzJDEuX2l0ZW1zLnNldChob2xlLCB0aGlzJDEuX2l0ZW1zLmdldChNYXRoLnRydW5jKGhvbGUgLyAyKSkpO1xuICB9XG4gIHRoaXMuX2l0ZW1zLnNldChob2xlLCB4KTtcbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQcmlvcml0eVF1ZXVlXG59O1xuXG52YXIgSXRlbVZpc2l0b3IgPSBmdW5jdGlvbiBJdGVtVmlzaXRvciAoKSB7fTtcblxuSXRlbVZpc2l0b3IucHJvdG90eXBlLnZpc2l0SXRlbSA9IGZ1bmN0aW9uIHZpc2l0SXRlbSAoaXRlbSkge307XG5JdGVtVmlzaXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkl0ZW1WaXNpdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEl0ZW1WaXNpdG9yXG59O1xuXG52YXIgU3BhdGlhbEluZGV4ID0gZnVuY3Rpb24gU3BhdGlhbEluZGV4ICgpIHt9O1xuXG5TcGF0aWFsSW5kZXgucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoaXRlbUVudiwgaXRlbSkge307XG5TcGF0aWFsSW5kZXgucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoaXRlbUVudiwgaXRlbSkge307XG5TcGF0aWFsSW5kZXgucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkgKCkge1xuICAvLyBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAvLyBjb25zdCBzZWFyY2hFbnYgPSBhcmd1bWVudHNbMF1cbiAgLy8gfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gIC8vIGNvbnN0IHNlYXJjaEVudiA9IGFyZ3VtZW50c1swXVxuICAvLyBjb25zdCB2aXNpdG9yID0gYXJndW1lbnRzWzFdXG4gIC8vIH1cbn07XG5TcGF0aWFsSW5kZXgucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TcGF0aWFsSW5kZXgucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU3BhdGlhbEluZGV4XG59O1xuXG52YXIgQWJzdHJhY3ROb2RlID0gZnVuY3Rpb24gQWJzdHJhY3ROb2RlICgpIHtcbiAgdGhpcy5fY2hpbGRCb3VuZGFibGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICB0aGlzLl9sZXZlbCA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxldmVsID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX2xldmVsID0gbGV2ZWw7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjIgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuZ2V0TGV2ZWwgPSBmdW5jdGlvbiBnZXRMZXZlbCAoKSB7XG4gIHJldHVybiB0aGlzLl9sZXZlbFxufTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICByZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzLnNpemUoKVxufTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRCb3VuZGFibGVzID0gZnVuY3Rpb24gZ2V0Q2hpbGRCb3VuZGFibGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlc1xufTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuYWRkQ2hpbGRCb3VuZGFibGUgPSBmdW5jdGlvbiBhZGRDaGlsZEJvdW5kYWJsZSAoY2hpbGRCb3VuZGFibGUpIHtcbiAgQXNzZXJ0LmlzVHJ1ZSh0aGlzLl9ib3VuZHMgPT09IG51bGwpO1xuICB0aGlzLl9jaGlsZEJvdW5kYWJsZXMuYWRkKGNoaWxkQm91bmRhYmxlKTtcbn07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NoaWxkQm91bmRhYmxlcy5pc0VtcHR5KClcbn07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyAoKSB7XG4gIGlmICh0aGlzLl9ib3VuZHMgPT09IG51bGwpIHtcbiAgICB0aGlzLl9ib3VuZHMgPSB0aGlzLmNvbXB1dGVCb3VuZHMoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYm91bmRzXG59O1xuQWJzdHJhY3ROb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtCb3VuZGFibGUsIFNlcmlhbGl6YWJsZV1cbn07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQWJzdHJhY3ROb2RlXG59O1xuc3RhdGljQWNjZXNzb3JzJDIyLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNjQ5MzcyMjE4NTkwOTU3MzcwOCB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQWJzdHJhY3ROb2RlLCBzdGF0aWNBY2Nlc3NvcnMkMjIgKTtcblxudmFyIENvbGxlY3Rpb25zID0gZnVuY3Rpb24gQ29sbGVjdGlvbnMgKCkge307XG5cbkNvbGxlY3Rpb25zLnJldmVyc2VPcmRlciA9IGZ1bmN0aW9uIHJldmVyc2VPcmRlciAoKSB7XG4gIHJldHVybiB7XG4gICAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICAgICAgcmV0dXJuIGIuY29tcGFyZVRvKGEpXG4gICAgfVxuICB9XG59O1xuQ29sbGVjdGlvbnMubWluID0gZnVuY3Rpb24gbWluIChsKSB7XG4gIENvbGxlY3Rpb25zLnNvcnQobCk7XG4gIHJldHVybiBsLmdldCgwKVxufTtcbkNvbGxlY3Rpb25zLnNvcnQgPSBmdW5jdGlvbiBzb3J0IChsLCBjKSB7XG4gIHZhciBhID0gbC50b0FycmF5KCk7XG4gIGlmIChjKSB7XG4gICAgQXJyYXlzLnNvcnQoYSwgYyk7XG4gIH0gZWxzZSB7XG4gICAgQXJyYXlzLnNvcnQoYSk7XG4gIH1cbiAgdmFyIGkgPSBsLml0ZXJhdG9yKCk7XG4gIGZvciAodmFyIHBvcyA9IDAsIGFsZW4gPSBhLmxlbmd0aDsgcG9zIDwgYWxlbjsgcG9zKyspIHtcbiAgICBpLm5leHQoKTtcbiAgICBpLnNldChhW3Bvc10pO1xuICB9XG59O1xuQ29sbGVjdGlvbnMuc2luZ2xldG9uTGlzdCA9IGZ1bmN0aW9uIHNpbmdsZXRvbkxpc3QgKG8pIHtcbiAgdmFyIGFycmF5TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgYXJyYXlMaXN0LmFkZChvKTtcbiAgcmV0dXJuIGFycmF5TGlzdFxufTtcblxudmFyIEJvdW5kYWJsZVBhaXIgPSBmdW5jdGlvbiBCb3VuZGFibGVQYWlyICgpIHtcbiAgdGhpcy5fYm91bmRhYmxlMSA9IG51bGw7XG4gIHRoaXMuX2JvdW5kYWJsZTIgPSBudWxsO1xuICB0aGlzLl9kaXN0YW5jZSA9IG51bGw7XG4gIHRoaXMuX2l0ZW1EaXN0YW5jZSA9IG51bGw7XG4gIHZhciBib3VuZGFibGUxID0gYXJndW1lbnRzWzBdO1xuICB2YXIgYm91bmRhYmxlMiA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGl0ZW1EaXN0YW5jZSA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5fYm91bmRhYmxlMSA9IGJvdW5kYWJsZTE7XG4gIHRoaXMuX2JvdW5kYWJsZTIgPSBib3VuZGFibGUyO1xuICB0aGlzLl9pdGVtRGlzdGFuY2UgPSBpdGVtRGlzdGFuY2U7XG4gIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5kaXN0YW5jZSgpO1xufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmV4cGFuZFRvUXVldWUgPSBmdW5jdGlvbiBleHBhbmRUb1F1ZXVlIChwcmlRLCBtaW5EaXN0YW5jZSkge1xuICB2YXIgaXNDb21wMSA9IEJvdW5kYWJsZVBhaXIuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMSk7XG4gIHZhciBpc0NvbXAyID0gQm91bmRhYmxlUGFpci5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUyKTtcbiAgaWYgKGlzQ29tcDEgJiYgaXNDb21wMikge1xuICAgIGlmIChCb3VuZGFibGVQYWlyLmFyZWEodGhpcy5fYm91bmRhYmxlMSkgPiBCb3VuZGFibGVQYWlyLmFyZWEodGhpcy5fYm91bmRhYmxlMikpIHtcbiAgICAgIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTEsIHRoaXMuX2JvdW5kYWJsZTIsIHByaVEsIG1pbkRpc3RhbmNlKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTIsIHRoaXMuX2JvdW5kYWJsZTEsIHByaVEsIG1pbkRpc3RhbmNlKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9IGVsc2UgaWYgKGlzQ29tcDEpIHtcbiAgICB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUxLCB0aGlzLl9ib3VuZGFibGUyLCBwcmlRLCBtaW5EaXN0YW5jZSk7XG4gICAgcmV0dXJuIG51bGxcbiAgfSBlbHNlIGlmIChpc0NvbXAyKSB7XG4gICAgdGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMiwgdGhpcy5fYm91bmRhYmxlMSwgcHJpUSwgbWluRGlzdGFuY2UpO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignbmVpdGhlciBib3VuZGFibGUgaXMgY29tcG9zaXRlJylcbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5pc0xlYXZlcyA9IGZ1bmN0aW9uIGlzTGVhdmVzICgpIHtcbiAgcmV0dXJuICEoQm91bmRhYmxlUGFpci5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUxKSB8fCBCb3VuZGFibGVQYWlyLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTIpKVxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgbmQgPSBvO1xuICBpZiAodGhpcy5fZGlzdGFuY2UgPCBuZC5fZGlzdGFuY2UpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX2Rpc3RhbmNlID4gbmQuX2Rpc3RhbmNlKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5leHBhbmQgPSBmdW5jdGlvbiBleHBhbmQgKGJuZENvbXBvc2l0ZSwgYm5kT3RoZXIsIHByaVEsIG1pbkRpc3RhbmNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNoaWxkcmVuID0gYm5kQ29tcG9zaXRlLmdldENoaWxkQm91bmRhYmxlcygpO1xuICBmb3IgKHZhciBpID0gY2hpbGRyZW4uaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGNoaWxkID0gaS5uZXh0KCk7XG4gICAgdmFyIGJwID0gbmV3IEJvdW5kYWJsZVBhaXIoY2hpbGQsIGJuZE90aGVyLCB0aGlzJDEuX2l0ZW1EaXN0YW5jZSk7XG4gICAgaWYgKGJwLmdldERpc3RhbmNlKCkgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgcHJpUS5hZGQoYnApO1xuICAgIH1cbiAgfVxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmdldEJvdW5kYWJsZSA9IGZ1bmN0aW9uIGdldEJvdW5kYWJsZSAoaSkge1xuICBpZiAoaSA9PT0gMCkgeyByZXR1cm4gdGhpcy5fYm91bmRhYmxlMSB9XG4gIHJldHVybiB0aGlzLl9ib3VuZGFibGUyXG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXREaXN0YW5jZSAoKSB7XG4gIHJldHVybiB0aGlzLl9kaXN0YW5jZVxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKCkge1xuICBpZiAodGhpcy5pc0xlYXZlcygpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1EaXN0YW5jZS5kaXN0YW5jZSh0aGlzLl9ib3VuZGFibGUxLCB0aGlzLl9ib3VuZGFibGUyKVxuICB9XG4gIHJldHVybiB0aGlzLl9ib3VuZGFibGUxLmdldEJvdW5kcygpLmRpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTIuZ2V0Qm91bmRzKCkpXG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJvdW5kYWJsZVBhaXJcbn07XG5Cb3VuZGFibGVQYWlyLmFyZWEgPSBmdW5jdGlvbiBhcmVhIChiKSB7XG4gIHJldHVybiBiLmdldEJvdW5kcygpLmdldEFyZWEoKVxufTtcbkJvdW5kYWJsZVBhaXIuaXNDb21wb3NpdGUgPSBmdW5jdGlvbiBpc0NvbXBvc2l0ZSAoaXRlbSkge1xuICByZXR1cm4gaXRlbSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZVxufTtcblxudmFyIEFic3RyYWN0U1RSdHJlZSA9IGZ1bmN0aW9uIEFic3RyYWN0U1RSdHJlZSAoKSB7XG4gIHRoaXMuX3Jvb3QgPSBudWxsO1xuICB0aGlzLl9idWlsdCA9IGZhbHNlO1xuICB0aGlzLl9pdGVtQm91bmRhYmxlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fbm9kZUNhcGFjaXR5ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgbm9kZUNhcGFjaXR5ID0gQWJzdHJhY3RTVFJ0cmVlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWTtcbiAgICB0aGlzLl9ub2RlQ2FwYWNpdHkgPSBub2RlQ2FwYWNpdHk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBub2RlQ2FwYWNpdHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICBBc3NlcnQuaXNUcnVlKG5vZGVDYXBhY2l0eSQxID4gMSwgJ05vZGUgY2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgIHRoaXMuX25vZGVDYXBhY2l0eSA9IG5vZGVDYXBhY2l0eSQxO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDIzID0geyBJbnRlcnNlY3RzT3A6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUZBVUxUX05PREVfQ0FQQUNJVFk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuZ2V0Tm9kZUNhcGFjaXR5ID0gZnVuY3Rpb24gZ2V0Tm9kZUNhcGFjaXR5ICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVDYXBhY2l0eVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUubGFzdE5vZGUgPSBmdW5jdGlvbiBsYXN0Tm9kZSAobm9kZXMpIHtcbiAgcmV0dXJuIG5vZGVzLmdldChub2Rlcy5zaXplKCkgLSAxKVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICB0aGlzLmJ1aWxkKCk7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSh0aGlzLl9yb290KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbm9kZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2l6ZSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICAgIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkge1xuICAgICAgICBzaXplICs9IHRoaXMkMS5zaXplKGNoaWxkQm91bmRhYmxlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBJdGVtQm91bmRhYmxlKSB7XG4gICAgICAgIHNpemUgKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemVcbiAgfVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUucmVtb3ZlSXRlbSA9IGZ1bmN0aW9uIHJlbW92ZUl0ZW0gKG5vZGUsIGl0ZW0pIHtcbiAgdmFyIGNoaWxkVG9SZW1vdmUgPSBudWxsO1xuICBmb3IgKHZhciBpID0gbm9kZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBJdGVtQm91bmRhYmxlKSB7XG4gICAgICBpZiAoY2hpbGRCb3VuZGFibGUuZ2V0SXRlbSgpID09PSBpdGVtKSB7IGNoaWxkVG9SZW1vdmUgPSBjaGlsZEJvdW5kYWJsZTsgfVxuICAgIH1cbiAgfVxuICBpZiAoY2hpbGRUb1JlbW92ZSAhPT0gbnVsbCkge1xuICAgIG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKGNoaWxkVG9SZW1vdmUpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5pdGVtc1RyZWUgPSBmdW5jdGlvbiBpdGVtc1RyZWUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5idWlsZCgpO1xuICAgIHZhciB2YWx1ZXNUcmVlID0gdGhpcy5pdGVtc1RyZWUodGhpcy5fcm9vdCk7XG4gICAgaWYgKHZhbHVlc1RyZWUgPT09IG51bGwpIHsgcmV0dXJuIG5ldyBBcnJheUxpc3QoKSB9XG4gICAgcmV0dXJuIHZhbHVlc1RyZWVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHZhbHVlc1RyZWVGb3JOb2RlID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGkgPSBub2RlLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlc1RyZWVGb3JDaGlsZCA9IHRoaXMkMS5pdGVtc1RyZWUoY2hpbGRCb3VuZGFibGUpO1xuICAgICAgICBpZiAodmFsdWVzVHJlZUZvckNoaWxkICE9PSBudWxsKSB7IHZhbHVlc1RyZWVGb3JOb2RlLmFkZCh2YWx1ZXNUcmVlRm9yQ2hpbGQpOyB9XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgSXRlbUJvdW5kYWJsZSkge1xuICAgICAgICB2YWx1ZXNUcmVlRm9yTm9kZS5hZGQoY2hpbGRCb3VuZGFibGUuZ2V0SXRlbSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWVzVHJlZUZvck5vZGUuc2l6ZSgpIDw9IDApIHsgcmV0dXJuIG51bGwgfVxuICAgIHJldHVybiB2YWx1ZXNUcmVlRm9yTm9kZVxuICB9XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKGJvdW5kcywgaXRlbSkge1xuICBBc3NlcnQuaXNUcnVlKCF0aGlzLl9idWlsdCwgJ0Nhbm5vdCBpbnNlcnQgaXRlbXMgaW50byBhbiBTVFIgcGFja2VkIFItdHJlZSBhZnRlciBpdCBoYXMgYmVlbiBidWlsdC4nKTtcbiAgdGhpcy5faXRlbUJvdW5kYWJsZXMuYWRkKG5ldyBJdGVtQm91bmRhYmxlKGJvdW5kcywgaXRlbSkpO1xufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuYm91bmRhYmxlc0F0TGV2ZWwgPSBmdW5jdGlvbiBib3VuZGFibGVzQXRMZXZlbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGJvdW5kYWJsZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdGhpcy5ib3VuZGFibGVzQXRMZXZlbChsZXZlbCwgdGhpcy5fcm9vdCwgYm91bmRhYmxlcyk7XG4gICAgcmV0dXJuIGJvdW5kYWJsZXNcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGxldmVsJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHRvcCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgYm91bmRhYmxlcyQxID0gYXJndW1lbnRzWzJdO1xuICAgIEFzc2VydC5pc1RydWUobGV2ZWwkMSA+IC0yKTtcbiAgICBpZiAodG9wLmdldExldmVsKCkgPT09IGxldmVsJDEpIHtcbiAgICAgIGJvdW5kYWJsZXMkMS5hZGQodG9wKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSB0b3AuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgYm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICBpZiAoYm91bmRhYmxlIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSB7XG4gICAgICAgIHRoaXMkMS5ib3VuZGFibGVzQXRMZXZlbChsZXZlbCQxLCBib3VuZGFibGUsIGJvdW5kYWJsZXMkMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBc3NlcnQuaXNUcnVlKGJvdW5kYWJsZSBpbnN0YW5jZW9mIEl0ZW1Cb3VuZGFibGUpO1xuICAgICAgICBpZiAobGV2ZWwkMSA9PT0gLTEpIHtcbiAgICAgICAgICBib3VuZGFibGVzJDEuYWRkKGJvdW5kYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiBxdWVyeSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc2VhcmNoQm91bmRzID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuYnVpbGQoKTtcbiAgICB2YXIgbWF0Y2hlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzXG4gICAgfVxuICAgIGlmICh0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSwgc2VhcmNoQm91bmRzKSkge1xuICAgICAgdGhpcy5xdWVyeShzZWFyY2hCb3VuZHMsIHRoaXMuX3Jvb3QsIG1hdGNoZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlc1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2VhcmNoQm91bmRzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHZpc2l0b3IgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5idWlsZCgpO1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLCBzZWFyY2hCb3VuZHMkMSkpIHtcbiAgICAgIHRoaXMucXVlcnkoc2VhcmNoQm91bmRzJDEsIHRoaXMuX3Jvb3QsIHZpc2l0b3IpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMl0sIEl0ZW1WaXNpdG9yKSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT2JqZWN0ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkpIHtcbiAgICAgIHZhciBzZWFyY2hCb3VuZHMkMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBub2RlID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHZpc2l0b3IkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBjaGlsZEJvdW5kYWJsZXMgPSBub2RlLmdldENoaWxkQm91bmRhYmxlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZEJvdW5kYWJsZXMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gY2hpbGRCb3VuZGFibGVzLmdldChpKTtcbiAgICAgICAgaWYgKCF0aGlzJDEuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhjaGlsZEJvdW5kYWJsZS5nZXRCb3VuZHMoKSwgc2VhcmNoQm91bmRzJDIpKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpIHtcbiAgICAgICAgICB0aGlzJDEucXVlcnkoc2VhcmNoQm91bmRzJDIsIGNoaWxkQm91bmRhYmxlLCB2aXNpdG9yJDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgSXRlbUJvdW5kYWJsZSkge1xuICAgICAgICAgIHZpc2l0b3IkMS52aXNpdEl0ZW0oY2hpbGRCb3VuZGFibGUuZ2V0SXRlbSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1syXSwgTGlzdCkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdCAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpKSB7XG4gICAgICB2YXIgc2VhcmNoQm91bmRzJDMgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbm9kZSQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIG1hdGNoZXMkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBjaGlsZEJvdW5kYWJsZXMkMSA9IG5vZGUkMS5nZXRDaGlsZEJvdW5kYWJsZXMoKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNoaWxkQm91bmRhYmxlcyQxLnNpemUoKTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGNoaWxkQm91bmRhYmxlJDEgPSBjaGlsZEJvdW5kYWJsZXMkMS5nZXQoaSQxKTtcbiAgICAgICAgaWYgKCF0aGlzJDEuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhjaGlsZEJvdW5kYWJsZSQxLmdldEJvdW5kcygpLCBzZWFyY2hCb3VuZHMkMykpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEJvdW5kYWJsZSQxIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSB7XG4gICAgICAgICAgdGhpcyQxLnF1ZXJ5KHNlYXJjaEJvdW5kcyQzLCBjaGlsZEJvdW5kYWJsZSQxLCBtYXRjaGVzJDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQm91bmRhYmxlJDEgaW5zdGFuY2VvZiBJdGVtQm91bmRhYmxlKSB7XG4gICAgICAgICAgbWF0Y2hlcyQxLmFkZChjaGlsZEJvdW5kYWJsZSQxLmdldEl0ZW0oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gYnVpbGQgKCkge1xuICBpZiAodGhpcy5fYnVpbHQpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLl9yb290ID0gdGhpcy5faXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpID8gdGhpcy5jcmVhdGVOb2RlKDApIDogdGhpcy5jcmVhdGVIaWdoZXJMZXZlbHModGhpcy5faXRlbUJvdW5kYWJsZXMsIC0xKTtcbiAgdGhpcy5faXRlbUJvdW5kYWJsZXMgPSBudWxsO1xuICB0aGlzLl9idWlsdCA9IHRydWU7XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5nZXRSb290ID0gZnVuY3Rpb24gZ2V0Um9vdCAoKSB7XG4gIHRoaXMuYnVpbGQoKTtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Rcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2VhcmNoQm91bmRzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBpdGVtID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuYnVpbGQoKTtcbiAgICBpZiAodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksIHNlYXJjaEJvdW5kcykpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW92ZShzZWFyY2hCb3VuZHMsIHRoaXMuX3Jvb3QsIGl0ZW0pXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgc2VhcmNoQm91bmRzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGl0ZW0kMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgZm91bmQgPSB0aGlzLnJlbW92ZUl0ZW0obm9kZSwgaXRlbSQxKTtcbiAgICBpZiAoZm91bmQpIHsgcmV0dXJuIHRydWUgfVxuICAgIHZhciBjaGlsZFRvUHJ1bmUgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSBub2RlLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICBpZiAoIXRoaXMkMS5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGNoaWxkQm91bmRhYmxlLmdldEJvdW5kcygpLCBzZWFyY2hCb3VuZHMkMSkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkge1xuICAgICAgICBmb3VuZCA9IHRoaXMkMS5yZW1vdmUoc2VhcmNoQm91bmRzJDEsIGNoaWxkQm91bmRhYmxlLCBpdGVtJDEpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICBjaGlsZFRvUHJ1bmUgPSBjaGlsZEJvdW5kYWJsZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaGlsZFRvUHJ1bmUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZFRvUHJ1bmUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXNFbXB0eSgpKSB7XG4gICAgICAgIG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKGNoaWxkVG9QcnVuZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3VuZFxuICB9XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5jcmVhdGVIaWdoZXJMZXZlbHMgPSBmdW5jdGlvbiBjcmVhdGVIaWdoZXJMZXZlbHMgKGJvdW5kYWJsZXNPZkFMZXZlbCwgbGV2ZWwpIHtcbiAgQXNzZXJ0LmlzVHJ1ZSghYm91bmRhYmxlc09mQUxldmVsLmlzRW1wdHkoKSk7XG4gIHZhciBwYXJlbnRCb3VuZGFibGVzID0gdGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzKGJvdW5kYWJsZXNPZkFMZXZlbCwgbGV2ZWwgKyAxKTtcbiAgaWYgKHBhcmVudEJvdW5kYWJsZXMuc2l6ZSgpID09PSAxKSB7XG4gICAgcmV0dXJuIHBhcmVudEJvdW5kYWJsZXMuZ2V0KDApXG4gIH1cbiAgcmV0dXJuIHRoaXMuY3JlYXRlSGlnaGVyTGV2ZWxzKHBhcmVudEJvdW5kYWJsZXMsIGxldmVsICsgMSlcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmRlcHRoID0gZnVuY3Rpb24gZGVwdGggKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICB0aGlzLmJ1aWxkKCk7XG4gICAgcmV0dXJuIHRoaXMuZGVwdGgodGhpcy5fcm9vdClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG1heENoaWxkRGVwdGggPSAwO1xuICAgIGZvciAodmFyIGkgPSBub2RlLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkRGVwdGggPSB0aGlzJDEuZGVwdGgoY2hpbGRCb3VuZGFibGUpO1xuICAgICAgICBpZiAoY2hpbGREZXB0aCA+IG1heENoaWxkRGVwdGgpIHsgbWF4Q2hpbGREZXB0aCA9IGNoaWxkRGVwdGg7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heENoaWxkRGVwdGggKyAxXG4gIH1cbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXMgPSBmdW5jdGlvbiBjcmVhdGVQYXJlbnRCb3VuZGFibGVzIChjaGlsZEJvdW5kYWJsZXMsIG5ld0xldmVsKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgQXNzZXJ0LmlzVHJ1ZSghY2hpbGRCb3VuZGFibGVzLmlzRW1wdHkoKSk7XG4gIHZhciBwYXJlbnRCb3VuZGFibGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICBwYXJlbnRCb3VuZGFibGVzLmFkZCh0aGlzLmNyZWF0ZU5vZGUobmV3TGV2ZWwpKTtcbiAgdmFyIHNvcnRlZENoaWxkQm91bmRhYmxlcyA9IG5ldyBBcnJheUxpc3QoY2hpbGRCb3VuZGFibGVzKTtcbiAgQ29sbGVjdGlvbnMuc29ydChzb3J0ZWRDaGlsZEJvdW5kYWJsZXMsIHRoaXMuZ2V0Q29tcGFyYXRvcigpKTtcbiAgZm9yICh2YXIgaSA9IHNvcnRlZENoaWxkQm91bmRhYmxlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICBpZiAodGhpcyQxLmxhc3ROb2RlKHBhcmVudEJvdW5kYWJsZXMpLmdldENoaWxkQm91bmRhYmxlcygpLnNpemUoKSA9PT0gdGhpcyQxLmdldE5vZGVDYXBhY2l0eSgpKSB7XG4gICAgICBwYXJlbnRCb3VuZGFibGVzLmFkZCh0aGlzJDEuY3JlYXRlTm9kZShuZXdMZXZlbCkpO1xuICAgIH1cbiAgICB0aGlzJDEubGFzdE5vZGUocGFyZW50Qm91bmRhYmxlcykuYWRkQ2hpbGRCb3VuZGFibGUoY2hpbGRCb3VuZGFibGUpO1xuICB9XG4gIHJldHVybiBwYXJlbnRCb3VuZGFibGVzXG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gIGlmICghdGhpcy5fYnVpbHQpIHsgcmV0dXJuIHRoaXMuX2l0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKSB9XG4gIHJldHVybiB0aGlzLl9yb290LmlzRW1wdHkoKVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VyaWFsaXphYmxlXVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBBYnN0cmFjdFNUUnRyZWVcbn07XG5BYnN0cmFjdFNUUnRyZWUuY29tcGFyZURvdWJsZXMgPSBmdW5jdGlvbiBjb21wYXJlRG91YmxlcyAoYSwgYikge1xuICByZXR1cm4gYSA+IGIgPyAxIDogYSA8IGIgPyAtMSA6IDBcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjMuSW50ZXJzZWN0c09wLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEludGVyc2VjdHNPcCB9O1xuc3RhdGljQWNjZXNzb3JzJDIzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTM4ODY0MzU4MTQzNjAyNDEzMzcgfTtcbnN0YXRpY0FjY2Vzc29ycyQyMy5ERUZBVUxUX05PREVfQ0FQQUNJVFkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMTAgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEFic3RyYWN0U1RSdHJlZSwgc3RhdGljQWNjZXNzb3JzJDIzICk7XG5cbnZhciBJbnRlcnNlY3RzT3AgPSBmdW5jdGlvbiBJbnRlcnNlY3RzT3AgKCkge307XG5cbnZhciBJdGVtRGlzdGFuY2UgPSBmdW5jdGlvbiBJdGVtRGlzdGFuY2UgKCkge307XG5cbkl0ZW1EaXN0YW5jZS5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSAoaXRlbTEsIGl0ZW0yKSB7fTtcbkl0ZW1EaXN0YW5jZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkl0ZW1EaXN0YW5jZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBJdGVtRGlzdGFuY2Vcbn07XG5cbnZhciBTVFJ0cmVlID0gKGZ1bmN0aW9uIChBYnN0cmFjdFNUUnRyZWUkJDEpIHtcbiAgZnVuY3Rpb24gU1RSdHJlZSAobm9kZUNhcGFjaXR5KSB7XG4gICAgbm9kZUNhcGFjaXR5ID0gbm9kZUNhcGFjaXR5IHx8IFNUUnRyZWUuREVGQVVMVF9OT0RFX0NBUEFDSVRZO1xuICAgIEFic3RyYWN0U1RSdHJlZSQkMS5jYWxsKHRoaXMsIG5vZGVDYXBhY2l0eSk7XG4gIH1cblxuICBpZiAoIEFic3RyYWN0U1RSdHJlZSQkMSApIFNUUnRyZWUuX19wcm90b19fID0gQWJzdHJhY3RTVFJ0cmVlJCQxO1xuICBTVFJ0cmVlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEFic3RyYWN0U1RSdHJlZSQkMSAmJiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlICk7XG4gIFNUUnRyZWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1RSdHJlZTtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBTVFJ0cmVlTm9kZTogeyBjb25maWd1cmFibGU6IHRydWUgfSxzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHhDb21wYXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHlDb21wYXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LGludGVyc2VjdHNPcDogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUZBVUxUX05PREVfQ0FQQUNJVFk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyA9IGZ1bmN0aW9uIGNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXMgKHZlcnRpY2FsU2xpY2VzLCBuZXdMZXZlbCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgQXNzZXJ0LmlzVHJ1ZSh2ZXJ0aWNhbFNsaWNlcy5sZW5ndGggPiAwKTtcbiAgICB2YXIgcGFyZW50Qm91bmRhYmxlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2FsU2xpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJlbnRCb3VuZGFibGVzLmFkZEFsbCh0aGlzJDEuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlKHZlcnRpY2FsU2xpY2VzW2ldLCBuZXdMZXZlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Qm91bmRhYmxlc1xuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gY3JlYXRlTm9kZSAobGV2ZWwpIHtcbiAgICByZXR1cm4gbmV3IFNUUnRyZWVOb2RlKGxldmVsKVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnNpemUuY2FsbCh0aGlzKVxuICAgIH0gZWxzZSB7IHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnNpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBpdGVtRW52ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoaXRlbUVudi5pc051bGwoKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5pbnNlcnQuY2FsbCh0aGlzLCBpdGVtRW52LCBpdGVtKTtcbiAgICB9IGVsc2UgeyByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5pbnNlcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmdldEludGVyc2VjdHNPcCA9IGZ1bmN0aW9uIGdldEludGVyc2VjdHNPcCAoKSB7XG4gICAgcmV0dXJuIFNUUnRyZWUuaW50ZXJzZWN0c09wXG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLnZlcnRpY2FsU2xpY2VzID0gZnVuY3Rpb24gdmVydGljYWxTbGljZXMgKGNoaWxkQm91bmRhYmxlcywgc2xpY2VDb3VudCkge1xuICAgIHZhciBzbGljZUNhcGFjaXR5ID0gTWF0aC50cnVuYyhNYXRoLmNlaWwoY2hpbGRCb3VuZGFibGVzLnNpemUoKSAvIHNsaWNlQ291bnQpKTtcbiAgICB2YXIgc2xpY2VzID0gbmV3IEFycmF5KHNsaWNlQ291bnQpLmZpbGwobnVsbCk7XG4gICAgdmFyIGkgPSBjaGlsZEJvdW5kYWJsZXMuaXRlcmF0b3IoKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNsaWNlQ291bnQ7IGorKykge1xuICAgICAgc2xpY2VzW2pdID0gbmV3IEFycmF5TGlzdCgpO1xuICAgICAgdmFyIGJvdW5kYWJsZXNBZGRlZFRvU2xpY2UgPSAwO1xuICAgICAgd2hpbGUgKGkuaGFzTmV4dCgpICYmIGJvdW5kYWJsZXNBZGRlZFRvU2xpY2UgPCBzbGljZUNhcGFjaXR5KSB7XG4gICAgICAgIHZhciBjaGlsZEJvdW5kYWJsZSA9IGkubmV4dCgpO1xuICAgICAgICBzbGljZXNbal0uYWRkKGNoaWxkQm91bmRhYmxlKTtcbiAgICAgICAgYm91bmRhYmxlc0FkZGVkVG9TbGljZSsrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2xpY2VzXG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgc2VhcmNoRW52ID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBzZWFyY2hFbnYpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgc2VhcmNoRW52JDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdmlzaXRvciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBzZWFyY2hFbnYkMSwgdmlzaXRvcik7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1syXSwgSXRlbVZpc2l0b3IpICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBPYmplY3QgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSkge1xuICAgICAgICB2YXIgc2VhcmNoQm91bmRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgbm9kZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHZpc2l0b3IkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsIHNlYXJjaEJvdW5kcywgbm9kZSwgdmlzaXRvciQxKTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1syXSwgTGlzdCkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdCAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpKSB7XG4gICAgICAgIHZhciBzZWFyY2hCb3VuZHMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIG5vZGUkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLCBzZWFyY2hCb3VuZHMkMSwgbm9kZSQxLCBtYXRjaGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmdldENvbXBhcmF0b3IgPSBmdW5jdGlvbiBnZXRDb21wYXJhdG9yICgpIHtcbiAgICByZXR1cm4gU1RSdHJlZS55Q29tcGFyYXRvclxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UgPSBmdW5jdGlvbiBjcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UgKGNoaWxkQm91bmRhYmxlcywgbmV3TGV2ZWwpIHtcbiAgICByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzLmNhbGwodGhpcywgY2hpbGRCb3VuZGFibGVzLCBuZXdMZXZlbClcbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGl0ZW1FbnYgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIGl0ZW1FbnYsIGl0ZW0pXG4gICAgfSBlbHNlIHsgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5kZXB0aCA9IGZ1bmN0aW9uIGRlcHRoICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUuZGVwdGguY2FsbCh0aGlzKVxuICAgIH0gZWxzZSB7IHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLmRlcHRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzID0gZnVuY3Rpb24gY3JlYXRlUGFyZW50Qm91bmRhYmxlcyAoY2hpbGRCb3VuZGFibGVzLCBuZXdMZXZlbCkge1xuICAgIEFzc2VydC5pc1RydWUoIWNoaWxkQm91bmRhYmxlcy5pc0VtcHR5KCkpO1xuICAgIHZhciBtaW5MZWFmQ291bnQgPSBNYXRoLnRydW5jKE1hdGguY2VpbChjaGlsZEJvdW5kYWJsZXMuc2l6ZSgpIC8gdGhpcy5nZXROb2RlQ2FwYWNpdHkoKSkpO1xuICAgIHZhciBzb3J0ZWRDaGlsZEJvdW5kYWJsZXMgPSBuZXcgQXJyYXlMaXN0KGNoaWxkQm91bmRhYmxlcyk7XG4gICAgQ29sbGVjdGlvbnMuc29ydChzb3J0ZWRDaGlsZEJvdW5kYWJsZXMsIFNUUnRyZWUueENvbXBhcmF0b3IpO1xuICAgIHZhciB2ZXJ0aWNhbFNsaWNlcyA9IHRoaXMudmVydGljYWxTbGljZXMoc29ydGVkQ2hpbGRCb3VuZGFibGVzLCBNYXRoLnRydW5jKE1hdGguY2VpbChNYXRoLnNxcnQobWluTGVhZkNvdW50KSkpKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzKHZlcnRpY2FsU2xpY2VzLCBuZXdMZXZlbClcbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUubmVhcmVzdE5laWdoYm91ciA9IGZ1bmN0aW9uIG5lYXJlc3ROZWlnaGJvdXIgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgSXRlbURpc3RhbmNlKSkge1xuICAgICAgICB2YXIgaXRlbURpc3QgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBicCA9IG5ldyBCb3VuZGFibGVQYWlyKHRoaXMuZ2V0Um9vdCgpLCB0aGlzLmdldFJvb3QoKSwgaXRlbURpc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGJwKVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBCb3VuZGFibGVQYWlyKSB7XG4gICAgICAgIHZhciBpbml0Qm5kUGFpciA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihpbml0Qm5kUGFpciwgRG91YmxlLlBPU0lUSVZFX0lORklOSVRZKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFNUUnRyZWUgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgSXRlbURpc3RhbmNlKSkge1xuICAgICAgICB2YXIgdHJlZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGl0ZW1EaXN0JDEgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBicCQxID0gbmV3IEJvdW5kYWJsZVBhaXIodGhpcy5nZXRSb290KCksIHRyZWUuZ2V0Um9vdCgpLCBpdGVtRGlzdCQxKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihicCQxKVxuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBCb3VuZGFibGVQYWlyICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBpbml0Qm5kUGFpciQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgbWF4RGlzdGFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHZhciBkaXN0YW5jZUxvd2VyQm91bmQgPSBtYXhEaXN0YW5jZTtcbiAgICAgICAgdmFyIG1pblBhaXIgPSBudWxsO1xuICAgICAgICB2YXIgcHJpUSA9IG5ldyBQcmlvcml0eVF1ZXVlKCk7XG4gICAgICAgIHByaVEuYWRkKGluaXRCbmRQYWlyJDEpO1xuICAgICAgICB3aGlsZSAoIXByaVEuaXNFbXB0eSgpICYmIGRpc3RhbmNlTG93ZXJCb3VuZCA+IDAuMCkge1xuICAgICAgICAgIHZhciBibmRQYWlyID0gcHJpUS5wb2xsKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IGJuZFBhaXIuZ2V0RGlzdGFuY2UoKTtcbiAgICAgICAgICBpZiAoY3VycmVudERpc3RhbmNlID49IGRpc3RhbmNlTG93ZXJCb3VuZCkgeyBicmVhayB9XG4gICAgICAgICAgaWYgKGJuZFBhaXIuaXNMZWF2ZXMoKSkge1xuICAgICAgICAgICAgZGlzdGFuY2VMb3dlckJvdW5kID0gY3VycmVudERpc3RhbmNlO1xuICAgICAgICAgICAgbWluUGFpciA9IGJuZFBhaXI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJuZFBhaXIuZXhwYW5kVG9RdWV1ZShwcmlRLCBkaXN0YW5jZUxvd2VyQm91bmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21pblBhaXIuZ2V0Qm91bmRhYmxlKDApLmdldEl0ZW0oKSwgbWluUGFpci5nZXRCb3VuZGFibGUoMSkuZ2V0SXRlbSgpXVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgdmFyIGVudiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGl0ZW1EaXN0JDIgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgYm5kID0gbmV3IEl0ZW1Cb3VuZGFibGUoZW52LCBpdGVtKTtcbiAgICAgIHZhciBicCQyID0gbmV3IEJvdW5kYWJsZVBhaXIodGhpcy5nZXRSb290KCksIGJuZCwgaXRlbURpc3QkMik7XG4gICAgICByZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGJwJDIpWzBdXG4gICAgfVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW1NwYXRpYWxJbmRleCwgU2VyaWFsaXphYmxlXVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gU1RSdHJlZVxuICB9O1xuICBTVFJ0cmVlLmNlbnRyZVggPSBmdW5jdGlvbiBjZW50cmVYIChlKSB7XG4gICAgcmV0dXJuIFNUUnRyZWUuYXZnKGUuZ2V0TWluWCgpLCBlLmdldE1heFgoKSlcbiAgfTtcbiAgU1RSdHJlZS5hdmcgPSBmdW5jdGlvbiBhdmcgKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgKyBiKSAvIDJcbiAgfTtcbiAgU1RSdHJlZS5jZW50cmVZID0gZnVuY3Rpb24gY2VudHJlWSAoZSkge1xuICAgIHJldHVybiBTVFJ0cmVlLmF2ZyhlLmdldE1pblkoKSwgZS5nZXRNYXhZKCkpXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5TVFJ0cmVlTm9kZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBTVFJ0cmVlTm9kZSB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyNTkyNzQ3MDIzNjg5NTY5MDAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnhDb21wYXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZXJmYWNlc186IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtDb21wYXJhdG9yXVxuICAgICAgfSxcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChvMSwgbzIpIHtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5jb21wYXJlRG91YmxlcyhTVFJ0cmVlLmNlbnRyZVgobzEuZ2V0Qm91bmRzKCkpLCBTVFJ0cmVlLmNlbnRyZVgobzIuZ2V0Qm91bmRzKCkpKVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnlDb21wYXJhdG9yLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZXJmYWNlc186IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtDb21wYXJhdG9yXVxuICAgICAgfSxcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChvMSwgbzIpIHtcbiAgICAgICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5jb21wYXJlRG91YmxlcyhTVFJ0cmVlLmNlbnRyZVkobzEuZ2V0Qm91bmRzKCkpLCBTVFJ0cmVlLmNlbnRyZVkobzIuZ2V0Qm91bmRzKCkpKVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLmludGVyc2VjdHNPcC5nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGludGVyZmFjZXNfOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbQWJzdHJhY3RTVFJ0cmVlJCQxLkludGVyc2VjdHNPcF1cbiAgICAgIH0sXG4gICAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbiAoYUJvdW5kcywgYkJvdW5kcykge1xuICAgICAgICByZXR1cm4gYUJvdW5kcy5pbnRlcnNlY3RzKGJCb3VuZHMpXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuREVGQVVMVF9OT0RFX0NBUEFDSVRZLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEwIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFNUUnRyZWUsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBTVFJ0cmVlO1xufShBYnN0cmFjdFNUUnRyZWUpKTtcblxudmFyIFNUUnRyZWVOb2RlID0gKGZ1bmN0aW9uIChBYnN0cmFjdE5vZGUkJDEpIHtcbiAgZnVuY3Rpb24gU1RSdHJlZU5vZGUgKCkge1xuICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50c1swXTtcbiAgICBBYnN0cmFjdE5vZGUkJDEuY2FsbCh0aGlzLCBsZXZlbCk7XG4gIH1cblxuICBpZiAoIEFic3RyYWN0Tm9kZSQkMSApIFNUUnRyZWVOb2RlLl9fcHJvdG9fXyA9IEFic3RyYWN0Tm9kZSQkMTtcbiAgU1RSdHJlZU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQWJzdHJhY3ROb2RlJCQxICYmIEFic3RyYWN0Tm9kZSQkMS5wcm90b3R5cGUgKTtcbiAgU1RSdHJlZU5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU1RSdHJlZU5vZGU7XG4gIFNUUnRyZWVOb2RlLnByb3RvdHlwZS5jb21wdXRlQm91bmRzID0gZnVuY3Rpb24gY29tcHV0ZUJvdW5kcyAoKSB7XG4gICAgdmFyIGJvdW5kcyA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICAgIGlmIChib3VuZHMgPT09IG51bGwpIHtcbiAgICAgICAgYm91bmRzID0gbmV3IEVudmVsb3BlKGNoaWxkQm91bmRhYmxlLmdldEJvdW5kcygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJvdW5kcy5leHBhbmRUb0luY2x1ZGUoY2hpbGRCb3VuZGFibGUuZ2V0Qm91bmRzKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYm91bmRzXG4gIH07XG4gIFNUUnRyZWVOb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgU1RSdHJlZU5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBTVFJ0cmVlTm9kZVxuICB9O1xuXG4gIHJldHVybiBTVFJ0cmVlTm9kZTtcbn0oQWJzdHJhY3ROb2RlKSk7XG5cbnZhciBTZWdtZW50UG9pbnRDb21wYXJhdG9yID0gZnVuY3Rpb24gU2VnbWVudFBvaW50Q29tcGFyYXRvciAoKSB7fTtcblxuU2VnbWVudFBvaW50Q29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNlZ21lbnRQb2ludENvbXBhcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvclxufTtcblNlZ21lbnRQb2ludENvbXBhcmF0b3IucmVsYXRpdmVTaWduID0gZnVuY3Rpb24gcmVsYXRpdmVTaWduICh4MCwgeDEpIHtcbiAgaWYgKHgwIDwgeDEpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHgwID4geDEpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcblNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKG9jdGFudCwgcDAsIHAxKSB7XG4gIGlmIChwMC5lcXVhbHMyRChwMSkpIHsgcmV0dXJuIDAgfVxuICB2YXIgeFNpZ24gPSBTZWdtZW50UG9pbnRDb21wYXJhdG9yLnJlbGF0aXZlU2lnbihwMC54LCBwMS54KTtcbiAgdmFyIHlTaWduID0gU2VnbWVudFBvaW50Q29tcGFyYXRvci5yZWxhdGl2ZVNpZ24ocDAueSwgcDEueSk7XG4gIHN3aXRjaCAob2N0YW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKHhTaWduLCB5U2lnbilcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUoeVNpZ24sIHhTaWduKVxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSh5U2lnbiwgLXhTaWduKVxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSgteFNpZ24sIHlTaWduKVxuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSgteFNpZ24sIC15U2lnbilcbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUoLXlTaWduLCAteFNpZ24pXG4gICAgY2FzZSA2OlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKC15U2lnbiwgeFNpZ24pXG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKHhTaWduLCAteVNpZ24pXG4gICAgZGVmYXVsdDpcbiAgfVxuICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoJ2ludmFsaWQgb2N0YW50IHZhbHVlJyk7XG4gIHJldHVybiAwXG59O1xuU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUgPSBmdW5jdGlvbiBjb21wYXJlVmFsdWUgKGNvbXBhcmVTaWduMCwgY29tcGFyZVNpZ24xKSB7XG4gIGlmIChjb21wYXJlU2lnbjAgPCAwKSB7IHJldHVybiAtMSB9XG4gIGlmIChjb21wYXJlU2lnbjAgPiAwKSB7IHJldHVybiAxIH1cbiAgaWYgKGNvbXBhcmVTaWduMSA8IDApIHsgcmV0dXJuIC0xIH1cbiAgaWYgKGNvbXBhcmVTaWduMSA+IDApIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcblxudmFyIFNlZ21lbnROb2RlID0gZnVuY3Rpb24gU2VnbWVudE5vZGUgKCkge1xuICB0aGlzLl9zZWdTdHJpbmcgPSBudWxsO1xuICB0aGlzLmNvb3JkID0gbnVsbDtcbiAgdGhpcy5zZWdtZW50SW5kZXggPSBudWxsO1xuICB0aGlzLl9zZWdtZW50T2N0YW50ID0gbnVsbDtcbiAgdGhpcy5faXNJbnRlcmlvciA9IG51bGw7XG4gIHZhciBzZWdTdHJpbmcgPSBhcmd1bWVudHNbMF07XG4gIHZhciBjb29yZCA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIHNlZ21lbnRJbmRleCA9IGFyZ3VtZW50c1syXTtcbiAgdmFyIHNlZ21lbnRPY3RhbnQgPSBhcmd1bWVudHNbM107XG4gIHRoaXMuX3NlZ1N0cmluZyA9IHNlZ1N0cmluZztcbiAgdGhpcy5jb29yZCA9IG5ldyBDb29yZGluYXRlKGNvb3JkKTtcbiAgdGhpcy5zZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXg7XG4gIHRoaXMuX3NlZ21lbnRPY3RhbnQgPSBzZWdtZW50T2N0YW50O1xuICB0aGlzLl9pc0ludGVyaW9yID0gIWNvb3JkLmVxdWFsczJEKHNlZ1N0cmluZy5nZXRDb29yZGluYXRlKHNlZ21lbnRJbmRleCkpO1xufTtcblNlZ21lbnROb2RlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiB0aGlzLmNvb3JkXG59O1xuU2VnbWVudE5vZGUucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICBvdXQucHJpbnQodGhpcy5jb29yZCk7XG4gIG91dC5wcmludCgnIHNlZyAjID0gJyArIHRoaXMuc2VnbWVudEluZGV4KTtcbn07XG5TZWdtZW50Tm9kZS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvYmopIHtcbiAgdmFyIG90aGVyID0gb2JqO1xuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPCBvdGhlci5zZWdtZW50SW5kZXgpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuc2VnbWVudEluZGV4ID4gb3RoZXIuc2VnbWVudEluZGV4KSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuY29vcmQuZXF1YWxzMkQob3RoZXIuY29vcmQpKSB7IHJldHVybiAwIH1cbiAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZSh0aGlzLl9zZWdtZW50T2N0YW50LCB0aGlzLmNvb3JkLCBvdGhlci5jb29yZClcbn07XG5TZWdtZW50Tm9kZS5wcm90b3R5cGUuaXNFbmRQb2ludCA9IGZ1bmN0aW9uIGlzRW5kUG9pbnQgKG1heFNlZ21lbnRJbmRleCkge1xuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPT09IDAgJiYgIXRoaXMuX2lzSW50ZXJpb3IpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPT09IG1heFNlZ21lbnRJbmRleCkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcblNlZ21lbnROb2RlLnByb3RvdHlwZS5pc0ludGVyaW9yID0gZnVuY3Rpb24gaXNJbnRlcmlvciAoKSB7XG4gIHJldHVybiB0aGlzLl9pc0ludGVyaW9yXG59O1xuU2VnbWVudE5vZGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGVdXG59O1xuU2VnbWVudE5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudE5vZGVcbn07XG5cbi8vIGltcG9ydCBJdGVyYXRvciBmcm9tICcuLi8uLi8uLi8uLi9qYXZhL3V0aWwvSXRlcmF0b3InXG52YXIgU2VnbWVudE5vZGVMaXN0ID0gZnVuY3Rpb24gU2VnbWVudE5vZGVMaXN0ICgpIHtcbiAgdGhpcy5fbm9kZU1hcCA9IG5ldyBUcmVlTWFwKCk7XG4gIHRoaXMuX2VkZ2UgPSBudWxsO1xuICB2YXIgZWRnZSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fZWRnZSA9IGVkZ2U7XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5nZXRTcGxpdENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0U3BsaXRDb29yZGluYXRlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvb3JkTGlzdCA9IG5ldyBDb29yZGluYXRlTGlzdCgpO1xuICB0aGlzLmFkZEVuZHBvaW50cygpO1xuICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gIHZhciBlaVByZXYgPSBpdC5uZXh0KCk7XG4gIHdoaWxlIChpdC5oYXNOZXh0KCkpIHtcbiAgICB2YXIgZWkgPSBpdC5uZXh0KCk7XG4gICAgdGhpcyQxLmFkZEVkZ2VDb29yZGluYXRlcyhlaVByZXYsIGVpLCBjb29yZExpc3QpO1xuICAgIGVpUHJldiA9IGVpO1xuICB9XG4gIHJldHVybiBjb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuYWRkQ29sbGFwc2VkTm9kZXMgPSBmdW5jdGlvbiBhZGRDb2xsYXBzZWROb2RlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvbGxhcHNlZFZlcnRleEluZGV4ZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKGNvbGxhcHNlZFZlcnRleEluZGV4ZXMpO1xuICB0aGlzLmZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyhjb2xsYXBzZWRWZXJ0ZXhJbmRleGVzKTtcbiAgZm9yICh2YXIgaXQgPSBjb2xsYXBzZWRWZXJ0ZXhJbmRleGVzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgdmVydGV4SW5kZXggPSBpdC5uZXh0KCkuaW50VmFsdWUoKTtcbiAgICB0aGlzJDEuYWRkKHRoaXMkMS5fZWRnZS5nZXRDb29yZGluYXRlKHZlcnRleEluZGV4KSwgdmVydGV4SW5kZXgpO1xuICB9XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgb3V0LnByaW50bG4oJ0ludGVyc2VjdGlvbnM6Jyk7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIGVpLnByaW50KG91dCk7XG4gIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyA9IGZ1bmN0aW9uIGZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlcyAoY29sbGFwc2VkVmVydGV4SW5kZXhlcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZWRnZS5zaXplKCkgLSAyOyBpKyspIHtcbiAgICB2YXIgcDAgPSB0aGlzJDEuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShpKTtcbiAgICAvLyBjb25zdCBwMSA9IHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShpICsgMSlcbiAgICB2YXIgcDIgPSB0aGlzJDEuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShpICsgMik7XG4gICAgaWYgKHAwLmVxdWFsczJEKHAyKSkge1xuICAgICAgY29sbGFwc2VkVmVydGV4SW5kZXhlcy5hZGQobmV3IEludGVnZXIoaSArIDEpKTtcbiAgICB9XG4gIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmFkZEVkZ2VDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGFkZEVkZ2VDb29yZGluYXRlcyAoZWkwLCBlaTEsIGNvb3JkTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIC8vIGxldCBucHRzID0gZWkxLnNlZ21lbnRJbmRleCAtIGVpMC5zZWdtZW50SW5kZXggKyAyXG4gIHZhciBsYXN0U2VnU3RhcnRQdCA9IHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShlaTEuc2VnbWVudEluZGV4KTtcbiAgdmFyIHVzZUludFB0MSA9IGVpMS5pc0ludGVyaW9yKCkgfHwgIWVpMS5jb29yZC5lcXVhbHMyRChsYXN0U2VnU3RhcnRQdCk7XG4gIC8vIGlmICghdXNlSW50UHQxKSB7XG4gIC8vIG5wdHMtLVxuICAvLyB9XG4gIC8vIGNvbnN0IGlwdCA9IDBcbiAgY29vcmRMaXN0LmFkZChuZXcgQ29vcmRpbmF0ZShlaTAuY29vcmQpLCBmYWxzZSk7XG4gIGZvciAodmFyIGkgPSBlaTAuc2VnbWVudEluZGV4ICsgMTsgaSA8PSBlaTEuc2VnbWVudEluZGV4OyBpKyspIHtcbiAgICBjb29yZExpc3QuYWRkKHRoaXMkMS5fZWRnZS5nZXRDb29yZGluYXRlKGkpKTtcbiAgfVxuICBpZiAodXNlSW50UHQxKSB7XG4gICAgY29vcmRMaXN0LmFkZChuZXcgQ29vcmRpbmF0ZShlaTEuY29vcmQpKTtcbiAgfVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKClcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmFkZFNwbGl0RWRnZXMgPSBmdW5jdGlvbiBhZGRTcGxpdEVkZ2VzIChlZGdlTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuYWRkRW5kcG9pbnRzKCk7XG4gIHRoaXMuYWRkQ29sbGFwc2VkTm9kZXMoKTtcbiAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpO1xuICB2YXIgZWlQcmV2ID0gaXQubmV4dCgpO1xuICB3aGlsZSAoaXQuaGFzTmV4dCgpKSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIHZhciBuZXdFZGdlID0gdGhpcyQxLmNyZWF0ZVNwbGl0RWRnZShlaVByZXYsIGVpKTtcbiAgICBlZGdlTGlzdC5hZGQobmV3RWRnZSk7XG4gICAgZWlQcmV2ID0gZWk7XG4gIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmZpbmRDb2xsYXBzZUluZGV4ID0gZnVuY3Rpb24gZmluZENvbGxhcHNlSW5kZXggKGVpMCwgZWkxLCBjb2xsYXBzZWRWZXJ0ZXhJbmRleCkge1xuICBpZiAoIWVpMC5jb29yZC5lcXVhbHMyRChlaTEuY29vcmQpKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBudW1WZXJ0aWNlc0JldHdlZW4gPSBlaTEuc2VnbWVudEluZGV4IC0gZWkwLnNlZ21lbnRJbmRleDtcbiAgaWYgKCFlaTEuaXNJbnRlcmlvcigpKSB7XG4gICAgbnVtVmVydGljZXNCZXR3ZWVuLS07XG4gIH1cbiAgaWYgKG51bVZlcnRpY2VzQmV0d2VlbiA9PT0gMSkge1xuICAgIGNvbGxhcHNlZFZlcnRleEluZGV4WzBdID0gZWkwLnNlZ21lbnRJbmRleCArIDE7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2RlcyA9IGZ1bmN0aW9uIGZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2RlcyAoY29sbGFwc2VkVmVydGV4SW5kZXhlcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjb2xsYXBzZWRWZXJ0ZXhJbmRleCA9IG5ldyBBcnJheSgxKS5maWxsKG51bGwpO1xuICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gIHZhciBlaVByZXYgPSBpdC5uZXh0KCk7XG4gIHdoaWxlIChpdC5oYXNOZXh0KCkpIHtcbiAgICB2YXIgZWkgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGlzQ29sbGFwc2VkID0gdGhpcyQxLmZpbmRDb2xsYXBzZUluZGV4KGVpUHJldiwgZWksIGNvbGxhcHNlZFZlcnRleEluZGV4KTtcbiAgICBpZiAoaXNDb2xsYXBzZWQpIHsgY29sbGFwc2VkVmVydGV4SW5kZXhlcy5hZGQobmV3IEludGVnZXIoY29sbGFwc2VkVmVydGV4SW5kZXhbMF0pKTsgfVxuICAgIGVpUHJldiA9IGVpO1xuICB9XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5nZXRFZGdlID0gZnVuY3Rpb24gZ2V0RWRnZSAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlXG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5hZGRFbmRwb2ludHMgPSBmdW5jdGlvbiBhZGRFbmRwb2ludHMgKCkge1xuICB2YXIgbWF4U2VnSW5kZXggPSB0aGlzLl9lZGdlLnNpemUoKSAtIDE7XG4gIHRoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZSgwKSwgMCk7XG4gIHRoaXMuYWRkKHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShtYXhTZWdJbmRleCksIG1heFNlZ0luZGV4KTtcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmNyZWF0ZVNwbGl0RWRnZSA9IGZ1bmN0aW9uIGNyZWF0ZVNwbGl0RWRnZSAoZWkwLCBlaTEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbnB0cyA9IGVpMS5zZWdtZW50SW5kZXggLSBlaTAuc2VnbWVudEluZGV4ICsgMjtcbiAgdmFyIGxhc3RTZWdTdGFydFB0ID0gdGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGVpMS5zZWdtZW50SW5kZXgpO1xuICB2YXIgdXNlSW50UHQxID0gZWkxLmlzSW50ZXJpb3IoKSB8fCAhZWkxLmNvb3JkLmVxdWFsczJEKGxhc3RTZWdTdGFydFB0KTtcbiAgaWYgKCF1c2VJbnRQdDEpIHtcbiAgICBucHRzLS07XG4gIH1cbiAgdmFyIHB0cyA9IG5ldyBBcnJheShucHRzKS5maWxsKG51bGwpO1xuICB2YXIgaXB0ID0gMDtcbiAgcHRzW2lwdCsrXSA9IG5ldyBDb29yZGluYXRlKGVpMC5jb29yZCk7XG4gIGZvciAodmFyIGkgPSBlaTAuc2VnbWVudEluZGV4ICsgMTsgaSA8PSBlaTEuc2VnbWVudEluZGV4OyBpKyspIHtcbiAgICBwdHNbaXB0KytdID0gdGhpcyQxLl9lZGdlLmdldENvb3JkaW5hdGUoaSk7XG4gIH1cbiAgaWYgKHVzZUludFB0MSkgeyBwdHNbaXB0XSA9IG5ldyBDb29yZGluYXRlKGVpMS5jb29yZCk7IH1cbiAgcmV0dXJuIG5ldyBOb2RlZFNlZ21lbnRTdHJpbmcocHRzLCB0aGlzLl9lZGdlLmdldERhdGEoKSlcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoaW50UHQsIHNlZ21lbnRJbmRleCkge1xuICB2YXIgZWlOZXcgPSBuZXcgU2VnbWVudE5vZGUodGhpcy5fZWRnZSwgaW50UHQsIHNlZ21lbnRJbmRleCwgdGhpcy5fZWRnZS5nZXRTZWdtZW50T2N0YW50KHNlZ21lbnRJbmRleCkpO1xuICB2YXIgZWkgPSB0aGlzLl9ub2RlTWFwLmdldChlaU5ldyk7XG4gIGlmIChlaSAhPT0gbnVsbCkge1xuICAgIEFzc2VydC5pc1RydWUoZWkuY29vcmQuZXF1YWxzMkQoaW50UHQpLCAnRm91bmQgZXF1YWwgbm9kZXMgd2l0aCBkaWZmZXJlbnQgY29vcmRpbmF0ZXMnKTtcbiAgICByZXR1cm4gZWlcbiAgfVxuICB0aGlzLl9ub2RlTWFwLnB1dChlaU5ldywgZWlOZXcpO1xuICByZXR1cm4gZWlOZXdcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmNoZWNrU3BsaXRFZGdlc0NvcnJlY3RuZXNzID0gZnVuY3Rpb24gY2hlY2tTcGxpdEVkZ2VzQ29ycmVjdG5lc3MgKHNwbGl0RWRnZXMpIHtcbiAgdmFyIGVkZ2VQdHMgPSB0aGlzLl9lZGdlLmdldENvb3JkaW5hdGVzKCk7XG4gIHZhciBzcGxpdDAgPSBzcGxpdEVkZ2VzLmdldCgwKTtcbiAgdmFyIHB0MCA9IHNwbGl0MC5nZXRDb29yZGluYXRlKDApO1xuICBpZiAoIXB0MC5lcXVhbHMyRChlZGdlUHRzWzBdKSkgeyB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignYmFkIHNwbGl0IGVkZ2Ugc3RhcnQgcG9pbnQgYXQgJyArIHB0MCkgfVxuICB2YXIgc3BsaXRuID0gc3BsaXRFZGdlcy5nZXQoc3BsaXRFZGdlcy5zaXplKCkgLSAxKTtcbiAgdmFyIHNwbGl0blB0cyA9IHNwbGl0bi5nZXRDb29yZGluYXRlcygpO1xuICB2YXIgcHRuID0gc3BsaXRuUHRzW3NwbGl0blB0cy5sZW5ndGggLSAxXTtcbiAgaWYgKCFwdG4uZXF1YWxzMkQoZWRnZVB0c1tlZGdlUHRzLmxlbmd0aCAtIDFdKSkgeyB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignYmFkIHNwbGl0IGVkZ2UgZW5kIHBvaW50IGF0ICcgKyBwdG4pIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudE5vZGVMaXN0XG59O1xuXG5cblxuLy8gY2xhc3MgTm9kZVZlcnRleEl0ZXJhdG9yIHtcbi8vICAgY29uc3RydWN0b3IgKCkge1xuLy8gICAgIHRoaXMuX25vZGVMaXN0ID0gbnVsbFxuLy8gICAgIHRoaXMuX2VkZ2UgPSBudWxsXG4vLyAgICAgdGhpcy5fbm9kZUl0ID0gbnVsbFxuLy8gICAgIHRoaXMuX2N1cnJOb2RlID0gbnVsbFxuLy8gICAgIHRoaXMuX25leHROb2RlID0gbnVsbFxuLy8gICAgIHRoaXMuX2N1cnJTZWdJbmRleCA9IDBcbi8vICAgICBsZXQgbm9kZUxpc3QgPSBhcmd1bWVudHNbMF1cbi8vICAgICB0aGlzLl9ub2RlTGlzdCA9IG5vZGVMaXN0XG4vLyAgICAgdGhpcy5fZWRnZSA9IG5vZGVMaXN0LmdldEVkZ2UoKVxuLy8gICAgIHRoaXMuX25vZGVJdCA9IG5vZGVMaXN0Lml0ZXJhdG9yKClcbi8vICAgICB0aGlzLnJlYWROZXh0Tm9kZSgpXG4vLyAgIH1cbi8vICAgbmV4dCAoKSB7XG4vLyAgICAgaWYgKHRoaXMuX2N1cnJOb2RlID09PSBudWxsKSB7XG4vLyAgICAgICB0aGlzLl9jdXJyTm9kZSA9IHRoaXMuX25leHROb2RlXG4vLyAgICAgICB0aGlzLl9jdXJyU2VnSW5kZXggPSB0aGlzLl9jdXJyTm9kZS5zZWdtZW50SW5kZXhcbi8vICAgICAgIHRoaXMucmVhZE5leHROb2RlKClcbi8vICAgICAgIHJldHVybiB0aGlzLl9jdXJyTm9kZVxuLy8gICAgIH1cbi8vICAgICBpZiAodGhpcy5fbmV4dE5vZGUgPT09IG51bGwpIHJldHVybiBudWxsXG4vLyAgICAgaWYgKHRoaXMuX25leHROb2RlLnNlZ21lbnRJbmRleCA9PT0gdGhpcy5fY3Vyck5vZGUuc2VnbWVudEluZGV4KSB7XG4vLyAgICAgICB0aGlzLl9jdXJyTm9kZSA9IHRoaXMuX25leHROb2RlXG4vLyAgICAgICB0aGlzLl9jdXJyU2VnSW5kZXggPSB0aGlzLl9jdXJyTm9kZS5zZWdtZW50SW5kZXhcbi8vICAgICAgIHRoaXMucmVhZE5leHROb2RlKClcbi8vICAgICAgIHJldHVybiB0aGlzLl9jdXJyTm9kZVxuLy8gICAgIH1cbi8vICAgICBpZiAodGhpcy5fbmV4dE5vZGUuc2VnbWVudEluZGV4ID4gdGhpcy5fY3Vyck5vZGUuc2VnbWVudEluZGV4KSB7fVxuLy8gICAgIHJldHVybiBudWxsXG4vLyAgIH1cbi8vICAgcmVtb3ZlICgpIHtcbi8vICAgICAvLyB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24odGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSlcbi8vICAgfVxuLy8gICBoYXNOZXh0ICgpIHtcbi8vICAgICBpZiAodGhpcy5fbmV4dE5vZGUgPT09IG51bGwpIHJldHVybiBmYWxzZVxuLy8gICAgIHJldHVybiB0cnVlXG4vLyAgIH1cbi8vICAgcmVhZE5leHROb2RlICgpIHtcbi8vICAgICBpZiAodGhpcy5fbm9kZUl0Lmhhc05leHQoKSkgdGhpcy5fbmV4dE5vZGUgPSB0aGlzLl9ub2RlSXQubmV4dCgpOyBlbHNlIHRoaXMuX25leHROb2RlID0gbnVsbFxuLy8gICB9XG4vLyAgIGludGVyZmFjZXNfICgpIHtcbi8vICAgICByZXR1cm4gW0l0ZXJhdG9yXVxuLy8gICB9XG4vLyAgIGdldENsYXNzICgpIHtcbi8vICAgICByZXR1cm4gTm9kZVZlcnRleEl0ZXJhdG9yXG4vLyAgIH1cbi8vIH1cblxudmFyIE9jdGFudCA9IGZ1bmN0aW9uIE9jdGFudCAoKSB7fTtcblxuT2N0YW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuT2N0YW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE9jdGFudFxufTtcbk9jdGFudC5vY3RhbnQgPSBmdW5jdGlvbiBvY3RhbnQgKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgZHggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGR5ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChkeCA9PT0gMC4wICYmIGR5ID09PSAwLjApIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgcG9pbnQgKCAnICsgZHggKyAnLCAnICsgZHkgKyAnICknKSB9XG4gICAgdmFyIGFkeCA9IE1hdGguYWJzKGR4KTtcbiAgICB2YXIgYWR5ID0gTWF0aC5hYnMoZHkpO1xuICAgIGlmIChkeCA+PSAwKSB7XG4gICAgICBpZiAoZHkgPj0gMCkge1xuICAgICAgICBpZiAoYWR4ID49IGFkeSkgeyByZXR1cm4gMDsgfSBlbHNlIHsgcmV0dXJuIDEgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFkeCA+PSBhZHkpIHsgcmV0dXJuIDc7IH0gZWxzZSB7IHJldHVybiA2IH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGR5ID49IDApIHtcbiAgICAgICAgaWYgKGFkeCA+PSBhZHkpIHsgcmV0dXJuIDM7IH0gZWxzZSB7IHJldHVybiAyIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhZHggPj0gYWR5KSB7IHJldHVybiA0OyB9IGVsc2UgeyByZXR1cm4gNSB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGR4JDEgPSBwMS54IC0gcDAueDtcbiAgICB2YXIgZHkkMSA9IHAxLnkgLSBwMC55O1xuICAgIGlmIChkeCQxID09PSAwLjAgJiYgZHkkMSA9PT0gMC4wKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0Nhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzICcgKyBwMCkgfVxuICAgIHJldHVybiBPY3RhbnQub2N0YW50KGR4JDEsIGR5JDEpXG4gIH1cbn07XG5cbnZhciBTZWdtZW50U3RyaW5nID0gZnVuY3Rpb24gU2VnbWVudFN0cmluZyAoKSB7fTtcblxuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7fTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHt9O1xuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHt9O1xuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAoKSB7fTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiBzZXREYXRhIChkYXRhKSB7fTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhICgpIHt9O1xuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU2VnbWVudFN0cmluZ1xufTtcblxudmFyIE5vZGFibGVTZWdtZW50U3RyaW5nID0gZnVuY3Rpb24gTm9kYWJsZVNlZ21lbnRTdHJpbmcgKCkge307XG5cbk5vZGFibGVTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5hZGRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBhZGRJbnRlcnNlY3Rpb24gKGludFB0LCBzZWdtZW50SW5kZXgpIHt9O1xuTm9kYWJsZVNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlZ21lbnRTdHJpbmddXG59O1xuTm9kYWJsZVNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9kYWJsZVNlZ21lbnRTdHJpbmdcbn07XG5cbnZhciBOb2RlZFNlZ21lbnRTdHJpbmcgPSBmdW5jdGlvbiBOb2RlZFNlZ21lbnRTdHJpbmcgKCkge1xuICB0aGlzLl9ub2RlTGlzdCA9IG5ldyBTZWdtZW50Tm9kZUxpc3QodGhpcyk7XG4gIHRoaXMuX3B0cyA9IG51bGw7XG4gIHRoaXMuX2RhdGEgPSBudWxsO1xuICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fcHRzID0gcHRzO1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICByZXR1cm4gdGhpcy5fcHRzXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9wdHMubGVuZ3RoXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge1xuICByZXR1cm4gdGhpcy5fcHRzW2ldXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0c1swXS5lcXVhbHModGhpcy5fcHRzW3RoaXMuX3B0cy5sZW5ndGggLSAxXSlcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldFNlZ21lbnRPY3RhbnQgPSBmdW5jdGlvbiBnZXRTZWdtZW50T2N0YW50IChpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHRoaXMuX3B0cy5sZW5ndGggLSAxKSB7IHJldHVybiAtMSB9XG4gIHJldHVybiB0aGlzLnNhZmVPY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKGluZGV4KSwgdGhpcy5nZXRDb29yZGluYXRlKGluZGV4ICsgMSkpXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YSAoZGF0YSkge1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNhZmVPY3RhbnQgPSBmdW5jdGlvbiBzYWZlT2N0YW50IChwMCwgcDEpIHtcbiAgaWYgKHAwLmVxdWFsczJEKHAxKSkgeyByZXR1cm4gMCB9XG4gIHJldHVybiBPY3RhbnQub2N0YW50KHAwLCBwMSlcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RhdGFcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmFkZEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGludFB0JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNlZ21lbnRJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmFkZEludGVyc2VjdGlvbk5vZGUoaW50UHQkMSwgc2VnbWVudEluZGV4KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIGxpID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzZWdtZW50SW5kZXgkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAvLyBjb25zdCBnZW9tSW5kZXggPSBhcmd1bWVudHNbMl1cbiAgICB2YXIgaW50SW5kZXggPSBhcmd1bWVudHNbM107XG4gICAgdmFyIGludFB0ID0gbmV3IENvb3JkaW5hdGUobGkuZ2V0SW50ZXJzZWN0aW9uKGludEluZGV4KSk7XG4gICAgdGhpcy5hZGRJbnRlcnNlY3Rpb24oaW50UHQsIHNlZ21lbnRJbmRleCQxKTtcbiAgfVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZSh0aGlzLl9wdHMpKVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Tm9kZUxpc3QgPSBmdW5jdGlvbiBnZXROb2RlTGlzdCAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlTGlzdFxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9uTm9kZSA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbk5vZGUgKGludFB0LCBzZWdtZW50SW5kZXgpIHtcbiAgdmFyIG5vcm1hbGl6ZWRTZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXg7XG4gIHZhciBuZXh0U2VnSW5kZXggPSBub3JtYWxpemVkU2VnbWVudEluZGV4ICsgMTtcbiAgaWYgKG5leHRTZWdJbmRleCA8IHRoaXMuX3B0cy5sZW5ndGgpIHtcbiAgICB2YXIgbmV4dFB0ID0gdGhpcy5fcHRzW25leHRTZWdJbmRleF07XG4gICAgaWYgKGludFB0LmVxdWFsczJEKG5leHRQdCkpIHtcbiAgICAgIG5vcm1hbGl6ZWRTZWdtZW50SW5kZXggPSBuZXh0U2VnSW5kZXg7XG4gICAgfVxuICB9XG4gIHZhciBlaSA9IHRoaXMuX25vZGVMaXN0LmFkZChpbnRQdCwgbm9ybWFsaXplZFNlZ21lbnRJbmRleCk7XG4gIHJldHVybiBlaVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbnMgKGxpLCBzZWdtZW50SW5kZXgsIGdlb21JbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7IGkrKykge1xuICAgIHRoaXMkMS5hZGRJbnRlcnNlY3Rpb24obGksIHNlZ21lbnRJbmRleCwgZ2VvbUluZGV4LCBpKTtcbiAgfVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbTm9kYWJsZVNlZ21lbnRTdHJpbmddXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGVkU2VnbWVudFN0cmluZ1xufTtcbk5vZGVkU2VnbWVudFN0cmluZy5nZXROb2RlZFN1YnN0cmluZ3MgPSBmdW5jdGlvbiBnZXROb2RlZFN1YnN0cmluZ3MgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzZWdTdHJpbmdzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciByZXN1bHRFZGdlbGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBOb2RlZFNlZ21lbnRTdHJpbmcuZ2V0Tm9kZWRTdWJzdHJpbmdzKHNlZ1N0cmluZ3MsIHJlc3VsdEVkZ2VsaXN0KTtcbiAgICByZXR1cm4gcmVzdWx0RWRnZWxpc3RcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHNlZ1N0cmluZ3MkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcmVzdWx0RWRnZWxpc3QkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICBmb3IgKHZhciBpID0gc2VnU3RyaW5ncyQxLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzID0gaS5uZXh0KCk7XG4gICAgICBzcy5nZXROb2RlTGlzdCgpLmFkZFNwbGl0RWRnZXMocmVzdWx0RWRnZWxpc3QkMSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgTGluZVNlZ21lbnQgPSBmdW5jdGlvbiBMaW5lU2VnbWVudCAoKSB7XG4gIHRoaXMucDAgPSBudWxsO1xuICB0aGlzLnAxID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnAwID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB0aGlzLnAxID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxzID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMucDAgPSBuZXcgQ29vcmRpbmF0ZShscy5wMCk7XG4gICAgdGhpcy5wMSA9IG5ldyBDb29yZGluYXRlKGxzLnAxKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy5wMCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnAxID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgeDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHkwID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB4MSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgeTEgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5wMCA9IG5ldyBDb29yZGluYXRlKHgwLCB5MCk7XG4gICAgdGhpcy5wMSA9IG5ldyBDb29yZGluYXRlKHgxLCB5MSk7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjQgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5taW5YID0gZnVuY3Rpb24gbWluWCAoKSB7XG4gIHJldHVybiBNYXRoLm1pbih0aGlzLnAwLngsIHRoaXMucDEueClcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUub3JpZW50YXRpb25JbmRleCA9IGZ1bmN0aW9uIG9yaWVudGF0aW9uSW5kZXggKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVNlZ21lbnQpIHtcbiAgICB2YXIgc2VnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvcmllbnQwID0gQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCwgdGhpcy5wMSwgc2VnLnAwKTtcbiAgICB2YXIgb3JpZW50MSA9IENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHRoaXMucDAsIHRoaXMucDEsIHNlZy5wMSk7XG4gICAgaWYgKG9yaWVudDAgPj0gMCAmJiBvcmllbnQxID49IDApIHsgcmV0dXJuIE1hdGgubWF4KG9yaWVudDAsIG9yaWVudDEpIH1cbiAgICBpZiAob3JpZW50MCA8PSAwICYmIG9yaWVudDEgPD0gMCkgeyByZXR1cm4gTWF0aC5tYXgob3JpZW50MCwgb3JpZW50MSkgfVxuICAgIHJldHVybiAwXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleCh0aGlzLnAwLCB0aGlzLnAxLCBwKVxuICB9XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnRvR2VvbWV0cnkgPSBmdW5jdGlvbiB0b0dlb21ldHJ5IChnZW9tRmFjdG9yeSkge1xuICByZXR1cm4gZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5wMCwgdGhpcy5wMV0pXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmlzVmVydGljYWwgPSBmdW5jdGlvbiBpc1ZlcnRpY2FsICgpIHtcbiAgcmV0dXJuIHRoaXMucDAueCA9PT0gdGhpcy5wMS54XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAobykge1xuICBpZiAoIShvIGluc3RhbmNlb2YgTGluZVNlZ21lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIG90aGVyID0gbztcbiAgcmV0dXJuIHRoaXMucDAuZXF1YWxzKG90aGVyLnAwKSAmJiB0aGlzLnAxLmVxdWFscyhvdGhlci5wMSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChsaW5lKSB7XG4gIHZhciBsaSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgbGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLnAwLCB0aGlzLnAxLCBsaW5lLnAwLCBsaW5lLnAxKTtcbiAgaWYgKGxpLmhhc0ludGVyc2VjdGlvbigpKSB7IHJldHVybiBsaS5nZXRJbnRlcnNlY3Rpb24oMCkgfVxuICByZXR1cm4gbnVsbFxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5wcm9qZWN0ID0gZnVuY3Rpb24gcHJvamVjdCAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHAuZXF1YWxzKHRoaXMucDApIHx8IHAuZXF1YWxzKHRoaXMucDEpKSB7IHJldHVybiBuZXcgQ29vcmRpbmF0ZShwKSB9XG4gICAgdmFyIHIgPSB0aGlzLnByb2plY3Rpb25GYWN0b3IocCk7XG4gICAgdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICBjb29yZC54ID0gdGhpcy5wMC54ICsgciAqICh0aGlzLnAxLnggLSB0aGlzLnAwLngpO1xuICAgIGNvb3JkLnkgPSB0aGlzLnAwLnkgKyByICogKHRoaXMucDEueSAtIHRoaXMucDAueSk7XG4gICAgcmV0dXJuIGNvb3JkXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVNlZ21lbnQpIHtcbiAgICB2YXIgc2VnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwZjAgPSB0aGlzLnByb2plY3Rpb25GYWN0b3Ioc2VnLnAwKTtcbiAgICB2YXIgcGYxID0gdGhpcy5wcm9qZWN0aW9uRmFjdG9yKHNlZy5wMSk7XG4gICAgaWYgKHBmMCA+PSAxLjAgJiYgcGYxID49IDEuMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKHBmMCA8PSAwLjAgJiYgcGYxIDw9IDAuMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIG5ld3AwID0gdGhpcy5wcm9qZWN0KHNlZy5wMCk7XG4gICAgaWYgKHBmMCA8IDAuMCkgeyBuZXdwMCA9IHRoaXMucDA7IH1cbiAgICBpZiAocGYwID4gMS4wKSB7IG5ld3AwID0gdGhpcy5wMTsgfVxuICAgIHZhciBuZXdwMSA9IHRoaXMucHJvamVjdChzZWcucDEpO1xuICAgIGlmIChwZjEgPCAwLjApIHsgbmV3cDEgPSB0aGlzLnAwOyB9XG4gICAgaWYgKHBmMSA+IDEuMCkgeyBuZXdwMSA9IHRoaXMucDE7IH1cbiAgICByZXR1cm4gbmV3IExpbmVTZWdtZW50KG5ld3AwLCBuZXdwMSlcbiAgfVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUgKCkge1xuICBpZiAodGhpcy5wMS5jb21wYXJlVG8odGhpcy5wMCkgPCAwKSB7IHRoaXMucmV2ZXJzZSgpOyB9XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmFuZ2xlID0gZnVuY3Rpb24gYW5nbGUgKCkge1xuICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnAxLnkgLSB0aGlzLnAwLnksIHRoaXMucDEueCAtIHRoaXMucDAueClcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHtcbiAgaWYgKGkgPT09IDApIHsgcmV0dXJuIHRoaXMucDAgfVxuICByZXR1cm4gdGhpcy5wMVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIgPSBmdW5jdGlvbiBkaXN0YW5jZVBlcnBlbmRpY3VsYXIgKHApIHtcbiAgcmV0dXJuIENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZVBlcnBlbmRpY3VsYXIocCwgdGhpcy5wMCwgdGhpcy5wMSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUubWluWSA9IGZ1bmN0aW9uIG1pblkgKCkge1xuICByZXR1cm4gTWF0aC5taW4odGhpcy5wMC55LCB0aGlzLnAxLnkpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLm1pZFBvaW50ID0gZnVuY3Rpb24gbWlkUG9pbnQgKCkge1xuICByZXR1cm4gTGluZVNlZ21lbnQubWlkUG9pbnQodGhpcy5wMCwgdGhpcy5wMSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUucHJvamVjdGlvbkZhY3RvciA9IGZ1bmN0aW9uIHByb2plY3Rpb25GYWN0b3IgKHApIHtcbiAgaWYgKHAuZXF1YWxzKHRoaXMucDApKSB7IHJldHVybiAwLjAgfVxuICBpZiAocC5lcXVhbHModGhpcy5wMSkpIHsgcmV0dXJuIDEuMCB9XG4gIHZhciBkeCA9IHRoaXMucDEueCAtIHRoaXMucDAueDtcbiAgdmFyIGR5ID0gdGhpcy5wMS55IC0gdGhpcy5wMC55O1xuICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHk7XG4gIGlmIChsZW4gPD0gMC4wKSB7IHJldHVybiBEb3VibGUuTmFOIH1cbiAgdmFyIHIgPSAoKHAueCAtIHRoaXMucDAueCkgKiBkeCArIChwLnkgLSB0aGlzLnAwLnkpICogZHkpIC8gbGVuO1xuICByZXR1cm4gclxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5jbG9zZXN0UG9pbnRzID0gZnVuY3Rpb24gY2xvc2VzdFBvaW50cyAobGluZSkge1xuICB2YXIgaW50UHQgPSB0aGlzLmludGVyc2VjdGlvbihsaW5lKTtcbiAgaWYgKGludFB0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtpbnRQdCwgaW50UHRdXG4gIH1cbiAgdmFyIGNsb3Nlc3RQdCA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICB2YXIgbWluRGlzdGFuY2UgPSBEb3VibGUuTUFYX1ZBTFVFO1xuICB2YXIgZGlzdCA9IG51bGw7XG4gIHZhciBjbG9zZTAwID0gdGhpcy5jbG9zZXN0UG9pbnQobGluZS5wMCk7XG4gIG1pbkRpc3RhbmNlID0gY2xvc2UwMC5kaXN0YW5jZShsaW5lLnAwKTtcbiAgY2xvc2VzdFB0WzBdID0gY2xvc2UwMDtcbiAgY2xvc2VzdFB0WzFdID0gbGluZS5wMDtcbiAgdmFyIGNsb3NlMDEgPSB0aGlzLmNsb3Nlc3RQb2ludChsaW5lLnAxKTtcbiAgZGlzdCA9IGNsb3NlMDEuZGlzdGFuY2UobGluZS5wMSk7XG4gIGlmIChkaXN0IDwgbWluRGlzdGFuY2UpIHtcbiAgICBtaW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgY2xvc2VzdFB0WzBdID0gY2xvc2UwMTtcbiAgICBjbG9zZXN0UHRbMV0gPSBsaW5lLnAxO1xuICB9XG4gIHZhciBjbG9zZTEwID0gbGluZS5jbG9zZXN0UG9pbnQodGhpcy5wMCk7XG4gIGRpc3QgPSBjbG9zZTEwLmRpc3RhbmNlKHRoaXMucDApO1xuICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgbWluRGlzdGFuY2UgPSBkaXN0O1xuICAgIGNsb3Nlc3RQdFswXSA9IHRoaXMucDA7XG4gICAgY2xvc2VzdFB0WzFdID0gY2xvc2UxMDtcbiAgfVxuICB2YXIgY2xvc2UxMSA9IGxpbmUuY2xvc2VzdFBvaW50KHRoaXMucDEpO1xuICBkaXN0ID0gY2xvc2UxMS5kaXN0YW5jZSh0aGlzLnAxKTtcbiAgaWYgKGRpc3QgPCBtaW5EaXN0YW5jZSkge1xuICAgIG1pbkRpc3RhbmNlID0gZGlzdDtcbiAgICBjbG9zZXN0UHRbMF0gPSB0aGlzLnAxO1xuICAgIGNsb3Nlc3RQdFsxXSA9IGNsb3NlMTE7XG4gIH1cbiAgcmV0dXJuIGNsb3Nlc3RQdFxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5jbG9zZXN0UG9pbnQgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnQgKHApIHtcbiAgdmFyIGZhY3RvciA9IHRoaXMucHJvamVjdGlvbkZhY3RvcihwKTtcbiAgaWYgKGZhY3RvciA+IDAgJiYgZmFjdG9yIDwgMSkge1xuICAgIHJldHVybiB0aGlzLnByb2plY3QocClcbiAgfVxuICB2YXIgZGlzdDAgPSB0aGlzLnAwLmRpc3RhbmNlKHApO1xuICB2YXIgZGlzdDEgPSB0aGlzLnAxLmRpc3RhbmNlKHApO1xuICBpZiAoZGlzdDAgPCBkaXN0MSkgeyByZXR1cm4gdGhpcy5wMCB9XG4gIHJldHVybiB0aGlzLnAxXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLm1heFggPSBmdW5jdGlvbiBtYXhYICgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KHRoaXMucDAueCwgdGhpcy5wMS54KVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuICByZXR1cm4gdGhpcy5wMC5kaXN0YW5jZSh0aGlzLnAxKVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgdmFyIG90aGVyID0gbztcbiAgdmFyIGNvbXAwID0gdGhpcy5wMC5jb21wYXJlVG8ob3RoZXIucDApO1xuICBpZiAoY29tcDAgIT09IDApIHsgcmV0dXJuIGNvbXAwIH1cbiAgcmV0dXJuIHRoaXMucDEuY29tcGFyZVRvKG90aGVyLnAxKVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gIHZhciB0ZW1wID0gdGhpcy5wMDtcbiAgdGhpcy5wMCA9IHRoaXMucDE7XG4gIHRoaXMucDEgPSB0ZW1wO1xufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5lcXVhbHNUb3BvID0gZnVuY3Rpb24gZXF1YWxzVG9wbyAob3RoZXIpIHtcbiAgcmV0dXJuIHRoaXMucDAuZXF1YWxzKG90aGVyLnAwKSAmJlxuICAgICAgICAodGhpcy5wMS5lcXVhbHMob3RoZXIucDEpIHx8IHRoaXMucDAuZXF1YWxzKG90aGVyLnAxKSkgJiZcbiAgICAgICAgIHRoaXMucDEuZXF1YWxzKG90aGVyLnAwKVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5saW5lSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gbGluZUludGVyc2VjdGlvbiAobGluZSkge1xuICB0cnkge1xuICAgIHZhciBpbnRQdCA9IEhDb29yZGluYXRlLmludGVyc2VjdGlvbih0aGlzLnAwLCB0aGlzLnAxLCBsaW5lLnAwLCBsaW5lLnAxKTtcbiAgICByZXR1cm4gaW50UHRcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZXggaW5zdGFuY2VvZiBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uKSB7fSBlbHNlIHsgdGhyb3cgZXggfVxuICB9IGZpbmFsbHkge31cbiAgcmV0dXJuIG51bGxcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUubWF4WSA9IGZ1bmN0aW9uIG1heFkgKCkge1xuICByZXR1cm4gTWF0aC5tYXgodGhpcy5wMC55LCB0aGlzLnAxLnkpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnBvaW50QWxvbmdPZmZzZXQgPSBmdW5jdGlvbiBwb2ludEFsb25nT2Zmc2V0IChzZWdtZW50TGVuZ3RoRnJhY3Rpb24sIG9mZnNldERpc3RhbmNlKSB7XG4gIHZhciBzZWd4ID0gdGhpcy5wMC54ICsgc2VnbWVudExlbmd0aEZyYWN0aW9uICogKHRoaXMucDEueCAtIHRoaXMucDAueCk7XG4gIHZhciBzZWd5ID0gdGhpcy5wMC55ICsgc2VnbWVudExlbmd0aEZyYWN0aW9uICogKHRoaXMucDEueSAtIHRoaXMucDAueSk7XG4gIHZhciBkeCA9IHRoaXMucDEueCAtIHRoaXMucDAueDtcbiAgdmFyIGR5ID0gdGhpcy5wMS55IC0gdGhpcy5wMC55O1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgdmFyIHV4ID0gMC4wO1xuICB2YXIgdXkgPSAwLjA7XG4gIGlmIChvZmZzZXREaXN0YW5jZSAhPT0gMC4wKSB7XG4gICAgaWYgKGxlbiA8PSAwLjApIHsgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBvZmZzZXQgZnJvbSB6ZXJvLWxlbmd0aCBsaW5lIHNlZ21lbnQnKSB9XG4gICAgdXggPSBvZmZzZXREaXN0YW5jZSAqIGR4IC8gbGVuO1xuICAgIHV5ID0gb2Zmc2V0RGlzdGFuY2UgKiBkeSAvIGxlbjtcbiAgfVxuICB2YXIgb2Zmc2V0eCA9IHNlZ3ggLSB1eTtcbiAgdmFyIG9mZnNldHkgPSBzZWd5ICsgdXg7XG4gIHZhciBjb29yZCA9IG5ldyBDb29yZGluYXRlKG9mZnNldHgsIG9mZnNldHkpO1xuICByZXR1cm4gY29vcmRcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuc2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBzZXRDb29yZGluYXRlcyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxzID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0Q29vcmRpbmF0ZXMobHMucDAsIGxzLnAxKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLnAwLnggPSBwMC54O1xuICAgIHRoaXMucDAueSA9IHAwLnk7XG4gICAgdGhpcy5wMS54ID0gcDEueDtcbiAgICB0aGlzLnAxLnkgPSBwMS55O1xuICB9XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnNlZ21lbnRGcmFjdGlvbiA9IGZ1bmN0aW9uIHNlZ21lbnRGcmFjdGlvbiAoaW5wdXRQdCkge1xuICB2YXIgc2VnRnJhYyA9IHRoaXMucHJvamVjdGlvbkZhY3RvcihpbnB1dFB0KTtcbiAgaWYgKHNlZ0ZyYWMgPCAwLjApIHsgc2VnRnJhYyA9IDAuMDsgfSBlbHNlIGlmIChzZWdGcmFjID4gMS4wIHx8IERvdWJsZS5pc05hTihzZWdGcmFjKSkgeyBzZWdGcmFjID0gMS4wOyB9XG4gIHJldHVybiBzZWdGcmFjXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gJ0xJTkVTVFJJTkcoICcgKyB0aGlzLnAwLnggKyAnICcgKyB0aGlzLnAwLnkgKyAnLCAnICsgdGhpcy5wMS54ICsgJyAnICsgdGhpcy5wMS55ICsgJyknXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmlzSG9yaXpvbnRhbCA9IGZ1bmN0aW9uIGlzSG9yaXpvbnRhbCAoKSB7XG4gIHJldHVybiB0aGlzLnAwLnkgPT09IHRoaXMucDEueVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTZWdtZW50KSB7XG4gICAgdmFyIGxzID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBDR0FsZ29yaXRobXMuZGlzdGFuY2VMaW5lTGluZSh0aGlzLnAwLCB0aGlzLnAxLCBscy5wMCwgbHMucDEpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocCwgdGhpcy5wMCwgdGhpcy5wMSlcbiAgfVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5wb2ludEFsb25nID0gZnVuY3Rpb24gcG9pbnRBbG9uZyAoc2VnbWVudExlbmd0aEZyYWN0aW9uKSB7XG4gIHZhciBjb29yZCA9IG5ldyBDb29yZGluYXRlKCk7XG4gIGNvb3JkLnggPSB0aGlzLnAwLnggKyBzZWdtZW50TGVuZ3RoRnJhY3Rpb24gKiAodGhpcy5wMS54IC0gdGhpcy5wMC54KTtcbiAgY29vcmQueSA9IHRoaXMucDAueSArIHNlZ21lbnRMZW5ndGhGcmFjdGlvbiAqICh0aGlzLnAxLnkgLSB0aGlzLnAwLnkpO1xuICByZXR1cm4gY29vcmRcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSAoKSB7XG4gIHZhciBiaXRzMCA9IERvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueCk7XG4gIGJpdHMwIF49IERvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueSkgKiAzMTtcbiAgdmFyIGhhc2gwID0gTWF0aC50cnVuYyhiaXRzMCkgXiBNYXRoLnRydW5jKGJpdHMwID4+IDMyKTtcbiAgdmFyIGJpdHMxID0gRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS54KTtcbiAgYml0czEgXj0gRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMS55KSAqIDMxO1xuICB2YXIgaGFzaDEgPSBNYXRoLnRydW5jKGJpdHMxKSBeIE1hdGgudHJ1bmMoYml0czEgPj4gMzIpO1xuICByZXR1cm4gaGFzaDAgXiBoYXNoMVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlLCBTZXJpYWxpemFibGVdXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTGluZVNlZ21lbnRcbn07XG5MaW5lU2VnbWVudC5taWRQb2ludCA9IGZ1bmN0aW9uIG1pZFBvaW50IChwMCwgcDEpIHtcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKChwMC54ICsgcDEueCkgLyAyLCAocDAueSArIHAxLnkpIC8gMilcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjQuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAzMjUyMDA1ODMzNDY2MjU2MjI3IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBMaW5lU2VnbWVudCwgc3RhdGljQWNjZXNzb3JzJDI0ICk7XG5cbnZhciBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiA9IGZ1bmN0aW9uIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uICgpIHtcbiAgdGhpcy50ZW1wRW52MSA9IG5ldyBFbnZlbG9wZSgpO1xuICB0aGlzLnRlbXBFbnYyID0gbmV3IEVudmVsb3BlKCk7XG4gIHRoaXMuX292ZXJsYXBTZWcxID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuX292ZXJsYXBTZWcyID0gbmV3IExpbmVTZWdtZW50KCk7XG59O1xuTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24ucHJvdG90eXBlLm92ZXJsYXAgPSBmdW5jdGlvbiBvdmVybGFwICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyBjb25zdCBzZWcxID0gYXJndW1lbnRzWzBdXG4gICAgLy8gY29uc3Qgc2VnMiA9IGFyZ3VtZW50c1sxXVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgbWMxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzdGFydDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1jMiA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgc3RhcnQyID0gYXJndW1lbnRzWzNdO1xuICAgIG1jMS5nZXRMaW5lU2VnbWVudChzdGFydDEsIHRoaXMuX292ZXJsYXBTZWcxKTtcbiAgICBtYzIuZ2V0TGluZVNlZ21lbnQoc3RhcnQyLCB0aGlzLl9vdmVybGFwU2VnMik7XG4gICAgdGhpcy5vdmVybGFwKHRoaXMuX292ZXJsYXBTZWcxLCB0aGlzLl9vdmVybGFwU2VnMik7XG4gIH1cbn07XG5Nb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uXG59O1xuXG52YXIgTW9ub3RvbmVDaGFpbiA9IGZ1bmN0aW9uIE1vbm90b25lQ2hhaW4gKCkge1xuICB0aGlzLl9wdHMgPSBudWxsO1xuICB0aGlzLl9zdGFydCA9IG51bGw7XG4gIHRoaXMuX2VuZCA9IG51bGw7XG4gIHRoaXMuX2VudiA9IG51bGw7XG4gIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICB0aGlzLl9pZCA9IG51bGw7XG4gIHZhciBwdHMgPSBhcmd1bWVudHNbMF07XG4gIHZhciBzdGFydCA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGVuZCA9IGFyZ3VtZW50c1syXTtcbiAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHNbM107XG4gIHRoaXMuX3B0cyA9IHB0cztcbiAgdGhpcy5fc3RhcnQgPSBzdGFydDtcbiAgdGhpcy5fZW5kID0gZW5kO1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRMaW5lU2VnbWVudCA9IGZ1bmN0aW9uIGdldExpbmVTZWdtZW50IChpbmRleCwgbHMpIHtcbiAgbHMucDAgPSB0aGlzLl9wdHNbaW5kZXhdO1xuICBscy5wMSA9IHRoaXMuX3B0c1tpbmRleCArIDFdO1xufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmNvbXB1dGVTZWxlY3QgPSBmdW5jdGlvbiBjb21wdXRlU2VsZWN0IChzZWFyY2hFbnYsIHN0YXJ0MCwgZW5kMCwgbWNzKSB7XG4gIHZhciBwMCA9IHRoaXMuX3B0c1tzdGFydDBdO1xuICB2YXIgcDEgPSB0aGlzLl9wdHNbZW5kMF07XG4gIG1jcy50ZW1wRW52MS5pbml0KHAwLCBwMSk7XG4gIGlmIChlbmQwIC0gc3RhcnQwID09PSAxKSB7XG4gICAgbWNzLnNlbGVjdCh0aGlzLCBzdGFydDApO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKCFzZWFyY2hFbnYuaW50ZXJzZWN0cyhtY3MudGVtcEVudjEpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG1pZCA9IE1hdGgudHJ1bmMoKHN0YXJ0MCArIGVuZDApIC8gMik7XG4gIGlmIChzdGFydDAgPCBtaWQpIHtcbiAgICB0aGlzLmNvbXB1dGVTZWxlY3Qoc2VhcmNoRW52LCBzdGFydDAsIG1pZCwgbWNzKTtcbiAgfVxuICBpZiAobWlkIDwgZW5kMCkge1xuICAgIHRoaXMuY29tcHV0ZVNlbGVjdChzZWFyY2hFbnYsIG1pZCwgZW5kMCwgbWNzKTtcbiAgfVxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjb29yZCA9IG5ldyBBcnJheSh0aGlzLl9lbmQgLSB0aGlzLl9zdGFydCArIDEpLmZpbGwobnVsbCk7XG4gIHZhciBpbmRleCA9IDA7XG4gIGZvciAodmFyIGkgPSB0aGlzLl9zdGFydDsgaSA8PSB0aGlzLl9lbmQ7IGkrKykge1xuICAgIGNvb3JkW2luZGV4KytdID0gdGhpcyQxLl9wdHNbaV07XG4gIH1cbiAgcmV0dXJuIGNvb3JkXG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuY29tcHV0ZU92ZXJsYXBzID0gZnVuY3Rpb24gY29tcHV0ZU92ZXJsYXBzIChtYywgbWNvKSB7XG4gIHRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwodGhpcy5fc3RhcnQsIHRoaXMuX2VuZCwgbWMsIG1jLl9zdGFydCwgbWMuX2VuZCwgbWNvKTtcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5zZXRJZCA9IGZ1bmN0aW9uIHNldElkIChpZCkge1xuICB0aGlzLl9pZCA9IGlkO1xufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCAoc2VhcmNoRW52LCBtY3MpIHtcbiAgdGhpcy5jb21wdXRlU2VsZWN0KHNlYXJjaEVudiwgdGhpcy5fc3RhcnQsIHRoaXMuX2VuZCwgbWNzKTtcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRFbnZlbG9wZSA9IGZ1bmN0aW9uIGdldEVudmVsb3BlICgpIHtcbiAgaWYgKHRoaXMuX2VudiA9PT0gbnVsbCkge1xuICAgIHZhciBwMCA9IHRoaXMuX3B0c1t0aGlzLl9zdGFydF07XG4gICAgdmFyIHAxID0gdGhpcy5fcHRzW3RoaXMuX2VuZF07XG4gICAgdGhpcy5fZW52ID0gbmV3IEVudmVsb3BlKHAwLCBwMSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2VudlxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmdldEVuZEluZGV4ID0gZnVuY3Rpb24gZ2V0RW5kSW5kZXggKCkge1xuICByZXR1cm4gdGhpcy5fZW5kXG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0U3RhcnRJbmRleCA9IGZ1bmN0aW9uIGdldFN0YXJ0SW5kZXggKCkge1xuICByZXR1cm4gdGhpcy5fc3RhcnRcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCAoKSB7XG4gIHJldHVybiB0aGlzLl9jb250ZXh0XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0SWQgPSBmdW5jdGlvbiBnZXRJZCAoKSB7XG4gIHJldHVybiB0aGlzLl9pZFxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmNvbXB1dGVPdmVybGFwc0ludGVybmFsID0gZnVuY3Rpb24gY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwgKHN0YXJ0MCwgZW5kMCwgbWMsIHN0YXJ0MSwgZW5kMSwgbWNvKSB7XG4gIHZhciBwMDAgPSB0aGlzLl9wdHNbc3RhcnQwXTtcbiAgdmFyIHAwMSA9IHRoaXMuX3B0c1tlbmQwXTtcbiAgdmFyIHAxMCA9IG1jLl9wdHNbc3RhcnQxXTtcbiAgdmFyIHAxMSA9IG1jLl9wdHNbZW5kMV07XG4gIGlmIChlbmQwIC0gc3RhcnQwID09PSAxICYmIGVuZDEgLSBzdGFydDEgPT09IDEpIHtcbiAgICBtY28ub3ZlcmxhcCh0aGlzLCBzdGFydDAsIG1jLCBzdGFydDEpO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgbWNvLnRlbXBFbnYxLmluaXQocDAwLCBwMDEpO1xuICBtY28udGVtcEVudjIuaW5pdChwMTAsIHAxMSk7XG4gIGlmICghbWNvLnRlbXBFbnYxLmludGVyc2VjdHMobWNvLnRlbXBFbnYyKSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBtaWQwID0gTWF0aC50cnVuYygoc3RhcnQwICsgZW5kMCkgLyAyKTtcbiAgdmFyIG1pZDEgPSBNYXRoLnRydW5jKChzdGFydDEgKyBlbmQxKSAvIDIpO1xuICBpZiAoc3RhcnQwIDwgbWlkMCkge1xuICAgIGlmIChzdGFydDEgPCBtaWQxKSB7IHRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwoc3RhcnQwLCBtaWQwLCBtYywgc3RhcnQxLCBtaWQxLCBtY28pOyB9XG4gICAgaWYgKG1pZDEgPCBlbmQxKSB7IHRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwoc3RhcnQwLCBtaWQwLCBtYywgbWlkMSwgZW5kMSwgbWNvKTsgfVxuICB9XG4gIGlmIChtaWQwIDwgZW5kMCkge1xuICAgIGlmIChzdGFydDEgPCBtaWQxKSB7IHRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwobWlkMCwgZW5kMCwgbWMsIHN0YXJ0MSwgbWlkMSwgbWNvKTsgfVxuICAgIGlmIChtaWQxIDwgZW5kMSkgeyB0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKG1pZDAsIGVuZDAsIG1jLCBtaWQxLCBlbmQxLCBtY28pOyB9XG4gIH1cbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vdG9uZUNoYWluXG59O1xuXG52YXIgTW9ub3RvbmVDaGFpbkJ1aWxkZXIgPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluQnVpbGRlciAoKSB7fTtcblxuTW9ub3RvbmVDaGFpbkJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Nb25vdG9uZUNoYWluQnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vdG9uZUNoYWluQnVpbGRlclxufTtcbk1vbm90b25lQ2hhaW5CdWlsZGVyLmdldENoYWluU3RhcnRJbmRpY2VzID0gZnVuY3Rpb24gZ2V0Q2hhaW5TdGFydEluZGljZXMgKHB0cykge1xuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgc3RhcnRJbmRleExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHN0YXJ0SW5kZXhMaXN0LmFkZChuZXcgSW50ZWdlcihzdGFydCkpO1xuICBkbyB7XG4gICAgdmFyIGxhc3QgPSBNb25vdG9uZUNoYWluQnVpbGRlci5maW5kQ2hhaW5FbmQocHRzLCBzdGFydCk7XG4gICAgc3RhcnRJbmRleExpc3QuYWRkKG5ldyBJbnRlZ2VyKGxhc3QpKTtcbiAgICBzdGFydCA9IGxhc3Q7XG4gIH0gd2hpbGUgKHN0YXJ0IDwgcHRzLmxlbmd0aCAtIDEpXG4gIHZhciBzdGFydEluZGV4ID0gTW9ub3RvbmVDaGFpbkJ1aWxkZXIudG9JbnRBcnJheShzdGFydEluZGV4TGlzdCk7XG4gIHJldHVybiBzdGFydEluZGV4XG59O1xuTW9ub3RvbmVDaGFpbkJ1aWxkZXIuZmluZENoYWluRW5kID0gZnVuY3Rpb24gZmluZENoYWluRW5kIChwdHMsIHN0YXJ0KSB7XG4gIHZhciBzYWZlU3RhcnQgPSBzdGFydDtcbiAgd2hpbGUgKHNhZmVTdGFydCA8IHB0cy5sZW5ndGggLSAxICYmIHB0c1tzYWZlU3RhcnRdLmVxdWFsczJEKHB0c1tzYWZlU3RhcnQgKyAxXSkpIHtcbiAgICBzYWZlU3RhcnQrKztcbiAgfVxuICBpZiAoc2FmZVN0YXJ0ID49IHB0cy5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIHB0cy5sZW5ndGggLSAxXG4gIH1cbiAgdmFyIGNoYWluUXVhZCA9IFF1YWRyYW50LnF1YWRyYW50KHB0c1tzYWZlU3RhcnRdLCBwdHNbc2FmZVN0YXJ0ICsgMV0pO1xuICB2YXIgbGFzdCA9IHN0YXJ0ICsgMTtcbiAgd2hpbGUgKGxhc3QgPCBwdHMubGVuZ3RoKSB7XG4gICAgaWYgKCFwdHNbbGFzdCAtIDFdLmVxdWFsczJEKHB0c1tsYXN0XSkpIHtcbiAgICAgIHZhciBxdWFkID0gUXVhZHJhbnQucXVhZHJhbnQocHRzW2xhc3QgLSAxXSwgcHRzW2xhc3RdKTtcbiAgICAgIGlmIChxdWFkICE9PSBjaGFpblF1YWQpIHsgYnJlYWsgfVxuICAgIH1cbiAgICBsYXN0Kys7XG4gIH1cbiAgcmV0dXJuIGxhc3QgLSAxXG59O1xuTW9ub3RvbmVDaGFpbkJ1aWxkZXIuZ2V0Q2hhaW5zID0gZnVuY3Rpb24gZ2V0Q2hhaW5zICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBNb25vdG9uZUNoYWluQnVpbGRlci5nZXRDaGFpbnMocHRzLCBudWxsKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcHRzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGNvbnRleHQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1jTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IE1vbm90b25lQ2hhaW5CdWlsZGVyLmdldENoYWluU3RhcnRJbmRpY2VzKHB0cyQxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0SW5kZXgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgbWMgPSBuZXcgTW9ub3RvbmVDaGFpbihwdHMkMSwgc3RhcnRJbmRleFtpXSwgc3RhcnRJbmRleFtpICsgMV0sIGNvbnRleHQpO1xuICAgICAgbWNMaXN0LmFkZChtYyk7XG4gICAgfVxuICAgIHJldHVybiBtY0xpc3RcbiAgfVxufTtcbk1vbm90b25lQ2hhaW5CdWlsZGVyLnRvSW50QXJyYXkgPSBmdW5jdGlvbiB0b0ludEFycmF5IChsaXN0KSB7XG4gIHZhciBhcnJheSA9IG5ldyBBcnJheShsaXN0LnNpemUoKSkuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gbGlzdC5nZXQoaSkuaW50VmFsdWUoKTtcbiAgfVxuICByZXR1cm4gYXJyYXlcbn07XG5cbnZhciBOb2RlciA9IGZ1bmN0aW9uIE5vZGVyICgpIHt9O1xuXG5Ob2Rlci5wcm90b3R5cGUuY29tcHV0ZU5vZGVzID0gZnVuY3Rpb24gY29tcHV0ZU5vZGVzIChzZWdTdHJpbmdzKSB7fTtcbk5vZGVyLnByb3RvdHlwZS5nZXROb2RlZFN1YnN0cmluZ3MgPSBmdW5jdGlvbiBnZXROb2RlZFN1YnN0cmluZ3MgKCkge307XG5Ob2Rlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk5vZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGVyXG59O1xuXG52YXIgU2luZ2xlUGFzc05vZGVyID0gZnVuY3Rpb24gU2luZ2xlUGFzc05vZGVyICgpIHtcbiAgdGhpcy5fc2VnSW50ID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHt9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc2VnSW50ID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0U2VnbWVudEludGVyc2VjdG9yKHNlZ0ludCk7XG4gIH1cbn07XG5TaW5nbGVQYXNzTm9kZXIucHJvdG90eXBlLnNldFNlZ21lbnRJbnRlcnNlY3RvciA9IGZ1bmN0aW9uIHNldFNlZ21lbnRJbnRlcnNlY3RvciAoc2VnSW50KSB7XG4gIHRoaXMuX3NlZ0ludCA9IHNlZ0ludDtcbn07XG5TaW5nbGVQYXNzTm9kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW05vZGVyXVxufTtcblNpbmdsZVBhc3NOb2Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTaW5nbGVQYXNzTm9kZXJcbn07XG5cbnZhciBNQ0luZGV4Tm9kZXIgPSAoZnVuY3Rpb24gKFNpbmdsZVBhc3NOb2RlciQkMSkge1xuICBmdW5jdGlvbiBNQ0luZGV4Tm9kZXIgKHNpKSB7XG4gICAgaWYgKHNpKSB7IFNpbmdsZVBhc3NOb2RlciQkMS5jYWxsKHRoaXMsIHNpKTsgfVxuICAgIGVsc2UgeyBTaW5nbGVQYXNzTm9kZXIkJDEuY2FsbCh0aGlzKTsgfVxuICAgIHRoaXMuX21vbm9DaGFpbnMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdGhpcy5faW5kZXggPSBuZXcgU1RSdHJlZSgpO1xuICAgIHRoaXMuX2lkQ291bnRlciA9IDA7XG4gICAgdGhpcy5fbm9kZWRTZWdTdHJpbmdzID0gbnVsbDtcbiAgICB0aGlzLl9uT3ZlcmxhcHMgPSAwO1xuICB9XG5cbiAgaWYgKCBTaW5nbGVQYXNzTm9kZXIkJDEgKSBNQ0luZGV4Tm9kZXIuX19wcm90b19fID0gU2luZ2xlUGFzc05vZGVyJCQxO1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2luZ2xlUGFzc05vZGVyJCQxICYmIFNpbmdsZVBhc3NOb2RlciQkMS5wcm90b3R5cGUgKTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1DSW5kZXhOb2RlcjtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBTZWdtZW50T3ZlcmxhcEFjdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlLmdldE1vbm90b25lQ2hhaW5zID0gZnVuY3Rpb24gZ2V0TW9ub3RvbmVDaGFpbnMgKCkge1xuICAgIHJldHVybiB0aGlzLl9tb25vQ2hhaW5zXG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuZ2V0Tm9kZWRTdWJzdHJpbmdzID0gZnVuY3Rpb24gZ2V0Tm9kZWRTdWJzdHJpbmdzICgpIHtcbiAgICByZXR1cm4gTm9kZWRTZWdtZW50U3RyaW5nLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLl9ub2RlZFNlZ1N0cmluZ3MpXG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiBnZXRJbmRleCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4XG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChzZWdTdHIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzZWdDaGFpbnMgPSBNb25vdG9uZUNoYWluQnVpbGRlci5nZXRDaGFpbnMoc2VnU3RyLmdldENvb3JkaW5hdGVzKCksIHNlZ1N0cik7XG4gICAgZm9yICh2YXIgaSA9IHNlZ0NoYWlucy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBtYyA9IGkubmV4dCgpO1xuICAgICAgbWMuc2V0SWQodGhpcyQxLl9pZENvdW50ZXIrKyk7XG4gICAgICB0aGlzJDEuX2luZGV4Lmluc2VydChtYy5nZXRFbnZlbG9wZSgpLCBtYyk7XG4gICAgICB0aGlzJDEuX21vbm9DaGFpbnMuYWRkKG1jKTtcbiAgICB9XG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuY29tcHV0ZU5vZGVzID0gZnVuY3Rpb24gY29tcHV0ZU5vZGVzIChpbnB1dFNlZ1N0cmluZ3MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuX25vZGVkU2VnU3RyaW5ncyA9IGlucHV0U2VnU3RyaW5ncztcbiAgICBmb3IgKHZhciBpID0gaW5wdXRTZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdGhpcyQxLmFkZChpLm5leHQoKSk7XG4gICAgfVxuICAgIHRoaXMuaW50ZXJzZWN0Q2hhaW5zKCk7XG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuaW50ZXJzZWN0Q2hhaW5zID0gZnVuY3Rpb24gaW50ZXJzZWN0Q2hhaW5zICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBvdmVybGFwQWN0aW9uID0gbmV3IFNlZ21lbnRPdmVybGFwQWN0aW9uKHRoaXMuX3NlZ0ludCk7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX21vbm9DaGFpbnMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgcXVlcnlDaGFpbiA9IGkubmV4dCgpO1xuICAgICAgdmFyIG92ZXJsYXBDaGFpbnMgPSB0aGlzJDEuX2luZGV4LnF1ZXJ5KHF1ZXJ5Q2hhaW4uZ2V0RW52ZWxvcGUoKSk7XG4gICAgICBmb3IgKHZhciBqID0gb3ZlcmxhcENoYWlucy5pdGVyYXRvcigpOyBqLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIHRlc3RDaGFpbiA9IGoubmV4dCgpO1xuICAgICAgICBpZiAodGVzdENoYWluLmdldElkKCkgPiBxdWVyeUNoYWluLmdldElkKCkpIHtcbiAgICAgICAgICBxdWVyeUNoYWluLmNvbXB1dGVPdmVybGFwcyh0ZXN0Q2hhaW4sIG92ZXJsYXBBY3Rpb24pO1xuICAgICAgICAgIHRoaXMkMS5fbk92ZXJsYXBzKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMkMS5fc2VnSW50LmlzRG9uZSgpKSB7IHJldHVybiBudWxsIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE1DSW5kZXhOb2RlclxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuU2VnbWVudE92ZXJsYXBBY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VnbWVudE92ZXJsYXBBY3Rpb24gfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTUNJbmRleE5vZGVyLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTUNJbmRleE5vZGVyO1xufShTaW5nbGVQYXNzTm9kZXIpKTtcblxudmFyIFNlZ21lbnRPdmVybGFwQWN0aW9uID0gKGZ1bmN0aW9uIChNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBTZWdtZW50T3ZlcmxhcEFjdGlvbiAoKSB7XG4gICAgTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24kJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9zaSA9IG51bGw7XG4gICAgdmFyIHNpID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX3NpID0gc2k7XG4gIH1cblxuICBpZiAoIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uJCQxICkgU2VnbWVudE92ZXJsYXBBY3Rpb24uX19wcm90b19fID0gTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24kJDE7XG4gIFNlZ21lbnRPdmVybGFwQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uJCQxICYmIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBTZWdtZW50T3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTZWdtZW50T3ZlcmxhcEFjdGlvbjtcbiAgU2VnbWVudE92ZXJsYXBBY3Rpb24ucHJvdG90eXBlLm92ZXJsYXAgPSBmdW5jdGlvbiBvdmVybGFwICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgdmFyIG1jMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBzdGFydDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgbWMyID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIHN0YXJ0MiA9IGFyZ3VtZW50c1szXTtcbiAgICAgIHZhciBzczEgPSBtYzEuZ2V0Q29udGV4dCgpO1xuICAgICAgdmFyIHNzMiA9IG1jMi5nZXRDb250ZXh0KCk7XG4gICAgICB0aGlzLl9zaS5wcm9jZXNzSW50ZXJzZWN0aW9ucyhzczEsIHN0YXJ0MSwgc3MyLCBzdGFydDIpO1xuICAgIH0gZWxzZSB7IHJldHVybiBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiQkMS5wcm90b3R5cGUub3ZlcmxhcC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgU2VnbWVudE92ZXJsYXBBY3Rpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBTZWdtZW50T3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFNlZ21lbnRPdmVybGFwQWN0aW9uXG4gIH07XG5cbiAgcmV0dXJuIFNlZ21lbnRPdmVybGFwQWN0aW9uO1xufShNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbikpO1xuXG52YXIgQnVmZmVyUGFyYW1ldGVycyA9IGZ1bmN0aW9uIEJ1ZmZlclBhcmFtZXRlcnMgKCkge1xuICB0aGlzLl9xdWFkcmFudFNlZ21lbnRzID0gQnVmZmVyUGFyYW1ldGVycy5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTO1xuICB0aGlzLl9lbmRDYXBTdHlsZSA9IEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX1JPVU5EO1xuICB0aGlzLl9qb2luU3R5bGUgPSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fUk9VTkQ7XG4gIHRoaXMuX21pdHJlTGltaXQgPSBCdWZmZXJQYXJhbWV0ZXJzLkRFRkFVTFRfTUlUUkVfTElNSVQ7XG4gIHRoaXMuX2lzU2luZ2xlU2lkZWQgPSBmYWxzZTtcbiAgdGhpcy5fc2ltcGxpZnlGYWN0b3IgPSBCdWZmZXJQYXJhbWV0ZXJzLkRFRkFVTFRfU0lNUExJRllfRkFDVE9SO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHF1YWRyYW50U2VnbWVudHMgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHF1YWRyYW50U2VnbWVudHMpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcXVhZHJhbnRTZWdtZW50cyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBlbmRDYXBTdHlsZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLnNldFF1YWRyYW50U2VnbWVudHMocXVhZHJhbnRTZWdtZW50cyQxKTtcbiAgICB0aGlzLnNldEVuZENhcFN0eWxlKGVuZENhcFN0eWxlKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHF1YWRyYW50U2VnbWVudHMkMiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZW5kQ2FwU3R5bGUkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgam9pblN0eWxlID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBtaXRyZUxpbWl0ID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyhxdWFkcmFudFNlZ21lbnRzJDIpO1xuICAgIHRoaXMuc2V0RW5kQ2FwU3R5bGUoZW5kQ2FwU3R5bGUkMSk7XG4gICAgdGhpcy5zZXRKb2luU3R5bGUoam9pblN0eWxlKTtcbiAgICB0aGlzLnNldE1pdHJlTGltaXQobWl0cmVMaW1pdCk7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjUgPSB7IENBUF9ST1VORDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDQVBfRkxBVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDQVBfU1FVQVJFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEpPSU5fUk9VTkQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sSk9JTl9NSVRSRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxKT0lOX0JFVkVMOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sREVGQVVMVF9NSVRSRV9MSU1JVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0RW5kQ2FwU3R5bGUgPSBmdW5jdGlvbiBnZXRFbmRDYXBTdHlsZSAoKSB7XG4gIHJldHVybiB0aGlzLl9lbmRDYXBTdHlsZVxufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLmlzU2luZ2xlU2lkZWQgPSBmdW5jdGlvbiBpc1NpbmdsZVNpZGVkICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzU2luZ2xlU2lkZWRcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5zZXRRdWFkcmFudFNlZ21lbnRzID0gZnVuY3Rpb24gc2V0UXVhZHJhbnRTZWdtZW50cyAocXVhZFNlZ3MpIHtcbiAgdGhpcy5fcXVhZHJhbnRTZWdtZW50cyA9IHF1YWRTZWdzO1xuICBpZiAodGhpcy5fcXVhZHJhbnRTZWdtZW50cyA9PT0gMCkgeyB0aGlzLl9qb2luU3R5bGUgPSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fQkVWRUw7IH1cbiAgaWYgKHRoaXMuX3F1YWRyYW50U2VnbWVudHMgPCAwKSB7XG4gICAgdGhpcy5fam9pblN0eWxlID0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX01JVFJFO1xuICAgIHRoaXMuX21pdHJlTGltaXQgPSBNYXRoLmFicyh0aGlzLl9xdWFkcmFudFNlZ21lbnRzKTtcbiAgfVxuICBpZiAocXVhZFNlZ3MgPD0gMCkge1xuICAgIHRoaXMuX3F1YWRyYW50U2VnbWVudHMgPSAxO1xuICB9XG4gIGlmICh0aGlzLl9qb2luU3R5bGUgIT09IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9ST1VORCkge1xuICAgIHRoaXMuX3F1YWRyYW50U2VnbWVudHMgPSBCdWZmZXJQYXJhbWV0ZXJzLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM7XG4gIH1cbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRKb2luU3R5bGUgPSBmdW5jdGlvbiBnZXRKb2luU3R5bGUgKCkge1xuICByZXR1cm4gdGhpcy5fam9pblN0eWxlXG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuc2V0Sm9pblN0eWxlID0gZnVuY3Rpb24gc2V0Sm9pblN0eWxlIChqb2luU3R5bGUpIHtcbiAgdGhpcy5fam9pblN0eWxlID0gam9pblN0eWxlO1xufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLnNldFNpbXBsaWZ5RmFjdG9yID0gZnVuY3Rpb24gc2V0U2ltcGxpZnlGYWN0b3IgKHNpbXBsaWZ5RmFjdG9yKSB7XG4gIHRoaXMuX3NpbXBsaWZ5RmFjdG9yID0gc2ltcGxpZnlGYWN0b3IgPCAwID8gMCA6IHNpbXBsaWZ5RmFjdG9yO1xufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLmdldFNpbXBsaWZ5RmFjdG9yID0gZnVuY3Rpb24gZ2V0U2ltcGxpZnlGYWN0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fc2ltcGxpZnlGYWN0b3Jcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRRdWFkcmFudFNlZ21lbnRzID0gZnVuY3Rpb24gZ2V0UXVhZHJhbnRTZWdtZW50cyAoKSB7XG4gIHJldHVybiB0aGlzLl9xdWFkcmFudFNlZ21lbnRzXG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuc2V0RW5kQ2FwU3R5bGUgPSBmdW5jdGlvbiBzZXRFbmRDYXBTdHlsZSAoZW5kQ2FwU3R5bGUpIHtcbiAgdGhpcy5fZW5kQ2FwU3R5bGUgPSBlbmRDYXBTdHlsZTtcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRNaXRyZUxpbWl0ID0gZnVuY3Rpb24gZ2V0TWl0cmVMaW1pdCAoKSB7XG4gIHJldHVybiB0aGlzLl9taXRyZUxpbWl0XG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuc2V0TWl0cmVMaW1pdCA9IGZ1bmN0aW9uIHNldE1pdHJlTGltaXQgKG1pdHJlTGltaXQpIHtcbiAgdGhpcy5fbWl0cmVMaW1pdCA9IG1pdHJlTGltaXQ7XG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuc2V0U2luZ2xlU2lkZWQgPSBmdW5jdGlvbiBzZXRTaW5nbGVTaWRlZCAoaXNTaW5nbGVTaWRlZCkge1xuICB0aGlzLl9pc1NpbmdsZVNpZGVkID0gaXNTaW5nbGVTaWRlZDtcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJQYXJhbWV0ZXJzXG59O1xuQnVmZmVyUGFyYW1ldGVycy5idWZmZXJEaXN0YW5jZUVycm9yID0gZnVuY3Rpb24gYnVmZmVyRGlzdGFuY2VFcnJvciAocXVhZFNlZ3MpIHtcbiAgdmFyIGFscGhhID0gTWF0aC5QSSAvIDIuMCAvIHF1YWRTZWdzO1xuICByZXR1cm4gMSAtIE1hdGguY29zKGFscGhhIC8gMi4wKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5DQVBfUk9VTkQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDI1LkNBUF9GTEFULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5DQVBfU1FVQVJFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5KT0lOX1JPVU5ELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5KT0lOX01JVFJFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5KT0lOX0JFVkVMLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDggfTtcbnN0YXRpY0FjY2Vzc29ycyQyNS5ERUZBVUxUX01JVFJFX0xJTUlULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDUuMCB9O1xuc3RhdGljQWNjZXNzb3JzJDI1LkRFRkFVTFRfU0lNUExJRllfRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuMDEgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlclBhcmFtZXRlcnMsIHN0YXRpY0FjY2Vzc29ycyQyNSApO1xuXG52YXIgQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllciA9IGZ1bmN0aW9uIEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIgKGlucHV0TGluZSkge1xuICB0aGlzLl9kaXN0YW5jZVRvbCA9IG51bGw7XG4gIHRoaXMuX2lzRGVsZXRlZCA9IG51bGw7XG4gIHRoaXMuX2FuZ2xlT3JpZW50YXRpb24gPSBDR0FsZ29yaXRobXMuQ09VTlRFUkNMT0NLV0lTRTtcbiAgdGhpcy5faW5wdXRMaW5lID0gaW5wdXRMaW5lIHx8IG51bGw7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDI2ID0geyBJTklUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERFTEVURTogeyBjb25maWd1cmFibGU6IHRydWUgfSxLRUVQOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE5VTV9QVFNfVE9fQ0hFQ0s6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmlzRGVsZXRhYmxlID0gZnVuY3Rpb24gaXNEZWxldGFibGUgKGkwLCBpMSwgaTIsIGRpc3RhbmNlVG9sKSB7XG4gIHZhciBwMCA9IHRoaXMuX2lucHV0TGluZVtpMF07XG4gIHZhciBwMSA9IHRoaXMuX2lucHV0TGluZVtpMV07XG4gIHZhciBwMiA9IHRoaXMuX2lucHV0TGluZVtpMl07XG4gIGlmICghdGhpcy5pc0NvbmNhdmUocDAsIHAxLCBwMikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCF0aGlzLmlzU2hhbGxvdyhwMCwgcDEsIHAyLCBkaXN0YW5jZVRvbCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHRoaXMuaXNTaGFsbG93U2FtcGxlZChwMCwgcDEsIGkwLCBpMiwgZGlzdGFuY2VUb2wpXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzID0gZnVuY3Rpb24gZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaW5kZXggPSAxO1xuICAvLyBjb25zdCBtYXhJbmRleCA9IHRoaXMuX2lucHV0TGluZS5sZW5ndGggLSAxXG4gIHZhciBtaWRJbmRleCA9IHRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgoaW5kZXgpO1xuICB2YXIgbGFzdEluZGV4ID0gdGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChtaWRJbmRleCk7XG4gIHZhciBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgd2hpbGUgKGxhc3RJbmRleCA8IHRoaXMuX2lucHV0TGluZS5sZW5ndGgpIHtcbiAgICB2YXIgaXNNaWRkbGVWZXJ0ZXhEZWxldGVkID0gZmFsc2U7XG4gICAgaWYgKHRoaXMkMS5pc0RlbGV0YWJsZShpbmRleCwgbWlkSW5kZXgsIGxhc3RJbmRleCwgdGhpcyQxLl9kaXN0YW5jZVRvbCkpIHtcbiAgICAgIHRoaXMkMS5faXNEZWxldGVkW21pZEluZGV4XSA9IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuREVMRVRFO1xuICAgICAgaXNNaWRkbGVWZXJ0ZXhEZWxldGVkID0gdHJ1ZTtcbiAgICAgIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc01pZGRsZVZlcnRleERlbGV0ZWQpIHsgaW5kZXggPSBsYXN0SW5kZXg7IH0gZWxzZSB7IGluZGV4ID0gbWlkSW5kZXg7IH1cbiAgICBtaWRJbmRleCA9IHRoaXMkMS5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChpbmRleCk7XG4gICAgbGFzdEluZGV4ID0gdGhpcyQxLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KG1pZEluZGV4KTtcbiAgfVxuICByZXR1cm4gaXNDaGFuZ2VkXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuaXNTaGFsbG93Q29uY2F2aXR5ID0gZnVuY3Rpb24gaXNTaGFsbG93Q29uY2F2aXR5IChwMCwgcDEsIHAyLCBkaXN0YW5jZVRvbCkge1xuICB2YXIgb3JpZW50YXRpb24gPSBDR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uKHAwLCBwMSwgcDIpO1xuICB2YXIgaXNBbmdsZVRvU2ltcGxpZnkgPSBvcmllbnRhdGlvbiA9PT0gdGhpcy5fYW5nbGVPcmllbnRhdGlvbjtcbiAgaWYgKCFpc0FuZ2xlVG9TaW1wbGlmeSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgZGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShwMSwgcDAsIHAyKTtcbiAgcmV0dXJuIGRpc3QgPCBkaXN0YW5jZVRvbFxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmlzU2hhbGxvd1NhbXBsZWQgPSBmdW5jdGlvbiBpc1NoYWxsb3dTYW1wbGVkIChwMCwgcDIsIGkwLCBpMiwgZGlzdGFuY2VUb2wpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaW5jID0gTWF0aC50cnVuYygoaTIgLSBpMCkgLyBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLk5VTV9QVFNfVE9fQ0hFQ0spO1xuICBpZiAoaW5jIDw9IDApIHsgaW5jID0gMTsgfVxuICBmb3IgKHZhciBpID0gaTA7IGkgPCBpMjsgaSArPSBpbmMpIHtcbiAgICBpZiAoIXRoaXMkMS5pc1NoYWxsb3cocDAsIHAyLCB0aGlzJDEuX2lucHV0TGluZVtpXSwgZGlzdGFuY2VUb2wpKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5pc0NvbmNhdmUgPSBmdW5jdGlvbiBpc0NvbmNhdmUgKHAwLCBwMSwgcDIpIHtcbiAgdmFyIG9yaWVudGF0aW9uID0gQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbihwMCwgcDEsIHAyKTtcbiAgdmFyIGlzQ29uY2F2ZSA9IG9yaWVudGF0aW9uID09PSB0aGlzLl9hbmdsZU9yaWVudGF0aW9uO1xuICByZXR1cm4gaXNDb25jYXZlXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuc2ltcGxpZnkgPSBmdW5jdGlvbiBzaW1wbGlmeSAoZGlzdGFuY2VUb2wpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl9kaXN0YW5jZVRvbCA9IE1hdGguYWJzKGRpc3RhbmNlVG9sKTtcbiAgaWYgKGRpc3RhbmNlVG9sIDwgMCkgeyB0aGlzLl9hbmdsZU9yaWVudGF0aW9uID0gQ0dBbGdvcml0aG1zLkNMT0NLV0lTRTsgfVxuICB0aGlzLl9pc0RlbGV0ZWQgPSBuZXcgQXJyYXkodGhpcy5faW5wdXRMaW5lLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgdmFyIGlzQ2hhbmdlZCA9IGZhbHNlO1xuICBkbyB7XG4gICAgaXNDaGFuZ2VkID0gdGhpcyQxLmRlbGV0ZVNoYWxsb3dDb25jYXZpdGllcygpO1xuICB9IHdoaWxlIChpc0NoYW5nZWQpXG4gIHJldHVybiB0aGlzLmNvbGxhcHNlTGluZSgpXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuZmluZE5leHROb25EZWxldGVkSW5kZXggPSBmdW5jdGlvbiBmaW5kTmV4dE5vbkRlbGV0ZWRJbmRleCAoaW5kZXgpIHtcbiAgdmFyIG5leHQgPSBpbmRleCArIDE7XG4gIHdoaWxlIChuZXh0IDwgdGhpcy5faW5wdXRMaW5lLmxlbmd0aCAmJiB0aGlzLl9pc0RlbGV0ZWRbbmV4dF0gPT09IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuREVMRVRFKSB7IG5leHQrKzsgfVxuICByZXR1cm4gbmV4dFxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmlzU2hhbGxvdyA9IGZ1bmN0aW9uIGlzU2hhbGxvdyAocDAsIHAxLCBwMiwgZGlzdGFuY2VUb2wpIHtcbiAgdmFyIGRpc3QgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocDEsIHAwLCBwMik7XG4gIHJldHVybiBkaXN0IDwgZGlzdGFuY2VUb2xcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5jb2xsYXBzZUxpbmUgPSBmdW5jdGlvbiBjb2xsYXBzZUxpbmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjb29yZExpc3QgPSBuZXcgQ29vcmRpbmF0ZUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9pbnB1dExpbmUubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLl9pc0RlbGV0ZWRbaV0gIT09IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuREVMRVRFKSB7IGNvb3JkTGlzdC5hZGQodGhpcyQxLl9pbnB1dExpbmVbaV0pOyB9XG4gIH1cbiAgcmV0dXJuIGNvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllclxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuc2ltcGxpZnkgPSBmdW5jdGlvbiBzaW1wbGlmeSAoaW5wdXRMaW5lLCBkaXN0YW5jZVRvbCkge1xuICB2YXIgc2ltcCA9IG5ldyBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyKGlucHV0TGluZSk7XG4gIHJldHVybiBzaW1wLnNpbXBsaWZ5KGRpc3RhbmNlVG9sKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQyNi5JTklULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNi5ERUxFVEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDI2LktFRVAuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDI2Lk5VTV9QVFNfVE9fQ0hFQ0suZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMTAgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIsIHN0YXRpY0FjY2Vzc29ycyQyNiApO1xuXG52YXIgT2Zmc2V0U2VnbWVudFN0cmluZyA9IGZ1bmN0aW9uIE9mZnNldFNlZ21lbnRTdHJpbmcgKCkge1xuICB0aGlzLl9wdExpc3QgPSBudWxsO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IG51bGw7XG4gIHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZSA9IDAuMDtcbiAgdGhpcy5fcHRMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyOCA9IHsgQ09PUkRJTkFURV9BUlJBWV9UWVBFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgdmFyIGNvb3JkID0gdGhpcy5fcHRMaXN0LnRvQXJyYXkoT2Zmc2V0U2VnbWVudFN0cmluZy5DT09SRElOQVRFX0FSUkFZX1RZUEUpO1xuICByZXR1cm4gY29vcmRcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zZXRQcmVjaXNpb25Nb2RlbCA9IGZ1bmN0aW9uIHNldFByZWNpc2lvbk1vZGVsIChwcmVjaXNpb25Nb2RlbCkge1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IHByZWNpc2lvbk1vZGVsO1xufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmFkZFB0ID0gZnVuY3Rpb24gYWRkUHQgKHB0KSB7XG4gIHZhciBidWZQdCA9IG5ldyBDb29yZGluYXRlKHB0KTtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoYnVmUHQpO1xuICBpZiAodGhpcy5pc1JlZHVuZGFudChidWZQdCkpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLl9wdExpc3QuYWRkKGJ1ZlB0KTtcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5yZXZlcmUgPSBmdW5jdGlvbiByZXZlcmUgKCkge307XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5hZGRQdHMgPSBmdW5jdGlvbiBhZGRQdHMgKHB0LCBpc0ZvcndhcmQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoaXNGb3J3YXJkKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcyQxLmFkZFB0KHB0W2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSQxID0gcHQubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgICB0aGlzJDEuYWRkUHQocHRbaSQxXSk7XG4gICAgfVxuICB9XG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuaXNSZWR1bmRhbnQgPSBmdW5jdGlvbiBpc1JlZHVuZGFudCAocHQpIHtcbiAgaWYgKHRoaXMuX3B0TGlzdC5zaXplKCkgPCAxKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBsYXN0UHQgPSB0aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCkgLSAxKTtcbiAgdmFyIHB0RGlzdCA9IHB0LmRpc3RhbmNlKGxhc3RQdCk7XG4gIGlmIChwdERpc3QgPCB0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2UpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGZhY3QgPSBuZXcgR2VvbWV0cnlGYWN0b3J5KCk7XG4gIHZhciBsaW5lID0gZmFjdC5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gIHJldHVybiBsaW5lLnRvU3RyaW5nKClcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5jbG9zZVJpbmcgPSBmdW5jdGlvbiBjbG9zZVJpbmcgKCkge1xuICBpZiAodGhpcy5fcHRMaXN0LnNpemUoKSA8IDEpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgc3RhcnRQdCA9IG5ldyBDb29yZGluYXRlKHRoaXMuX3B0TGlzdC5nZXQoMCkpO1xuICB2YXIgbGFzdFB0ID0gdGhpcy5fcHRMaXN0LmdldCh0aGlzLl9wdExpc3Quc2l6ZSgpIC0gMSk7XG4gIC8vIGNvbnN0IGxhc3QyUHQgPSBudWxsXG4gIC8vIGlmICh0aGlzLl9wdExpc3Quc2l6ZSgpID49IDIpIGxhc3QyUHQgPSB0aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCkgLSAyKVxuICBpZiAoc3RhcnRQdC5lcXVhbHMobGFzdFB0KSkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuX3B0TGlzdC5hZGQoc3RhcnRQdCk7XG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2V0TWluaW11bVZlcnRleERpc3RhbmNlID0gZnVuY3Rpb24gc2V0TWluaW11bVZlcnRleERpc3RhbmNlIChtaW5pbWltVmVydGV4RGlzdGFuY2UpIHtcbiAgdGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlID0gbWluaW1pbVZlcnRleERpc3RhbmNlO1xufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE9mZnNldFNlZ21lbnRTdHJpbmdcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjguQ09PUkRJTkFURV9BUlJBWV9UWVBFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBcnJheSgwKS5maWxsKG51bGwpIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBPZmZzZXRTZWdtZW50U3RyaW5nLCBzdGF0aWNBY2Nlc3NvcnMkMjggKTtcblxudmFyIEFuZ2xlID0gZnVuY3Rpb24gQW5nbGUgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjkgPSB7IFBJX1RJTUVTXzI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sUElfT1ZFUl8yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFBJX09WRVJfNDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDT1VOVEVSQ0xPQ0tXSVNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENMT0NLV0lTRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxOT05FOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkFuZ2xlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQW5nbGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQW5nbGVcbn07XG5BbmdsZS50b0RlZ3JlZXMgPSBmdW5jdGlvbiB0b0RlZ3JlZXMgKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAxODAgLyBNYXRoLlBJXG59O1xuQW5nbGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplIChhbmdsZSkge1xuICB3aGlsZSAoYW5nbGUgPiBNYXRoLlBJKSB7IGFuZ2xlIC09IEFuZ2xlLlBJX1RJTUVTXzI7IH1cbiAgd2hpbGUgKGFuZ2xlIDw9IC1NYXRoLlBJKSB7IGFuZ2xlICs9IEFuZ2xlLlBJX1RJTUVTXzI7IH1cbiAgcmV0dXJuIGFuZ2xlXG59O1xuQW5nbGUuYW5nbGUgPSBmdW5jdGlvbiBhbmdsZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIE1hdGguYXRhbjIocC55LCBwLngpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gICAgdmFyIGR5ID0gcDEueSAtIHAwLnk7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoZHksIGR4KVxuICB9XG59O1xuQW5nbGUuaXNBY3V0ZSA9IGZ1bmN0aW9uIGlzQWN1dGUgKHAwLCBwMSwgcDIpIHtcbiAgdmFyIGR4MCA9IHAwLnggLSBwMS54O1xuICB2YXIgZHkwID0gcDAueSAtIHAxLnk7XG4gIHZhciBkeDEgPSBwMi54IC0gcDEueDtcbiAgdmFyIGR5MSA9IHAyLnkgLSBwMS55O1xuICB2YXIgZG90cHJvZCA9IGR4MCAqIGR4MSArIGR5MCAqIGR5MTtcbiAgcmV0dXJuIGRvdHByb2QgPiAwXG59O1xuQW5nbGUuaXNPYnR1c2UgPSBmdW5jdGlvbiBpc09idHVzZSAocDAsIHAxLCBwMikge1xuICB2YXIgZHgwID0gcDAueCAtIHAxLng7XG4gIHZhciBkeTAgPSBwMC55IC0gcDEueTtcbiAgdmFyIGR4MSA9IHAyLnggLSBwMS54O1xuICB2YXIgZHkxID0gcDIueSAtIHAxLnk7XG4gIHZhciBkb3Rwcm9kID0gZHgwICogZHgxICsgZHkwICogZHkxO1xuICByZXR1cm4gZG90cHJvZCA8IDBcbn07XG5BbmdsZS5pbnRlcmlvckFuZ2xlID0gZnVuY3Rpb24gaW50ZXJpb3JBbmdsZSAocDAsIHAxLCBwMikge1xuICB2YXIgYW5nbGVQcmV2ID0gQW5nbGUuYW5nbGUocDEsIHAwKTtcbiAgdmFyIGFuZ2xlTmV4dCA9IEFuZ2xlLmFuZ2xlKHAxLCBwMik7XG4gIHJldHVybiBNYXRoLmFicyhhbmdsZU5leHQgLSBhbmdsZVByZXYpXG59O1xuQW5nbGUubm9ybWFsaXplUG9zaXRpdmUgPSBmdW5jdGlvbiBub3JtYWxpemVQb3NpdGl2ZSAoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlIDwgMC4wKSB7XG4gICAgd2hpbGUgKGFuZ2xlIDwgMC4wKSB7IGFuZ2xlICs9IEFuZ2xlLlBJX1RJTUVTXzI7IH1cbiAgICBpZiAoYW5nbGUgPj0gQW5nbGUuUElfVElNRVNfMikgeyBhbmdsZSA9IDAuMDsgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChhbmdsZSA+PSBBbmdsZS5QSV9USU1FU18yKSB7IGFuZ2xlIC09IEFuZ2xlLlBJX1RJTUVTXzI7IH1cbiAgICBpZiAoYW5nbGUgPCAwLjApIHsgYW5nbGUgPSAwLjA7IH1cbiAgfVxuICByZXR1cm4gYW5nbGVcbn07XG5BbmdsZS5hbmdsZUJldHdlZW4gPSBmdW5jdGlvbiBhbmdsZUJldHdlZW4gKHRpcDEsIHRhaWwsIHRpcDIpIHtcbiAgdmFyIGExID0gQW5nbGUuYW5nbGUodGFpbCwgdGlwMSk7XG4gIHZhciBhMiA9IEFuZ2xlLmFuZ2xlKHRhaWwsIHRpcDIpO1xuICByZXR1cm4gQW5nbGUuZGlmZihhMSwgYTIpXG59O1xuQW5nbGUuZGlmZiA9IGZ1bmN0aW9uIGRpZmYgKGFuZzEsIGFuZzIpIHtcbiAgdmFyIGRlbEFuZ2xlID0gbnVsbDtcbiAgaWYgKGFuZzEgPCBhbmcyKSB7XG4gICAgZGVsQW5nbGUgPSBhbmcyIC0gYW5nMTtcbiAgfSBlbHNlIHtcbiAgICBkZWxBbmdsZSA9IGFuZzEgLSBhbmcyO1xuICB9XG4gIGlmIChkZWxBbmdsZSA+IE1hdGguUEkpIHtcbiAgICBkZWxBbmdsZSA9IDIgKiBNYXRoLlBJIC0gZGVsQW5nbGU7XG4gIH1cbiAgcmV0dXJuIGRlbEFuZ2xlXG59O1xuQW5nbGUudG9SYWRpYW5zID0gZnVuY3Rpb24gdG9SYWRpYW5zIChhbmdsZURlZ3JlZXMpIHtcbiAgcmV0dXJuIGFuZ2xlRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMFxufTtcbkFuZ2xlLmdldFR1cm4gPSBmdW5jdGlvbiBnZXRUdXJuIChhbmcxLCBhbmcyKSB7XG4gIHZhciBjcm9zc3Byb2R1Y3QgPSBNYXRoLnNpbihhbmcyIC0gYW5nMSk7XG4gIGlmIChjcm9zc3Byb2R1Y3QgPiAwKSB7XG4gICAgcmV0dXJuIEFuZ2xlLkNPVU5URVJDTE9DS1dJU0VcbiAgfVxuICBpZiAoY3Jvc3Nwcm9kdWN0IDwgMCkge1xuICAgIHJldHVybiBBbmdsZS5DTE9DS1dJU0VcbiAgfVxuICByZXR1cm4gQW5nbGUuTk9ORVxufTtcbkFuZ2xlLmFuZ2xlQmV0d2Vlbk9yaWVudGVkID0gZnVuY3Rpb24gYW5nbGVCZXR3ZWVuT3JpZW50ZWQgKHRpcDEsIHRhaWwsIHRpcDIpIHtcbiAgdmFyIGExID0gQW5nbGUuYW5nbGUodGFpbCwgdGlwMSk7XG4gIHZhciBhMiA9IEFuZ2xlLmFuZ2xlKHRhaWwsIHRpcDIpO1xuICB2YXIgYW5nRGVsID0gYTIgLSBhMTtcbiAgaWYgKGFuZ0RlbCA8PSAtTWF0aC5QSSkgeyByZXR1cm4gYW5nRGVsICsgQW5nbGUuUElfVElNRVNfMiB9XG4gIGlmIChhbmdEZWwgPiBNYXRoLlBJKSB7IHJldHVybiBhbmdEZWwgLSBBbmdsZS5QSV9USU1FU18yIH1cbiAgcmV0dXJuIGFuZ0RlbFxufTtcbnN0YXRpY0FjY2Vzc29ycyQyOS5QSV9USU1FU18yLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIuMCAqIE1hdGguUEkgfTtcbnN0YXRpY0FjY2Vzc29ycyQyOS5QSV9PVkVSXzIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF0aC5QSSAvIDIuMCB9O1xuc3RhdGljQWNjZXNzb3JzJDI5LlBJX09WRVJfNC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXRoLlBJIC8gNC4wIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjkuQ09VTlRFUkNMT0NLV0lTRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ09VTlRFUkNMT0NLV0lTRSB9O1xuc3RhdGljQWNjZXNzb3JzJDI5LkNMT0NLV0lTRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjkuTk9ORS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ09MTElORUFSIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBBbmdsZSwgc3RhdGljQWNjZXNzb3JzJDI5ICk7XG5cbnZhciBPZmZzZXRTZWdtZW50R2VuZXJhdG9yID0gZnVuY3Rpb24gT2Zmc2V0U2VnbWVudEdlbmVyYXRvciAoKSB7XG4gIHRoaXMuX21heEN1cnZlU2VnbWVudEVycm9yID0gMC4wO1xuICB0aGlzLl9maWxsZXRBbmdsZVF1YW50dW0gPSBudWxsO1xuICB0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yID0gMTtcbiAgdGhpcy5fc2VnTGlzdCA9IG51bGw7XG4gIHRoaXMuX2Rpc3RhbmNlID0gMC4wO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IG51bGw7XG4gIHRoaXMuX2J1ZlBhcmFtcyA9IG51bGw7XG4gIHRoaXMuX2xpID0gbnVsbDtcbiAgdGhpcy5fczAgPSBudWxsO1xuICB0aGlzLl9zMSA9IG51bGw7XG4gIHRoaXMuX3MyID0gbnVsbDtcbiAgdGhpcy5fc2VnMCA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLl9zZWcxID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuX29mZnNldDAgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5fb2Zmc2V0MSA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLl9zaWRlID0gMDtcbiAgdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlID0gZmFsc2U7XG4gIHZhciBwcmVjaXNpb25Nb2RlbCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGJ1ZlBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IHByZWNpc2lvbk1vZGVsO1xuICB0aGlzLl9idWZQYXJhbXMgPSBidWZQYXJhbXM7XG4gIHRoaXMuX2xpID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICB0aGlzLl9maWxsZXRBbmdsZVF1YW50dW0gPSBNYXRoLlBJIC8gMi4wIC8gYnVmUGFyYW1zLmdldFF1YWRyYW50U2VnbWVudHMoKTtcbiAgaWYgKGJ1ZlBhcmFtcy5nZXRRdWFkcmFudFNlZ21lbnRzKCkgPj0gOCAmJiBidWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCkgPT09IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9ST1VORCkgeyB0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yID0gT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUjsgfVxuICB0aGlzLmluaXQoZGlzdGFuY2UpO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyNyA9IHsgT0ZGU0VUX1NFR01FTlRfU0VQQVJBVElPTl9GQUNUT1I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxNQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTmV4dFNlZ21lbnQgPSBmdW5jdGlvbiBhZGROZXh0U2VnbWVudCAocCwgYWRkU3RhcnRQb2ludCkge1xuICB0aGlzLl9zMCA9IHRoaXMuX3MxO1xuICB0aGlzLl9zMSA9IHRoaXMuX3MyO1xuICB0aGlzLl9zMiA9IHA7XG4gIHRoaXMuX3NlZzAuc2V0Q29vcmRpbmF0ZXModGhpcy5fczAsIHRoaXMuX3MxKTtcbiAgdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcwLCB0aGlzLl9zaWRlLCB0aGlzLl9kaXN0YW5jZSwgdGhpcy5fb2Zmc2V0MCk7XG4gIHRoaXMuX3NlZzEuc2V0Q29vcmRpbmF0ZXModGhpcy5fczEsIHRoaXMuX3MyKTtcbiAgdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLl9zZWcxLCB0aGlzLl9zaWRlLCB0aGlzLl9kaXN0YW5jZSwgdGhpcy5fb2Zmc2V0MSk7XG4gIGlmICh0aGlzLl9zMS5lcXVhbHModGhpcy5fczIpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG9yaWVudGF0aW9uID0gQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbih0aGlzLl9zMCwgdGhpcy5fczEsIHRoaXMuX3MyKTtcbiAgdmFyIG91dHNpZGVUdXJuID0gKG9yaWVudGF0aW9uID09PSBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFICYmIHRoaXMuX3NpZGUgPT09IFBvc2l0aW9uLkxFRlQpIHx8IChvcmllbnRhdGlvbiA9PT0gQ0dBbGdvcml0aG1zLkNPVU5URVJDTE9DS1dJU0UgJiYgdGhpcy5fc2lkZSA9PT0gUG9zaXRpb24uUklHSFQpO1xuICBpZiAob3JpZW50YXRpb24gPT09IDApIHtcbiAgICB0aGlzLmFkZENvbGxpbmVhcihhZGRTdGFydFBvaW50KTtcbiAgfSBlbHNlIGlmIChvdXRzaWRlVHVybikge1xuICAgIHRoaXMuYWRkT3V0c2lkZVR1cm4ob3JpZW50YXRpb24sIGFkZFN0YXJ0UG9pbnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYWRkSW5zaWRlVHVybihvcmllbnRhdGlvbiwgYWRkU3RhcnRQb2ludCk7XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRMaW5lRW5kQ2FwID0gZnVuY3Rpb24gYWRkTGluZUVuZENhcCAocDAsIHAxKSB7XG4gIHZhciBzZWcgPSBuZXcgTGluZVNlZ21lbnQocDAsIHAxKTtcbiAgdmFyIG9mZnNldEwgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChzZWcsIFBvc2l0aW9uLkxFRlQsIHRoaXMuX2Rpc3RhbmNlLCBvZmZzZXRMKTtcbiAgdmFyIG9mZnNldFIgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChzZWcsIFBvc2l0aW9uLlJJR0hULCB0aGlzLl9kaXN0YW5jZSwgb2Zmc2V0Uik7XG4gIHZhciBkeCA9IHAxLnggLSBwMC54O1xuICB2YXIgZHkgPSBwMS55IC0gcDAueTtcbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihkeSwgZHgpO1xuICBzd2l0Y2ggKHRoaXMuX2J1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKSB7XG4gICAgY2FzZSBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9ST1VORDpcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQob2Zmc2V0TC5wMSk7XG4gICAgICB0aGlzLmFkZEZpbGxldEFyYyhwMSwgYW5nbGUgKyBNYXRoLlBJIC8gMiwgYW5nbGUgLSBNYXRoLlBJIC8gMiwgQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSwgdGhpcy5fZGlzdGFuY2UpO1xuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChvZmZzZXRSLnAxKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9GTEFUOlxuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChvZmZzZXRMLnAxKTtcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQob2Zmc2V0Ui5wMSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgQnVmZmVyUGFyYW1ldGVycy5DQVBfU1FVQVJFOlxuICAgICAgdmFyIHNxdWFyZUNhcFNpZGVPZmZzZXQgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgICAgc3F1YXJlQ2FwU2lkZU9mZnNldC54ID0gTWF0aC5hYnModGhpcy5fZGlzdGFuY2UpICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgc3F1YXJlQ2FwU2lkZU9mZnNldC55ID0gTWF0aC5hYnModGhpcy5fZGlzdGFuY2UpICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdmFyIHNxdWFyZUNhcExPZmZzZXQgPSBuZXcgQ29vcmRpbmF0ZShvZmZzZXRMLnAxLnggKyBzcXVhcmVDYXBTaWRlT2Zmc2V0LngsIG9mZnNldEwucDEueSArIHNxdWFyZUNhcFNpZGVPZmZzZXQueSk7XG4gICAgICB2YXIgc3F1YXJlQ2FwUk9mZnNldCA9IG5ldyBDb29yZGluYXRlKG9mZnNldFIucDEueCArIHNxdWFyZUNhcFNpZGVPZmZzZXQueCwgb2Zmc2V0Ui5wMS55ICsgc3F1YXJlQ2FwU2lkZU9mZnNldC55KTtcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQoc3F1YXJlQ2FwTE9mZnNldCk7XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHNxdWFyZUNhcFJPZmZzZXQpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gIHZhciBwdHMgPSB0aGlzLl9zZWdMaXN0LmdldENvb3JkaW5hdGVzKCk7XG4gIHJldHVybiBwdHNcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRNaXRyZUpvaW4gPSBmdW5jdGlvbiBhZGRNaXRyZUpvaW4gKHAsIG9mZnNldDAsIG9mZnNldDEsIGRpc3RhbmNlKSB7XG4gIHZhciBpc01pdHJlV2l0aGluTGltaXQgPSB0cnVlO1xuICB2YXIgaW50UHQgPSBudWxsO1xuICB0cnkge1xuICAgIGludFB0ID0gSENvb3JkaW5hdGUuaW50ZXJzZWN0aW9uKG9mZnNldDAucDAsIG9mZnNldDAucDEsIG9mZnNldDEucDAsIG9mZnNldDEucDEpO1xuICAgIHZhciBtaXRyZVJhdGlvID0gZGlzdGFuY2UgPD0gMC4wID8gMS4wIDogaW50UHQuZGlzdGFuY2UocCkgLyBNYXRoLmFicyhkaXN0YW5jZSk7XG4gICAgaWYgKG1pdHJlUmF0aW8gPiB0aGlzLl9idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKSB7IGlzTWl0cmVXaXRoaW5MaW1pdCA9IGZhbHNlOyB9XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbikge1xuICAgICAgaW50UHQgPSBuZXcgQ29vcmRpbmF0ZSgwLCAwKTtcbiAgICAgIGlzTWl0cmVXaXRoaW5MaW1pdCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7IHRocm93IGV4IH1cbiAgfSBmaW5hbGx5IHt9XG4gIGlmIChpc01pdHJlV2l0aGluTGltaXQpIHtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KGludFB0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmFkZExpbWl0ZWRNaXRyZUpvaW4ob2Zmc2V0MCwgb2Zmc2V0MSwgZGlzdGFuY2UsIHRoaXMuX2J1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkpO1xuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkRmlsbGV0Q29ybmVyID0gZnVuY3Rpb24gYWRkRmlsbGV0Q29ybmVyIChwLCBwMCwgcDEsIGRpcmVjdGlvbiwgcmFkaXVzKSB7XG4gIHZhciBkeDAgPSBwMC54IC0gcC54O1xuICB2YXIgZHkwID0gcDAueSAtIHAueTtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKGR5MCwgZHgwKTtcbiAgdmFyIGR4MSA9IHAxLnggLSBwLng7XG4gIHZhciBkeTEgPSBwMS55IC0gcC55O1xuICB2YXIgZW5kQW5nbGUgPSBNYXRoLmF0YW4yKGR5MSwgZHgxKTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSkge1xuICAgIGlmIChzdGFydEFuZ2xlIDw9IGVuZEFuZ2xlKSB7IHN0YXJ0QW5nbGUgKz0gMi4wICogTWF0aC5QSTsgfVxuICB9IGVsc2Uge1xuICAgIGlmIChzdGFydEFuZ2xlID49IGVuZEFuZ2xlKSB7IHN0YXJ0QW5nbGUgLT0gMi4wICogTWF0aC5QSTsgfVxuICB9XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQocDApO1xuICB0aGlzLmFkZEZpbGxldEFyYyhwLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZGlyZWN0aW9uLCByYWRpdXMpO1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KHAxKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRPdXRzaWRlVHVybiA9IGZ1bmN0aW9uIGFkZE91dHNpZGVUdXJuIChvcmllbnRhdGlvbiwgYWRkU3RhcnRQb2ludCkge1xuICBpZiAodGhpcy5fb2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLl9vZmZzZXQxLnAwKSA8IHRoaXMuX2Rpc3RhbmNlICogT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUikge1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSk7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAodGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpID09PSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fTUlUUkUpIHtcbiAgICB0aGlzLmFkZE1pdHJlSm9pbih0aGlzLl9zMSwgdGhpcy5fb2Zmc2V0MCwgdGhpcy5fb2Zmc2V0MSwgdGhpcy5fZGlzdGFuY2UpO1xuICB9IGVsc2UgaWYgKHRoaXMuX2J1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKSA9PT0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX0JFVkVMKSB7XG4gICAgdGhpcy5hZGRCZXZlbEpvaW4odGhpcy5fb2Zmc2V0MCwgdGhpcy5fb2Zmc2V0MSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGFkZFN0YXJ0UG9pbnQpIHsgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTsgfVxuICAgIHRoaXMuYWRkRmlsbGV0Q29ybmVyKHRoaXMuX3MxLCB0aGlzLl9vZmZzZXQwLnAxLCB0aGlzLl9vZmZzZXQxLnAwLCBvcmllbnRhdGlvbiwgdGhpcy5fZGlzdGFuY2UpO1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCk7XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5jcmVhdGVTcXVhcmUgPSBmdW5jdGlvbiBjcmVhdGVTcXVhcmUgKHApIHtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgQ29vcmRpbmF0ZShwLnggKyB0aGlzLl9kaXN0YW5jZSwgcC55ICsgdGhpcy5fZGlzdGFuY2UpKTtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgQ29vcmRpbmF0ZShwLnggKyB0aGlzLl9kaXN0YW5jZSwgcC55IC0gdGhpcy5fZGlzdGFuY2UpKTtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgQ29vcmRpbmF0ZShwLnggLSB0aGlzLl9kaXN0YW5jZSwgcC55IC0gdGhpcy5fZGlzdGFuY2UpKTtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChuZXcgQ29vcmRpbmF0ZShwLnggLSB0aGlzLl9kaXN0YW5jZSwgcC55ICsgdGhpcy5fZGlzdGFuY2UpKTtcbiAgdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRTZWdtZW50cyA9IGZ1bmN0aW9uIGFkZFNlZ21lbnRzIChwdCwgaXNGb3J3YXJkKSB7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHRzKHB0LCBpc0ZvcndhcmQpO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZEZpcnN0U2VnbWVudCA9IGZ1bmN0aW9uIGFkZEZpcnN0U2VnbWVudCAoKSB7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTGFzdFNlZ21lbnQgPSBmdW5jdGlvbiBhZGRMYXN0U2VnbWVudCAoKSB7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMSk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuaW5pdFNpZGVTZWdtZW50cyA9IGZ1bmN0aW9uIGluaXRTaWRlU2VnbWVudHMgKHMxLCBzMiwgc2lkZSkge1xuICB0aGlzLl9zMSA9IHMxO1xuICB0aGlzLl9zMiA9IHMyO1xuICB0aGlzLl9zaWRlID0gc2lkZTtcbiAgdGhpcy5fc2VnMS5zZXRDb29yZGluYXRlcyhzMSwgczIpO1xuICB0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzEsIHNpZGUsIHRoaXMuX2Rpc3RhbmNlLCB0aGlzLl9vZmZzZXQxKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRMaW1pdGVkTWl0cmVKb2luID0gZnVuY3Rpb24gYWRkTGltaXRlZE1pdHJlSm9pbiAob2Zmc2V0MCwgb2Zmc2V0MSwgZGlzdGFuY2UsIG1pdHJlTGltaXQpIHtcbiAgdmFyIGJhc2VQdCA9IHRoaXMuX3NlZzAucDE7XG4gIHZhciBhbmcwID0gQW5nbGUuYW5nbGUoYmFzZVB0LCB0aGlzLl9zZWcwLnAwKTtcbiAgLy8gY29uc3QgYW5nMSA9IEFuZ2xlLmFuZ2xlKGJhc2VQdCwgdGhpcy5fc2VnMS5wMSlcbiAgdmFyIGFuZ0RpZmYgPSBBbmdsZS5hbmdsZUJldHdlZW5PcmllbnRlZCh0aGlzLl9zZWcwLnAwLCBiYXNlUHQsIHRoaXMuX3NlZzEucDEpO1xuICB2YXIgYW5nRGlmZkhhbGYgPSBhbmdEaWZmIC8gMjtcbiAgdmFyIG1pZEFuZyA9IEFuZ2xlLm5vcm1hbGl6ZShhbmcwICsgYW5nRGlmZkhhbGYpO1xuICB2YXIgbWl0cmVNaWRBbmcgPSBBbmdsZS5ub3JtYWxpemUobWlkQW5nICsgTWF0aC5QSSk7XG4gIHZhciBtaXRyZURpc3QgPSBtaXRyZUxpbWl0ICogZGlzdGFuY2U7XG4gIHZhciBiZXZlbERlbHRhID0gbWl0cmVEaXN0ICogTWF0aC5hYnMoTWF0aC5zaW4oYW5nRGlmZkhhbGYpKTtcbiAgdmFyIGJldmVsSGFsZkxlbiA9IGRpc3RhbmNlIC0gYmV2ZWxEZWx0YTtcbiAgdmFyIGJldmVsTWlkWCA9IGJhc2VQdC54ICsgbWl0cmVEaXN0ICogTWF0aC5jb3MobWl0cmVNaWRBbmcpO1xuICB2YXIgYmV2ZWxNaWRZID0gYmFzZVB0LnkgKyBtaXRyZURpc3QgKiBNYXRoLnNpbihtaXRyZU1pZEFuZyk7XG4gIHZhciBiZXZlbE1pZFB0ID0gbmV3IENvb3JkaW5hdGUoYmV2ZWxNaWRYLCBiZXZlbE1pZFkpO1xuICB2YXIgbWl0cmVNaWRMaW5lID0gbmV3IExpbmVTZWdtZW50KGJhc2VQdCwgYmV2ZWxNaWRQdCk7XG4gIHZhciBiZXZlbEVuZExlZnQgPSBtaXRyZU1pZExpbmUucG9pbnRBbG9uZ09mZnNldCgxLjAsIGJldmVsSGFsZkxlbik7XG4gIHZhciBiZXZlbEVuZFJpZ2h0ID0gbWl0cmVNaWRMaW5lLnBvaW50QWxvbmdPZmZzZXQoMS4wLCAtYmV2ZWxIYWxmTGVuKTtcbiAgaWYgKHRoaXMuX3NpZGUgPT09IFBvc2l0aW9uLkxFRlQpIHtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KGJldmVsRW5kTGVmdCk7XG4gICAgdGhpcy5fc2VnTGlzdC5hZGRQdChiZXZlbEVuZFJpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KGJldmVsRW5kUmlnaHQpO1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQoYmV2ZWxFbmRMZWZ0KTtcbiAgfVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmNvbXB1dGVPZmZzZXRTZWdtZW50ID0gZnVuY3Rpb24gY29tcHV0ZU9mZnNldFNlZ21lbnQgKHNlZywgc2lkZSwgZGlzdGFuY2UsIG9mZnNldCkge1xuICB2YXIgc2lkZVNpZ24gPSBzaWRlID09PSBQb3NpdGlvbi5MRUZUID8gMSA6IC0xO1xuICB2YXIgZHggPSBzZWcucDEueCAtIHNlZy5wMC54O1xuICB2YXIgZHkgPSBzZWcucDEueSAtIHNlZy5wMC55O1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgdmFyIHV4ID0gc2lkZVNpZ24gKiBkaXN0YW5jZSAqIGR4IC8gbGVuO1xuICB2YXIgdXkgPSBzaWRlU2lnbiAqIGRpc3RhbmNlICogZHkgLyBsZW47XG4gIG9mZnNldC5wMC54ID0gc2VnLnAwLnggLSB1eTtcbiAgb2Zmc2V0LnAwLnkgPSBzZWcucDAueSArIHV4O1xuICBvZmZzZXQucDEueCA9IHNlZy5wMS54IC0gdXk7XG4gIG9mZnNldC5wMS55ID0gc2VnLnAxLnkgKyB1eDtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRGaWxsZXRBcmMgPSBmdW5jdGlvbiBhZGRGaWxsZXRBcmMgKHAsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBkaXJlY3Rpb24sIHJhZGl1cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBkaXJlY3Rpb25GYWN0b3IgPSBkaXJlY3Rpb24gPT09IENHQWxnb3JpdGhtcy5DTE9DS1dJU0UgPyAtMSA6IDE7XG4gIHZhciB0b3RhbEFuZ2xlID0gTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKTtcbiAgdmFyIG5TZWdzID0gTWF0aC50cnVuYyh0b3RhbEFuZ2xlIC8gdGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtICsgMC41KTtcbiAgaWYgKG5TZWdzIDwgMSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBpbml0QW5nbGUgPSAwLjA7XG4gIHZhciBjdXJyQW5nbGVJbmMgPSB0b3RhbEFuZ2xlIC8gblNlZ3M7XG4gIHZhciBjdXJyQW5nbGUgPSBpbml0QW5nbGU7XG4gIHZhciBwdCA9IG5ldyBDb29yZGluYXRlKCk7XG4gIHdoaWxlIChjdXJyQW5nbGUgPCB0b3RhbEFuZ2xlKSB7XG4gICAgdmFyIGFuZ2xlID0gc3RhcnRBbmdsZSArIGRpcmVjdGlvbkZhY3RvciAqIGN1cnJBbmdsZTtcbiAgICBwdC54ID0gcC54ICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIHB0LnkgPSBwLnkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdGhpcyQxLl9zZWdMaXN0LmFkZFB0KHB0KTtcbiAgICBjdXJyQW5nbGUgKz0gY3VyckFuZ2xlSW5jO1xuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkSW5zaWRlVHVybiA9IGZ1bmN0aW9uIGFkZEluc2lkZVR1cm4gKG9yaWVudGF0aW9uLCBhZGRTdGFydFBvaW50KSB7XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5fb2Zmc2V0MC5wMCwgdGhpcy5fb2Zmc2V0MC5wMSwgdGhpcy5fb2Zmc2V0MS5wMCwgdGhpcy5fb2Zmc2V0MS5wMSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGUgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMuX29mZnNldDEucDApIDwgdGhpcy5fZGlzdGFuY2UgKiBPZmZzZXRTZWdtZW50R2VuZXJhdG9yLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUikge1xuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTtcbiAgICAgIGlmICh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yID4gMCkge1xuICAgICAgICB2YXIgbWlkMCA9IG5ldyBDb29yZGluYXRlKCh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICogdGhpcy5fb2Zmc2V0MC5wMS54ICsgdGhpcy5fczEueCkgLyAodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciArIDEpLCAodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciAqIHRoaXMuX29mZnNldDAucDEueSArIHRoaXMuX3MxLnkpIC8gKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgKyAxKSk7XG4gICAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQobWlkMCk7XG4gICAgICAgIHZhciBtaWQxID0gbmV3IENvb3JkaW5hdGUoKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgKiB0aGlzLl9vZmZzZXQxLnAwLnggKyB0aGlzLl9zMS54KSAvICh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICsgMSksICh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICogdGhpcy5fb2Zmc2V0MS5wMC55ICsgdGhpcy5fczEueSkgLyAodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciArIDEpKTtcbiAgICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChtaWQxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fczEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKTtcbiAgICB9XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5jcmVhdGVDaXJjbGUgPSBmdW5jdGlvbiBjcmVhdGVDaXJjbGUgKHApIHtcbiAgdmFyIHB0ID0gbmV3IENvb3JkaW5hdGUocC54ICsgdGhpcy5fZGlzdGFuY2UsIHAueSk7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQocHQpO1xuICB0aGlzLmFkZEZpbGxldEFyYyhwLCAwLjAsIDIuMCAqIE1hdGguUEksIC0xLCB0aGlzLl9kaXN0YW5jZSk7XG4gIHRoaXMuX3NlZ0xpc3QuY2xvc2VSaW5nKCk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkQmV2ZWxKb2luID0gZnVuY3Rpb24gYWRkQmV2ZWxKb2luIChvZmZzZXQwLCBvZmZzZXQxKSB7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQob2Zmc2V0MC5wMSk7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQob2Zmc2V0MS5wMCk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGRpc3RhbmNlKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIHRoaXMuX21heEN1cnZlU2VnbWVudEVycm9yID0gZGlzdGFuY2UgKiAoMSAtIE1hdGguY29zKHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bSAvIDIuMCkpO1xuICB0aGlzLl9zZWdMaXN0ID0gbmV3IE9mZnNldFNlZ21lbnRTdHJpbmcoKTtcbiAgdGhpcy5fc2VnTGlzdC5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLl9wcmVjaXNpb25Nb2RlbCk7XG4gIHRoaXMuX3NlZ0xpc3Quc2V0TWluaW11bVZlcnRleERpc3RhbmNlKGRpc3RhbmNlICogT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5DVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IpO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZENvbGxpbmVhciA9IGZ1bmN0aW9uIGFkZENvbGxpbmVhciAoYWRkU3RhcnRQb2ludCkge1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMuX3MwLCB0aGlzLl9zMSwgdGhpcy5fczEsIHRoaXMuX3MyKTtcbiAgdmFyIG51bUludCA9IHRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpO1xuICBpZiAobnVtSW50ID49IDIpIHtcbiAgICBpZiAodGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpID09PSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fQkVWRUwgfHwgdGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpID09PSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fTUlUUkUpIHtcbiAgICAgIGlmIChhZGRTdGFydFBvaW50KSB7IHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MC5wMSk7IH1cbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQodGhpcy5fb2Zmc2V0MS5wMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRmlsbGV0Q29ybmVyKHRoaXMuX3MxLCB0aGlzLl9vZmZzZXQwLnAxLCB0aGlzLl9vZmZzZXQxLnAwLCBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFLCB0aGlzLl9kaXN0YW5jZSk7XG4gICAgfVxuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuY2xvc2VSaW5nID0gZnVuY3Rpb24gY2xvc2VSaW5nICgpIHtcbiAgdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5oYXNOYXJyb3dDb25jYXZlQW5nbGUgPSBmdW5jdGlvbiBoYXNOYXJyb3dDb25jYXZlQW5nbGUgKCkge1xuICByZXR1cm4gdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlXG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT2Zmc2V0U2VnbWVudEdlbmVyYXRvclxufTtcbnN0YXRpY0FjY2Vzc29ycyQyNy5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxLjBFLTMgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNy5JTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMS4wRS0zIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjcuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEuMEUtNiB9O1xuc3RhdGljQWNjZXNzb3JzJDI3Lk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDgwIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBPZmZzZXRTZWdtZW50R2VuZXJhdG9yLCBzdGF0aWNBY2Nlc3NvcnMkMjcgKTtcblxudmFyIE9mZnNldEN1cnZlQnVpbGRlciA9IGZ1bmN0aW9uIE9mZnNldEN1cnZlQnVpbGRlciAoKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gMC4wO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IG51bGw7XG4gIHRoaXMuX2J1ZlBhcmFtcyA9IG51bGw7XG4gIHZhciBwcmVjaXNpb25Nb2RlbCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGJ1ZlBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBwcmVjaXNpb25Nb2RlbDtcbiAgdGhpcy5fYnVmUGFyYW1zID0gYnVmUGFyYW1zO1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuZ2V0T2Zmc2V0Q3VydmUgPSBmdW5jdGlvbiBnZXRPZmZzZXRDdXJ2ZSAoaW5wdXRQdHMsIGRpc3RhbmNlKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIGlmIChkaXN0YW5jZSA9PT0gMC4wKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGlzUmlnaHRTaWRlID0gZGlzdGFuY2UgPCAwLjA7XG4gIHZhciBwb3NEaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKTtcbiAgdmFyIHNlZ0dlbiA9IHRoaXMuZ2V0U2VnR2VuKHBvc0Rpc3RhbmNlKTtcbiAgaWYgKGlucHV0UHRzLmxlbmd0aCA8PSAxKSB7XG4gICAgdGhpcy5jb21wdXRlUG9pbnRDdXJ2ZShpbnB1dFB0c1swXSwgc2VnR2VuKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNvbXB1dGVPZmZzZXRDdXJ2ZShpbnB1dFB0cywgaXNSaWdodFNpZGUsIHNlZ0dlbik7XG4gIH1cbiAgdmFyIGN1cnZlUHRzID0gc2VnR2VuLmdldENvb3JkaW5hdGVzKCk7XG4gIGlmIChpc1JpZ2h0U2lkZSkgeyBDb29yZGluYXRlQXJyYXlzLnJldmVyc2UoY3VydmVQdHMpOyB9XG4gIHJldHVybiBjdXJ2ZVB0c1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUgPSBmdW5jdGlvbiBjb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZSAoaW5wdXRQdHMsIGlzUmlnaHRTaWRlLCBzZWdHZW4pIHtcbiAgdmFyIGRpc3RUb2wgPSB0aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtcbiAgaWYgKGlzUmlnaHRTaWRlKSB7XG4gICAgc2VnR2VuLmFkZFNlZ21lbnRzKGlucHV0UHRzLCB0cnVlKTtcbiAgICB2YXIgc2ltcDIgPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KGlucHV0UHRzLCAtZGlzdFRvbCk7XG4gICAgdmFyIG4yID0gc2ltcDIubGVuZ3RoIC0gMTtcbiAgICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wMltuMl0sIHNpbXAyW24yIC0gMV0sIFBvc2l0aW9uLkxFRlQpO1xuICAgIHNlZ0dlbi5hZGRGaXJzdFNlZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpID0gbjIgLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgc2VnR2VuLmFkZE5leHRTZWdtZW50KHNpbXAyW2ldLCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2VnR2VuLmFkZFNlZ21lbnRzKGlucHV0UHRzLCBmYWxzZSk7XG4gICAgdmFyIHNpbXAxID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgZGlzdFRvbCk7XG4gICAgdmFyIG4xID0gc2ltcDEubGVuZ3RoIC0gMTtcbiAgICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wMVswXSwgc2ltcDFbMV0sIFBvc2l0aW9uLkxFRlQpO1xuICAgIHNlZ0dlbi5hZGRGaXJzdFNlZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpJDEgPSAyOyBpJDEgPD0gbjE7IGkkMSsrKSB7XG4gICAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcDFbaSQxXSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIHNlZ0dlbi5hZGRMYXN0U2VnbWVudCgpO1xuICBzZWdHZW4uY2xvc2VSaW5nKCk7XG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5jb21wdXRlUmluZ0J1ZmZlckN1cnZlID0gZnVuY3Rpb24gY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZSAoaW5wdXRQdHMsIHNpZGUsIHNlZ0dlbikge1xuICB2YXIgZGlzdFRvbCA9IHRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO1xuICBpZiAoc2lkZSA9PT0gUG9zaXRpb24uUklHSFQpIHsgZGlzdFRvbCA9IC1kaXN0VG9sOyB9XG4gIHZhciBzaW1wID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgZGlzdFRvbCk7XG4gIHZhciBuID0gc2ltcC5sZW5ndGggLSAxO1xuICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wW24gLSAxXSwgc2ltcFswXSwgc2lkZSk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IG47IGkrKykge1xuICAgIHZhciBhZGRTdGFydFBvaW50ID0gaSAhPT0gMTtcbiAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcFtpXSwgYWRkU3RhcnRQb2ludCk7XG4gIH1cbiAgc2VnR2VuLmNsb3NlUmluZygpO1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSA9IGZ1bmN0aW9uIGNvbXB1dGVMaW5lQnVmZmVyQ3VydmUgKGlucHV0UHRzLCBzZWdHZW4pIHtcbiAgdmFyIGRpc3RUb2wgPSB0aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuX2Rpc3RhbmNlKTtcbiAgdmFyIHNpbXAxID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgZGlzdFRvbCk7XG4gIHZhciBuMSA9IHNpbXAxLmxlbmd0aCAtIDE7XG4gIHNlZ0dlbi5pbml0U2lkZVNlZ21lbnRzKHNpbXAxWzBdLCBzaW1wMVsxXSwgUG9zaXRpb24uTEVGVCk7XG4gIGZvciAodmFyIGkgPSAyOyBpIDw9IG4xOyBpKyspIHtcbiAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcDFbaV0sIHRydWUpO1xuICB9XG4gIHNlZ0dlbi5hZGRMYXN0U2VnbWVudCgpO1xuICBzZWdHZW4uYWRkTGluZUVuZENhcChzaW1wMVtuMSAtIDFdLCBzaW1wMVtuMV0pO1xuICB2YXIgc2ltcDIgPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KGlucHV0UHRzLCAtZGlzdFRvbCk7XG4gIHZhciBuMiA9IHNpbXAyLmxlbmd0aCAtIDE7XG4gIHNlZ0dlbi5pbml0U2lkZVNlZ21lbnRzKHNpbXAyW24yXSwgc2ltcDJbbjIgLSAxXSwgUG9zaXRpb24uTEVGVCk7XG4gIGZvciAodmFyIGkkMSA9IG4yIC0gMjsgaSQxID49IDA7IGkkMS0tKSB7XG4gICAgc2VnR2VuLmFkZE5leHRTZWdtZW50KHNpbXAyW2kkMV0sIHRydWUpO1xuICB9XG4gIHNlZ0dlbi5hZGRMYXN0U2VnbWVudCgpO1xuICBzZWdHZW4uYWRkTGluZUVuZENhcChzaW1wMlsxXSwgc2ltcDJbMF0pO1xuICBzZWdHZW4uY2xvc2VSaW5nKCk7XG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5jb21wdXRlUG9pbnRDdXJ2ZSA9IGZ1bmN0aW9uIGNvbXB1dGVQb2ludEN1cnZlIChwdCwgc2VnR2VuKSB7XG4gIHN3aXRjaCAodGhpcy5fYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpIHtcbiAgICBjYXNlIEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX1JPVU5EOlxuICAgICAgc2VnR2VuLmNyZWF0ZUNpcmNsZShwdCk7XG4gICAgICBicmVha1xuICAgIGNhc2UgQnVmZmVyUGFyYW1ldGVycy5DQVBfU1FVQVJFOlxuICAgICAgc2VnR2VuLmNyZWF0ZVNxdWFyZShwdCk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gIH1cbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmdldExpbmVDdXJ2ZSA9IGZ1bmN0aW9uIGdldExpbmVDdXJ2ZSAoaW5wdXRQdHMsIGRpc3RhbmNlKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIGlmIChkaXN0YW5jZSA8IDAuMCAmJiAhdGhpcy5fYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChkaXN0YW5jZSA9PT0gMC4wKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHBvc0Rpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2UpO1xuICB2YXIgc2VnR2VuID0gdGhpcy5nZXRTZWdHZW4ocG9zRGlzdGFuY2UpO1xuICBpZiAoaW5wdXRQdHMubGVuZ3RoIDw9IDEpIHtcbiAgICB0aGlzLmNvbXB1dGVQb2ludEN1cnZlKGlucHV0UHRzWzBdLCBzZWdHZW4pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKSB7XG4gICAgICB2YXIgaXNSaWdodFNpZGUgPSBkaXN0YW5jZSA8IDAuMDtcbiAgICAgIHRoaXMuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUoaW5wdXRQdHMsIGlzUmlnaHRTaWRlLCBzZWdHZW4pO1xuICAgIH0gZWxzZSB7IHRoaXMuY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZShpbnB1dFB0cywgc2VnR2VuKTsgfVxuICB9XG4gIHZhciBsaW5lQ29vcmQgPSBzZWdHZW4uZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgcmV0dXJuIGxpbmVDb29yZFxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuZ2V0QnVmZmVyUGFyYW1ldGVycyA9IGZ1bmN0aW9uIGdldEJ1ZmZlclBhcmFtZXRlcnMgKCkge1xuICByZXR1cm4gdGhpcy5fYnVmUGFyYW1zXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5zaW1wbGlmeVRvbGVyYW5jZSA9IGZ1bmN0aW9uIHNpbXBsaWZ5VG9sZXJhbmNlIChidWZEaXN0YW5jZSkge1xuICByZXR1cm4gYnVmRGlzdGFuY2UgKiB0aGlzLl9idWZQYXJhbXMuZ2V0U2ltcGxpZnlGYWN0b3IoKVxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuZ2V0UmluZ0N1cnZlID0gZnVuY3Rpb24gZ2V0UmluZ0N1cnZlIChpbnB1dFB0cywgc2lkZSwgZGlzdGFuY2UpIHtcbiAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgaWYgKGlucHV0UHRzLmxlbmd0aCA8PSAyKSB7IHJldHVybiB0aGlzLmdldExpbmVDdXJ2ZShpbnB1dFB0cywgZGlzdGFuY2UpIH1cbiAgaWYgKGRpc3RhbmNlID09PSAwLjApIHtcbiAgICByZXR1cm4gT2Zmc2V0Q3VydmVCdWlsZGVyLmNvcHlDb29yZGluYXRlcyhpbnB1dFB0cylcbiAgfVxuICB2YXIgc2VnR2VuID0gdGhpcy5nZXRTZWdHZW4oZGlzdGFuY2UpO1xuICB0aGlzLmNvbXB1dGVSaW5nQnVmZmVyQ3VydmUoaW5wdXRQdHMsIHNpZGUsIHNlZ0dlbik7XG4gIHJldHVybiBzZWdHZW4uZ2V0Q29vcmRpbmF0ZXMoKVxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZU9mZnNldEN1cnZlID0gZnVuY3Rpb24gY29tcHV0ZU9mZnNldEN1cnZlIChpbnB1dFB0cywgaXNSaWdodFNpZGUsIHNlZ0dlbikge1xuICB2YXIgZGlzdFRvbCA9IHRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO1xuICBpZiAoaXNSaWdodFNpZGUpIHtcbiAgICB2YXIgc2ltcDIgPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KGlucHV0UHRzLCAtZGlzdFRvbCk7XG4gICAgdmFyIG4yID0gc2ltcDIubGVuZ3RoIC0gMTtcbiAgICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wMltuMl0sIHNpbXAyW24yIC0gMV0sIFBvc2l0aW9uLkxFRlQpO1xuICAgIHNlZ0dlbi5hZGRGaXJzdFNlZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpID0gbjIgLSAyOyBpID49IDA7IGktLSkge1xuICAgICAgc2VnR2VuLmFkZE5leHRTZWdtZW50KHNpbXAyW2ldLCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNpbXAxID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeShpbnB1dFB0cywgZGlzdFRvbCk7XG4gICAgdmFyIG4xID0gc2ltcDEubGVuZ3RoIC0gMTtcbiAgICBzZWdHZW4uaW5pdFNpZGVTZWdtZW50cyhzaW1wMVswXSwgc2ltcDFbMV0sIFBvc2l0aW9uLkxFRlQpO1xuICAgIHNlZ0dlbi5hZGRGaXJzdFNlZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpJDEgPSAyOyBpJDEgPD0gbjE7IGkkMSsrKSB7XG4gICAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcDFbaSQxXSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIHNlZ0dlbi5hZGRMYXN0U2VnbWVudCgpO1xufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuZ2V0U2VnR2VuID0gZnVuY3Rpb24gZ2V0U2VnR2VuIChkaXN0YW5jZSkge1xuICByZXR1cm4gbmV3IE9mZnNldFNlZ21lbnRHZW5lcmF0b3IodGhpcy5fcHJlY2lzaW9uTW9kZWwsIHRoaXMuX2J1ZlBhcmFtcywgZGlzdGFuY2UpXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE9mZnNldEN1cnZlQnVpbGRlclxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5jb3B5Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBjb3B5Q29vcmRpbmF0ZXMgKHB0cykge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShwdHMubGVuZ3RoKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcHkubGVuZ3RoOyBpKyspIHtcbiAgICBjb3B5W2ldID0gbmV3IENvb3JkaW5hdGUocHRzW2ldKTtcbiAgfVxuICByZXR1cm4gY29weVxufTtcblxudmFyIFN1YmdyYXBoRGVwdGhMb2NhdGVyID0gZnVuY3Rpb24gU3ViZ3JhcGhEZXB0aExvY2F0ZXIgKCkge1xuICB0aGlzLl9zdWJncmFwaHMgPSBudWxsO1xuICB0aGlzLl9zZWcgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5fY2dhID0gbmV3IENHQWxnb3JpdGhtcygpO1xuICB2YXIgc3ViZ3JhcGhzID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9zdWJncmFwaHMgPSBzdWJncmFwaHM7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDMwID0geyBEZXB0aFNlZ21lbnQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblN1YmdyYXBoRGVwdGhMb2NhdGVyLnByb3RvdHlwZS5maW5kU3RhYmJlZFNlZ21lbnRzID0gZnVuY3Rpb24gZmluZFN0YWJiZWRTZWdtZW50cyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc3RhYmJpbmdSYXlMZWZ0UHQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHN0YWJiZWRTZWdtZW50cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fc3ViZ3JhcGhzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGJzZyA9IGkubmV4dCgpO1xuICAgICAgdmFyIGVudiA9IGJzZy5nZXRFbnZlbG9wZSgpO1xuICAgICAgaWYgKHN0YWJiaW5nUmF5TGVmdFB0LnkgPCBlbnYuZ2V0TWluWSgpIHx8IHN0YWJiaW5nUmF5TGVmdFB0LnkgPiBlbnYuZ2V0TWF4WSgpKSB7IGNvbnRpbnVlIH1cbiAgICAgIHRoaXMkMS5maW5kU3RhYmJlZFNlZ21lbnRzKHN0YWJiaW5nUmF5TGVmdFB0LCBic2cuZ2V0RGlyZWN0ZWRFZGdlcygpLCBzdGFiYmVkU2VnbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhYmJlZFNlZ21lbnRzXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzJdLCBMaXN0KSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBEaXJlY3RlZEVkZ2UpKSB7XG4gICAgICB2YXIgc3RhYmJpbmdSYXlMZWZ0UHQkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkaXJFZGdlID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHN0YWJiZWRTZWdtZW50cyQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIHB0cyA9IGRpckVkZ2UuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwdHMubGVuZ3RoIC0gMTsgaSQxKyspIHtcbiAgICAgICAgdGhpcyQxLl9zZWcucDAgPSBwdHNbaSQxXTtcbiAgICAgICAgdGhpcyQxLl9zZWcucDEgPSBwdHNbaSQxICsgMV07XG4gICAgICAgIGlmICh0aGlzJDEuX3NlZy5wMC55ID4gdGhpcyQxLl9zZWcucDEueSkgeyB0aGlzJDEuX3NlZy5yZXZlcnNlKCk7IH1cbiAgICAgICAgdmFyIG1heHggPSBNYXRoLm1heCh0aGlzJDEuX3NlZy5wMC54LCB0aGlzJDEuX3NlZy5wMS54KTtcbiAgICAgICAgaWYgKG1heHggPCBzdGFiYmluZ1JheUxlZnRQdCQxLngpIHsgY29udGludWUgfVxuICAgICAgICBpZiAodGhpcyQxLl9zZWcuaXNIb3Jpem9udGFsKCkpIHsgY29udGludWUgfVxuICAgICAgICBpZiAoc3RhYmJpbmdSYXlMZWZ0UHQkMS55IDwgdGhpcyQxLl9zZWcucDAueSB8fCBzdGFiYmluZ1JheUxlZnRQdCQxLnkgPiB0aGlzJDEuX3NlZy5wMS55KSB7IGNvbnRpbnVlIH1cbiAgICAgICAgaWYgKENHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24odGhpcyQxLl9zZWcucDAsIHRoaXMkMS5fc2VnLnAxLCBzdGFiYmluZ1JheUxlZnRQdCQxKSA9PT0gQ0dBbGdvcml0aG1zLlJJR0hUKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIGRlcHRoID0gZGlyRWRnZS5nZXREZXB0aChQb3NpdGlvbi5MRUZUKTtcbiAgICAgICAgaWYgKCF0aGlzJDEuX3NlZy5wMC5lcXVhbHMocHRzW2kkMV0pKSB7IGRlcHRoID0gZGlyRWRnZS5nZXREZXB0aChQb3NpdGlvbi5SSUdIVCk7IH1cbiAgICAgICAgdmFyIGRzID0gbmV3IERlcHRoU2VnbWVudCh0aGlzJDEuX3NlZywgZGVwdGgpO1xuICAgICAgICBzdGFiYmVkU2VnbWVudHMkMS5hZGQoZHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1syXSwgTGlzdCkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgTGlzdCkpKSB7XG4gICAgICB2YXIgc3RhYmJpbmdSYXlMZWZ0UHQkMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkaXJFZGdlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBzdGFiYmVkU2VnbWVudHMkMiA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGZvciAodmFyIGkkMiA9IGRpckVkZ2VzLml0ZXJhdG9yKCk7IGkkMi5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBkZSA9IGkkMi5uZXh0KCk7XG4gICAgICAgIGlmICghZGUuaXNGb3J3YXJkKCkpIHsgY29udGludWUgfVxuICAgICAgICB0aGlzJDEuZmluZFN0YWJiZWRTZWdtZW50cyhzdGFiYmluZ1JheUxlZnRQdCQyLCBkZSwgc3RhYmJlZFNlZ21lbnRzJDIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblN1YmdyYXBoRGVwdGhMb2NhdGVyLnByb3RvdHlwZS5nZXREZXB0aCA9IGZ1bmN0aW9uIGdldERlcHRoIChwKSB7XG4gIHZhciBzdGFiYmVkU2VnbWVudHMgPSB0aGlzLmZpbmRTdGFiYmVkU2VnbWVudHMocCk7XG4gIGlmIChzdGFiYmVkU2VnbWVudHMuc2l6ZSgpID09PSAwKSB7IHJldHVybiAwIH1cbiAgdmFyIGRzID0gQ29sbGVjdGlvbnMubWluKHN0YWJiZWRTZWdtZW50cyk7XG4gIHJldHVybiBkcy5fbGVmdERlcHRoXG59O1xuU3ViZ3JhcGhEZXB0aExvY2F0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TdWJncmFwaERlcHRoTG9jYXRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTdWJncmFwaERlcHRoTG9jYXRlclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzMC5EZXB0aFNlZ21lbnQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gRGVwdGhTZWdtZW50IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdWJncmFwaERlcHRoTG9jYXRlciwgc3RhdGljQWNjZXNzb3JzJDMwICk7XG5cbnZhciBEZXB0aFNlZ21lbnQgPSBmdW5jdGlvbiBEZXB0aFNlZ21lbnQgKCkge1xuICB0aGlzLl91cHdhcmRTZWcgPSBudWxsO1xuICB0aGlzLl9sZWZ0RGVwdGggPSBudWxsO1xuICB2YXIgc2VnID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZGVwdGggPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX3Vwd2FyZFNlZyA9IG5ldyBMaW5lU2VnbWVudChzZWcpO1xuICB0aGlzLl9sZWZ0RGVwdGggPSBkZXB0aDtcbn07XG5EZXB0aFNlZ21lbnQucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAob2JqKSB7XG4gIHZhciBvdGhlciA9IG9iajtcbiAgaWYgKHRoaXMuX3Vwd2FyZFNlZy5taW5YKCkgPj0gb3RoZXIuX3Vwd2FyZFNlZy5tYXhYKCkpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fdXB3YXJkU2VnLm1heFgoKSA8PSBvdGhlci5fdXB3YXJkU2VnLm1pblgoKSkgeyByZXR1cm4gLTEgfVxuICB2YXIgb3JpZW50SW5kZXggPSB0aGlzLl91cHdhcmRTZWcub3JpZW50YXRpb25JbmRleChvdGhlci5fdXB3YXJkU2VnKTtcbiAgaWYgKG9yaWVudEluZGV4ICE9PSAwKSB7IHJldHVybiBvcmllbnRJbmRleCB9XG4gIG9yaWVudEluZGV4ID0gLTEgKiBvdGhlci5fdXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgodGhpcy5fdXB3YXJkU2VnKTtcbiAgaWYgKG9yaWVudEluZGV4ICE9PSAwKSB7IHJldHVybiBvcmllbnRJbmRleCB9XG4gIHJldHVybiB0aGlzLl91cHdhcmRTZWcuY29tcGFyZVRvKG90aGVyLl91cHdhcmRTZWcpXG59O1xuRGVwdGhTZWdtZW50LnByb3RvdHlwZS5jb21wYXJlWCA9IGZ1bmN0aW9uIGNvbXBhcmVYIChzZWcwLCBzZWcxKSB7XG4gIHZhciBjb21wYXJlMCA9IHNlZzAucDAuY29tcGFyZVRvKHNlZzEucDApO1xuICBpZiAoY29tcGFyZTAgIT09IDApIHsgcmV0dXJuIGNvbXBhcmUwIH1cbiAgcmV0dXJuIHNlZzAucDEuY29tcGFyZVRvKHNlZzEucDEpXG59O1xuRGVwdGhTZWdtZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Vwd2FyZFNlZy50b1N0cmluZygpXG59O1xuRGVwdGhTZWdtZW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcbkRlcHRoU2VnbWVudC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEZXB0aFNlZ21lbnRcbn07XG5cbnZhciBUcmlhbmdsZSA9IGZ1bmN0aW9uIFRyaWFuZ2xlIChwMCwgcDEsIHAyKSB7XG4gIHRoaXMucDAgPSBwMCB8fCBudWxsO1xuICB0aGlzLnAxID0gcDEgfHwgbnVsbDtcbiAgdGhpcy5wMiA9IHAyIHx8IG51bGw7XG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmFyZWEgPSBmdW5jdGlvbiBhcmVhICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLmFyZWEodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuc2lnbmVkQXJlYSA9IGZ1bmN0aW9uIHNpZ25lZEFyZWEgKCkge1xuICByZXR1cm4gVHJpYW5nbGUuc2lnbmVkQXJlYSh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5pbnRlcnBvbGF0ZVogPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZVogKHApIHtcbiAgaWYgKHAgPT09IG51bGwpIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignU3VwcGxpZWQgcG9pbnQgaXMgbnVsbC4nKSB9XG4gIHJldHVybiBUcmlhbmdsZS5pbnRlcnBvbGF0ZVoocCwgdGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUubG9uZ2VzdFNpZGVMZW5ndGggPSBmdW5jdGlvbiBsb25nZXN0U2lkZUxlbmd0aCAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5sb25nZXN0U2lkZUxlbmd0aCh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5pc0FjdXRlID0gZnVuY3Rpb24gaXNBY3V0ZSAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5pc0FjdXRlKHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmNpcmN1bWNlbnRyZSA9IGZ1bmN0aW9uIGNpcmN1bWNlbnRyZSAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5jaXJjdW1jZW50cmUodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuYXJlYTNEID0gZnVuY3Rpb24gYXJlYTNEICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLmFyZWEzRCh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5jZW50cm9pZCA9IGZ1bmN0aW9uIGNlbnRyb2lkICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLmNlbnRyb2lkKHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmluQ2VudHJlID0gZnVuY3Rpb24gaW5DZW50cmUgKCkge1xuICByZXR1cm4gVHJpYW5nbGUuaW5DZW50cmUodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlXG59O1xuVHJpYW5nbGUuYXJlYSA9IGZ1bmN0aW9uIGFyZWEgKGEsIGIsIGMpIHtcbiAgcmV0dXJuIE1hdGguYWJzKCgoYy54IC0gYS54KSAqIChiLnkgLSBhLnkpIC0gKGIueCAtIGEueCkgKiAoYy55IC0gYS55KSkgLyAyKVxufTtcblRyaWFuZ2xlLnNpZ25lZEFyZWEgPSBmdW5jdGlvbiBzaWduZWRBcmVhIChhLCBiLCBjKSB7XG4gIHJldHVybiAoKGMueCAtIGEueCkgKiAoYi55IC0gYS55KSAtIChiLnggLSBhLngpICogKGMueSAtIGEueSkpIC8gMlxufTtcblRyaWFuZ2xlLmRldCA9IGZ1bmN0aW9uIGRldCAobTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIHJldHVybiBtMDAgKiBtMTEgLSBtMDEgKiBtMTBcbn07XG5UcmlhbmdsZS5pbnRlcnBvbGF0ZVogPSBmdW5jdGlvbiBpbnRlcnBvbGF0ZVogKHAsIHYwLCB2MSwgdjIpIHtcbiAgdmFyIHgwID0gdjAueDtcbiAgdmFyIHkwID0gdjAueTtcbiAgdmFyIGEgPSB2MS54IC0geDA7XG4gIHZhciBiID0gdjIueCAtIHgwO1xuICB2YXIgYyA9IHYxLnkgLSB5MDtcbiAgdmFyIGQgPSB2Mi55IC0geTA7XG4gIHZhciBkZXQgPSBhICogZCAtIGIgKiBjO1xuICB2YXIgZHggPSBwLnggLSB4MDtcbiAgdmFyIGR5ID0gcC55IC0geTA7XG4gIHZhciB0ID0gKGQgKiBkeCAtIGIgKiBkeSkgLyBkZXQ7XG4gIHZhciB1ID0gKC1jICogZHggKyBhICogZHkpIC8gZGV0O1xuICB2YXIgeiA9IHYwLnogKyB0ICogKHYxLnogLSB2MC56KSArIHUgKiAodjIueiAtIHYwLnopO1xuICByZXR1cm4gelxufTtcblRyaWFuZ2xlLmxvbmdlc3RTaWRlTGVuZ3RoID0gZnVuY3Rpb24gbG9uZ2VzdFNpZGVMZW5ndGggKGEsIGIsIGMpIHtcbiAgdmFyIGxlbkFCID0gYS5kaXN0YW5jZShiKTtcbiAgdmFyIGxlbkJDID0gYi5kaXN0YW5jZShjKTtcbiAgdmFyIGxlbkNBID0gYy5kaXN0YW5jZShhKTtcbiAgdmFyIG1heExlbiA9IGxlbkFCO1xuICBpZiAobGVuQkMgPiBtYXhMZW4pIHsgbWF4TGVuID0gbGVuQkM7IH1cbiAgaWYgKGxlbkNBID4gbWF4TGVuKSB7IG1heExlbiA9IGxlbkNBOyB9XG4gIHJldHVybiBtYXhMZW5cbn07XG5UcmlhbmdsZS5pc0FjdXRlID0gZnVuY3Rpb24gaXNBY3V0ZSAoYSwgYiwgYykge1xuICBpZiAoIUFuZ2xlLmlzQWN1dGUoYSwgYiwgYykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCFBbmdsZS5pc0FjdXRlKGIsIGMsIGEpKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmICghQW5nbGUuaXNBY3V0ZShjLCBhLCBiKSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdHJ1ZVxufTtcblRyaWFuZ2xlLmNpcmN1bWNlbnRyZSA9IGZ1bmN0aW9uIGNpcmN1bWNlbnRyZSAoYSwgYiwgYykge1xuICB2YXIgY3ggPSBjLng7XG4gIHZhciBjeSA9IGMueTtcbiAgdmFyIGF4ID0gYS54IC0gY3g7XG4gIHZhciBheSA9IGEueSAtIGN5O1xuICB2YXIgYnggPSBiLnggLSBjeDtcbiAgdmFyIGJ5ID0gYi55IC0gY3k7XG4gIHZhciBkZW5vbSA9IDIgKiBUcmlhbmdsZS5kZXQoYXgsIGF5LCBieCwgYnkpO1xuICB2YXIgbnVteCA9IFRyaWFuZ2xlLmRldChheSwgYXggKiBheCArIGF5ICogYXksIGJ5LCBieCAqIGJ4ICsgYnkgKiBieSk7XG4gIHZhciBudW15ID0gVHJpYW5nbGUuZGV0KGF4LCBheCAqIGF4ICsgYXkgKiBheSwgYngsIGJ4ICogYnggKyBieSAqIGJ5KTtcbiAgdmFyIGNjeCA9IGN4IC0gbnVteCAvIGRlbm9tO1xuICB2YXIgY2N5ID0gY3kgKyBudW15IC8gZGVub207XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZShjY3gsIGNjeSlcbn07XG5UcmlhbmdsZS5wZXJwZW5kaWN1bGFyQmlzZWN0b3IgPSBmdW5jdGlvbiBwZXJwZW5kaWN1bGFyQmlzZWN0b3IgKGEsIGIpIHtcbiAgdmFyIGR4ID0gYi54IC0gYS54O1xuICB2YXIgZHkgPSBiLnkgLSBhLnk7XG4gIHZhciBsMSA9IG5ldyBIQ29vcmRpbmF0ZShhLnggKyBkeCAvIDIuMCwgYS55ICsgZHkgLyAyLjAsIDEuMCk7XG4gIHZhciBsMiA9IG5ldyBIQ29vcmRpbmF0ZShhLnggLSBkeSArIGR4IC8gMi4wLCBhLnkgKyBkeCArIGR5IC8gMi4wLCAxLjApO1xuICByZXR1cm4gbmV3IEhDb29yZGluYXRlKGwxLCBsMilcbn07XG5UcmlhbmdsZS5hbmdsZUJpc2VjdG9yID0gZnVuY3Rpb24gYW5nbGVCaXNlY3RvciAoYSwgYiwgYykge1xuICB2YXIgbGVuMCA9IGIuZGlzdGFuY2UoYSk7XG4gIHZhciBsZW4yID0gYi5kaXN0YW5jZShjKTtcbiAgdmFyIGZyYWMgPSBsZW4wIC8gKGxlbjAgKyBsZW4yKTtcbiAgdmFyIGR4ID0gYy54IC0gYS54O1xuICB2YXIgZHkgPSBjLnkgLSBhLnk7XG4gIHZhciBzcGxpdFB0ID0gbmV3IENvb3JkaW5hdGUoYS54ICsgZnJhYyAqIGR4LCBhLnkgKyBmcmFjICogZHkpO1xuICByZXR1cm4gc3BsaXRQdFxufTtcblRyaWFuZ2xlLmFyZWEzRCA9IGZ1bmN0aW9uIGFyZWEzRCAoYSwgYiwgYykge1xuICB2YXIgdXggPSBiLnggLSBhLng7XG4gIHZhciB1eSA9IGIueSAtIGEueTtcbiAgdmFyIHV6ID0gYi56IC0gYS56O1xuICB2YXIgdnggPSBjLnggLSBhLng7XG4gIHZhciB2eSA9IGMueSAtIGEueTtcbiAgdmFyIHZ6ID0gYy56IC0gYS56O1xuICB2YXIgY3Jvc3N4ID0gdXkgKiB2eiAtIHV6ICogdnk7XG4gIHZhciBjcm9zc3kgPSB1eiAqIHZ4IC0gdXggKiB2ejtcbiAgdmFyIGNyb3NzeiA9IHV4ICogdnkgLSB1eSAqIHZ4O1xuICB2YXIgYWJzU3EgPSBjcm9zc3ggKiBjcm9zc3ggKyBjcm9zc3kgKiBjcm9zc3kgKyBjcm9zc3ogKiBjcm9zc3o7XG4gIHZhciBhcmVhM0QgPSBNYXRoLnNxcnQoYWJzU3EpIC8gMjtcbiAgcmV0dXJuIGFyZWEzRFxufTtcblRyaWFuZ2xlLmNlbnRyb2lkID0gZnVuY3Rpb24gY2VudHJvaWQgKGEsIGIsIGMpIHtcbiAgdmFyIHggPSAoYS54ICsgYi54ICsgYy54KSAvIDM7XG4gIHZhciB5ID0gKGEueSArIGIueSArIGMueSkgLyAzO1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoeCwgeSlcbn07XG5UcmlhbmdsZS5pbkNlbnRyZSA9IGZ1bmN0aW9uIGluQ2VudHJlIChhLCBiLCBjKSB7XG4gIHZhciBsZW4wID0gYi5kaXN0YW5jZShjKTtcbiAgdmFyIGxlbjEgPSBhLmRpc3RhbmNlKGMpO1xuICB2YXIgbGVuMiA9IGEuZGlzdGFuY2UoYik7XG4gIHZhciBjaXJjdW0gPSBsZW4wICsgbGVuMSArIGxlbjI7XG4gIHZhciBpbkNlbnRyZVggPSAobGVuMCAqIGEueCArIGxlbjEgKiBiLnggKyBsZW4yICogYy54KSAvIGNpcmN1bTtcbiAgdmFyIGluQ2VudHJlWSA9IChsZW4wICogYS55ICsgbGVuMSAqIGIueSArIGxlbjIgKiBjLnkpIC8gY2lyY3VtO1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoaW5DZW50cmVYLCBpbkNlbnRyZVkpXG59O1xuXG52YXIgT2Zmc2V0Q3VydmVTZXRCdWlsZGVyID0gZnVuY3Rpb24gT2Zmc2V0Q3VydmVTZXRCdWlsZGVyICgpIHtcbiAgdGhpcy5faW5wdXRHZW9tID0gbnVsbDtcbiAgdGhpcy5fZGlzdGFuY2UgPSBudWxsO1xuICB0aGlzLl9jdXJ2ZUJ1aWxkZXIgPSBudWxsO1xuICB0aGlzLl9jdXJ2ZUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBpbnB1dEdlb20gPSBhcmd1bWVudHNbMF07XG4gIHZhciBkaXN0YW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGN1cnZlQnVpbGRlciA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5faW5wdXRHZW9tID0gaW5wdXRHZW9tO1xuICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICB0aGlzLl9jdXJ2ZUJ1aWxkZXIgPSBjdXJ2ZUJ1aWxkZXI7XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uIGFkZFBvaW50IChwKSB7XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8PSAwLjApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgY29vcmQgPSBwLmdldENvb3JkaW5hdGVzKCk7XG4gIHZhciBjdXJ2ZSA9IHRoaXMuX2N1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoY29vcmQsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgdGhpcy5hZGRDdXJ2ZShjdXJ2ZSwgTG9jYXRpb24uRVhURVJJT1IsIExvY2F0aW9uLklOVEVSSU9SKTtcbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmFkZFBvbHlnb24gPSBmdW5jdGlvbiBhZGRQb2x5Z29uIChwKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9mZnNldERpc3RhbmNlID0gdGhpcy5fZGlzdGFuY2U7XG4gIHZhciBvZmZzZXRTaWRlID0gUG9zaXRpb24uTEVGVDtcbiAgaWYgKHRoaXMuX2Rpc3RhbmNlIDwgMC4wKSB7XG4gICAgb2Zmc2V0RGlzdGFuY2UgPSAtdGhpcy5fZGlzdGFuY2U7XG4gICAgb2Zmc2V0U2lkZSA9IFBvc2l0aW9uLlJJR0hUO1xuICB9XG4gIHZhciBzaGVsbCA9IHAuZ2V0RXh0ZXJpb3JSaW5nKCk7XG4gIHZhciBzaGVsbENvb3JkID0gQ29vcmRpbmF0ZUFycmF5cy5yZW1vdmVSZXBlYXRlZFBvaW50cyhzaGVsbC5nZXRDb29yZGluYXRlcygpKTtcbiAgaWYgKHRoaXMuX2Rpc3RhbmNlIDwgMC4wICYmIHRoaXMuaXNFcm9kZWRDb21wbGV0ZWx5KHNoZWxsLCB0aGlzLl9kaXN0YW5jZSkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAodGhpcy5fZGlzdGFuY2UgPD0gMC4wICYmIHNoZWxsQ29vcmQubGVuZ3RoIDwgMykgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuYWRkUG9seWdvblJpbmcoc2hlbGxDb29yZCwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldFNpZGUsIExvY2F0aW9uLkVYVEVSSU9SLCBMb2NhdGlvbi5JTlRFUklPUik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcC5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSsrKSB7XG4gICAgdmFyIGhvbGUgPSBwLmdldEludGVyaW9yUmluZ04oaSk7XG4gICAgdmFyIGhvbGVDb29yZCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMoaG9sZS5nZXRDb29yZGluYXRlcygpKTtcbiAgICBpZiAodGhpcyQxLl9kaXN0YW5jZSA+IDAuMCAmJiB0aGlzJDEuaXNFcm9kZWRDb21wbGV0ZWx5KGhvbGUsIC10aGlzJDEuX2Rpc3RhbmNlKSkgeyBjb250aW51ZSB9XG4gICAgdGhpcyQxLmFkZFBvbHlnb25SaW5nKGhvbGVDb29yZCwgb2Zmc2V0RGlzdGFuY2UsIFBvc2l0aW9uLm9wcG9zaXRlKG9mZnNldFNpZGUpLCBMb2NhdGlvbi5JTlRFUklPUiwgTG9jYXRpb24uRVhURVJJT1IpO1xuICB9XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseSA9IGZ1bmN0aW9uIGlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5ICh0cmlhbmdsZUNvb3JkLCBidWZmZXJEaXN0YW5jZSkge1xuICB2YXIgdHJpID0gbmV3IFRyaWFuZ2xlKHRyaWFuZ2xlQ29vcmRbMF0sIHRyaWFuZ2xlQ29vcmRbMV0sIHRyaWFuZ2xlQ29vcmRbMl0pO1xuICB2YXIgaW5DZW50cmUgPSB0cmkuaW5DZW50cmUoKTtcbiAgdmFyIGRpc3RUb0NlbnRyZSA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShpbkNlbnRyZSwgdHJpLnAwLCB0cmkucDEpO1xuICByZXR1cm4gZGlzdFRvQ2VudHJlIDwgTWF0aC5hYnMoYnVmZmVyRGlzdGFuY2UpXG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGRMaW5lU3RyaW5nID0gZnVuY3Rpb24gYWRkTGluZVN0cmluZyAobGluZSkge1xuICBpZiAodGhpcy5fZGlzdGFuY2UgPD0gMC4wICYmICF0aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0QnVmZmVyUGFyYW1ldGVycygpLmlzU2luZ2xlU2lkZWQoKSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBjb29yZCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMobGluZS5nZXRDb29yZGluYXRlcygpKTtcbiAgdmFyIGN1cnZlID0gdGhpcy5fY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShjb29yZCwgdGhpcy5fZGlzdGFuY2UpO1xuICB0aGlzLmFkZEN1cnZlKGN1cnZlLCBMb2NhdGlvbi5FWFRFUklPUiwgTG9jYXRpb24uSU5URVJJT1IpO1xufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuYWRkQ3VydmUgPSBmdW5jdGlvbiBhZGRDdXJ2ZSAoY29vcmQsIGxlZnRMb2MsIHJpZ2h0TG9jKSB7XG4gIGlmIChjb29yZCA9PT0gbnVsbCB8fCBjb29yZC5sZW5ndGggPCAyKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGUgPSBuZXcgTm9kZWRTZWdtZW50U3RyaW5nKGNvb3JkLCBuZXcgTGFiZWwoMCwgTG9jYXRpb24uQk9VTkRBUlksIGxlZnRMb2MsIHJpZ2h0TG9jKSk7XG4gIHRoaXMuX2N1cnZlTGlzdC5hZGQoZSk7XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5nZXRDdXJ2ZXMgPSBmdW5jdGlvbiBnZXRDdXJ2ZXMgKCkge1xuICB0aGlzLmFkZCh0aGlzLl9pbnB1dEdlb20pO1xuICByZXR1cm4gdGhpcy5fY3VydmVMaXN0XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGRQb2x5Z29uUmluZyA9IGZ1bmN0aW9uIGFkZFBvbHlnb25SaW5nIChjb29yZCwgb2Zmc2V0RGlzdGFuY2UsIHNpZGUsIGN3TGVmdExvYywgY3dSaWdodExvYykge1xuICBpZiAob2Zmc2V0RGlzdGFuY2UgPT09IDAuMCAmJiBjb29yZC5sZW5ndGggPCBMaW5lYXJSaW5nLk1JTklNVU1fVkFMSURfU0laRSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBsZWZ0TG9jID0gY3dMZWZ0TG9jO1xuICB2YXIgcmlnaHRMb2MgPSBjd1JpZ2h0TG9jO1xuICBpZiAoY29vcmQubGVuZ3RoID49IExpbmVhclJpbmcuTUlOSU1VTV9WQUxJRF9TSVpFICYmIENHQWxnb3JpdGhtcy5pc0NDVyhjb29yZCkpIHtcbiAgICBsZWZ0TG9jID0gY3dSaWdodExvYztcbiAgICByaWdodExvYyA9IGN3TGVmdExvYztcbiAgICBzaWRlID0gUG9zaXRpb24ub3Bwb3NpdGUoc2lkZSk7XG4gIH1cbiAgdmFyIGN1cnZlID0gdGhpcy5fY3VydmVCdWlsZGVyLmdldFJpbmdDdXJ2ZShjb29yZCwgc2lkZSwgb2Zmc2V0RGlzdGFuY2UpO1xuICB0aGlzLmFkZEN1cnZlKGN1cnZlLCBsZWZ0TG9jLCByaWdodExvYyk7XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGcpIHtcbiAgaWYgKGcuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKGcgaW5zdGFuY2VvZiBQb2x5Z29uKSB7IHRoaXMuYWRkUG9seWdvbihnKTsgfVxuICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTGluZVN0cmluZykgeyB0aGlzLmFkZExpbmVTdHJpbmcoZyk7IH1cbiAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIFBvaW50KSB7IHRoaXMuYWRkUG9pbnQoZyk7IH1cbiAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIE11bHRpUG9pbnQpIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aUxpbmVTdHJpbmcpIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24pIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gIC8vIGVsc2UgdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKGcuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpXG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5pc0Vyb2RlZENvbXBsZXRlbHkgPSBmdW5jdGlvbiBpc0Vyb2RlZENvbXBsZXRlbHkgKHJpbmcsIGJ1ZmZlckRpc3RhbmNlKSB7XG4gIHZhciByaW5nQ29vcmQgPSByaW5nLmdldENvb3JkaW5hdGVzKCk7XG4gIC8vIGNvbnN0IG1pbkRpYW0gPSAwLjBcbiAgaWYgKHJpbmdDb29yZC5sZW5ndGggPCA0KSB7IHJldHVybiBidWZmZXJEaXN0YW5jZSA8IDAgfVxuICBpZiAocmluZ0Nvb3JkLmxlbmd0aCA9PT0gNCkgeyByZXR1cm4gdGhpcy5pc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseShyaW5nQ29vcmQsIGJ1ZmZlckRpc3RhbmNlKSB9XG4gIHZhciBlbnYgPSByaW5nLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgdmFyIGVudk1pbkRpbWVuc2lvbiA9IE1hdGgubWluKGVudi5nZXRIZWlnaHQoKSwgZW52LmdldFdpZHRoKCkpO1xuICBpZiAoYnVmZmVyRGlzdGFuY2UgPCAwLjAgJiYgMiAqIE1hdGguYWJzKGJ1ZmZlckRpc3RhbmNlKSA+IGVudk1pbkRpbWVuc2lvbikgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuYWRkQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIGFkZENvbGxlY3Rpb24gKGdjKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYy5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciBnID0gZ2MuZ2V0R2VvbWV0cnlOKGkpO1xuICAgIHRoaXMkMS5hZGQoZyk7XG4gIH1cbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT2Zmc2V0Q3VydmVTZXRCdWlsZGVyXG59O1xuXG52YXIgUG9pbnRPbkdlb21ldHJ5TG9jYXRvciA9IGZ1bmN0aW9uIFBvaW50T25HZW9tZXRyeUxvY2F0b3IgKCkge307XG5cblBvaW50T25HZW9tZXRyeUxvY2F0b3IucHJvdG90eXBlLmxvY2F0ZSA9IGZ1bmN0aW9uIGxvY2F0ZSAocCkge307XG5Qb2ludE9uR2VvbWV0cnlMb2NhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9pbnRPbkdlb21ldHJ5TG9jYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2ludE9uR2VvbWV0cnlMb2NhdG9yXG59O1xuXG52YXIgR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IgPSBmdW5jdGlvbiBHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvciAoKSB7XG4gIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gIHRoaXMuX2F0U3RhcnQgPSBudWxsO1xuICB0aGlzLl9tYXggPSBudWxsO1xuICB0aGlzLl9pbmRleCA9IG51bGw7XG4gIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvciA9IG51bGw7XG4gIHZhciBwYXJlbnQgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgdGhpcy5fYXRTdGFydCA9IHRydWU7XG4gIHRoaXMuX2luZGV4ID0gMDtcbiAgdGhpcy5fbWF4ID0gcGFyZW50LmdldE51bUdlb21ldHJpZXMoKTtcbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQgKCkge1xuICBpZiAodGhpcy5fYXRTdGFydCkge1xuICAgIHRoaXMuX2F0U3RhcnQgPSBmYWxzZTtcbiAgICBpZiAoR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IuaXNBdG9taWModGhpcy5fcGFyZW50KSkgeyB0aGlzLl9pbmRleCsrOyB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudFxuICB9XG4gIGlmICh0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IgIT09IG51bGwpIHtcbiAgICBpZiAodGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLmhhc05leHQoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX21heCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uKClcbiAgfVxuICB2YXIgb2JqID0gdGhpcy5fcGFyZW50LmdldEdlb21ldHJ5Tih0aGlzLl9pbmRleCsrKTtcbiAgaWYgKG9iaiBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvciA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvcihvYmopO1xuICAgIHJldHVybiB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpXG4gIH1cbiAgcmV0dXJuIG9ialxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IodGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSlcbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvci5wcm90b3R5cGUuaGFzTmV4dCA9IGZ1bmN0aW9uIGhhc05leHQgKCkge1xuICBpZiAodGhpcy5fYXRTdGFydCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvciAhPT0gbnVsbCkge1xuICAgIGlmICh0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9tYXgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtJdGVyYXRvcl1cbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvclxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yLmlzQXRvbWljID0gZnVuY3Rpb24gaXNBdG9taWMgKGdlb20pIHtcbiAgcmV0dXJuICEoZ2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbilcbn07XG5cbnZhciBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IgPSBmdW5jdGlvbiBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IgKCkge1xuICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2dlb20gPSBnZW9tO1xufTtcblNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5wcm90b3R5cGUubG9jYXRlID0gZnVuY3Rpb24gbG9jYXRlIChwKSB7XG4gIHJldHVybiBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IubG9jYXRlKHAsIHRoaXMuX2dlb20pXG59O1xuU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtQb2ludE9uR2VvbWV0cnlMb2NhdG9yXVxufTtcblNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3Jcbn07XG5TaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuaXNQb2ludEluUmluZyA9IGZ1bmN0aW9uIGlzUG9pbnRJblJpbmcgKHAsIHJpbmcpIHtcbiAgaWYgKCFyaW5nLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHApKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBDR0FsZ29yaXRobXMuaXNQb2ludEluUmluZyhwLCByaW5nLmdldENvb3JkaW5hdGVzKCkpXG59O1xuU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmNvbnRhaW5zUG9pbnRJblBvbHlnb24gPSBmdW5jdGlvbiBjb250YWluc1BvaW50SW5Qb2x5Z29uIChwLCBwb2x5KSB7XG4gIGlmIChwb2x5LmlzRW1wdHkoKSkgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgc2hlbGwgPSBwb2x5LmdldEV4dGVyaW9yUmluZygpO1xuICBpZiAoIVNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5pc1BvaW50SW5SaW5nKHAsIHNoZWxsKSkgeyByZXR1cm4gZmFsc2UgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7IGkrKykge1xuICAgIHZhciBob2xlID0gcG9seS5nZXRJbnRlcmlvclJpbmdOKGkpO1xuICAgIGlmIChTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuaXNQb2ludEluUmluZyhwLCBob2xlKSkgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiBjb250YWluc1BvaW50IChwLCBnZW9tKSB7XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgIHJldHVybiBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuY29udGFpbnNQb2ludEluUG9seWdvbihwLCBnZW9tKVxuICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICB2YXIgZ2VvbWkgPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IoZ2VvbSk7XG4gICAgd2hpbGUgKGdlb21pLmhhc05leHQoKSkge1xuICAgICAgdmFyIGcyID0gZ2VvbWkubmV4dCgpO1xuICAgICAgaWYgKGcyICE9PSBnZW9tKSB7IGlmIChTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuY29udGFpbnNQb2ludChwLCBnMikpIHsgcmV0dXJuIHRydWUgfSB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5sb2NhdGUgPSBmdW5jdGlvbiBsb2NhdGUgKHAsIGdlb20pIHtcbiAgaWYgKGdlb20uaXNFbXB0eSgpKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gIGlmIChTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuY29udGFpbnNQb2ludChwLCBnZW9tKSkgeyByZXR1cm4gTG9jYXRpb24uSU5URVJJT1IgfVxuICByZXR1cm4gTG9jYXRpb24uRVhURVJJT1Jcbn07XG5cbnZhciBFZGdlRW5kU3RhciA9IGZ1bmN0aW9uIEVkZ2VFbmRTdGFyICgpIHtcbiAgdGhpcy5fZWRnZU1hcCA9IG5ldyBUcmVlTWFwKCk7XG4gIHRoaXMuX2VkZ2VMaXN0ID0gbnVsbDtcbiAgdGhpcy5fcHRJbkFyZWFMb2NhdGlvbiA9IFtMb2NhdGlvbi5OT05FLCBMb2NhdGlvbi5OT05FXTtcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0TmV4dENXID0gZnVuY3Rpb24gZ2V0TmV4dENXIChlZSkge1xuICB0aGlzLmdldEVkZ2VzKCk7XG4gIHZhciBpID0gdGhpcy5fZWRnZUxpc3QuaW5kZXhPZihlZSk7XG4gIHZhciBpTmV4dENXID0gaSAtIDE7XG4gIGlmIChpID09PSAwKSB7IGlOZXh0Q1cgPSB0aGlzLl9lZGdlTGlzdC5zaXplKCkgLSAxOyB9XG4gIHJldHVybiB0aGlzLl9lZGdlTGlzdC5nZXQoaU5leHRDVylcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUucHJvcGFnYXRlU2lkZUxhYmVscyA9IGZ1bmN0aW9uIHByb3BhZ2F0ZVNpZGVMYWJlbHMgKGdlb21JbmRleCkge1xuICB2YXIgc3RhcnRMb2MgPSBMb2NhdGlvbi5OT05FO1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIHZhciBsYWJlbCA9IGUuZ2V0TGFiZWwoKTtcbiAgICBpZiAobGFiZWwuaXNBcmVhKGdlb21JbmRleCkgJiYgbGFiZWwuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5MRUZUKSAhPT0gTG9jYXRpb24uTk9ORSkgeyBzdGFydExvYyA9IGxhYmVsLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uTEVGVCk7IH1cbiAgfVxuICBpZiAoc3RhcnRMb2MgPT09IExvY2F0aW9uLk5PTkUpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgY3VyckxvYyA9IHN0YXJ0TG9jO1xuICBmb3IgKHZhciBpdCQxID0gdGhpcy5pdGVyYXRvcigpOyBpdCQxLmhhc05leHQoKTspIHtcbiAgICB2YXIgZSQxID0gaXQkMS5uZXh0KCk7XG4gICAgdmFyIGxhYmVsJDEgPSBlJDEuZ2V0TGFiZWwoKTtcbiAgICBpZiAobGFiZWwkMS5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLk9OKSA9PT0gTG9jYXRpb24uTk9ORSkgeyBsYWJlbCQxLnNldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uT04sIGN1cnJMb2MpOyB9XG4gICAgaWYgKGxhYmVsJDEuaXNBcmVhKGdlb21JbmRleCkpIHtcbiAgICAgIHZhciBsZWZ0TG9jID0gbGFiZWwkMS5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLkxFRlQpO1xuICAgICAgdmFyIHJpZ2h0TG9jID0gbGFiZWwkMS5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLlJJR0hUKTtcbiAgICAgIGlmIChyaWdodExvYyAhPT0gTG9jYXRpb24uTk9ORSkge1xuICAgICAgICBpZiAocmlnaHRMb2MgIT09IGN1cnJMb2MpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCdzaWRlIGxvY2F0aW9uIGNvbmZsaWN0JywgZSQxLmdldENvb3JkaW5hdGUoKSkgfVxuICAgICAgICBpZiAobGVmdExvYyA9PT0gTG9jYXRpb24uTk9ORSkge1xuICAgICAgICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgnZm91bmQgc2luZ2xlIG51bGwgc2lkZSAoYXQgJyArIGUkMS5nZXRDb29yZGluYXRlKCkgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJMb2MgPSBsZWZ0TG9jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQXNzZXJ0LmlzVHJ1ZShsYWJlbCQxLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uTEVGVCkgPT09IExvY2F0aW9uLk5PTkUsICdmb3VuZCBzaW5nbGUgbnVsbCBzaWRlJyk7XG4gICAgICAgIGxhYmVsJDEuc2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5SSUdIVCwgY3VyckxvYyk7XG4gICAgICAgIGxhYmVsJDEuc2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5MRUZULCBjdXJyTG9jKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gIGlmICghaXQuaGFzTmV4dCgpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gIHJldHVybiBlLmdldENvb3JkaW5hdGUoKVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgU3lzdGVtLm91dC5wcmludGxuKCdFZGdlRW5kU3RhcjogICAnICsgdGhpcy5nZXRDb29yZGluYXRlKCkpO1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIGUucHJpbnQob3V0KTtcbiAgfVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5pc0FyZWFMYWJlbHNDb25zaXN0ZW50ID0gZnVuY3Rpb24gaXNBcmVhTGFiZWxzQ29uc2lzdGVudCAoZ2VvbUdyYXBoKSB7XG4gIHRoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHMoZ2VvbUdyYXBoLmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSk7XG4gIHJldHVybiB0aGlzLmNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQoMClcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCA9IGZ1bmN0aW9uIGNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQgKGdlb21JbmRleCkge1xuICB2YXIgZWRnZXMgPSB0aGlzLmdldEVkZ2VzKCk7XG4gIGlmIChlZGdlcy5zaXplKCkgPD0gMCkgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBsYXN0RWRnZUluZGV4ID0gZWRnZXMuc2l6ZSgpIC0gMTtcbiAgdmFyIHN0YXJ0TGFiZWwgPSBlZGdlcy5nZXQobGFzdEVkZ2VJbmRleCkuZ2V0TGFiZWwoKTtcbiAgdmFyIHN0YXJ0TG9jID0gc3RhcnRMYWJlbC5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLkxFRlQpO1xuICBBc3NlcnQuaXNUcnVlKHN0YXJ0TG9jICE9PSBMb2NhdGlvbi5OT05FLCAnRm91bmQgdW5sYWJlbGxlZCBhcmVhIGVkZ2UnKTtcbiAgdmFyIGN1cnJMb2MgPSBzdGFydExvYztcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgbGFiZWwgPSBlLmdldExhYmVsKCk7XG4gICAgQXNzZXJ0LmlzVHJ1ZShsYWJlbC5pc0FyZWEoZ2VvbUluZGV4KSwgJ0ZvdW5kIG5vbi1hcmVhIGVkZ2UnKTtcbiAgICB2YXIgbGVmdExvYyA9IGxhYmVsLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uTEVGVCk7XG4gICAgdmFyIHJpZ2h0TG9jID0gbGFiZWwuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5SSUdIVCk7XG4gICAgaWYgKGxlZnRMb2MgPT09IHJpZ2h0TG9jKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKHJpZ2h0TG9jICE9PSBjdXJyTG9jKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgY3VyckxvYyA9IGxlZnRMb2M7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZmluZEluZGV4ID0gZnVuY3Rpb24gZmluZEluZGV4IChlU2VhcmNoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5pdGVyYXRvcigpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2VkZ2VMaXN0LnNpemUoKTsgaSsrKSB7XG4gICAgdmFyIGUgPSB0aGlzJDEuX2VkZ2VMaXN0LmdldChpKTtcbiAgICBpZiAoZSA9PT0gZVNlYXJjaCkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IgKCkge1xuICByZXR1cm4gdGhpcy5nZXRFZGdlcygpLml0ZXJhdG9yKClcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiBnZXRFZGdlcyAoKSB7XG4gIGlmICh0aGlzLl9lZGdlTGlzdCA9PT0gbnVsbCkge1xuICAgIHRoaXMuX2VkZ2VMaXN0ID0gbmV3IEFycmF5TGlzdCh0aGlzLl9lZGdlTWFwLnZhbHVlcygpKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZWRnZUxpc3Rcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAoZ2VvbUluZGV4LCBwLCBnZW9tKSB7XG4gIGlmICh0aGlzLl9wdEluQXJlYUxvY2F0aW9uW2dlb21JbmRleF0gPT09IExvY2F0aW9uLk5PTkUpIHtcbiAgICB0aGlzLl9wdEluQXJlYUxvY2F0aW9uW2dlb21JbmRleF0gPSBTaW1wbGVQb2ludEluQXJlYUxvY2F0b3IubG9jYXRlKHAsIGdlb21bZ2VvbUluZGV4XS5nZXRHZW9tZXRyeSgpKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fcHRJbkFyZWFMb2NhdGlvbltnZW9tSW5kZXhdXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICBidWYuYXBwZW5kKCdFZGdlRW5kU3RhcjogICAnICsgdGhpcy5nZXRDb29yZGluYXRlKCkpO1xuICBidWYuYXBwZW5kKCdcXG4nKTtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICBidWYuYXBwZW5kKGUpO1xuICAgIGJ1Zi5hcHBlbmQoJ1xcbicpO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoKVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5jb21wdXRlRWRnZUVuZExhYmVscyA9IGZ1bmN0aW9uIGNvbXB1dGVFZGdlRW5kTGFiZWxzIChib3VuZGFyeU5vZGVSdWxlKSB7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVlID0gaXQubmV4dCgpO1xuICAgIGVlLmNvbXB1dGVMYWJlbChib3VuZGFyeU5vZGVSdWxlKTtcbiAgfVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5jb21wdXRlTGFiZWxsaW5nID0gZnVuY3Rpb24gY29tcHV0ZUxhYmVsbGluZyAoZ2VvbUdyYXBoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyhnZW9tR3JhcGhbMF0uZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKTtcbiAgdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDApO1xuICB0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMSk7XG4gIHZhciBoYXNEaW1lbnNpb25hbENvbGxhcHNlRWRnZSA9IFtmYWxzZSwgZmFsc2VdO1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIHZhciBsYWJlbCA9IGUuZ2V0TGFiZWwoKTtcbiAgICBmb3IgKHZhciBnZW9taSA9IDA7IGdlb21pIDwgMjsgZ2VvbWkrKykge1xuICAgICAgaWYgKGxhYmVsLmlzTGluZShnZW9taSkgJiYgbGFiZWwuZ2V0TG9jYXRpb24oZ2VvbWkpID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyBoYXNEaW1lbnNpb25hbENvbGxhcHNlRWRnZVtnZW9taV0gPSB0cnVlOyB9XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGl0JDEgPSB0aGlzLml0ZXJhdG9yKCk7IGl0JDEuaGFzTmV4dCgpOykge1xuICAgIHZhciBlJDEgPSBpdCQxLm5leHQoKTtcbiAgICB2YXIgbGFiZWwkMSA9IGUkMS5nZXRMYWJlbCgpO1xuICAgIGZvciAodmFyIGdlb21pJDEgPSAwOyBnZW9taSQxIDwgMjsgZ2VvbWkkMSsrKSB7XG4gICAgICBpZiAobGFiZWwkMS5pc0FueU51bGwoZ2VvbWkkMSkpIHtcbiAgICAgICAgdmFyIGxvYyA9IExvY2F0aW9uLk5PTkU7XG4gICAgICAgIGlmIChoYXNEaW1lbnNpb25hbENvbGxhcHNlRWRnZVtnZW9taSQxXSkge1xuICAgICAgICAgIGxvYyA9IExvY2F0aW9uLkVYVEVSSU9SO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwID0gZSQxLmdldENvb3JkaW5hdGUoKTtcbiAgICAgICAgICBsb2MgPSB0aGlzJDEuZ2V0TG9jYXRpb24oZ2VvbWkkMSwgcCwgZ2VvbUdyYXBoKTtcbiAgICAgICAgfVxuICAgICAgICBsYWJlbCQxLnNldEFsbExvY2F0aW9uc0lmTnVsbChnZW9taSQxLCBsb2MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5nZXREZWdyZWUgPSBmdW5jdGlvbiBnZXREZWdyZWUgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZU1hcC5zaXplKClcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuaW5zZXJ0RWRnZUVuZCA9IGZ1bmN0aW9uIGluc2VydEVkZ2VFbmQgKGUsIG9iaikge1xuICB0aGlzLl9lZGdlTWFwLnB1dChlLCBvYmopO1xuICB0aGlzLl9lZGdlTGlzdCA9IG51bGw7XG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFZGdlRW5kU3RhclxufTtcblxudmFyIERpcmVjdGVkRWRnZVN0YXIgPSAoZnVuY3Rpb24gKEVkZ2VFbmRTdGFyJCQxKSB7XG4gIGZ1bmN0aW9uIERpcmVjdGVkRWRnZVN0YXIgKCkge1xuICAgIEVkZ2VFbmRTdGFyJCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0ID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gICAgdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HID0gMTtcbiAgICB0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HID0gMjtcbiAgfVxuXG4gIGlmICggRWRnZUVuZFN0YXIkJDEgKSBEaXJlY3RlZEVkZ2VTdGFyLl9fcHJvdG9fXyA9IEVkZ2VFbmRTdGFyJCQxO1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVkZ2VFbmRTdGFyJCQxICYmIEVkZ2VFbmRTdGFyJCQxLnByb3RvdHlwZSApO1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERpcmVjdGVkRWRnZVN0YXI7XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzID0gZnVuY3Rpb24gbGlua1Jlc3VsdERpcmVjdGVkRWRnZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5nZXRSZXN1bHRBcmVhRWRnZXMoKTtcbiAgICB2YXIgZmlyc3RPdXQgPSBudWxsO1xuICAgIHZhciBpbmNvbWluZyA9IG51bGw7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKTsgaSsrKSB7XG4gICAgICB2YXIgbmV4dE91dCA9IHRoaXMkMS5fcmVzdWx0QXJlYUVkZ2VMaXN0LmdldChpKTtcbiAgICAgIHZhciBuZXh0SW4gPSBuZXh0T3V0LmdldFN5bSgpO1xuICAgICAgaWYgKCFuZXh0T3V0LmdldExhYmVsKCkuaXNBcmVhKCkpIHsgY29udGludWUgfVxuICAgICAgaWYgKGZpcnN0T3V0ID09PSBudWxsICYmIG5leHRPdXQuaXNJblJlc3VsdCgpKSB7IGZpcnN0T3V0ID0gbmV4dE91dDsgfVxuICAgICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgICBjYXNlIHRoaXMkMS5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HOlxuICAgICAgICAgIGlmICghbmV4dEluLmlzSW5SZXN1bHQoKSkgeyBjb250aW51ZSB9XG4gICAgICAgICAgaW5jb21pbmcgPSBuZXh0SW47XG4gICAgICAgICAgc3RhdGUgPSB0aGlzJDEuX0xJTktJTkdfVE9fT1VUR09JTkc7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSB0aGlzJDEuX0xJTktJTkdfVE9fT1VUR09JTkc6XG4gICAgICAgICAgaWYgKCFuZXh0T3V0LmlzSW5SZXN1bHQoKSkgeyBjb250aW51ZSB9XG4gICAgICAgICAgaW5jb21pbmcuc2V0TmV4dChuZXh0T3V0KTtcbiAgICAgICAgICBzdGF0ZSA9IHRoaXMkMS5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5fTElOS0lOR19UT19PVVRHT0lORykge1xuICAgICAgaWYgKGZpcnN0T3V0ID09PSBudWxsKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbignbm8gb3V0Z29pbmcgZGlyRWRnZSBmb3VuZCcsIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKSB9XG4gICAgICBBc3NlcnQuaXNUcnVlKGZpcnN0T3V0LmlzSW5SZXN1bHQoKSwgJ3VuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZScpO1xuICAgICAgaW5jb21pbmcuc2V0TmV4dChmaXJzdE91dCk7XG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKGVlKSB7XG4gICAgdmFyIGRlID0gZWU7XG4gICAgdGhpcy5pbnNlcnRFZGdlRW5kKGRlLCBkZSk7XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmdldFJpZ2h0bW9zdEVkZ2UgPSBmdW5jdGlvbiBnZXRSaWdodG1vc3RFZGdlICgpIHtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmdldEVkZ2VzKCk7XG4gICAgdmFyIHNpemUgPSBlZGdlcy5zaXplKCk7XG4gICAgaWYgKHNpemUgPCAxKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgZGUwID0gZWRnZXMuZ2V0KDApO1xuICAgIGlmIChzaXplID09PSAxKSB7IHJldHVybiBkZTAgfVxuICAgIHZhciBkZUxhc3QgPSBlZGdlcy5nZXQoc2l6ZSAtIDEpO1xuICAgIHZhciBxdWFkMCA9IGRlMC5nZXRRdWFkcmFudCgpO1xuICAgIHZhciBxdWFkMSA9IGRlTGFzdC5nZXRRdWFkcmFudCgpO1xuICAgIGlmIChRdWFkcmFudC5pc05vcnRoZXJuKHF1YWQwKSAmJiBRdWFkcmFudC5pc05vcnRoZXJuKHF1YWQxKSkgeyByZXR1cm4gZGUwOyB9IGVsc2UgaWYgKCFRdWFkcmFudC5pc05vcnRoZXJuKHF1YWQwKSAmJiAhUXVhZHJhbnQuaXNOb3J0aGVybihxdWFkMSkpIHsgcmV0dXJuIGRlTGFzdDsgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnN0IG5vbkhvcml6b250YWxFZGdlID0gbnVsbFxuICAgICAgaWYgKGRlMC5nZXREeSgpICE9PSAwKSB7IHJldHVybiBkZTA7IH0gZWxzZSBpZiAoZGVMYXN0LmdldER5KCkgIT09IDApIHsgcmV0dXJuIGRlTGFzdCB9XG4gICAgfVxuICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgnZm91bmQgdHdvIGhvcml6b250YWwgZWRnZXMgaW5jaWRlbnQgb24gbm9kZScpO1xuICAgIHJldHVybiBudWxsXG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICAgIFN5c3RlbS5vdXQucHJpbnRsbignRGlyZWN0ZWRFZGdlU3RhcjogJyArIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgb3V0LnByaW50KCdvdXQgJyk7XG4gICAgICBkZS5wcmludChvdXQpO1xuICAgICAgb3V0LnByaW50bG4oKTtcbiAgICAgIG91dC5wcmludCgnaW4gJyk7XG4gICAgICBkZS5nZXRTeW0oKS5wcmludChvdXQpO1xuICAgICAgb3V0LnByaW50bG4oKTtcbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmdldFJlc3VsdEFyZWFFZGdlcyA9IGZ1bmN0aW9uIGdldFJlc3VsdEFyZWFFZGdlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0ICE9PSBudWxsKSB7IHJldHVybiB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QgfVxuICAgIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgaWYgKGRlLmlzSW5SZXN1bHQoKSB8fCBkZS5nZXRTeW0oKS5pc0luUmVzdWx0KCkpIHsgdGhpcyQxLl9yZXN1bHRBcmVhRWRnZUxpc3QuYWRkKGRlKTsgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLnVwZGF0ZUxhYmVsbGluZyA9IGZ1bmN0aW9uIHVwZGF0ZUxhYmVsbGluZyAobm9kZUxhYmVsKSB7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBsYWJlbCA9IGRlLmdldExhYmVsKCk7XG4gICAgICBsYWJlbC5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCwgbm9kZUxhYmVsLmdldExvY2F0aW9uKDApKTtcbiAgICAgIGxhYmVsLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLCBub2RlTGFiZWwuZ2V0TG9jYXRpb24oMSkpO1xuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUubGlua0FsbERpcmVjdGVkRWRnZXMgPSBmdW5jdGlvbiBsaW5rQWxsRGlyZWN0ZWRFZGdlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLmdldEVkZ2VzKCk7XG4gICAgdmFyIHByZXZPdXQgPSBudWxsO1xuICAgIHZhciBmaXJzdEluID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fZWRnZUxpc3Quc2l6ZSgpIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBuZXh0T3V0ID0gdGhpcyQxLl9lZGdlTGlzdC5nZXQoaSk7XG4gICAgICB2YXIgbmV4dEluID0gbmV4dE91dC5nZXRTeW0oKTtcbiAgICAgIGlmIChmaXJzdEluID09PSBudWxsKSB7IGZpcnN0SW4gPSBuZXh0SW47IH1cbiAgICAgIGlmIChwcmV2T3V0ICE9PSBudWxsKSB7IG5leHRJbi5zZXROZXh0KHByZXZPdXQpOyB9XG4gICAgICBwcmV2T3V0ID0gbmV4dE91dDtcbiAgICB9XG4gICAgZmlyc3RJbi5zZXROZXh0KHByZXZPdXQpO1xuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5jb21wdXRlRGVwdGhzID0gZnVuY3Rpb24gY29tcHV0ZURlcHRocyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGRlID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGVkZ2VJbmRleCA9IHRoaXMuZmluZEluZGV4KGRlKTtcbiAgICAgIC8vIGNvbnN0IGxhYmVsID0gZGUuZ2V0TGFiZWwoKVxuICAgICAgdmFyIHN0YXJ0RGVwdGggPSBkZS5nZXREZXB0aChQb3NpdGlvbi5MRUZUKTtcbiAgICAgIHZhciB0YXJnZXRMYXN0RGVwdGggPSBkZS5nZXREZXB0aChQb3NpdGlvbi5SSUdIVCk7XG4gICAgICB2YXIgbmV4dERlcHRoID0gdGhpcy5jb21wdXRlRGVwdGhzKGVkZ2VJbmRleCArIDEsIHRoaXMuX2VkZ2VMaXN0LnNpemUoKSwgc3RhcnREZXB0aCk7XG4gICAgICB2YXIgbGFzdERlcHRoID0gdGhpcy5jb21wdXRlRGVwdGhzKDAsIGVkZ2VJbmRleCwgbmV4dERlcHRoKTtcbiAgICAgIGlmIChsYXN0RGVwdGggIT09IHRhcmdldExhc3REZXB0aCkgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24oJ2RlcHRoIG1pc21hdGNoIGF0ICcgKyBkZS5nZXRDb29yZGluYXRlKCkpIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGVuZEluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHN0YXJ0RGVwdGgkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBjdXJyRGVwdGggPSBzdGFydERlcHRoJDE7XG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVuZEluZGV4OyBpKyspIHtcbiAgICAgICAgdmFyIG5leHREZSA9IHRoaXMkMS5fZWRnZUxpc3QuZ2V0KGkpO1xuICAgICAgICAvLyBjb25zdCBsYWJlbCA9IG5leHREZS5nZXRMYWJlbCgpXG4gICAgICAgIG5leHREZS5zZXRFZGdlRGVwdGhzKFBvc2l0aW9uLlJJR0hULCBjdXJyRGVwdGgpO1xuICAgICAgICBjdXJyRGVwdGggPSBuZXh0RGUuZ2V0RGVwdGgoUG9zaXRpb24uTEVGVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VyckRlcHRoXG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5tZXJnZVN5bUxhYmVscyA9IGZ1bmN0aW9uIG1lcmdlU3ltTGFiZWxzICgpIHtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgdmFyIGxhYmVsID0gZGUuZ2V0TGFiZWwoKTtcbiAgICAgIGxhYmVsLm1lcmdlKGRlLmdldFN5bSgpLmdldExhYmVsKCkpO1xuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUubGlua01pbmltYWxEaXJlY3RlZEVkZ2VzID0gZnVuY3Rpb24gbGlua01pbmltYWxEaXJlY3RlZEVkZ2VzIChlcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGZpcnN0T3V0ID0gbnVsbDtcbiAgICB2YXIgaW5jb21pbmcgPSBudWxsO1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgbmV4dE91dCA9IHRoaXMkMS5fcmVzdWx0QXJlYUVkZ2VMaXN0LmdldChpKTtcbiAgICAgIHZhciBuZXh0SW4gPSBuZXh0T3V0LmdldFN5bSgpO1xuICAgICAgaWYgKGZpcnN0T3V0ID09PSBudWxsICYmIG5leHRPdXQuZ2V0RWRnZVJpbmcoKSA9PT0gZXIpIHsgZmlyc3RPdXQgPSBuZXh0T3V0OyB9XG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgdGhpcyQxLl9TQ0FOTklOR19GT1JfSU5DT01JTkc6XG4gICAgICAgICAgaWYgKG5leHRJbi5nZXRFZGdlUmluZygpICE9PSBlcikgeyBjb250aW51ZSB9XG4gICAgICAgICAgaW5jb21pbmcgPSBuZXh0SW47XG4gICAgICAgICAgc3RhdGUgPSB0aGlzJDEuX0xJTktJTkdfVE9fT1VUR09JTkc7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSB0aGlzJDEuX0xJTktJTkdfVE9fT1VUR09JTkc6XG4gICAgICAgICAgaWYgKG5leHRPdXQuZ2V0RWRnZVJpbmcoKSAhPT0gZXIpIHsgY29udGludWUgfVxuICAgICAgICAgIGluY29taW5nLnNldE5leHRNaW4obmV4dE91dCk7XG4gICAgICAgICAgc3RhdGUgPSB0aGlzJDEuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORztcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdGUgPT09IHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcpIHtcbiAgICAgIEFzc2VydC5pc1RydWUoZmlyc3RPdXQgIT09IG51bGwsICdmb3VuZCBudWxsIGZvciBmaXJzdCBvdXRnb2luZyBkaXJFZGdlJyk7XG4gICAgICBBc3NlcnQuaXNUcnVlKGZpcnN0T3V0LmdldEVkZ2VSaW5nKCkgPT09IGVyLCAndW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlJyk7XG4gICAgICBpbmNvbWluZy5zZXROZXh0TWluKGZpcnN0T3V0KTtcbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmdldE91dGdvaW5nRGVncmVlID0gZnVuY3Rpb24gZ2V0T3V0Z29pbmdEZWdyZWUgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIgZGVncmVlID0gMDtcbiAgICAgIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICAgICAgaWYgKGRlLmlzSW5SZXN1bHQoKSkgeyBkZWdyZWUrKzsgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZ3JlZVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGRlZ3JlZSQxID0gMDtcbiAgICAgIGZvciAodmFyIGl0JDEgPSB0aGlzLml0ZXJhdG9yKCk7IGl0JDEuaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgZGUkMSA9IGl0JDEubmV4dCgpO1xuICAgICAgICBpZiAoZGUkMS5nZXRFZGdlUmluZygpID09PSBlcikgeyBkZWdyZWUkMSsrOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVncmVlJDFcbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmdldExhYmVsID0gZnVuY3Rpb24gZ2V0TGFiZWwgKCkge1xuICAgIHJldHVybiB0aGlzLl9sYWJlbFxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5maW5kQ292ZXJlZExpbmVFZGdlcyA9IGZ1bmN0aW9uIGZpbmRDb3ZlcmVkTGluZUVkZ2VzICgpIHtcbiAgICB2YXIgc3RhcnRMb2MgPSBMb2NhdGlvbi5OT05FO1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbmV4dE91dCA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBuZXh0SW4gPSBuZXh0T3V0LmdldFN5bSgpO1xuICAgICAgaWYgKCFuZXh0T3V0LmlzTGluZUVkZ2UoKSkge1xuICAgICAgICBpZiAobmV4dE91dC5pc0luUmVzdWx0KCkpIHtcbiAgICAgICAgICBzdGFydExvYyA9IExvY2F0aW9uLklOVEVSSU9SO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRJbi5pc0luUmVzdWx0KCkpIHtcbiAgICAgICAgICBzdGFydExvYyA9IExvY2F0aW9uLkVYVEVSSU9SO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXJ0TG9jID09PSBMb2NhdGlvbi5OT05FKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgY3VyckxvYyA9IHN0YXJ0TG9jO1xuICAgIGZvciAodmFyIGl0JDEgPSB0aGlzLml0ZXJhdG9yKCk7IGl0JDEuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIG5leHRPdXQkMSA9IGl0JDEubmV4dCgpO1xuICAgICAgdmFyIG5leHRJbiQxID0gbmV4dE91dCQxLmdldFN5bSgpO1xuICAgICAgaWYgKG5leHRPdXQkMS5pc0xpbmVFZGdlKCkpIHtcbiAgICAgICAgbmV4dE91dCQxLmdldEVkZ2UoKS5zZXRDb3ZlcmVkKGN1cnJMb2MgPT09IExvY2F0aW9uLklOVEVSSU9SKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuZXh0T3V0JDEuaXNJblJlc3VsdCgpKSB7IGN1cnJMb2MgPSBMb2NhdGlvbi5FWFRFUklPUjsgfVxuICAgICAgICBpZiAobmV4dEluJDEuaXNJblJlc3VsdCgpKSB7IGN1cnJMb2MgPSBMb2NhdGlvbi5JTlRFUklPUjsgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuY29tcHV0ZUxhYmVsbGluZyA9IGZ1bmN0aW9uIGNvbXB1dGVMYWJlbGxpbmcgKGdlb20pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIEVkZ2VFbmRTdGFyJCQxLnByb3RvdHlwZS5jb21wdXRlTGFiZWxsaW5nLmNhbGwodGhpcywgZ2VvbSk7XG4gICAgdGhpcy5fbGFiZWwgPSBuZXcgTGFiZWwoTG9jYXRpb24uTk9ORSk7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBlZSA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBlID0gZWUuZ2V0RWRnZSgpO1xuICAgICAgdmFyIGVMYWJlbCA9IGUuZ2V0TGFiZWwoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIHZhciBlTG9jID0gZUxhYmVsLmdldExvY2F0aW9uKGkpO1xuICAgICAgICBpZiAoZUxvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IgfHwgZUxvYyA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgdGhpcyQxLl9sYWJlbC5zZXRMb2NhdGlvbihpLCBMb2NhdGlvbi5JTlRFUklPUik7IH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gRGlyZWN0ZWRFZGdlU3RhclxuICB9O1xuXG4gIHJldHVybiBEaXJlY3RlZEVkZ2VTdGFyO1xufShFZGdlRW5kU3RhcikpO1xuXG52YXIgT3ZlcmxheU5vZGVGYWN0b3J5ID0gKGZ1bmN0aW9uIChOb2RlRmFjdG9yeSQkMSkge1xuICBmdW5jdGlvbiBPdmVybGF5Tm9kZUZhY3RvcnkgKCkge1xuICAgIE5vZGVGYWN0b3J5JCQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIE5vZGVGYWN0b3J5JCQxICkgT3ZlcmxheU5vZGVGYWN0b3J5Ll9fcHJvdG9fXyA9IE5vZGVGYWN0b3J5JCQxO1xuICBPdmVybGF5Tm9kZUZhY3RvcnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTm9kZUZhY3RvcnkkJDEgJiYgTm9kZUZhY3RvcnkkJDEucHJvdG90eXBlICk7XG4gIE92ZXJsYXlOb2RlRmFjdG9yeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPdmVybGF5Tm9kZUZhY3Rvcnk7XG5cbiAgT3ZlcmxheU5vZGVGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gY3JlYXRlTm9kZSAoY29vcmQpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUoY29vcmQsIG5ldyBEaXJlY3RlZEVkZ2VTdGFyKCkpXG4gIH07XG4gIE92ZXJsYXlOb2RlRmFjdG9yeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE92ZXJsYXlOb2RlRmFjdG9yeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE92ZXJsYXlOb2RlRmFjdG9yeVxuICB9O1xuXG4gIHJldHVybiBPdmVybGF5Tm9kZUZhY3Rvcnk7XG59KE5vZGVGYWN0b3J5KSk7XG5cbnZhciBPcmllbnRlZENvb3JkaW5hdGVBcnJheSA9IGZ1bmN0aW9uIE9yaWVudGVkQ29vcmRpbmF0ZUFycmF5ICgpIHtcbiAgdGhpcy5fcHRzID0gbnVsbDtcbiAgdGhpcy5fb3JpZW50YXRpb24gPSBudWxsO1xuICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9wdHMgPSBwdHM7XG4gIHRoaXMuX29yaWVudGF0aW9uID0gT3JpZW50ZWRDb29yZGluYXRlQXJyYXkub3JpZW50YXRpb24ocHRzKTtcbn07XG5PcmllbnRlZENvb3JkaW5hdGVBcnJheS5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvMSkge1xuICB2YXIgb2NhID0gbzE7XG4gIHZhciBjb21wID0gT3JpZW50ZWRDb29yZGluYXRlQXJyYXkuY29tcGFyZU9yaWVudGVkKHRoaXMuX3B0cywgdGhpcy5fb3JpZW50YXRpb24sIG9jYS5fcHRzLCBvY2EuX29yaWVudGF0aW9uKTtcbiAgcmV0dXJuIGNvbXBcbn07XG5PcmllbnRlZENvb3JkaW5hdGVBcnJheS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5PcmllbnRlZENvb3JkaW5hdGVBcnJheS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBPcmllbnRlZENvb3JkaW5hdGVBcnJheVxufTtcbk9yaWVudGVkQ29vcmRpbmF0ZUFycmF5Lm9yaWVudGF0aW9uID0gZnVuY3Rpb24gb3JpZW50YXRpb24gKHB0cykge1xuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5cy5pbmNyZWFzaW5nRGlyZWN0aW9uKHB0cykgPT09IDFcbn07XG5PcmllbnRlZENvb3JkaW5hdGVBcnJheS5jb21wYXJlT3JpZW50ZWQgPSBmdW5jdGlvbiBjb21wYXJlT3JpZW50ZWQgKHB0czEsIG9yaWVudGF0aW9uMSwgcHRzMiwgb3JpZW50YXRpb24yKSB7XG4gIHZhciBkaXIxID0gb3JpZW50YXRpb24xID8gMSA6IC0xO1xuICB2YXIgZGlyMiA9IG9yaWVudGF0aW9uMiA/IDEgOiAtMTtcbiAgdmFyIGxpbWl0MSA9IG9yaWVudGF0aW9uMSA/IHB0czEubGVuZ3RoIDogLTE7XG4gIHZhciBsaW1pdDIgPSBvcmllbnRhdGlvbjIgPyBwdHMyLmxlbmd0aCA6IC0xO1xuICB2YXIgaTEgPSBvcmllbnRhdGlvbjEgPyAwIDogcHRzMS5sZW5ndGggLSAxO1xuICB2YXIgaTIgPSBvcmllbnRhdGlvbjIgPyAwIDogcHRzMi5sZW5ndGggLSAxO1xuICAvLyBjb25zdCBjb21wID0gMFxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBjb21wUHQgPSBwdHMxW2kxXS5jb21wYXJlVG8ocHRzMltpMl0pO1xuICAgIGlmIChjb21wUHQgIT09IDApIHsgcmV0dXJuIGNvbXBQdCB9XG4gICAgaTEgKz0gZGlyMTtcbiAgICBpMiArPSBkaXIyO1xuICAgIHZhciBkb25lMSA9IGkxID09PSBsaW1pdDE7XG4gICAgdmFyIGRvbmUyID0gaTIgPT09IGxpbWl0MjtcbiAgICBpZiAoZG9uZTEgJiYgIWRvbmUyKSB7IHJldHVybiAtMSB9XG4gICAgaWYgKCFkb25lMSAmJiBkb25lMikgeyByZXR1cm4gMSB9XG4gICAgaWYgKGRvbmUxICYmIGRvbmUyKSB7IHJldHVybiAwIH1cbiAgfVxufTtcblxudmFyIEVkZ2VMaXN0ID0gZnVuY3Rpb24gRWRnZUxpc3QgKCkge1xuICB0aGlzLl9lZGdlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fb2NhTWFwID0gbmV3IFRyZWVNYXAoKTtcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgb3V0LnByaW50KCdNVUxUSUxJTkVTVFJJTkcgKCAnKTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLl9lZGdlcy5zaXplKCk7IGorKykge1xuICAgIHZhciBlID0gdGhpcyQxLl9lZGdlcy5nZXQoaik7XG4gICAgaWYgKGogPiAwKSB7IG91dC5wcmludCgnLCcpOyB9XG4gICAgb3V0LnByaW50KCcoJyk7XG4gICAgdmFyIHB0cyA9IGUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgPiAwKSB7IG91dC5wcmludCgnLCcpOyB9XG4gICAgICBvdXQucHJpbnQocHRzW2ldLnggKyAnICcgKyBwdHNbaV0ueSk7XG4gICAgfVxuICAgIG91dC5wcmludGxuKCcpJyk7XG4gIH1cbiAgb3V0LnByaW50KCcpICAnKTtcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gYWRkQWxsIChlZGdlQ29sbCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSBlZGdlQ29sbC5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB0aGlzJDEuYWRkKGkubmV4dCgpKTtcbiAgfVxufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5maW5kRWRnZUluZGV4ID0gZnVuY3Rpb24gZmluZEVkZ2VJbmRleCAoZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZWRnZXMuc2l6ZSgpOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLl9lZGdlcy5nZXQoaSkuZXF1YWxzKGUpKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpXG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmdldEVkZ2VzID0gZnVuY3Rpb24gZ2V0RWRnZXMgKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZXNcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlcy5nZXQoaSlcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuZmluZEVxdWFsRWRnZSA9IGZ1bmN0aW9uIGZpbmRFcXVhbEVkZ2UgKGUpIHtcbiAgdmFyIG9jYSA9IG5ldyBPcmllbnRlZENvb3JkaW5hdGVBcnJheShlLmdldENvb3JkaW5hdGVzKCkpO1xuICB2YXIgbWF0Y2hFZGdlID0gdGhpcy5fb2NhTWFwLmdldChvY2EpO1xuICByZXR1cm4gbWF0Y2hFZGdlXG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZSkge1xuICB0aGlzLl9lZGdlcy5hZGQoZSk7XG4gIHZhciBvY2EgPSBuZXcgT3JpZW50ZWRDb29yZGluYXRlQXJyYXkoZS5nZXRDb29yZGluYXRlcygpKTtcbiAgdGhpcy5fb2NhTWFwLnB1dChvY2EsIGUpO1xufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZUxpc3Rcbn07XG5cbnZhciBTZWdtZW50SW50ZXJzZWN0b3IgPSBmdW5jdGlvbiBTZWdtZW50SW50ZXJzZWN0b3IgKCkge307XG5cblNlZ21lbnRJbnRlcnNlY3Rvci5wcm90b3R5cGUucHJvY2Vzc0ludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzSW50ZXJzZWN0aW9ucyAoZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkge307XG5TZWdtZW50SW50ZXJzZWN0b3IucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7fTtcblNlZ21lbnRJbnRlcnNlY3Rvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNlZ21lbnRJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTZWdtZW50SW50ZXJzZWN0b3Jcbn07XG5cbnZhciBJbnRlcnNlY3Rpb25BZGRlciA9IGZ1bmN0aW9uIEludGVyc2VjdGlvbkFkZGVyICgpIHtcbiAgdGhpcy5faGFzSW50ZXJzZWN0aW9uID0gZmFsc2U7XG4gIHRoaXMuX2hhc1Byb3BlciA9IGZhbHNlO1xuICB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvciA9IGZhbHNlO1xuICB0aGlzLl9oYXNJbnRlcmlvciA9IGZhbHNlO1xuICB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCA9IG51bGw7XG4gIHRoaXMuX2xpID0gbnVsbDtcbiAgdGhpcy5faXNTZWxmSW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgdGhpcy5udW1JbnRlcnNlY3Rpb25zID0gMDtcbiAgdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnMgPSAwO1xuICB0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnMgPSAwO1xuICB0aGlzLm51bVRlc3RzID0gMDtcbiAgdmFyIGxpID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9saSA9IGxpO1xufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5pc1RyaXZpYWxJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpc1RyaXZpYWxJbnRlcnNlY3Rpb24gKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpIHtcbiAgaWYgKGUwID09PSBlMSkge1xuICAgIGlmICh0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSA9PT0gMSkge1xuICAgICAgaWYgKEludGVyc2VjdGlvbkFkZGVyLmlzQWRqYWNlbnRTZWdtZW50cyhzZWdJbmRleDAsIHNlZ0luZGV4MSkpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYgKGUwLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgdmFyIG1heFNlZ0luZGV4ID0gZTAuc2l6ZSgpIC0gMTtcbiAgICAgICAgaWYgKChzZWdJbmRleDAgPT09IDAgJiYgc2VnSW5kZXgxID09PSBtYXhTZWdJbmRleCkgfHxcbiAgICAgICAgICAgIChzZWdJbmRleDEgPT09IDAgJiYgc2VnSW5kZXgwID09PSBtYXhTZWdJbmRleCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFByb3BlckludGVyc2VjdGlvblBvaW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50XG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3Jcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuZ2V0TGluZUludGVyc2VjdG9yID0gZnVuY3Rpb24gZ2V0TGluZUludGVyc2VjdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xpXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmhhc1Byb3BlckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc1Byb3BlckludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNQcm9wZXJcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUucHJvY2Vzc0ludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzSW50ZXJzZWN0aW9ucyAoZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkge1xuICBpZiAoZTAgPT09IGUxICYmIHNlZ0luZGV4MCA9PT0gc2VnSW5kZXgxKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5udW1UZXN0cysrO1xuICB2YXIgcDAwID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDBdO1xuICB2YXIgcDAxID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDAgKyAxXTtcbiAgdmFyIHAxMCA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxXTtcbiAgdmFyIHAxMSA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxICsgMV07XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAwLCBwMDEsIHAxMCwgcDExKTtcbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7XG4gICAgdGhpcy5udW1JbnRlcnNlY3Rpb25zKys7XG4gICAgaWYgKHRoaXMuX2xpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSkge1xuICAgICAgdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnMrKztcbiAgICAgIHRoaXMuX2hhc0ludGVyaW9yID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbihlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSkge1xuICAgICAgdGhpcy5faGFzSW50ZXJzZWN0aW9uID0gdHJ1ZTtcbiAgICAgIGUwLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksIHNlZ0luZGV4MCwgMCk7XG4gICAgICBlMS5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLCBzZWdJbmRleDEsIDEpO1xuICAgICAgaWYgKHRoaXMuX2xpLmlzUHJvcGVyKCkpIHtcbiAgICAgICAgdGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zKys7XG4gICAgICAgIHRoaXMuX2hhc1Byb3BlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2hhc1Byb3BlckludGVyaW9yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuaGFzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvblxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNJbnRlcmlvckludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNJbnRlcmlvclxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZWdtZW50SW50ZXJzZWN0b3JdXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSW50ZXJzZWN0aW9uQWRkZXJcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5pc0FkamFjZW50U2VnbWVudHMgPSBmdW5jdGlvbiBpc0FkamFjZW50U2VnbWVudHMgKGkxLCBpMikge1xuICByZXR1cm4gTWF0aC5hYnMoaTEgLSBpMikgPT09IDFcbn07XG5cbnZhciBFZGdlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gRWRnZUludGVyc2VjdGlvbiAoKSB7XG4gIHRoaXMuY29vcmQgPSBudWxsO1xuICB0aGlzLnNlZ21lbnRJbmRleCA9IG51bGw7XG4gIHRoaXMuZGlzdCA9IG51bGw7XG4gIHZhciBjb29yZCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIHNlZ21lbnRJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGRpc3QgPSBhcmd1bWVudHNbMl07XG4gIHRoaXMuY29vcmQgPSBuZXcgQ29vcmRpbmF0ZShjb29yZCk7XG4gIHRoaXMuc2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4O1xuICB0aGlzLmRpc3QgPSBkaXN0O1xufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmdldFNlZ21lbnRJbmRleCA9IGZ1bmN0aW9uIGdldFNlZ21lbnRJbmRleCAoKSB7XG4gIHJldHVybiB0aGlzLnNlZ21lbnRJbmRleFxufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuY29vcmRcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgb3V0LnByaW50KHRoaXMuY29vcmQpO1xuICBvdXQucHJpbnQoJyBzZWcgIyA9ICcgKyB0aGlzLnNlZ21lbnRJbmRleCk7XG4gIG91dC5wcmludGxuKCcgZGlzdCA9ICcgKyB0aGlzLmRpc3QpO1xufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAob2JqKSB7XG4gIHZhciBvdGhlciA9IG9iajtcbiAgcmV0dXJuIHRoaXMuY29tcGFyZShvdGhlci5zZWdtZW50SW5kZXgsIG90aGVyLmRpc3QpXG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuaXNFbmRQb2ludCA9IGZ1bmN0aW9uIGlzRW5kUG9pbnQgKG1heFNlZ21lbnRJbmRleCkge1xuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPT09IDAgJiYgdGhpcy5kaXN0ID09PSAwLjApIHsgcmV0dXJuIHRydWUgfVxuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPT09IG1heFNlZ21lbnRJbmRleCkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gdGhpcy5jb29yZCArICcgc2VnICMgPSAnICsgdGhpcy5zZWdtZW50SW5kZXggKyAnIGRpc3QgPSAnICsgdGhpcy5kaXN0XG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuZ2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXREaXN0YW5jZSAoKSB7XG4gIHJldHVybiB0aGlzLmRpc3Rcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoc2VnbWVudEluZGV4LCBkaXN0KSB7XG4gIGlmICh0aGlzLnNlZ21lbnRJbmRleCA8IHNlZ21lbnRJbmRleCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPiBzZWdtZW50SW5kZXgpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5kaXN0IDwgZGlzdCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5kaXN0ID4gZGlzdCkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVkZ2VJbnRlcnNlY3Rpb25cbn07XG5cbnZhciBFZGdlSW50ZXJzZWN0aW9uTGlzdCA9IGZ1bmN0aW9uIEVkZ2VJbnRlcnNlY3Rpb25MaXN0ICgpIHtcbiAgdGhpcy5fbm9kZU1hcCA9IG5ldyBUcmVlTWFwKCk7XG4gIHRoaXMuZWRnZSA9IG51bGw7XG4gIHZhciBlZGdlID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLmVkZ2UgPSBlZGdlO1xufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgb3V0LnByaW50bG4oJ0ludGVyc2VjdGlvbnM6Jyk7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIGVpLnByaW50KG91dCk7XG4gIH1cbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKClcbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuYWRkU3BsaXRFZGdlcyA9IGZ1bmN0aW9uIGFkZFNwbGl0RWRnZXMgKGVkZ2VMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5hZGRFbmRwb2ludHMoKTtcbiAgdmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpO1xuICB2YXIgZWlQcmV2ID0gaXQubmV4dCgpO1xuICB3aGlsZSAoaXQuaGFzTmV4dCgpKSB7XG4gICAgdmFyIGVpID0gaXQubmV4dCgpO1xuICAgIHZhciBuZXdFZGdlID0gdGhpcyQxLmNyZWF0ZVNwbGl0RWRnZShlaVByZXYsIGVpKTtcbiAgICBlZGdlTGlzdC5hZGQobmV3RWRnZSk7XG4gICAgZWlQcmV2ID0gZWk7XG4gIH1cbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuYWRkRW5kcG9pbnRzID0gZnVuY3Rpb24gYWRkRW5kcG9pbnRzICgpIHtcbiAgdmFyIG1heFNlZ0luZGV4ID0gdGhpcy5lZGdlLnB0cy5sZW5ndGggLSAxO1xuICB0aGlzLmFkZCh0aGlzLmVkZ2UucHRzWzBdLCAwLCAwLjApO1xuICB0aGlzLmFkZCh0aGlzLmVkZ2UucHRzW21heFNlZ0luZGV4XSwgbWF4U2VnSW5kZXgsIDAuMCk7XG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLmNyZWF0ZVNwbGl0RWRnZSA9IGZ1bmN0aW9uIGNyZWF0ZVNwbGl0RWRnZSAoZWkwLCBlaTEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbnB0cyA9IGVpMS5zZWdtZW50SW5kZXggLSBlaTAuc2VnbWVudEluZGV4ICsgMjtcbiAgdmFyIGxhc3RTZWdTdGFydFB0ID0gdGhpcy5lZGdlLnB0c1tlaTEuc2VnbWVudEluZGV4XTtcbiAgdmFyIHVzZUludFB0MSA9IGVpMS5kaXN0ID4gMC4wIHx8ICFlaTEuY29vcmQuZXF1YWxzMkQobGFzdFNlZ1N0YXJ0UHQpO1xuICBpZiAoIXVzZUludFB0MSkge1xuICAgIG5wdHMtLTtcbiAgfVxuICB2YXIgcHRzID0gbmV3IEFycmF5KG5wdHMpLmZpbGwobnVsbCk7XG4gIHZhciBpcHQgPSAwO1xuICBwdHNbaXB0KytdID0gbmV3IENvb3JkaW5hdGUoZWkwLmNvb3JkKTtcbiAgZm9yICh2YXIgaSA9IGVpMC5zZWdtZW50SW5kZXggKyAxOyBpIDw9IGVpMS5zZWdtZW50SW5kZXg7IGkrKykge1xuICAgIHB0c1tpcHQrK10gPSB0aGlzJDEuZWRnZS5wdHNbaV07XG4gIH1cbiAgaWYgKHVzZUludFB0MSkgeyBwdHNbaXB0XSA9IGVpMS5jb29yZDsgfVxuICByZXR1cm4gbmV3IEVkZ2UocHRzLCBuZXcgTGFiZWwodGhpcy5lZGdlLl9sYWJlbCkpXG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoaW50UHQsIHNlZ21lbnRJbmRleCwgZGlzdCkge1xuICB2YXIgZWlOZXcgPSBuZXcgRWRnZUludGVyc2VjdGlvbihpbnRQdCwgc2VnbWVudEluZGV4LCBkaXN0KTtcbiAgdmFyIGVpID0gdGhpcy5fbm9kZU1hcC5nZXQoZWlOZXcpO1xuICBpZiAoZWkgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZWlcbiAgfVxuICB0aGlzLl9ub2RlTWFwLnB1dChlaU5ldywgZWlOZXcpO1xuICByZXR1cm4gZWlOZXdcbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuaXNJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpc0ludGVyc2VjdGlvbiAocHQpIHtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZWkgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGVpLmNvb3JkLmVxdWFscyhwdCkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZUludGVyc2VjdGlvbkxpc3Rcbn07XG5cbnZhciBNb25vdG9uZUNoYWluSW5kZXhlciA9IGZ1bmN0aW9uIE1vbm90b25lQ2hhaW5JbmRleGVyICgpIHt9O1xuXG5Nb25vdG9uZUNoYWluSW5kZXhlci5wcm90b3R5cGUuZ2V0Q2hhaW5TdGFydEluZGljZXMgPSBmdW5jdGlvbiBnZXRDaGFpblN0YXJ0SW5kaWNlcyAocHRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIHN0YXJ0SW5kZXhMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBzdGFydEluZGV4TGlzdC5hZGQobmV3IEludGVnZXIoc3RhcnQpKTtcbiAgZG8ge1xuICAgIHZhciBsYXN0ID0gdGhpcyQxLmZpbmRDaGFpbkVuZChwdHMsIHN0YXJ0KTtcbiAgICBzdGFydEluZGV4TGlzdC5hZGQobmV3IEludGVnZXIobGFzdCkpO1xuICAgIHN0YXJ0ID0gbGFzdDtcbiAgfSB3aGlsZSAoc3RhcnQgPCBwdHMubGVuZ3RoIC0gMSlcbiAgdmFyIHN0YXJ0SW5kZXggPSBNb25vdG9uZUNoYWluSW5kZXhlci50b0ludEFycmF5KHN0YXJ0SW5kZXhMaXN0KTtcbiAgcmV0dXJuIHN0YXJ0SW5kZXhcbn07XG5Nb25vdG9uZUNoYWluSW5kZXhlci5wcm90b3R5cGUuZmluZENoYWluRW5kID0gZnVuY3Rpb24gZmluZENoYWluRW5kIChwdHMsIHN0YXJ0KSB7XG4gIHZhciBjaGFpblF1YWQgPSBRdWFkcmFudC5xdWFkcmFudChwdHNbc3RhcnRdLCBwdHNbc3RhcnQgKyAxXSk7XG4gIHZhciBsYXN0ID0gc3RhcnQgKyAxO1xuICB3aGlsZSAobGFzdCA8IHB0cy5sZW5ndGgpIHtcbiAgICB2YXIgcXVhZCA9IFF1YWRyYW50LnF1YWRyYW50KHB0c1tsYXN0IC0gMV0sIHB0c1tsYXN0XSk7XG4gICAgaWYgKHF1YWQgIT09IGNoYWluUXVhZCkgeyBicmVhayB9XG4gICAgbGFzdCsrO1xuICB9XG4gIHJldHVybiBsYXN0IC0gMVxufTtcbk1vbm90b25lQ2hhaW5JbmRleGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTW9ub3RvbmVDaGFpbkluZGV4ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub3RvbmVDaGFpbkluZGV4ZXJcbn07XG5Nb25vdG9uZUNoYWluSW5kZXhlci50b0ludEFycmF5ID0gZnVuY3Rpb24gdG9JbnRBcnJheSAobGlzdCkge1xuICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobGlzdC5zaXplKCkpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IGxpc3QuZ2V0KGkpLmludFZhbHVlKCk7XG4gIH1cbiAgcmV0dXJuIGFycmF5XG59O1xuXG52YXIgTW9ub3RvbmVDaGFpbkVkZ2UgPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluRWRnZSAoKSB7XG4gIHRoaXMuZSA9IG51bGw7XG4gIHRoaXMucHRzID0gbnVsbDtcbiAgdGhpcy5zdGFydEluZGV4ID0gbnVsbDtcbiAgdGhpcy5lbnYxID0gbmV3IEVudmVsb3BlKCk7XG4gIHRoaXMuZW52MiA9IG5ldyBFbnZlbG9wZSgpO1xuICB2YXIgZSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5lID0gZTtcbiAgdGhpcy5wdHMgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gIHZhciBtY2IgPSBuZXcgTW9ub3RvbmVDaGFpbkluZGV4ZXIoKTtcbiAgdGhpcy5zdGFydEluZGV4ID0gbWNiLmdldENoYWluU3RhcnRJbmRpY2VzKHRoaXMucHRzKTtcbn07XG5Nb25vdG9uZUNoYWluRWRnZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gIHJldHVybiB0aGlzLnB0c1xufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5nZXRNYXhYID0gZnVuY3Rpb24gZ2V0TWF4WCAoY2hhaW5JbmRleCkge1xuICB2YXIgeDEgPSB0aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbY2hhaW5JbmRleF1dLng7XG4gIHZhciB4MiA9IHRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFtjaGFpbkluZGV4ICsgMV1dLng7XG4gIHJldHVybiB4MSA+IHgyID8geDEgOiB4MlxufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5nZXRNaW5YID0gZnVuY3Rpb24gZ2V0TWluWCAoY2hhaW5JbmRleCkge1xuICB2YXIgeDEgPSB0aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbY2hhaW5JbmRleF1dLng7XG4gIHZhciB4MiA9IHRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFtjaGFpbkluZGV4ICsgMV1dLng7XG4gIHJldHVybiB4MSA8IHgyID8geDEgOiB4MlxufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluID0gZnVuY3Rpb24gY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIGNoYWluSW5kZXgwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtY2UgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGNoYWluSW5kZXgxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBzaSA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5zdGFydEluZGV4W2NoYWluSW5kZXgwXSwgdGhpcy5zdGFydEluZGV4W2NoYWluSW5kZXgwICsgMV0sIG1jZSwgbWNlLnN0YXJ0SW5kZXhbY2hhaW5JbmRleDFdLCBtY2Uuc3RhcnRJbmRleFtjaGFpbkluZGV4MSArIDFdLCBzaSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNikge1xuICAgIHZhciBzdGFydDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGVuZDAgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1jZSQxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBzdGFydDEgPSBhcmd1bWVudHNbM107XG4gICAgdmFyIGVuZDEgPSBhcmd1bWVudHNbNF07XG4gICAgdmFyIGVpID0gYXJndW1lbnRzWzVdO1xuICAgIHZhciBwMDAgPSB0aGlzLnB0c1tzdGFydDBdO1xuICAgIHZhciBwMDEgPSB0aGlzLnB0c1tlbmQwXTtcbiAgICB2YXIgcDEwID0gbWNlJDEucHRzW3N0YXJ0MV07XG4gICAgdmFyIHAxMSA9IG1jZSQxLnB0c1tlbmQxXTtcbiAgICBpZiAoZW5kMCAtIHN0YXJ0MCA9PT0gMSAmJiBlbmQxIC0gc3RhcnQxID09PSAxKSB7XG4gICAgICBlaS5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuZSwgc3RhcnQwLCBtY2UkMS5lLCBzdGFydDEpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdGhpcy5lbnYxLmluaXQocDAwLCBwMDEpO1xuICAgIHRoaXMuZW52Mi5pbml0KHAxMCwgcDExKTtcbiAgICBpZiAoIXRoaXMuZW52MS5pbnRlcnNlY3RzKHRoaXMuZW52MikpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBtaWQwID0gTWF0aC50cnVuYygoc3RhcnQwICsgZW5kMCkgLyAyKTtcbiAgICB2YXIgbWlkMSA9IE1hdGgudHJ1bmMoKHN0YXJ0MSArIGVuZDEpIC8gMik7XG4gICAgaWYgKHN0YXJ0MCA8IG1pZDApIHtcbiAgICAgIGlmIChzdGFydDEgPCBtaWQxKSB7IHRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihzdGFydDAsIG1pZDAsIG1jZSQxLCBzdGFydDEsIG1pZDEsIGVpKTsgfVxuICAgICAgaWYgKG1pZDEgPCBlbmQxKSB7IHRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihzdGFydDAsIG1pZDAsIG1jZSQxLCBtaWQxLCBlbmQxLCBlaSk7IH1cbiAgICB9XG4gICAgaWYgKG1pZDAgPCBlbmQwKSB7XG4gICAgICBpZiAoc3RhcnQxIDwgbWlkMSkgeyB0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obWlkMCwgZW5kMCwgbWNlJDEsIHN0YXJ0MSwgbWlkMSwgZWkpOyB9XG4gICAgICBpZiAobWlkMSA8IGVuZDEpIHsgdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG1pZDAsIGVuZDAsIG1jZSQxLCBtaWQxLCBlbmQxLCBlaSk7IH1cbiAgICB9XG4gIH1cbn07XG5Nb25vdG9uZUNoYWluRWRnZS5wcm90b3R5cGUuZ2V0U3RhcnRJbmRleGVzID0gZnVuY3Rpb24gZ2V0U3RhcnRJbmRleGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuc3RhcnRJbmRleFxufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3RzIChtY2UsIHNpKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YXJ0SW5kZXgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBtY2Uuc3RhcnRJbmRleC5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgIHRoaXMkMS5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKGksIG1jZSwgaiwgc2kpO1xuICAgIH1cbiAgfVxufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTW9ub3RvbmVDaGFpbkVkZ2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub3RvbmVDaGFpbkVkZ2Vcbn07XG5cbnZhciBEZXB0aCA9IGZ1bmN0aW9uIERlcHRoICgpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5fZGVwdGggPSBBcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFycmF5KDMpOyB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgdGhpcyQxLl9kZXB0aFtpXVtqXSA9IERlcHRoLk5VTExfVkFMVUU7XG4gICAgfVxuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDMxID0geyBOVUxMX1ZBTFVFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5EZXB0aC5wcm90b3R5cGUuZ2V0RGVwdGggPSBmdW5jdGlvbiBnZXREZXB0aCAoZ2VvbUluZGV4LCBwb3NJbmRleCkge1xuICByZXR1cm4gdGhpcy5fZGVwdGhbZ2VvbUluZGV4XVtwb3NJbmRleF1cbn07XG5EZXB0aC5wcm90b3R5cGUuc2V0RGVwdGggPSBmdW5jdGlvbiBzZXREZXB0aCAoZ2VvbUluZGV4LCBwb3NJbmRleCwgZGVwdGhWYWx1ZSkge1xuICB0aGlzLl9kZXB0aFtnZW9tSW5kZXhdW3Bvc0luZGV4XSA9IGRlcHRoVmFsdWU7XG59O1xuRGVwdGgucHJvdG90eXBlLmlzTnVsbCA9IGZ1bmN0aW9uIGlzTnVsbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgaWYgKHRoaXMkMS5fZGVwdGhbaV1bal0gIT09IERlcHRoLk5VTExfVkFMVUUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5fZGVwdGhbZ2VvbUluZGV4XVsxXSA9PT0gRGVwdGguTlVMTF9WQUxVRVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbUluZGV4JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHBvc0luZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiB0aGlzLl9kZXB0aFtnZW9tSW5kZXgkMV1bcG9zSW5kZXhdID09PSBEZXB0aC5OVUxMX1ZBTFVFXG4gIH1cbn07XG5EZXB0aC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIGlmICghdGhpcyQxLmlzTnVsbChpKSkge1xuICAgICAgdmFyIG1pbkRlcHRoID0gdGhpcyQxLl9kZXB0aFtpXVsxXTtcbiAgICAgIGlmICh0aGlzJDEuX2RlcHRoW2ldWzJdIDwgbWluRGVwdGgpIHsgbWluRGVwdGggPSB0aGlzJDEuX2RlcHRoW2ldWzJdOyB9XG4gICAgICBpZiAobWluRGVwdGggPCAwKSB7IG1pbkRlcHRoID0gMDsgfVxuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCAzOyBqKyspIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gMDtcbiAgICAgICAgaWYgKHRoaXMkMS5fZGVwdGhbaV1bal0gPiBtaW5EZXB0aCkgeyBuZXdWYWx1ZSA9IDE7IH1cbiAgICAgICAgdGhpcyQxLl9kZXB0aFtpXVtqXSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkRlcHRoLnByb3RvdHlwZS5nZXREZWx0YSA9IGZ1bmN0aW9uIGdldERlbHRhIChnZW9tSW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuX2RlcHRoW2dlb21JbmRleF1bUG9zaXRpb24uUklHSFRdIC0gdGhpcy5fZGVwdGhbZ2VvbUluZGV4XVtQb3NpdGlvbi5MRUZUXVxufTtcbkRlcHRoLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uIChnZW9tSW5kZXgsIHBvc0luZGV4KSB7XG4gIGlmICh0aGlzLl9kZXB0aFtnZW9tSW5kZXhdW3Bvc0luZGV4XSA8PSAwKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gIHJldHVybiBMb2NhdGlvbi5JTlRFUklPUlxufTtcbkRlcHRoLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuICdBOiAnICsgdGhpcy5fZGVwdGhbMF1bMV0gKyAnLCcgKyB0aGlzLl9kZXB0aFswXVsyXSArICcgQjogJyArIHRoaXMuX2RlcHRoWzFdWzFdICsgJywnICsgdGhpcy5fZGVwdGhbMV1bMl1cbn07XG5EZXB0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsYmwgPSBhcmd1bWVudHNbMF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgMzsgaisrKSB7XG4gICAgICAgIHZhciBsb2MgPSBsYmwuZ2V0TG9jYXRpb24oaSwgaik7XG4gICAgICAgIGlmIChsb2MgPT09IExvY2F0aW9uLkVYVEVSSU9SIHx8IGxvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHtcbiAgICAgICAgICBpZiAodGhpcyQxLmlzTnVsbChpLCBqKSkge1xuICAgICAgICAgICAgdGhpcyQxLl9kZXB0aFtpXVtqXSA9IERlcHRoLmRlcHRoQXRMb2NhdGlvbihsb2MpO1xuICAgICAgICAgIH0gZWxzZSB7IHRoaXMkMS5fZGVwdGhbaV1bal0gKz0gRGVwdGguZGVwdGhBdExvY2F0aW9uKGxvYyk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcG9zSW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGxvY2F0aW9uID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgdGhpcy5fZGVwdGhbZ2VvbUluZGV4XVtwb3NJbmRleF0rKzsgfVxuICB9XG59O1xuRGVwdGgucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5EZXB0aC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEZXB0aFxufTtcbkRlcHRoLmRlcHRoQXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGRlcHRoQXRMb2NhdGlvbiAobG9jYXRpb24pIHtcbiAgaWYgKGxvY2F0aW9uID09PSBMb2NhdGlvbi5FWFRFUklPUikgeyByZXR1cm4gMCB9XG4gIGlmIChsb2NhdGlvbiA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gRGVwdGguTlVMTF9WQUxVRVxufTtcbnN0YXRpY0FjY2Vzc29ycyQzMS5OVUxMX1ZBTFVFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEZXB0aCwgc3RhdGljQWNjZXNzb3JzJDMxICk7XG5cbnZhciBFZGdlID0gKGZ1bmN0aW9uIChHcmFwaENvbXBvbmVudCQkMSkge1xuICBmdW5jdGlvbiBFZGdlICgpIHtcbiAgICBHcmFwaENvbXBvbmVudCQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMucHRzID0gbnVsbDtcbiAgICB0aGlzLl9lbnYgPSBudWxsO1xuICAgIHRoaXMuZWlMaXN0ID0gbmV3IEVkZ2VJbnRlcnNlY3Rpb25MaXN0KHRoaXMpO1xuICAgIHRoaXMuX25hbWUgPSBudWxsO1xuICAgIHRoaXMuX21jZSA9IG51bGw7XG4gICAgdGhpcy5faXNJc29sYXRlZCA9IHRydWU7XG4gICAgdGhpcy5fZGVwdGggPSBuZXcgRGVwdGgoKTtcbiAgICB0aGlzLl9kZXB0aERlbHRhID0gMDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIHB0cyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIEVkZ2UuY2FsbCh0aGlzLCBwdHMsIG51bGwpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIHB0cyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxhYmVsID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy5wdHMgPSBwdHMkMTtcbiAgICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCBHcmFwaENvbXBvbmVudCQkMSApIEVkZ2UuX19wcm90b19fID0gR3JhcGhDb21wb25lbnQkJDE7XG4gIEVkZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR3JhcGhDb21wb25lbnQkJDEgJiYgR3JhcGhDb21wb25lbnQkJDEucHJvdG90eXBlICk7XG4gIEVkZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWRnZTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0RGVwdGggPSBmdW5jdGlvbiBnZXREZXB0aCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlcHRoXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldENvbGxhcHNlZEVkZ2UgPSBmdW5jdGlvbiBnZXRDb2xsYXBzZWRFZGdlICgpIHtcbiAgICB2YXIgbmV3UHRzID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gICAgbmV3UHRzWzBdID0gdGhpcy5wdHNbMF07XG4gICAgbmV3UHRzWzFdID0gdGhpcy5wdHNbMV07XG4gICAgdmFyIG5ld2UgPSBuZXcgRWRnZShuZXdQdHMsIExhYmVsLnRvTGluZUxhYmVsKHRoaXMuX2xhYmVsKSk7XG4gICAgcmV0dXJuIG5ld2VcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuaXNJc29sYXRlZCA9IGZ1bmN0aW9uIGlzSXNvbGF0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc0lzb2xhdGVkXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHJldHVybiB0aGlzLnB0c1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS5zZXRJc29sYXRlZCA9IGZ1bmN0aW9uIHNldElzb2xhdGVkIChpc0lzb2xhdGVkKSB7XG4gICAgdGhpcy5faXNJc29sYXRlZCA9IGlzSXNvbGF0ZWQ7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbiBzZXROYW1lIChuYW1lKSB7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAobykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKCEobyBpbnN0YW5jZW9mIEVkZ2UpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGUgPSBvO1xuICAgIGlmICh0aGlzLnB0cy5sZW5ndGggIT09IGUucHRzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHZhciBpc0VxdWFsRm9yd2FyZCA9IHRydWU7XG4gICAgdmFyIGlzRXF1YWxSZXZlcnNlID0gdHJ1ZTtcbiAgICB2YXIgaVJldiA9IHRoaXMucHRzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMkMS5wdHNbaV0uZXF1YWxzMkQoZS5wdHNbaV0pKSB7XG4gICAgICAgIGlzRXF1YWxGb3J3YXJkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMkMS5wdHNbaV0uZXF1YWxzMkQoZS5wdHNbLS1pUmV2XSkpIHtcbiAgICAgICAgaXNFcXVhbFJldmVyc2UgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNFcXVhbEZvcndhcmQgJiYgIWlzRXF1YWxSZXZlcnNlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMucHRzLmxlbmd0aCA+IDApIHsgcmV0dXJuIHRoaXMucHRzWzBdIH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgaSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLnB0c1tpXVxuICAgIH1cbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBvdXQucHJpbnQoJ2VkZ2UgJyArIHRoaXMuX25hbWUgKyAnOiAnKTtcbiAgICBvdXQucHJpbnQoJ0xJTkVTVFJJTkcgKCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkgeyBvdXQucHJpbnQoJywnKTsgfVxuICAgICAgb3V0LnByaW50KHRoaXMkMS5wdHNbaV0ueCArICcgJyArIHRoaXMkMS5wdHNbaV0ueSk7XG4gICAgfVxuICAgIG91dC5wcmludCgnKSAgJyArIHRoaXMuX2xhYmVsICsgJyAnICsgdGhpcy5fZGVwdGhEZWx0YSk7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmNvbXB1dGVJTSA9IGZ1bmN0aW9uIGNvbXB1dGVJTSAoaW0pIHtcbiAgICBFZGdlLnVwZGF0ZUlNKHRoaXMuX2xhYmVsLCBpbSk7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmlzQ29sbGFwc2VkID0gZnVuY3Rpb24gaXNDb2xsYXBzZWQgKCkge1xuICAgIGlmICghdGhpcy5fbGFiZWwuaXNBcmVhKCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodGhpcy5wdHMubGVuZ3RoICE9PSAzKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1syXSkpIHsgcmV0dXJuIHRydWUgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzW3RoaXMucHRzLmxlbmd0aCAtIDFdKVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXRNYXhpbXVtU2VnbWVudEluZGV4ID0gZnVuY3Rpb24gZ2V0TWF4aW11bVNlZ21lbnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHRzLmxlbmd0aCAtIDFcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0RGVwdGhEZWx0YSA9IGZ1bmN0aW9uIGdldERlcHRoRGVsdGEgKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXB0aERlbHRhXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldE51bVBvaW50cyA9IGZ1bmN0aW9uIGdldE51bVBvaW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHRzLmxlbmd0aFxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5wcmludFJldmVyc2UgPSBmdW5jdGlvbiBwcmludFJldmVyc2UgKG91dCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgb3V0LnByaW50KCdlZGdlICcgKyB0aGlzLl9uYW1lICsgJzogJyk7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMucHRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBvdXQucHJpbnQodGhpcyQxLnB0c1tpXSArICcgJyk7XG4gICAgfVxuICAgIG91dC5wcmludGxuKCcnKTtcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0TW9ub3RvbmVDaGFpbkVkZ2UgPSBmdW5jdGlvbiBnZXRNb25vdG9uZUNoYWluRWRnZSAoKSB7XG4gICAgaWYgKHRoaXMuX21jZSA9PT0gbnVsbCkgeyB0aGlzLl9tY2UgPSBuZXcgTW9ub3RvbmVDaGFpbkVkZ2UodGhpcyk7IH1cbiAgICByZXR1cm4gdGhpcy5fbWNlXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldEVudmVsb3BlID0gZnVuY3Rpb24gZ2V0RW52ZWxvcGUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX2VudiA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fZW52ID0gbmV3IEVudmVsb3BlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS5fZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzJDEucHRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VudlxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5hZGRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBhZGRJbnRlcnNlY3Rpb24gKGxpLCBzZWdtZW50SW5kZXgsIGdlb21JbmRleCwgaW50SW5kZXgpIHtcbiAgICB2YXIgaW50UHQgPSBuZXcgQ29vcmRpbmF0ZShsaS5nZXRJbnRlcnNlY3Rpb24oaW50SW5kZXgpKTtcbiAgICB2YXIgbm9ybWFsaXplZFNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleDtcbiAgICB2YXIgZGlzdCA9IGxpLmdldEVkZ2VEaXN0YW5jZShnZW9tSW5kZXgsIGludEluZGV4KTtcbiAgICB2YXIgbmV4dFNlZ0luZGV4ID0gbm9ybWFsaXplZFNlZ21lbnRJbmRleCArIDE7XG4gICAgaWYgKG5leHRTZWdJbmRleCA8IHRoaXMucHRzLmxlbmd0aCkge1xuICAgICAgdmFyIG5leHRQdCA9IHRoaXMucHRzW25leHRTZWdJbmRleF07XG4gICAgICBpZiAoaW50UHQuZXF1YWxzMkQobmV4dFB0KSkge1xuICAgICAgICBub3JtYWxpemVkU2VnbWVudEluZGV4ID0gbmV4dFNlZ0luZGV4O1xuICAgICAgICBkaXN0ID0gMC4wO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVpTGlzdC5hZGQoaW50UHQsIG5vcm1hbGl6ZWRTZWdtZW50SW5kZXgsIGRpc3QpO1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBidWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gICAgYnVmLmFwcGVuZCgnZWRnZSAnICsgdGhpcy5fbmFtZSArICc6ICcpO1xuICAgIGJ1Zi5hcHBlbmQoJ0xJTkVTVFJJTkcgKCcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChpID4gMCkgeyBidWYuYXBwZW5kKCcsJyk7IH1cbiAgICAgIGJ1Zi5hcHBlbmQodGhpcyQxLnB0c1tpXS54ICsgJyAnICsgdGhpcyQxLnB0c1tpXS55KTtcbiAgICB9XG4gICAgYnVmLmFwcGVuZCgnKSAgJyArIHRoaXMuX2xhYmVsICsgJyAnICsgdGhpcy5fZGVwdGhEZWx0YSk7XG4gICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmlzUG9pbnR3aXNlRXF1YWwgPSBmdW5jdGlvbiBpc1BvaW50d2lzZUVxdWFsIChlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5wdHMubGVuZ3RoICE9PSBlLnB0cy5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMkMS5wdHNbaV0uZXF1YWxzMkQoZS5wdHNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5zZXREZXB0aERlbHRhID0gZnVuY3Rpb24gc2V0RGVwdGhEZWx0YSAoZGVwdGhEZWx0YSkge1xuICAgIHRoaXMuX2RlcHRoRGVsdGEgPSBkZXB0aERlbHRhO1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCA9IGZ1bmN0aW9uIGdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5laUxpc3RcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbnMgKGxpLCBzZWdtZW50SW5kZXgsIGdlb21JbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaS5nZXRJbnRlcnNlY3Rpb25OdW0oKTsgaSsrKSB7XG4gICAgICB0aGlzJDEuYWRkSW50ZXJzZWN0aW9uKGxpLCBzZWdtZW50SW5kZXgsIGdlb21JbmRleCwgaSk7XG4gICAgfVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIEVkZ2VcbiAgfTtcbiAgRWRnZS51cGRhdGVJTSA9IGZ1bmN0aW9uIHVwZGF0ZUlNICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGxhYmVsID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGltID0gYXJndW1lbnRzWzFdO1xuICAgICAgaW0uc2V0QXRMZWFzdElmVmFsaWQobGFiZWwuZ2V0TG9jYXRpb24oMCwgUG9zaXRpb24uT04pLCBsYWJlbC5nZXRMb2NhdGlvbigxLCBQb3NpdGlvbi5PTiksIDEpO1xuICAgICAgaWYgKGxhYmVsLmlzQXJlYSgpKSB7XG4gICAgICAgIGltLnNldEF0TGVhc3RJZlZhbGlkKGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLkxFRlQpLCBsYWJlbC5nZXRMb2NhdGlvbigxLCBQb3NpdGlvbi5MRUZUKSwgMik7XG4gICAgICAgIGltLnNldEF0TGVhc3RJZlZhbGlkKGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLlJJR0hUKSwgbGFiZWwuZ2V0TG9jYXRpb24oMSwgUG9zaXRpb24uUklHSFQpLCAyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyByZXR1cm4gR3JhcGhDb21wb25lbnQkJDEucHJvdG90eXBlLnVwZGF0ZUlNLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuXG4gIHJldHVybiBFZGdlO1xufShHcmFwaENvbXBvbmVudCkpO1xuXG52YXIgQnVmZmVyQnVpbGRlciA9IGZ1bmN0aW9uIEJ1ZmZlckJ1aWxkZXIgKGJ1ZlBhcmFtcykge1xuICB0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWwgPSBudWxsO1xuICB0aGlzLl93b3JraW5nTm9kZXIgPSBudWxsO1xuICB0aGlzLl9nZW9tRmFjdCA9IG51bGw7XG4gIHRoaXMuX2dyYXBoID0gbnVsbDtcbiAgdGhpcy5fZWRnZUxpc3QgPSBuZXcgRWRnZUxpc3QoKTtcbiAgdGhpcy5fYnVmUGFyYW1zID0gYnVmUGFyYW1zIHx8IG51bGw7XG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuc2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsID0gZnVuY3Rpb24gc2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsIChwbSkge1xuICB0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWwgPSBwbTtcbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5pbnNlcnRVbmlxdWVFZGdlID0gZnVuY3Rpb24gaW5zZXJ0VW5pcXVlRWRnZSAoZSkge1xuICB2YXIgZXhpc3RpbmdFZGdlID0gdGhpcy5fZWRnZUxpc3QuZmluZEVxdWFsRWRnZShlKTtcbiAgaWYgKGV4aXN0aW5nRWRnZSAhPT0gbnVsbCkge1xuICAgIHZhciBleGlzdGluZ0xhYmVsID0gZXhpc3RpbmdFZGdlLmdldExhYmVsKCk7XG4gICAgdmFyIGxhYmVsVG9NZXJnZSA9IGUuZ2V0TGFiZWwoKTtcbiAgICBpZiAoIWV4aXN0aW5nRWRnZS5pc1BvaW50d2lzZUVxdWFsKGUpKSB7XG4gICAgICBsYWJlbFRvTWVyZ2UgPSBuZXcgTGFiZWwoZS5nZXRMYWJlbCgpKTtcbiAgICAgIGxhYmVsVG9NZXJnZS5mbGlwKCk7XG4gICAgfVxuICAgIGV4aXN0aW5nTGFiZWwubWVyZ2UobGFiZWxUb01lcmdlKTtcbiAgICB2YXIgbWVyZ2VEZWx0YSA9IEJ1ZmZlckJ1aWxkZXIuZGVwdGhEZWx0YShsYWJlbFRvTWVyZ2UpO1xuICAgIHZhciBleGlzdGluZ0RlbHRhID0gZXhpc3RpbmdFZGdlLmdldERlcHRoRGVsdGEoKTtcbiAgICB2YXIgbmV3RGVsdGEgPSBleGlzdGluZ0RlbHRhICsgbWVyZ2VEZWx0YTtcbiAgICBleGlzdGluZ0VkZ2Uuc2V0RGVwdGhEZWx0YShuZXdEZWx0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZWRnZUxpc3QuYWRkKGUpO1xuICAgIGUuc2V0RGVwdGhEZWx0YShCdWZmZXJCdWlsZGVyLmRlcHRoRGVsdGEoZS5nZXRMYWJlbCgpKSk7XG4gIH1cbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5idWlsZFN1YmdyYXBocyA9IGZ1bmN0aW9uIGJ1aWxkU3ViZ3JhcGhzIChzdWJncmFwaExpc3QsIHBvbHlCdWlsZGVyKSB7XG4gIHZhciBwcm9jZXNzZWRHcmFwaHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSBzdWJncmFwaExpc3QuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIHN1YmdyYXBoID0gaS5uZXh0KCk7XG4gICAgdmFyIHAgPSBzdWJncmFwaC5nZXRSaWdodG1vc3RDb29yZGluYXRlKCk7XG4gICAgdmFyIGxvY2F0ZXIgPSBuZXcgU3ViZ3JhcGhEZXB0aExvY2F0ZXIocHJvY2Vzc2VkR3JhcGhzKTtcbiAgICB2YXIgb3V0c2lkZURlcHRoID0gbG9jYXRlci5nZXREZXB0aChwKTtcbiAgICBzdWJncmFwaC5jb21wdXRlRGVwdGgob3V0c2lkZURlcHRoKTtcbiAgICBzdWJncmFwaC5maW5kUmVzdWx0RWRnZXMoKTtcbiAgICBwcm9jZXNzZWRHcmFwaHMuYWRkKHN1YmdyYXBoKTtcbiAgICBwb2x5QnVpbGRlci5hZGQoc3ViZ3JhcGguZ2V0RGlyZWN0ZWRFZGdlcygpLCBzdWJncmFwaC5nZXROb2RlcygpKTtcbiAgfVxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZVN1YmdyYXBocyA9IGZ1bmN0aW9uIGNyZWF0ZVN1YmdyYXBocyAoZ3JhcGgpIHtcbiAgdmFyIHN1YmdyYXBoTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IGdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG5vZGUgPSBpLm5leHQoKTtcbiAgICBpZiAoIW5vZGUuaXNWaXNpdGVkKCkpIHtcbiAgICAgIHZhciBzdWJncmFwaCA9IG5ldyBCdWZmZXJTdWJncmFwaCgpO1xuICAgICAgc3ViZ3JhcGguY3JlYXRlKG5vZGUpO1xuICAgICAgc3ViZ3JhcGhMaXN0LmFkZChzdWJncmFwaCk7XG4gICAgfVxuICB9XG4gIENvbGxlY3Rpb25zLnNvcnQoc3ViZ3JhcGhMaXN0LCBDb2xsZWN0aW9ucy5yZXZlcnNlT3JkZXIoKSk7XG4gIHJldHVybiBzdWJncmFwaExpc3Rcbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5ID0gZnVuY3Rpb24gY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSAoKSB7XG4gIHZhciBlbXB0eUdlb20gPSB0aGlzLl9nZW9tRmFjdC5jcmVhdGVQb2x5Z29uKCk7XG4gIHJldHVybiBlbXB0eUdlb21cbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5nZXROb2RlciA9IGZ1bmN0aW9uIGdldE5vZGVyIChwcmVjaXNpb25Nb2RlbCkge1xuICBpZiAodGhpcy5fd29ya2luZ05vZGVyICE9PSBudWxsKSB7IHJldHVybiB0aGlzLl93b3JraW5nTm9kZXIgfVxuICB2YXIgbm9kZXIgPSBuZXcgTUNJbmRleE5vZGVyKCk7XG4gIHZhciBsaSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgbGkuc2V0UHJlY2lzaW9uTW9kZWwocHJlY2lzaW9uTW9kZWwpO1xuICBub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IobmV3IEludGVyc2VjdGlvbkFkZGVyKGxpKSk7XG4gIHJldHVybiBub2RlclxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmJ1ZmZlciA9IGZ1bmN0aW9uIGJ1ZmZlciAoZywgZGlzdGFuY2UpIHtcbiAgdmFyIHByZWNpc2lvbk1vZGVsID0gdGhpcy5fd29ya2luZ1ByZWNpc2lvbk1vZGVsO1xuICBpZiAocHJlY2lzaW9uTW9kZWwgPT09IG51bGwpIHsgcHJlY2lzaW9uTW9kZWwgPSBnLmdldFByZWNpc2lvbk1vZGVsKCk7IH1cbiAgdGhpcy5fZ2VvbUZhY3QgPSBnLmdldEZhY3RvcnkoKTtcbiAgdmFyIGN1cnZlQnVpbGRlciA9IG5ldyBPZmZzZXRDdXJ2ZUJ1aWxkZXIocHJlY2lzaW9uTW9kZWwsIHRoaXMuX2J1ZlBhcmFtcyk7XG4gIHZhciBjdXJ2ZVNldEJ1aWxkZXIgPSBuZXcgT2Zmc2V0Q3VydmVTZXRCdWlsZGVyKGcsIGRpc3RhbmNlLCBjdXJ2ZUJ1aWxkZXIpO1xuICB2YXIgYnVmZmVyU2VnU3RyTGlzdCA9IGN1cnZlU2V0QnVpbGRlci5nZXRDdXJ2ZXMoKTtcbiAgaWYgKGJ1ZmZlclNlZ1N0ckxpc3Quc2l6ZSgpIDw9IDApIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KClcbiAgfVxuICB0aGlzLmNvbXB1dGVOb2RlZEVkZ2VzKGJ1ZmZlclNlZ1N0ckxpc3QsIHByZWNpc2lvbk1vZGVsKTtcbiAgdGhpcy5fZ3JhcGggPSBuZXcgUGxhbmFyR3JhcGgobmV3IE92ZXJsYXlOb2RlRmFjdG9yeSgpKTtcbiAgdGhpcy5fZ3JhcGguYWRkRWRnZXModGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSk7XG4gIHZhciBzdWJncmFwaExpc3QgPSB0aGlzLmNyZWF0ZVN1YmdyYXBocyh0aGlzLl9ncmFwaCk7XG4gIHZhciBwb2x5QnVpbGRlciA9IG5ldyBQb2x5Z29uQnVpbGRlcih0aGlzLl9nZW9tRmFjdCk7XG4gIHRoaXMuYnVpbGRTdWJncmFwaHMoc3ViZ3JhcGhMaXN0LCBwb2x5QnVpbGRlcik7XG4gIHZhciByZXN1bHRQb2x5TGlzdCA9IHBvbHlCdWlsZGVyLmdldFBvbHlnb25zKCk7XG4gIGlmIChyZXN1bHRQb2x5TGlzdC5zaXplKCkgPD0gMCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKVxuICB9XG4gIHZhciByZXN1bHRHZW9tID0gdGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShyZXN1bHRQb2x5TGlzdCk7XG4gIHJldHVybiByZXN1bHRHZW9tXG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZU5vZGVkRWRnZXMgPSBmdW5jdGlvbiBjb21wdXRlTm9kZWRFZGdlcyAoYnVmZmVyU2VnU3RyTGlzdCwgcHJlY2lzaW9uTW9kZWwpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbm9kZXIgPSB0aGlzLmdldE5vZGVyKHByZWNpc2lvbk1vZGVsKTtcbiAgbm9kZXIuY29tcHV0ZU5vZGVzKGJ1ZmZlclNlZ1N0ckxpc3QpO1xuICB2YXIgbm9kZWRTZWdTdHJpbmdzID0gbm9kZXIuZ2V0Tm9kZWRTdWJzdHJpbmdzKCk7XG4gIGZvciAodmFyIGkgPSBub2RlZFNlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIHNlZ1N0ciA9IGkubmV4dCgpO1xuICAgIHZhciBwdHMgPSBzZWdTdHIuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAocHRzLmxlbmd0aCA9PT0gMiAmJiBwdHNbMF0uZXF1YWxzMkQocHRzWzFdKSkgeyBjb250aW51ZSB9XG4gICAgdmFyIG9sZExhYmVsID0gc2VnU3RyLmdldERhdGEoKTtcbiAgICB2YXIgZWRnZSA9IG5ldyBFZGdlKHNlZ1N0ci5nZXRDb29yZGluYXRlcygpLCBuZXcgTGFiZWwob2xkTGFiZWwpKTtcbiAgICB0aGlzJDEuaW5zZXJ0VW5pcXVlRWRnZShlZGdlKTtcbiAgfVxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLnNldE5vZGVyID0gZnVuY3Rpb24gc2V0Tm9kZXIgKG5vZGVyKSB7XG4gIHRoaXMuX3dvcmtpbmdOb2RlciA9IG5vZGVyO1xufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJ1ZmZlckJ1aWxkZXJcbn07XG5CdWZmZXJCdWlsZGVyLmRlcHRoRGVsdGEgPSBmdW5jdGlvbiBkZXB0aERlbHRhIChsYWJlbCkge1xuICB2YXIgbExvYyA9IGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLkxFRlQpO1xuICB2YXIgckxvYyA9IGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLlJJR0hUKTtcbiAgaWYgKGxMb2MgPT09IExvY2F0aW9uLklOVEVSSU9SICYmIHJMb2MgPT09IExvY2F0aW9uLkVYVEVSSU9SKSB7IHJldHVybiAxOyB9IGVsc2UgaWYgKGxMb2MgPT09IExvY2F0aW9uLkVYVEVSSU9SICYmIHJMb2MgPT09IExvY2F0aW9uLklOVEVSSU9SKSB7IHJldHVybiAtMSB9XG4gIHJldHVybiAwXG59O1xuQnVmZmVyQnVpbGRlci5jb252ZXJ0U2VnU3RyaW5ncyA9IGZ1bmN0aW9uIGNvbnZlcnRTZWdTdHJpbmdzIChpdCkge1xuICB2YXIgZmFjdCA9IG5ldyBHZW9tZXRyeUZhY3RvcnkoKTtcbiAgdmFyIGxpbmVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB3aGlsZSAoaXQuaGFzTmV4dCgpKSB7XG4gICAgdmFyIHNzID0gaXQubmV4dCgpO1xuICAgIHZhciBsaW5lID0gZmFjdC5jcmVhdGVMaW5lU3RyaW5nKHNzLmdldENvb3JkaW5hdGVzKCkpO1xuICAgIGxpbmVzLmFkZChsaW5lKTtcbiAgfVxuICByZXR1cm4gZmFjdC5idWlsZEdlb21ldHJ5KGxpbmVzKVxufTtcblxudmFyIFNjYWxlZE5vZGVyID0gZnVuY3Rpb24gU2NhbGVkTm9kZXIgKCkge1xuICB0aGlzLl9ub2RlciA9IG51bGw7XG4gIHRoaXMuX3NjYWxlRmFjdG9yID0gbnVsbDtcbiAgdGhpcy5fb2Zmc2V0WCA9IG51bGw7XG4gIHRoaXMuX29mZnNldFkgPSBudWxsO1xuICB0aGlzLl9pc1NjYWxlZCA9IGZhbHNlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBub2RlciA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2NhbGVGYWN0b3IgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fbm9kZXIgPSBub2RlcjtcbiAgICB0aGlzLl9zY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICAgIHRoaXMuX29mZnNldFggPSAwLjA7XG4gICAgdGhpcy5fb2Zmc2V0WSA9IDAuMDtcbiAgICB0aGlzLl9pc1NjYWxlZCA9ICF0aGlzLmlzSW50ZWdlclByZWNpc2lvbigpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgbm9kZXIkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2NhbGVGYWN0b3IkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgb2Zmc2V0WCA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgb2Zmc2V0WSA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLl9ub2RlciA9IG5vZGVyJDE7XG4gICAgdGhpcy5fc2NhbGVGYWN0b3IgPSBzY2FsZUZhY3RvciQxO1xuICAgIHRoaXMuX29mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMuX29mZnNldFkgPSBvZmZzZXRZO1xuICAgIHRoaXMuX2lzU2NhbGVkID0gIXRoaXMuaXNJbnRlZ2VyUHJlY2lzaW9uKCk7XG4gIH1cbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUucmVzY2FsZSA9IGZ1bmN0aW9uIHJlc2NhbGUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb2xsZWN0aW9uKSkge1xuICAgIHZhciBzZWdTdHJpbmdzID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAodmFyIGkgPSBzZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzID0gaS5uZXh0KCk7XG4gICAgICB0aGlzJDEucmVzY2FsZShzcy5nZXRDb29yZGluYXRlcygpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICAgIC8vIGxldCBwMCA9IG51bGxcbiAgICAvLyBsZXQgcDEgPSBudWxsXG4gICAgLy8gaWYgKHB0cy5sZW5ndGggPT09IDIpIHtcbiAgICAvLyBwMCA9IG5ldyBDb29yZGluYXRlKHB0c1swXSlcbiAgICAvLyBwMSA9IG5ldyBDb29yZGluYXRlKHB0c1sxXSlcbiAgICAvLyB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHRzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgIHB0c1tpJDFdLnggPSBwdHNbaSQxXS54IC8gdGhpcyQxLl9zY2FsZUZhY3RvciArIHRoaXMkMS5fb2Zmc2V0WDtcbiAgICAgIHB0c1tpJDFdLnkgPSBwdHNbaSQxXS55IC8gdGhpcyQxLl9zY2FsZUZhY3RvciArIHRoaXMkMS5fb2Zmc2V0WTtcbiAgICB9XG4gICAgaWYgKHB0cy5sZW5ndGggPT09IDIgJiYgcHRzWzBdLmVxdWFsczJEKHB0c1sxXSkpIHtcbiAgICAgIFN5c3RlbS5vdXQucHJpbnRsbihwdHMpO1xuICAgIH1cbiAgfVxufTtcblNjYWxlZE5vZGVyLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29sbGVjdGlvbikpIHtcbiAgICB2YXIgc2VnU3RyaW5ncyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbm9kZWRTZWdtZW50U3RyaW5ncyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpID0gc2VnU3RyaW5ncy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBzcyA9IGkubmV4dCgpO1xuICAgICAgbm9kZWRTZWdtZW50U3RyaW5ncy5hZGQobmV3IE5vZGVkU2VnbWVudFN0cmluZyh0aGlzJDEuc2NhbGUoc3MuZ2V0Q29vcmRpbmF0ZXMoKSksIHNzLmdldERhdGEoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZWRTZWdtZW50U3RyaW5nc1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIHB0cyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcm91bmRQdHMgPSBuZXcgQXJyYXkocHRzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwdHMubGVuZ3RoOyBpJDErKykge1xuICAgICAgcm91bmRQdHNbaSQxXSA9IG5ldyBDb29yZGluYXRlKE1hdGgucm91bmQoKHB0c1tpJDFdLnggLSB0aGlzJDEuX29mZnNldFgpICogdGhpcyQxLl9zY2FsZUZhY3RvciksIE1hdGgucm91bmQoKHB0c1tpJDFdLnkgLSB0aGlzJDEuX29mZnNldFkpICogdGhpcyQxLl9zY2FsZUZhY3RvciksIHB0c1tpJDFdLnopO1xuICAgIH1cbiAgICB2YXIgcm91bmRQdHNOb0R1cCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMocm91bmRQdHMpO1xuICAgIHJldHVybiByb3VuZFB0c05vRHVwXG4gIH1cbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUuaXNJbnRlZ2VyUHJlY2lzaW9uID0gZnVuY3Rpb24gaXNJbnRlZ2VyUHJlY2lzaW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NjYWxlRmFjdG9yID09PSAxLjBcbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUuZ2V0Tm9kZWRTdWJzdHJpbmdzID0gZnVuY3Rpb24gZ2V0Tm9kZWRTdWJzdHJpbmdzICgpIHtcbiAgdmFyIHNwbGl0U1MgPSB0aGlzLl9ub2Rlci5nZXROb2RlZFN1YnN0cmluZ3MoKTtcbiAgaWYgKHRoaXMuX2lzU2NhbGVkKSB7IHRoaXMucmVzY2FsZShzcGxpdFNTKTsgfVxuICByZXR1cm4gc3BsaXRTU1xufTtcblNjYWxlZE5vZGVyLnByb3RvdHlwZS5jb21wdXRlTm9kZXMgPSBmdW5jdGlvbiBjb21wdXRlTm9kZXMgKGlucHV0U2VnU3RyaW5ncykge1xuICB2YXIgaW50U2VnU3RyaW5ncyA9IGlucHV0U2VnU3RyaW5ncztcbiAgaWYgKHRoaXMuX2lzU2NhbGVkKSB7IGludFNlZ1N0cmluZ3MgPSB0aGlzLnNjYWxlKGlucHV0U2VnU3RyaW5ncyk7IH1cbiAgdGhpcy5fbm9kZXIuY29tcHV0ZU5vZGVzKGludFNlZ1N0cmluZ3MpO1xufTtcblNjYWxlZE5vZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtOb2Rlcl1cbn07XG5TY2FsZWROb2Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTY2FsZWROb2RlclxufTtcblxudmFyIE5vZGluZ1ZhbGlkYXRvciA9IGZ1bmN0aW9uIE5vZGluZ1ZhbGlkYXRvciAoKSB7XG4gIHRoaXMuX2xpID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICB0aGlzLl9zZWdTdHJpbmdzID0gbnVsbDtcbiAgdmFyIHNlZ1N0cmluZ3MgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX3NlZ1N0cmluZ3MgPSBzZWdTdHJpbmdzO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzMyA9IHsgZmFjdDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzID0gaS5uZXh0KCk7XG4gICAgICB2YXIgcHRzID0gc3MuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIHRoaXMkMS5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhwdHNbMF0sIHRoaXMkMS5fc2VnU3RyaW5ncyk7XG4gICAgICB0aGlzJDEuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMocHRzW3B0cy5sZW5ndGggLSAxXSwgdGhpcyQxLl9zZWdTdHJpbmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB0ZXN0UHQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNlZ1N0cmluZ3MgPSBhcmd1bWVudHNbMV07XG4gICAgZm9yICh2YXIgaSQxID0gc2VnU3RyaW5ncy5pdGVyYXRvcigpOyBpJDEuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzJDEgPSBpJDEubmV4dCgpO1xuICAgICAgdmFyIHB0cyQxID0gc3MkMS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBwdHMkMS5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgaWYgKHB0cyQxW2pdLmVxdWFscyh0ZXN0UHQpKSB7IHRocm93IG5ldyBSdW50aW1lRXhjZXB0aW9uKCdmb3VuZCBlbmRwdC9pbnRlcmlvciBwdCBpbnRlcnNlY3Rpb24gYXQgaW5kZXggJyArIGogKyAnIDpwdCAnICsgdGVzdFB0KSB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9zZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzMCA9IGkubmV4dCgpO1xuICAgICAgZm9yICh2YXIgaiA9IHRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgai5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBzczEgPSBqLm5leHQoKTtcbiAgICAgICAgdGhpcyQxLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHNzMCwgc3MxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBzczAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc3MxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0czAgPSBzczAkMS5nZXRDb29yZGluYXRlcygpO1xuICAgIHZhciBwdHMxID0gc3MxJDEuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpMCA9IDA7IGkwIDwgcHRzMC5sZW5ndGggLSAxOyBpMCsrKSB7XG4gICAgICBmb3IgKHZhciBpMSA9IDA7IGkxIDwgcHRzMS5sZW5ndGggLSAxOyBpMSsrKSB7XG4gICAgICAgIHRoaXMkMS5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyhzczAkMSwgaTAsIHNzMSQxLCBpMSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgZTAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNlZ0luZGV4MCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZTEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHNlZ0luZGV4MSA9IGFyZ3VtZW50c1szXTtcbiAgICBpZiAoZTAgPT09IGUxICYmIHNlZ0luZGV4MCA9PT0gc2VnSW5kZXgxKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgcDAwID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDBdO1xuICAgIHZhciBwMDEgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MCArIDFdO1xuICAgIHZhciBwMTAgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MV07XG4gICAgdmFyIHAxMSA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxICsgMV07XG4gICAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMDAsIHAwMSwgcDEwLCBwMTEpO1xuICAgIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgICAgaWYgKHRoaXMuX2xpLmlzUHJvcGVyKCkgfHwgdGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLl9saSwgcDAwLCBwMDEpIHx8IHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5fbGksIHAxMCwgcDExKSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBhdCAnICsgcDAwICsgJy0nICsgcDAxICsgJyBhbmQgJyArIHAxMCArICctJyArIHAxMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrVmFsaWQgPSBmdW5jdGlvbiBjaGVja1ZhbGlkICgpIHtcbiAgdGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucygpO1xuICB0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCk7XG4gIHRoaXMuY2hlY2tDb2xsYXBzZXMoKTtcbn07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrQ29sbGFwc2VzID0gZnVuY3Rpb24gY2hlY2tDb2xsYXBzZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgc3MgPSBpLm5leHQoKTtcbiAgICAgIHRoaXMkMS5jaGVja0NvbGxhcHNlcyhzcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgc3MkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHRzID0gc3MkMS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHB0cy5sZW5ndGggLSAyOyBpJDErKykge1xuICAgICAgdGhpcyQxLmNoZWNrQ29sbGFwc2UocHRzW2kkMV0sIHB0c1tpJDEgKyAxXSwgcHRzW2kkMSArIDJdKTtcbiAgICB9XG4gIH1cbn07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24gKGxpLCBwMCwgcDEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaS5nZXRJbnRlcnNlY3Rpb25OdW0oKTsgaSsrKSB7XG4gICAgdmFyIGludFB0ID0gbGkuZ2V0SW50ZXJzZWN0aW9uKGkpO1xuICAgIGlmICghKGludFB0LmVxdWFscyhwMCkgfHwgaW50UHQuZXF1YWxzKHAxKSkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbk5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tDb2xsYXBzZSA9IGZ1bmN0aW9uIGNoZWNrQ29sbGFwc2UgKHAwLCBwMSwgcDIpIHtcbiAgaWYgKHAwLmVxdWFscyhwMikpIHsgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oJ2ZvdW5kIG5vbi1ub2RlZCBjb2xsYXBzZSBhdCAnICsgTm9kaW5nVmFsaWRhdG9yLmZhY3QuY3JlYXRlTGluZVN0cmluZyhbcDAsIHAxLCBwMl0pKSB9XG59O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE5vZGluZ1ZhbGlkYXRvclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzMy5mYWN0LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBHZW9tZXRyeUZhY3RvcnkoKSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTm9kaW5nVmFsaWRhdG9yLCBzdGF0aWNBY2Nlc3NvcnMkMzMgKTtcblxudmFyIEhvdFBpeGVsID0gZnVuY3Rpb24gSG90UGl4ZWwgKCkge1xuICB0aGlzLl9saSA9IG51bGw7XG4gIHRoaXMuX3B0ID0gbnVsbDtcbiAgdGhpcy5fb3JpZ2luYWxQdCA9IG51bGw7XG4gIHRoaXMuX3B0U2NhbGVkID0gbnVsbDtcbiAgdGhpcy5fcDBTY2FsZWQgPSBudWxsO1xuICB0aGlzLl9wMVNjYWxlZCA9IG51bGw7XG4gIHRoaXMuX3NjYWxlRmFjdG9yID0gbnVsbDtcbiAgdGhpcy5fbWlueCA9IG51bGw7XG4gIHRoaXMuX21heHggPSBudWxsO1xuICB0aGlzLl9taW55ID0gbnVsbDtcbiAgdGhpcy5fbWF4eSA9IG51bGw7XG4gIHRoaXMuX2Nvcm5lciA9IG5ldyBBcnJheSg0KS5maWxsKG51bGwpO1xuICB0aGlzLl9zYWZlRW52ID0gbnVsbDtcbiAgdmFyIHB0ID0gYXJndW1lbnRzWzBdO1xuICB2YXIgc2NhbGVGYWN0b3IgPSBhcmd1bWVudHNbMV07XG4gIHZhciBsaSA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5fb3JpZ2luYWxQdCA9IHB0O1xuICB0aGlzLl9wdCA9IHB0O1xuICB0aGlzLl9zY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yO1xuICB0aGlzLl9saSA9IGxpO1xuICBpZiAoc2NhbGVGYWN0b3IgPD0gMCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdTY2FsZSBmYWN0b3IgbXVzdCBiZSBub24temVybycpIH1cbiAgaWYgKHNjYWxlRmFjdG9yICE9PSAxLjApIHtcbiAgICB0aGlzLl9wdCA9IG5ldyBDb29yZGluYXRlKHRoaXMuc2NhbGUocHQueCksIHRoaXMuc2NhbGUocHQueSkpO1xuICAgIHRoaXMuX3AwU2NhbGVkID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB0aGlzLl9wMVNjYWxlZCA9IG5ldyBDb29yZGluYXRlKCk7XG4gIH1cbiAgdGhpcy5pbml0Q29ybmVycyh0aGlzLl9wdCk7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDM0ID0geyBTQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5Ib3RQaXhlbC5wcm90b3R5cGUuaW50ZXJzZWN0c1NjYWxlZCA9IGZ1bmN0aW9uIGludGVyc2VjdHNTY2FsZWQgKHAwLCBwMSkge1xuICB2YXIgc2VnTWlueCA9IE1hdGgubWluKHAwLngsIHAxLngpO1xuICB2YXIgc2VnTWF4eCA9IE1hdGgubWF4KHAwLngsIHAxLngpO1xuICB2YXIgc2VnTWlueSA9IE1hdGgubWluKHAwLnksIHAxLnkpO1xuICB2YXIgc2VnTWF4eSA9IE1hdGgubWF4KHAwLnksIHAxLnkpO1xuICB2YXIgaXNPdXRzaWRlUGl4ZWxFbnYgPSB0aGlzLl9tYXh4IDwgc2VnTWlueCB8fCB0aGlzLl9taW54ID4gc2VnTWF4eCB8fCB0aGlzLl9tYXh5IDwgc2VnTWlueSB8fCB0aGlzLl9taW55ID4gc2VnTWF4eTtcbiAgaWYgKGlzT3V0c2lkZVBpeGVsRW52KSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBpbnRlcnNlY3RzID0gdGhpcy5pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlKHAwLCBwMSk7XG4gIEFzc2VydC5pc1RydWUoIShpc091dHNpZGVQaXhlbEVudiAmJiBpbnRlcnNlY3RzKSwgJ0ZvdW5kIGJhZCBlbnZlbG9wZSB0ZXN0Jyk7XG4gIHJldHVybiBpbnRlcnNlY3RzXG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmluaXRDb3JuZXJzID0gZnVuY3Rpb24gaW5pdENvcm5lcnMgKHB0KSB7XG4gIHZhciB0b2xlcmFuY2UgPSAwLjU7XG4gIHRoaXMuX21pbnggPSBwdC54IC0gdG9sZXJhbmNlO1xuICB0aGlzLl9tYXh4ID0gcHQueCArIHRvbGVyYW5jZTtcbiAgdGhpcy5fbWlueSA9IHB0LnkgLSB0b2xlcmFuY2U7XG4gIHRoaXMuX21heHkgPSBwdC55ICsgdG9sZXJhbmNlO1xuICB0aGlzLl9jb3JuZXJbMF0gPSBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9tYXh4LCB0aGlzLl9tYXh5KTtcbiAgdGhpcy5fY29ybmVyWzFdID0gbmV3IENvb3JkaW5hdGUodGhpcy5fbWlueCwgdGhpcy5fbWF4eSk7XG4gIHRoaXMuX2Nvcm5lclsyXSA9IG5ldyBDb29yZGluYXRlKHRoaXMuX21pbngsIHRoaXMuX21pbnkpO1xuICB0aGlzLl9jb3JuZXJbM10gPSBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9tYXh4LCB0aGlzLl9taW55KTtcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMgKHAwLCBwMSkge1xuICBpZiAodGhpcy5fc2NhbGVGYWN0b3IgPT09IDEuMCkgeyByZXR1cm4gdGhpcy5pbnRlcnNlY3RzU2NhbGVkKHAwLCBwMSkgfVxuICB0aGlzLmNvcHlTY2FsZWQocDAsIHRoaXMuX3AwU2NhbGVkKTtcbiAgdGhpcy5jb3B5U2NhbGVkKHAxLCB0aGlzLl9wMVNjYWxlZCk7XG4gIHJldHVybiB0aGlzLmludGVyc2VjdHNTY2FsZWQodGhpcy5fcDBTY2FsZWQsIHRoaXMuX3AxU2NhbGVkKVxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlICh2YWwpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsICogdGhpcy5fc2NhbGVGYWN0b3IpXG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX29yaWdpbmFsUHRcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuY29weVNjYWxlZCA9IGZ1bmN0aW9uIGNvcHlTY2FsZWQgKHAsIHBTY2FsZWQpIHtcbiAgcFNjYWxlZC54ID0gdGhpcy5zY2FsZShwLngpO1xuICBwU2NhbGVkLnkgPSB0aGlzLnNjYWxlKHAueSk7XG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmdldFNhZmVFbnZlbG9wZSA9IGZ1bmN0aW9uIGdldFNhZmVFbnZlbG9wZSAoKSB7XG4gIGlmICh0aGlzLl9zYWZlRW52ID09PSBudWxsKSB7XG4gICAgdmFyIHNhZmVUb2xlcmFuY2UgPSBIb3RQaXhlbC5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SIC8gdGhpcy5fc2NhbGVGYWN0b3I7XG4gICAgdGhpcy5fc2FmZUVudiA9IG5ldyBFbnZlbG9wZSh0aGlzLl9vcmlnaW5hbFB0LnggLSBzYWZlVG9sZXJhbmNlLCB0aGlzLl9vcmlnaW5hbFB0LnggKyBzYWZlVG9sZXJhbmNlLCB0aGlzLl9vcmlnaW5hbFB0LnkgLSBzYWZlVG9sZXJhbmNlLCB0aGlzLl9vcmlnaW5hbFB0LnkgKyBzYWZlVG9sZXJhbmNlKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fc2FmZUVudlxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5pbnRlcnNlY3RzUGl4ZWxDbG9zdXJlID0gZnVuY3Rpb24gaW50ZXJzZWN0c1BpeGVsQ2xvc3VyZSAocDAsIHAxKSB7XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbMF0sIHRoaXMuX2Nvcm5lclsxXSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbMV0sIHRoaXMuX2Nvcm5lclsyXSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbMl0sIHRoaXMuX2Nvcm5lclszXSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbM10sIHRoaXMuX2Nvcm5lclswXSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlID0gZnVuY3Rpb24gaW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZSAocDAsIHAxKSB7XG4gIHZhciBpbnRlcnNlY3RzTGVmdCA9IGZhbHNlO1xuICB2YXIgaW50ZXJzZWN0c0JvdHRvbSA9IGZhbHNlO1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzBdLCB0aGlzLl9jb3JuZXJbMV0pO1xuICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbMV0sIHRoaXMuX2Nvcm5lclsyXSk7XG4gIGlmICh0aGlzLl9saS5pc1Byb3BlcigpKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7IGludGVyc2VjdHNMZWZ0ID0gdHJ1ZTsgfVxuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzJdLCB0aGlzLl9jb3JuZXJbM10pO1xuICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkgeyBpbnRlcnNlY3RzQm90dG9tID0gdHJ1ZTsgfVxuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwLCBwMSwgdGhpcy5fY29ybmVyWzNdLCB0aGlzLl9jb3JuZXJbMF0pO1xuICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChpbnRlcnNlY3RzTGVmdCAmJiBpbnRlcnNlY3RzQm90dG9tKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHAwLmVxdWFscyh0aGlzLl9wdCkpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocDEuZXF1YWxzKHRoaXMuX3B0KSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5hZGRTbmFwcGVkTm9kZSA9IGZ1bmN0aW9uIGFkZFNuYXBwZWROb2RlIChzZWdTdHIsIHNlZ0luZGV4KSB7XG4gIHZhciBwMCA9IHNlZ1N0ci5nZXRDb29yZGluYXRlKHNlZ0luZGV4KTtcbiAgdmFyIHAxID0gc2VnU3RyLmdldENvb3JkaW5hdGUoc2VnSW5kZXggKyAxKTtcbiAgaWYgKHRoaXMuaW50ZXJzZWN0cyhwMCwgcDEpKSB7XG4gICAgc2VnU3RyLmFkZEludGVyc2VjdGlvbih0aGlzLmdldENvb3JkaW5hdGUoKSwgc2VnSW5kZXgpO1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBIb3RQaXhlbFxufTtcbnN0YXRpY0FjY2Vzc29ycyQzNC5TQUZFX0VOVl9FWFBBTlNJT05fRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuNzUgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEhvdFBpeGVsLCBzdGF0aWNBY2Nlc3NvcnMkMzQgKTtcblxudmFyIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24gPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uICgpIHtcbiAgdGhpcy50ZW1wRW52MSA9IG5ldyBFbnZlbG9wZSgpO1xuICB0aGlzLnNlbGVjdGVkU2VnbWVudCA9IG5ldyBMaW5lU2VnbWVudCgpO1xufTtcbk1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gY29uc3Qgc2VnID0gYXJndW1lbnRzWzBdXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBtYyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc3RhcnRJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICBtYy5nZXRMaW5lU2VnbWVudChzdGFydEluZGV4LCB0aGlzLnNlbGVjdGVkU2VnbWVudCk7XG4gICAgdGhpcy5zZWxlY3QodGhpcy5zZWxlY3RlZFNlZ21lbnQpO1xuICB9XG59O1xuTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvblxufTtcblxudmFyIE1DSW5kZXhQb2ludFNuYXBwZXIgPSBmdW5jdGlvbiBNQ0luZGV4UG9pbnRTbmFwcGVyICgpIHtcbiAgdGhpcy5faW5kZXggPSBudWxsO1xuICB2YXIgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2luZGV4ID0gaW5kZXg7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDM1ID0geyBIb3RQaXhlbFNuYXBBY3Rpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbk1DSW5kZXhQb2ludFNuYXBwZXIucHJvdG90eXBlLnNuYXAgPSBmdW5jdGlvbiBzbmFwICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgaG90UGl4ZWwgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuc25hcChob3RQaXhlbCwgbnVsbCwgLTEpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBob3RQaXhlbCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwYXJlbnRFZGdlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBob3RQaXhlbFZlcnRleEluZGV4ID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBwaXhlbEVudiA9IGhvdFBpeGVsJDEuZ2V0U2FmZUVudmVsb3BlKCk7XG4gICAgdmFyIGhvdFBpeGVsU25hcEFjdGlvbiA9IG5ldyBIb3RQaXhlbFNuYXBBY3Rpb24oaG90UGl4ZWwkMSwgcGFyZW50RWRnZSwgaG90UGl4ZWxWZXJ0ZXhJbmRleCk7XG4gICAgdGhpcy5faW5kZXgucXVlcnkocGl4ZWxFbnYsIHtcbiAgICAgIGludGVyZmFjZXNfOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbSXRlbVZpc2l0b3JdXG4gICAgICB9LFxuICAgICAgdmlzaXRJdGVtOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgdGVzdENoYWluID0gaXRlbTtcbiAgICAgICAgdGVzdENoYWluLnNlbGVjdChwaXhlbEVudiwgaG90UGl4ZWxTbmFwQWN0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaG90UGl4ZWxTbmFwQWN0aW9uLmlzTm9kZUFkZGVkKClcbiAgfVxufTtcbk1DSW5kZXhQb2ludFNuYXBwZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5NQ0luZGV4UG9pbnRTbmFwcGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1DSW5kZXhQb2ludFNuYXBwZXJcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzUuSG90UGl4ZWxTbmFwQWN0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEhvdFBpeGVsU25hcEFjdGlvbiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggTUNJbmRleFBvaW50U25hcHBlciwgc3RhdGljQWNjZXNzb3JzJDM1ICk7XG5cbnZhciBIb3RQaXhlbFNuYXBBY3Rpb24gPSAoZnVuY3Rpb24gKE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gSG90UGl4ZWxTbmFwQWN0aW9uICgpIHtcbiAgICBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uJCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5faG90UGl4ZWwgPSBudWxsO1xuICAgIHRoaXMuX3BhcmVudEVkZ2UgPSBudWxsO1xuICAgIHRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXggPSBudWxsO1xuICAgIHRoaXMuX2lzTm9kZUFkZGVkID0gZmFsc2U7XG4gICAgdmFyIGhvdFBpeGVsID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwYXJlbnRFZGdlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBob3RQaXhlbFZlcnRleEluZGV4ID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX2hvdFBpeGVsID0gaG90UGl4ZWw7XG4gICAgdGhpcy5fcGFyZW50RWRnZSA9IHBhcmVudEVkZ2U7XG4gICAgdGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleCA9IGhvdFBpeGVsVmVydGV4SW5kZXg7XG4gIH1cblxuICBpZiAoIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24kJDEgKSBIb3RQaXhlbFNuYXBBY3Rpb24uX19wcm90b19fID0gTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiQkMTtcbiAgSG90UGl4ZWxTbmFwQWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24kJDEgJiYgTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgSG90UGl4ZWxTbmFwQWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhvdFBpeGVsU25hcEFjdGlvbjtcbiAgSG90UGl4ZWxTbmFwQWN0aW9uLnByb3RvdHlwZS5pc05vZGVBZGRlZCA9IGZ1bmN0aW9uIGlzTm9kZUFkZGVkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNOb2RlQWRkZWRcbiAgfTtcbiAgSG90UGl4ZWxTbmFwQWN0aW9uLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgbWMgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgc3RhcnRJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBzcyA9IG1jLmdldENvbnRleHQoKTtcbiAgICAgIGlmICh0aGlzLl9wYXJlbnRFZGdlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzcyA9PT0gdGhpcy5fcGFyZW50RWRnZSAmJiBzdGFydEluZGV4ID09PSB0aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4KSB7IHJldHVybiBudWxsIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzTm9kZUFkZGVkID0gdGhpcy5faG90UGl4ZWwuYWRkU25hcHBlZE5vZGUoc3MsIHN0YXJ0SW5kZXgpO1xuICAgIH0gZWxzZSB7IHJldHVybiBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uJCQxLnByb3RvdHlwZS5zZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIEhvdFBpeGVsU25hcEFjdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIEhvdFBpeGVsU25hcEFjdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIEhvdFBpeGVsU25hcEFjdGlvblxuICB9O1xuXG4gIHJldHVybiBIb3RQaXhlbFNuYXBBY3Rpb247XG59KE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24pKTtcblxudmFyIEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIgPSBmdW5jdGlvbiBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyICgpIHtcbiAgdGhpcy5fbGkgPSBudWxsO1xuICB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnMgPSBudWxsO1xuICB2YXIgbGkgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2xpID0gbGk7XG4gIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucyA9IG5ldyBBcnJheUxpc3QoKTtcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyLnByb3RvdHlwZS5wcm9jZXNzSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIHByb2Nlc3NJbnRlcnNlY3Rpb25zIChlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGUwID09PSBlMSAmJiBzZWdJbmRleDAgPT09IHNlZ0luZGV4MSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBwMDAgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MF07XG4gIHZhciBwMDEgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MCArIDFdO1xuICB2YXIgcDEwID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDFdO1xuICB2YXIgcDExID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDEgKyAxXTtcbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMDAsIHAwMSwgcDEwLCBwMTEpO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICBpZiAodGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKSB7XG4gICAgICBmb3IgKHZhciBpbnRJbmRleCA9IDA7IGludEluZGV4IDwgdGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7IGludEluZGV4KyspIHtcbiAgICAgICAgdGhpcyQxLl9pbnRlcmlvckludGVyc2VjdGlvbnMuYWRkKHRoaXMkMS5fbGkuZ2V0SW50ZXJzZWN0aW9uKGludEluZGV4KSk7XG4gICAgICB9XG4gICAgICBlMC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLCBzZWdJbmRleDAsIDApO1xuICAgICAgZTEuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSwgc2VnSW5kZXgxLCAxKTtcbiAgICB9XG4gIH1cbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyLnByb3RvdHlwZS5nZXRJbnRlcmlvckludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBnZXRJbnRlcmlvckludGVyc2VjdGlvbnMgKCkge1xuICByZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VnbWVudEludGVyc2VjdG9yXVxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlclxufTtcblxudmFyIE1DSW5kZXhTbmFwUm91bmRlciA9IGZ1bmN0aW9uIE1DSW5kZXhTbmFwUm91bmRlciAoKSB7XG4gIHRoaXMuX3BtID0gbnVsbDtcbiAgdGhpcy5fbGkgPSBudWxsO1xuICB0aGlzLl9zY2FsZUZhY3RvciA9IG51bGw7XG4gIHRoaXMuX25vZGVyID0gbnVsbDtcbiAgdGhpcy5fcG9pbnRTbmFwcGVyID0gbnVsbDtcbiAgdGhpcy5fbm9kZWRTZWdTdHJpbmdzID0gbnVsbDtcbiAgdmFyIHBtID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9wbSA9IHBtO1xuICB0aGlzLl9saSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgdGhpcy5fbGkuc2V0UHJlY2lzaW9uTW9kZWwocG0pO1xuICB0aGlzLl9zY2FsZUZhY3RvciA9IHBtLmdldFNjYWxlKCk7XG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5jaGVja0NvcnJlY3RuZXNzID0gZnVuY3Rpb24gY2hlY2tDb3JyZWN0bmVzcyAoaW5wdXRTZWdtZW50U3RyaW5ncykge1xuICB2YXIgcmVzdWx0U2VnU3RyaW5ncyA9IE5vZGVkU2VnbWVudFN0cmluZy5nZXROb2RlZFN1YnN0cmluZ3MoaW5wdXRTZWdtZW50U3RyaW5ncyk7XG4gIHZhciBudiA9IG5ldyBOb2RpbmdWYWxpZGF0b3IocmVzdWx0U2VnU3RyaW5ncyk7XG4gIHRyeSB7XG4gICAgbnYuY2hlY2tWYWxpZCgpO1xuICB9IGNhdGNoIChleCkge1xuICAgIGlmIChleCBpbnN0YW5jZW9mIEV4Y2VwdGlvbikge1xuICAgICAgZXgucHJpbnRTdGFja1RyYWNlKCk7XG4gICAgfSBlbHNlIHsgdGhyb3cgZXggfVxuICB9IGZpbmFsbHkge31cbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmdldE5vZGVkU3Vic3RyaW5ncyA9IGZ1bmN0aW9uIGdldE5vZGVkU3Vic3RyaW5ncyAoKSB7XG4gIHJldHVybiBOb2RlZFNlZ21lbnRTdHJpbmcuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMuX25vZGVkU2VnU3RyaW5ncylcbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLnNuYXBSb3VuZCA9IGZ1bmN0aW9uIHNuYXBSb3VuZCAoc2VnU3RyaW5ncywgbGkpIHtcbiAgdmFyIGludGVyc2VjdGlvbnMgPSB0aGlzLmZpbmRJbnRlcmlvckludGVyc2VjdGlvbnMoc2VnU3RyaW5ncywgbGkpO1xuICB0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyhpbnRlcnNlY3Rpb25zKTtcbiAgdGhpcy5jb21wdXRlVmVydGV4U25hcHMoc2VnU3RyaW5ncyk7XG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5maW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyAoc2VnU3RyaW5ncywgbGkpIHtcbiAgdmFyIGludEZpbmRlckFkZGVyID0gbmV3IEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIobGkpO1xuICB0aGlzLl9ub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IoaW50RmluZGVyQWRkZXIpO1xuICB0aGlzLl9ub2Rlci5jb21wdXRlTm9kZXMoc2VnU3RyaW5ncyk7XG4gIHJldHVybiBpbnRGaW5kZXJBZGRlci5nZXRJbnRlcmlvckludGVyc2VjdGlvbnMoKVxufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuY29tcHV0ZVZlcnRleFNuYXBzID0gZnVuY3Rpb24gY29tcHV0ZVZlcnRleFNuYXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29sbGVjdGlvbikpIHtcbiAgICB2YXIgZWRnZXMgPSBhcmd1bWVudHNbMF07XG4gICAgZm9yICh2YXIgaTAgPSBlZGdlcy5pdGVyYXRvcigpOyBpMC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZWRnZTAgPSBpMC5uZXh0KCk7XG4gICAgICB0aGlzJDEuY29tcHV0ZVZlcnRleFNuYXBzKGVkZ2UwKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTm9kZWRTZWdtZW50U3RyaW5nKSB7XG4gICAgdmFyIGUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0czAgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaG90UGl4ZWwgPSBuZXcgSG90UGl4ZWwocHRzMFtpXSwgdGhpcyQxLl9zY2FsZUZhY3RvciwgdGhpcyQxLl9saSk7XG4gICAgICB2YXIgaXNOb2RlQWRkZWQgPSB0aGlzJDEuX3BvaW50U25hcHBlci5zbmFwKGhvdFBpeGVsLCBlLCBpKTtcbiAgICAgIGlmIChpc05vZGVBZGRlZCkge1xuICAgICAgICBlLmFkZEludGVyc2VjdGlvbihwdHMwW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmNvbXB1dGVOb2RlcyA9IGZ1bmN0aW9uIGNvbXB1dGVOb2RlcyAoaW5wdXRTZWdtZW50U3RyaW5ncykge1xuICB0aGlzLl9ub2RlZFNlZ1N0cmluZ3MgPSBpbnB1dFNlZ21lbnRTdHJpbmdzO1xuICB0aGlzLl9ub2RlciA9IG5ldyBNQ0luZGV4Tm9kZXIoKTtcbiAgdGhpcy5fcG9pbnRTbmFwcGVyID0gbmV3IE1DSW5kZXhQb2ludFNuYXBwZXIodGhpcy5fbm9kZXIuZ2V0SW5kZXgoKSk7XG4gIHRoaXMuc25hcFJvdW5kKGlucHV0U2VnbWVudFN0cmluZ3MsIHRoaXMuX2xpKTtcbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwcyAoc25hcFB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGl0ID0gc25hcFB0cy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIHNuYXBQdCA9IGl0Lm5leHQoKTtcbiAgICB2YXIgaG90UGl4ZWwgPSBuZXcgSG90UGl4ZWwoc25hcFB0LCB0aGlzJDEuX3NjYWxlRmFjdG9yLCB0aGlzJDEuX2xpKTtcbiAgICB0aGlzJDEuX3BvaW50U25hcHBlci5zbmFwKGhvdFBpeGVsKTtcbiAgfVxufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbTm9kZXJdXG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1DSW5kZXhTbmFwUm91bmRlclxufTtcblxudmFyIEJ1ZmZlck9wID0gZnVuY3Rpb24gQnVmZmVyT3AgKCkge1xuICB0aGlzLl9hcmdHZW9tID0gbnVsbDtcbiAgdGhpcy5fZGlzdGFuY2UgPSBudWxsO1xuICB0aGlzLl9idWZQYXJhbXMgPSBuZXcgQnVmZmVyUGFyYW1ldGVycygpO1xuICB0aGlzLl9yZXN1bHRHZW9tZXRyeSA9IG51bGw7XG4gIHRoaXMuX3NhdmVFeGNlcHRpb24gPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX2FyZ0dlb20gPSBnO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBidWZQYXJhbXMgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fYXJnR2VvbSA9IGckMTtcbiAgICB0aGlzLl9idWZQYXJhbXMgPSBidWZQYXJhbXM7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzIgPSB7IENBUF9ST1VORDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDQVBfQlVUVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDQVBfRkxBVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDQVBfU1FVQVJFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1BWF9QUkVDSVNJT05fRElHSVRTOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5CdWZmZXJPcC5wcm90b3R5cGUuYnVmZmVyRml4ZWRQcmVjaXNpb24gPSBmdW5jdGlvbiBidWZmZXJGaXhlZFByZWNpc2lvbiAoZml4ZWRQTSkge1xuICB2YXIgbm9kZXIgPSBuZXcgU2NhbGVkTm9kZXIobmV3IE1DSW5kZXhTbmFwUm91bmRlcihuZXcgUHJlY2lzaW9uTW9kZWwoMS4wKSksIGZpeGVkUE0uZ2V0U2NhbGUoKSk7XG4gIHZhciBidWZCdWlsZGVyID0gbmV3IEJ1ZmZlckJ1aWxkZXIodGhpcy5fYnVmUGFyYW1zKTtcbiAgYnVmQnVpbGRlci5zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwoZml4ZWRQTSk7XG4gIGJ1ZkJ1aWxkZXIuc2V0Tm9kZXIobm9kZXIpO1xuICB0aGlzLl9yZXN1bHRHZW9tZXRyeSA9IGJ1ZkJ1aWxkZXIuYnVmZmVyKHRoaXMuX2FyZ0dlb20sIHRoaXMuX2Rpc3RhbmNlKTtcbn07XG5CdWZmZXJPcC5wcm90b3R5cGUuYnVmZmVyUmVkdWNlZFByZWNpc2lvbiA9IGZ1bmN0aW9uIGJ1ZmZlclJlZHVjZWRQcmVjaXNpb24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yICh2YXIgcHJlY0RpZ2l0cyA9IEJ1ZmZlck9wLk1BWF9QUkVDSVNJT05fRElHSVRTOyBwcmVjRGlnaXRzID49IDA7IHByZWNEaWdpdHMtLSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcyQxLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24ocHJlY0RpZ2l0cyk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBUb3BvbG9neUV4Y2VwdGlvbikge1xuICAgICAgICAgIHRoaXMkMS5fc2F2ZUV4Y2VwdGlvbiA9IGV4O1xuICAgICAgICB9IGVsc2UgeyB0aHJvdyBleCB9XG4gICAgICB9IGZpbmFsbHkge31cbiAgICAgIGlmICh0aGlzJDEuX3Jlc3VsdEdlb21ldHJ5ICE9PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy5fc2F2ZUV4Y2VwdGlvblxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcHJlY2lzaW9uRGlnaXRzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzaXplQmFzZWRTY2FsZUZhY3RvciA9IEJ1ZmZlck9wLnByZWNpc2lvblNjYWxlRmFjdG9yKHRoaXMuX2FyZ0dlb20sIHRoaXMuX2Rpc3RhbmNlLCBwcmVjaXNpb25EaWdpdHMpO1xuICAgIHZhciBmaXhlZFBNID0gbmV3IFByZWNpc2lvbk1vZGVsKHNpemVCYXNlZFNjYWxlRmFjdG9yKTtcbiAgICB0aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKGZpeGVkUE0pO1xuICB9XG59O1xuQnVmZmVyT3AucHJvdG90eXBlLmNvbXB1dGVHZW9tZXRyeSA9IGZ1bmN0aW9uIGNvbXB1dGVHZW9tZXRyeSAoKSB7XG4gIHRoaXMuYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24oKTtcbiAgaWYgKHRoaXMuX3Jlc3VsdEdlb21ldHJ5ICE9PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGFyZ1BNID0gdGhpcy5fYXJnR2VvbS5nZXRGYWN0b3J5KCkuZ2V0UHJlY2lzaW9uTW9kZWwoKTtcbiAgaWYgKGFyZ1BNLmdldFR5cGUoKSA9PT0gUHJlY2lzaW9uTW9kZWwuRklYRUQpIHsgdGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbihhcmdQTSk7IH0gZWxzZSB7IHRoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbigpOyB9XG59O1xuQnVmZmVyT3AucHJvdG90eXBlLnNldFF1YWRyYW50U2VnbWVudHMgPSBmdW5jdGlvbiBzZXRRdWFkcmFudFNlZ21lbnRzIChxdWFkcmFudFNlZ21lbnRzKSB7XG4gIHRoaXMuX2J1ZlBhcmFtcy5zZXRRdWFkcmFudFNlZ21lbnRzKHF1YWRyYW50U2VnbWVudHMpO1xufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5idWZmZXJPcmlnaW5hbFByZWNpc2lvbiA9IGZ1bmN0aW9uIGJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmQnVpbGRlciA9IG5ldyBCdWZmZXJCdWlsZGVyKHRoaXMuX2J1ZlBhcmFtcyk7XG4gICAgdGhpcy5fcmVzdWx0R2VvbWV0cnkgPSBidWZCdWlsZGVyLmJ1ZmZlcih0aGlzLl9hcmdHZW9tLCB0aGlzLl9kaXN0YW5jZSk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgUnVudGltZUV4Y2VwdGlvbikge1xuICAgICAgdGhpcy5fc2F2ZUV4Y2VwdGlvbiA9IGV4O1xuICAgIH0gZWxzZSB7IHRocm93IGV4IH1cbiAgfSBmaW5hbGx5IHt9XG59O1xuQnVmZmVyT3AucHJvdG90eXBlLmdldFJlc3VsdEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0UmVzdWx0R2VvbWV0cnkgKGRpc3RhbmNlKSB7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIHRoaXMuY29tcHV0ZUdlb21ldHJ5KCk7XG4gIHJldHVybiB0aGlzLl9yZXN1bHRHZW9tZXRyeVxufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5zZXRFbmRDYXBTdHlsZSA9IGZ1bmN0aW9uIHNldEVuZENhcFN0eWxlIChlbmRDYXBTdHlsZSkge1xuICB0aGlzLl9idWZQYXJhbXMuc2V0RW5kQ2FwU3R5bGUoZW5kQ2FwU3R5bGUpO1xufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQnVmZmVyT3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVyT3Bcbn07XG5CdWZmZXJPcC5idWZmZXJPcCA9IGZ1bmN0aW9uIGJ1ZmZlck9wICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZGlzdGFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGdCdWYgPSBuZXcgQnVmZmVyT3AoZyk7XG4gICAgdmFyIGdlb21CdWYgPSBnQnVmLmdldFJlc3VsdEdlb21ldHJ5KGRpc3RhbmNlKTtcbiAgICByZXR1cm4gZ2VvbUJ1ZlxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBnJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZGlzdGFuY2UkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBxdWFkcmFudFNlZ21lbnRzID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIGJ1Zk9wID0gbmV3IEJ1ZmZlck9wKGckMSk7XG4gICAgICBidWZPcC5zZXRRdWFkcmFudFNlZ21lbnRzKHF1YWRyYW50U2VnbWVudHMpO1xuICAgICAgdmFyIGdlb21CdWYkMSA9IGJ1Zk9wLmdldFJlc3VsdEdlb21ldHJ5KGRpc3RhbmNlJDEpO1xuICAgICAgcmV0dXJuIGdlb21CdWYkMVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgQnVmZmVyUGFyYW1ldGVycyAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgZyQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGRpc3RhbmNlJDIgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgcGFyYW1zID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIGJ1Zk9wJDEgPSBuZXcgQnVmZmVyT3AoZyQyLCBwYXJhbXMpO1xuICAgICAgdmFyIGdlb21CdWYkMiA9IGJ1Zk9wJDEuZ2V0UmVzdWx0R2VvbWV0cnkoZGlzdGFuY2UkMik7XG4gICAgICByZXR1cm4gZ2VvbUJ1ZiQyXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgZyQzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBkaXN0YW5jZSQzID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBxdWFkcmFudFNlZ21lbnRzJDEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGVuZENhcFN0eWxlID0gYXJndW1lbnRzWzNdO1xuICAgIHZhciBidWZPcCQyID0gbmV3IEJ1ZmZlck9wKGckMyk7XG4gICAgYnVmT3AkMi5zZXRRdWFkcmFudFNlZ21lbnRzKHF1YWRyYW50U2VnbWVudHMkMSk7XG4gICAgYnVmT3AkMi5zZXRFbmRDYXBTdHlsZShlbmRDYXBTdHlsZSk7XG4gICAgdmFyIGdlb21CdWYkMyA9IGJ1Zk9wJDIuZ2V0UmVzdWx0R2VvbWV0cnkoZGlzdGFuY2UkMyk7XG4gICAgcmV0dXJuIGdlb21CdWYkM1xuICB9XG59O1xuQnVmZmVyT3AucHJlY2lzaW9uU2NhbGVGYWN0b3IgPSBmdW5jdGlvbiBwcmVjaXNpb25TY2FsZUZhY3RvciAoZywgZGlzdGFuY2UsIG1heFByZWNpc2lvbkRpZ2l0cykge1xuICB2YXIgZW52ID0gZy5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gIHZhciBlbnZNYXggPSBNYXRoVXRpbC5tYXgoTWF0aC5hYnMoZW52LmdldE1heFgoKSksIE1hdGguYWJzKGVudi5nZXRNYXhZKCkpLCBNYXRoLmFicyhlbnYuZ2V0TWluWCgpKSwgTWF0aC5hYnMoZW52LmdldE1pblkoKSkpO1xuICB2YXIgZXhwYW5kQnlEaXN0YW5jZSA9IGRpc3RhbmNlID4gMC4wID8gZGlzdGFuY2UgOiAwLjA7XG4gIHZhciBidWZFbnZNYXggPSBlbnZNYXggKyAyICogZXhwYW5kQnlEaXN0YW5jZTtcbiAgdmFyIGJ1ZkVudlByZWNpc2lvbkRpZ2l0cyA9IE1hdGgudHJ1bmMoTWF0aC5sb2coYnVmRW52TWF4KSAvIE1hdGgubG9nKDEwKSArIDEuMCk7XG4gIHZhciBtaW5Vbml0TG9nMTAgPSBtYXhQcmVjaXNpb25EaWdpdHMgLSBidWZFbnZQcmVjaXNpb25EaWdpdHM7XG4gIHZhciBzY2FsZUZhY3RvciA9IE1hdGgucG93KDEwLjAsIG1pblVuaXRMb2cxMCk7XG4gIHJldHVybiBzY2FsZUZhY3RvclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzMi5DQVBfUk9VTkQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQnVmZmVyUGFyYW1ldGVycy5DQVBfUk9VTkQgfTtcbnN0YXRpY0FjY2Vzc29ycyQzMi5DQVBfQlVUVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9GTEFUIH07XG5zdGF0aWNBY2Nlc3NvcnMkMzIuQ0FQX0ZMQVQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQnVmZmVyUGFyYW1ldGVycy5DQVBfRkxBVCB9O1xuc3RhdGljQWNjZXNzb3JzJDMyLkNBUF9TUVVBUkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQnVmZmVyUGFyYW1ldGVycy5DQVBfU1FVQVJFIH07XG5zdGF0aWNBY2Nlc3NvcnMkMzIuTUFYX1BSRUNJU0lPTl9ESUdJVFMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMTIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlck9wLCBzdGF0aWNBY2Nlc3NvcnMkMzIgKTtcblxudmFyIFBvaW50UGFpckRpc3RhbmNlID0gZnVuY3Rpb24gUG9pbnRQYWlyRGlzdGFuY2UgKCkge1xuICB0aGlzLl9wdCA9IFtuZXcgQ29vcmRpbmF0ZSgpLCBuZXcgQ29vcmRpbmF0ZSgpXTtcbiAgdGhpcy5fZGlzdGFuY2UgPSBEb3VibGUuTmFOO1xuICB0aGlzLl9pc051bGwgPSB0cnVlO1xufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlIChpKSB7XG4gIHJldHVybiB0aGlzLl9wdFtpXVxufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5zZXRNaW5pbXVtID0gZnVuY3Rpb24gc2V0TWluaW11bSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHB0RGlzdCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldE1pbmltdW0ocHREaXN0Ll9wdFswXSwgcHREaXN0Ll9wdFsxXSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuX2lzTnVsbCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKHAwLCBwMSk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YXIgZGlzdCA9IHAwLmRpc3RhbmNlKHAxKTtcbiAgICBpZiAoZGlzdCA8IHRoaXMuX2Rpc3RhbmNlKSB7IHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEsIGRpc3QpOyB9XG4gIH1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZS5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uIGluaXRpYWxpemUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2lzTnVsbCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZShwMCk7XG4gICAgdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShwMSk7XG4gICAgdGhpcy5fZGlzdGFuY2UgPSBwMC5kaXN0YW5jZShwMSk7XG4gICAgdGhpcy5faXNOdWxsID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBwMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBkaXN0YW5jZSA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHAwJDEpO1xuICAgIHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUocDEkMSk7XG4gICAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICB0aGlzLl9pc051bGwgPSBmYWxzZTtcbiAgfVxufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlXG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLnNldE1heGltdW0gPSBmdW5jdGlvbiBzZXRNYXhpbXVtICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcHREaXN0ID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0TWF4aW11bShwdERpc3QuX3B0WzBdLCBwdERpc3QuX3B0WzFdKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5faXNOdWxsKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUocDAsIHAxKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHZhciBkaXN0ID0gcDAuZGlzdGFuY2UocDEpO1xuICAgIGlmIChkaXN0ID4gdGhpcy5fZGlzdGFuY2UpIHsgdGhpcy5pbml0aWFsaXplKHAwLCBwMSwgZGlzdCk7IH1cbiAgfVxufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9pbnRQYWlyRGlzdGFuY2Vcbn07XG5cbnZhciBEaXN0YW5jZVRvUG9pbnRGaW5kZXIgPSBmdW5jdGlvbiBEaXN0YW5jZVRvUG9pbnRGaW5kZXIgKCkge307XG5cbkRpc3RhbmNlVG9Qb2ludEZpbmRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkRpc3RhbmNlVG9Qb2ludEZpbmRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEaXN0YW5jZVRvUG9pbnRGaW5kZXJcbn07XG5EaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZURpc3RhbmNlICgpIHtcbiAgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFBvaW50UGFpckRpc3RhbmNlICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU3RyaW5nICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgdmFyIGxpbmUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGNvb3JkcyA9IGxpbmUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICB2YXIgdGVtcFNlZ21lbnQgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHRlbXBTZWdtZW50LnNldENvb3JkaW5hdGVzKGNvb3Jkc1tpXSwgY29vcmRzW2kgKyAxXSk7XG4gICAgICB2YXIgY2xvc2VzdFB0ID0gdGVtcFNlZ21lbnQuY2xvc2VzdFBvaW50KHB0KTtcbiAgICAgIHB0RGlzdC5zZXRNaW5pbXVtKGNsb3Nlc3RQdCwgcHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUG9seWdvbiAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBwb2x5ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QkMSA9IGFyZ3VtZW50c1syXTtcbiAgICBEaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlKHBvbHkuZ2V0RXh0ZXJpb3JSaW5nKCksIHB0JDEsIHB0RGlzdCQxKTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb2x5LmdldE51bUludGVyaW9yUmluZygpOyBpJDErKykge1xuICAgICAgRGlzdGFuY2VUb1BvaW50RmluZGVyLmNvbXB1dGVEaXN0YW5jZShwb2x5LmdldEludGVyaW9yUmluZ04oaSQxKSwgcHQkMSwgcHREaXN0JDEpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHREaXN0JDIgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgICBEaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlKGdlb20sIHB0JDIsIHB0RGlzdCQyKTtcbiAgICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgICBEaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlKGdlb20sIHB0JDIsIHB0RGlzdCQyKTtcbiAgICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBnYyA9IGdlb207XG4gICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBnYy5nZXROdW1HZW9tZXRyaWVzKCk7IGkkMisrKSB7XG4gICAgICAgIHZhciBnID0gZ2MuZ2V0R2VvbWV0cnlOKGkkMik7XG4gICAgICAgIERpc3RhbmNlVG9Qb2ludEZpbmRlci5jb21wdXRlRGlzdGFuY2UoZywgcHQkMiwgcHREaXN0JDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwdERpc3QkMi5zZXRNaW5pbXVtKGdlb20uZ2V0Q29vcmRpbmF0ZSgpLCBwdCQyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTZWdtZW50ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0JDMgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0RGlzdCQzID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBjbG9zZXN0UHQkMSA9IHNlZ21lbnQuY2xvc2VzdFBvaW50KHB0JDMpO1xuICAgIHB0RGlzdCQzLnNldE1pbmltdW0oY2xvc2VzdFB0JDEsIHB0JDMpO1xuICB9XG59O1xuXG52YXIgQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIgPSBmdW5jdGlvbiBCdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlciAoaW5wdXRHZW9tKSB7XG4gIHRoaXMuX21heFB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSgpO1xuICB0aGlzLl9pbnB1dEdlb20gPSBpbnB1dEdlb20gfHwgbnVsbDtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzYgPSB7IE1heFBvaW50RGlzdGFuY2VGaWx0ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIucHJvdG90eXBlLmNvbXB1dGVNYXhNaWRwb2ludERpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZU1heE1pZHBvaW50RGlzdGFuY2UgKGN1cnZlKSB7XG4gIHZhciBkaXN0RmlsdGVyID0gbmV3IE1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIodGhpcy5faW5wdXRHZW9tKTtcbiAgY3VydmUuYXBwbHkoZGlzdEZpbHRlcik7XG4gIHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKGRpc3RGaWx0ZXIuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKTtcbn07XG5CdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlci5wcm90b3R5cGUuY29tcHV0ZU1heFZlcnRleERpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZU1heFZlcnRleERpc3RhbmNlIChjdXJ2ZSkge1xuICB2YXIgZGlzdEZpbHRlciA9IG5ldyBNYXhQb2ludERpc3RhbmNlRmlsdGVyKHRoaXMuX2lucHV0R2VvbSk7XG4gIGN1cnZlLmFwcGx5KGRpc3RGaWx0ZXIpO1xuICB0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bShkaXN0RmlsdGVyLmdldE1heFBvaW50RGlzdGFuY2UoKSk7XG59O1xuQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIucHJvdG90eXBlLmZpbmREaXN0YW5jZSA9IGZ1bmN0aW9uIGZpbmREaXN0YW5jZSAoYnVmZmVyQ3VydmUpIHtcbiAgdGhpcy5jb21wdXRlTWF4VmVydGV4RGlzdGFuY2UoYnVmZmVyQ3VydmUpO1xuICB0aGlzLmNvbXB1dGVNYXhNaWRwb2ludERpc3RhbmNlKGJ1ZmZlckN1cnZlKTtcbiAgcmV0dXJuIHRoaXMuX21heFB0RGlzdC5nZXREaXN0YW5jZSgpXG59O1xuQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIucHJvdG90eXBlLmdldERpc3RhbmNlUG9pbnRzID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2VQb2ludHMgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4UHREaXN0XG59O1xuQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzNi5NYXhQb2ludERpc3RhbmNlRmlsdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIgfTtcbnN0YXRpY0FjY2Vzc29ycyQzNi5NYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyLCBzdGF0aWNBY2Nlc3NvcnMkMzYgKTtcblxudmFyIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIgPSBmdW5jdGlvbiBNYXhQb2ludERpc3RhbmNlRmlsdGVyIChnZW9tKSB7XG4gIHRoaXMuX21heFB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSgpO1xuICB0aGlzLl9taW5QdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UoKTtcbiAgdGhpcy5fZ2VvbSA9IGdlb20gfHwgbnVsbDtcbn07XG5NYXhQb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHB0KSB7XG4gIHRoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCk7XG4gIERpc3RhbmNlVG9Qb2ludEZpbmRlci5jb21wdXRlRGlzdGFuY2UodGhpcy5fZ2VvbSwgcHQsIHRoaXMuX21pblB0RGlzdCk7XG4gIHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCk7XG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0TWF4UG9pbnREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldE1heFBvaW50RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4UHREaXN0XG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZUZpbHRlcl1cbn07XG5NYXhQb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1heFBvaW50RGlzdGFuY2VGaWx0ZXJcbn07XG5cbnZhciBNYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyID0gZnVuY3Rpb24gTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlciAoZ2VvbSkge1xuICB0aGlzLl9tYXhQdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UoKTtcbiAgdGhpcy5fbWluUHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlKCk7XG4gIHRoaXMuX2dlb20gPSBnZW9tIHx8IG51bGw7XG59O1xuTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChzZXEsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBwMCA9IHNlcS5nZXRDb29yZGluYXRlKGluZGV4IC0gMSk7XG4gIHZhciBwMSA9IHNlcS5nZXRDb29yZGluYXRlKGluZGV4KTtcbiAgdmFyIG1pZFB0ID0gbmV3IENvb3JkaW5hdGUoKHAwLnggKyBwMS54KSAvIDIsIChwMC55ICsgcDEueSkgLyAyKTtcbiAgdGhpcy5fbWluUHREaXN0LmluaXRpYWxpemUoKTtcbiAgRGlzdGFuY2VUb1BvaW50RmluZGVyLmNvbXB1dGVEaXN0YW5jZSh0aGlzLl9nZW9tLCBtaWRQdCwgdGhpcy5fbWluUHREaXN0KTtcbiAgdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcy5fbWluUHREaXN0KTtcbn07XG5NYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5NYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5pc0dlb21ldHJ5Q2hhbmdlZCA9IGZ1bmN0aW9uIGlzR2VvbWV0cnlDaGFuZ2VkICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59O1xuTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0TWF4UG9pbnREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldE1heFBvaW50RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4UHREaXN0XG59O1xuTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyXVxufTtcbk1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlclxufTtcblxudmFyIFBvbHlnb25FeHRyYWN0ZXIgPSBmdW5jdGlvbiBQb2x5Z29uRXh0cmFjdGVyIChjb21wcykge1xuICB0aGlzLl9jb21wcyA9IGNvbXBzIHx8IG51bGw7XG59O1xuUG9seWdvbkV4dHJhY3Rlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnZW9tKSB7XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgUG9seWdvbikgeyB0aGlzLl9jb21wcy5hZGQoZ2VvbSk7IH1cbn07XG5Qb2x5Z29uRXh0cmFjdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUZpbHRlcl1cbn07XG5Qb2x5Z29uRXh0cmFjdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvbHlnb25FeHRyYWN0ZXJcbn07XG5Qb2x5Z29uRXh0cmFjdGVyLmdldFBvbHlnb25zID0gZnVuY3Rpb24gZ2V0UG9seWdvbnMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBQb2x5Z29uRXh0cmFjdGVyLmdldFBvbHlnb25zKGdlb20sIG5ldyBBcnJheUxpc3QoKSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb20kMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGlzdCA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZ2VvbSQxIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgICAgbGlzdC5hZGQoZ2VvbSQxKTtcbiAgICB9IGVsc2UgaWYgKGdlb20kMSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgICAgZ2VvbSQxLmFwcGx5KG5ldyBQb2x5Z29uRXh0cmFjdGVyKGxpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxufTtcblxudmFyIExpbmVhckNvbXBvbmVudEV4dHJhY3RlciA9IGZ1bmN0aW9uIExpbmVhckNvbXBvbmVudEV4dHJhY3RlciAoKSB7XG4gIHRoaXMuX2xpbmVzID0gbnVsbDtcbiAgdGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmcgPSBmYWxzZTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbGluZXMgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fbGluZXMgPSBsaW5lcztcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGxpbmVzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGlzRm9yY2VkVG9MaW5lU3RyaW5nID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2xpbmVzID0gbGluZXMkMTtcbiAgICB0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZyA9IGlzRm9yY2VkVG9MaW5lU3RyaW5nO1xuICB9XG59O1xuTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGdlb20pIHtcbiAgaWYgKHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nICYmIGdlb20gaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB7XG4gICAgdmFyIGxpbmUgPSBnZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKGdlb20uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO1xuICAgIHRoaXMuX2xpbmVzLmFkZChsaW5lKTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgTGluZVN0cmluZykgeyB0aGlzLl9saW5lcy5hZGQoZ2VvbSk7IH1cbn07XG5MaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIucHJvdG90eXBlLnNldEZvcmNlVG9MaW5lU3RyaW5nID0gZnVuY3Rpb24gc2V0Rm9yY2VUb0xpbmVTdHJpbmcgKGlzRm9yY2VkVG9MaW5lU3RyaW5nKSB7XG4gIHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nID0gaXNGb3JjZWRUb0xpbmVTdHJpbmc7XG59O1xuTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUNvbXBvbmVudEZpbHRlcl1cbn07XG5MaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyXG59O1xuTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnkgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBnZW9tLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyhnZW9tKSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb20kMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZm9yY2VUb0xpbmVTdHJpbmcgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIGdlb20kMS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXMoZ2VvbSQxLCBmb3JjZVRvTGluZVN0cmluZykpXG4gIH1cbn07XG5MaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXMgPSBmdW5jdGlvbiBnZXRMaW5lcyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyhnZW9tLCBmYWxzZSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvbGxlY3Rpb24pICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIENvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgZ2VvbXMgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbGluZXMkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGZvciAodmFyIGkgPSBnZW9tcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGcgPSBpLm5leHQoKTtcbiAgICAgICAgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKGcsIGxpbmVzJDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVzJDFcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5ICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdib29sZWFuJykge1xuICAgICAgdmFyIGdlb20kMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBmb3JjZVRvTGluZVN0cmluZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsaW5lcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICAgIGdlb20kMS5hcHBseShuZXcgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyKGxpbmVzLCBmb3JjZVRvTGluZVN0cmluZykpO1xuICAgICAgcmV0dXJuIGxpbmVzXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBDb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGdlb20kMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsaW5lcyQyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGdlb20kMiBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICAgICAgbGluZXMkMi5hZGQoZ2VvbSQyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlb20kMi5hcHBseShuZXcgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyKGxpbmVzJDIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lcyQyXG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Jvb2xlYW4nICYmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb2xsZWN0aW9uKSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBDb2xsZWN0aW9uKSkpIHtcbiAgICAgIHZhciBnZW9tcyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxpbmVzJDMgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgZm9yY2VUb0xpbmVTdHJpbmckMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGZvciAodmFyIGkkMSA9IGdlb21zJDEuaXRlcmF0b3IoKTsgaSQxLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGckMSA9IGkkMS5uZXh0KCk7XG4gICAgICAgIExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyhnJDEsIGxpbmVzJDMsIGZvcmNlVG9MaW5lU3RyaW5nJDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVzJDNcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdib29sZWFuJyAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgQ29sbGVjdGlvbikpKSB7XG4gICAgICB2YXIgZ2VvbSQzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxpbmVzJDQgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgZm9yY2VUb0xpbmVTdHJpbmckMiA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGdlb20kMy5hcHBseShuZXcgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyKGxpbmVzJDQsIGZvcmNlVG9MaW5lU3RyaW5nJDIpKTtcbiAgICAgIHJldHVybiBsaW5lcyQ0XG4gICAgfVxuICB9XG59O1xuXG52YXIgUG9pbnRMb2NhdG9yID0gZnVuY3Rpb24gUG9pbnRMb2NhdG9yICgpIHtcbiAgdGhpcy5fYm91bmRhcnlSdWxlID0gQm91bmRhcnlOb2RlUnVsZS5PR0NfU0ZTX0JPVU5EQVJZX1JVTEU7XG4gIHRoaXMuX2lzSW4gPSBudWxsO1xuICB0aGlzLl9udW1Cb3VuZGFyaWVzID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHt9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgYm91bmRhcnlSdWxlID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChib3VuZGFyeVJ1bGUgPT09IG51bGwpIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUnVsZSBtdXN0IGJlIG5vbi1udWxsJykgfVxuICAgIHRoaXMuX2JvdW5kYXJ5UnVsZSA9IGJvdW5kYXJ5UnVsZTtcbiAgfVxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUubG9jYXRlSW50ZXJuYWwgPSBmdW5jdGlvbiBsb2NhdGVJbnRlcm5hbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwb2x5ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChwb2x5LmlzRW1wdHkoKSkgeyByZXR1cm4gTG9jYXRpb24uRVhURVJJT1IgfVxuICAgIHZhciBzaGVsbCA9IHBvbHkuZ2V0RXh0ZXJpb3JSaW5nKCk7XG4gICAgdmFyIHNoZWxsTG9jID0gdGhpcy5sb2NhdGVJblBvbHlnb25SaW5nKHAsIHNoZWxsKTtcbiAgICBpZiAoc2hlbGxMb2MgPT09IExvY2F0aW9uLkVYVEVSSU9SKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gICAgaWYgKHNoZWxsTG9jID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyByZXR1cm4gTG9jYXRpb24uQk9VTkRBUlkgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSsrKSB7XG4gICAgICB2YXIgaG9sZSA9IHBvbHkuZ2V0SW50ZXJpb3JSaW5nTihpKTtcbiAgICAgIHZhciBob2xlTG9jID0gdGhpcyQxLmxvY2F0ZUluUG9seWdvblJpbmcocCwgaG9sZSk7XG4gICAgICBpZiAoaG9sZUxvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SIH1cbiAgICAgIGlmIChob2xlTG9jID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyByZXR1cm4gTG9jYXRpb24uQk9VTkRBUlkgfVxuICAgIH1cbiAgICByZXR1cm4gTG9jYXRpb24uSU5URVJJT1JcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICB2YXIgcCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICghbC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhwJDEpKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gICAgdmFyIHB0ID0gbC5nZXRDb29yZGluYXRlcygpO1xuICAgIGlmICghbC5pc0Nsb3NlZCgpKSB7XG4gICAgICBpZiAocCQxLmVxdWFscyhwdFswXSkgfHwgcCQxLmVxdWFscyhwdFtwdC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIExvY2F0aW9uLkJPVU5EQVJZXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDR0FsZ29yaXRobXMuaXNPbkxpbmUocCQxLCBwdCkpIHsgcmV0dXJuIExvY2F0aW9uLklOVEVSSU9SIH1cbiAgICByZXR1cm4gTG9jYXRpb24uRVhURVJJT1JcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgdmFyIHAkMiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHRDb29yZCA9IHB0JDEuZ2V0Q29vcmRpbmF0ZSgpO1xuICAgIGlmIChwdENvb3JkLmVxdWFsczJEKHAkMikpIHsgcmV0dXJuIExvY2F0aW9uLklOVEVSSU9SIH1cbiAgICByZXR1cm4gTG9jYXRpb24uRVhURVJJT1JcbiAgfVxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUubG9jYXRlSW5Qb2x5Z29uUmluZyA9IGZ1bmN0aW9uIGxvY2F0ZUluUG9seWdvblJpbmcgKHAsIHJpbmcpIHtcbiAgaWYgKCFyaW5nLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHApKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gIHJldHVybiBDR0FsZ29yaXRobXMubG9jYXRlUG9pbnRJblJpbmcocCwgcmluZy5nZXRDb29yZGluYXRlcygpKVxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIGludGVyc2VjdHMgKHAsIGdlb20pIHtcbiAgcmV0dXJuIHRoaXMubG9jYXRlKHAsIGdlb20pICE9PSBMb2NhdGlvbi5FWFRFUklPUlxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUudXBkYXRlTG9jYXRpb25JbmZvID0gZnVuY3Rpb24gdXBkYXRlTG9jYXRpb25JbmZvIChsb2MpIHtcbiAgaWYgKGxvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgdGhpcy5faXNJbiA9IHRydWU7IH1cbiAgaWYgKGxvYyA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgdGhpcy5fbnVtQm91bmRhcmllcysrOyB9XG59O1xuUG9pbnRMb2NhdG9yLnByb3RvdHlwZS5jb21wdXRlTG9jYXRpb24gPSBmdW5jdGlvbiBjb21wdXRlTG9jYXRpb24gKHAsIGdlb20pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbChwLCBnZW9tKSk7XG4gIH1cbiAgaWYgKGdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbChwLCBnZW9tKSk7XG4gIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICB0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHAsIGdlb20pKTtcbiAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgTXVsdGlMaW5lU3RyaW5nKSB7XG4gICAgdmFyIG1sID0gZ2VvbTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1sLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgICB2YXIgbCA9IG1sLmdldEdlb21ldHJ5TihpKTtcbiAgICAgIHRoaXMkMS51cGRhdGVMb2NhdGlvbkluZm8odGhpcyQxLmxvY2F0ZUludGVybmFsKHAsIGwpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIE11bHRpUG9seWdvbikge1xuICAgIHZhciBtcG9seSA9IGdlb207XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbXBvbHkuZ2V0TnVtR2VvbWV0cmllcygpOyBpJDErKykge1xuICAgICAgdmFyIHBvbHkgPSBtcG9seS5nZXRHZW9tZXRyeU4oaSQxKTtcbiAgICAgIHRoaXMkMS51cGRhdGVMb2NhdGlvbkluZm8odGhpcyQxLmxvY2F0ZUludGVybmFsKHAsIHBvbHkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgIHZhciBnZW9taSA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvcihnZW9tKTtcbiAgICB3aGlsZSAoZ2VvbWkuaGFzTmV4dCgpKSB7XG4gICAgICB2YXIgZzIgPSBnZW9taS5uZXh0KCk7XG4gICAgICBpZiAoZzIgIT09IGdlb20pIHsgdGhpcyQxLmNvbXB1dGVMb2NhdGlvbihwLCBnMik7IH1cbiAgICB9XG4gIH1cbn07XG5Qb2ludExvY2F0b3IucHJvdG90eXBlLmxvY2F0ZSA9IGZ1bmN0aW9uIGxvY2F0ZSAocCwgZ2VvbSkge1xuICBpZiAoZ2VvbS5pc0VtcHR5KCkpIHsgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SIH1cbiAgaWYgKGdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYXRlSW50ZXJuYWwocCwgZ2VvbSlcbiAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgIHJldHVybiB0aGlzLmxvY2F0ZUludGVybmFsKHAsIGdlb20pXG4gIH1cbiAgdGhpcy5faXNJbiA9IGZhbHNlO1xuICB0aGlzLl9udW1Cb3VuZGFyaWVzID0gMDtcbiAgdGhpcy5jb21wdXRlTG9jYXRpb24ocCwgZ2VvbSk7XG4gIGlmICh0aGlzLl9ib3VuZGFyeVJ1bGUuaXNJbkJvdW5kYXJ5KHRoaXMuX251bUJvdW5kYXJpZXMpKSB7IHJldHVybiBMb2NhdGlvbi5CT1VOREFSWSB9XG4gIGlmICh0aGlzLl9udW1Cb3VuZGFyaWVzID4gMCB8fCB0aGlzLl9pc0luKSB7IHJldHVybiBMb2NhdGlvbi5JTlRFUklPUiB9XG4gIHJldHVybiBMb2NhdGlvbi5FWFRFUklPUlxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2ludExvY2F0b3Jcbn07XG5cbnZhciBHZW9tZXRyeUxvY2F0aW9uID0gZnVuY3Rpb24gR2VvbWV0cnlMb2NhdGlvbiAoKSB7XG4gIHRoaXMuX2NvbXBvbmVudCA9IG51bGw7XG4gIHRoaXMuX3NlZ0luZGV4ID0gbnVsbDtcbiAgdGhpcy5fcHQgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBjb21wb25lbnQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0ID0gYXJndW1lbnRzWzFdO1xuICAgIEdlb21ldHJ5TG9jYXRpb24uY2FsbCh0aGlzLCBjb21wb25lbnQsIEdlb21ldHJ5TG9jYXRpb24uSU5TSURFX0FSRUEsIHB0KTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGNvbXBvbmVudCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzZWdJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHQkMSA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLl9jb21wb25lbnQgPSBjb21wb25lbnQkMTtcbiAgICB0aGlzLl9zZWdJbmRleCA9IHNlZ0luZGV4O1xuICAgIHRoaXMuX3B0ID0gcHQkMTtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzOCA9IHsgSU5TSURFX0FSRUE6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkdlb21ldHJ5TG9jYXRpb24ucHJvdG90eXBlLmlzSW5zaWRlQXJlYSA9IGZ1bmN0aW9uIGlzSW5zaWRlQXJlYSAoKSB7XG4gIHJldHVybiB0aGlzLl9zZWdJbmRleCA9PT0gR2VvbWV0cnlMb2NhdGlvbi5JTlNJREVfQVJFQVxufTtcbkdlb21ldHJ5TG9jYXRpb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0XG59O1xuR2VvbWV0cnlMb2NhdGlvbi5wcm90b3R5cGUuZ2V0R2VvbWV0cnlDb21wb25lbnQgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeUNvbXBvbmVudCAoKSB7XG4gIHJldHVybiB0aGlzLl9jb21wb25lbnRcbn07XG5HZW9tZXRyeUxvY2F0aW9uLnByb3RvdHlwZS5nZXRTZWdtZW50SW5kZXggPSBmdW5jdGlvbiBnZXRTZWdtZW50SW5kZXggKCkge1xuICByZXR1cm4gdGhpcy5fc2VnSW5kZXhcbn07XG5HZW9tZXRyeUxvY2F0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlMb2NhdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUxvY2F0aW9uXG59O1xuc3RhdGljQWNjZXNzb3JzJDM4LklOU0lERV9BUkVBLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC0xIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBHZW9tZXRyeUxvY2F0aW9uLCBzdGF0aWNBY2Nlc3NvcnMkMzggKTtcblxudmFyIFBvaW50RXh0cmFjdGVyID0gZnVuY3Rpb24gUG9pbnRFeHRyYWN0ZXIgKHB0cykge1xuICB0aGlzLl9wdHMgPSBwdHMgfHwgbnVsbDtcbn07XG5Qb2ludEV4dHJhY3Rlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnZW9tKSB7XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgUG9pbnQpIHsgdGhpcy5fcHRzLmFkZChnZW9tKTsgfVxufTtcblBvaW50RXh0cmFjdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUZpbHRlcl1cbn07XG5Qb2ludEV4dHJhY3Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2ludEV4dHJhY3RlclxufTtcblBvaW50RXh0cmFjdGVyLmdldFBvaW50cyA9IGZ1bmN0aW9uIGdldFBvaW50cyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgcmV0dXJuIENvbGxlY3Rpb25zLnNpbmdsZXRvbkxpc3QoZ2VvbSlcbiAgICB9XG4gICAgcmV0dXJuIFBvaW50RXh0cmFjdGVyLmdldFBvaW50cyhnZW9tLCBuZXcgQXJyYXlMaXN0KCkpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxpc3QgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGdlb20kMSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICBsaXN0LmFkZChnZW9tJDEpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbSQxIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgICBnZW9tJDEuYXBwbHkobmV3IFBvaW50RXh0cmFjdGVyKGxpc3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxufTtcblxudmFyIENvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlciA9IGZ1bmN0aW9uIENvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlciAoKSB7XG4gIHRoaXMuX2xvY2F0aW9ucyA9IG51bGw7XG4gIHZhciBsb2NhdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2xvY2F0aW9ucyA9IGxvY2F0aW9ucztcbn07XG5Db25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoZ2VvbSkge1xuICBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvaW50IHx8IGdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nIHx8IGdlb20gaW5zdGFuY2VvZiBQb2x5Z29uKSB7IHRoaXMuX2xvY2F0aW9ucy5hZGQobmV3IEdlb21ldHJ5TG9jYXRpb24oZ2VvbSwgMCwgZ2VvbS5nZXRDb29yZGluYXRlKCkpKTsgfVxufTtcbkNvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlGaWx0ZXJdXG59O1xuQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlclxufTtcbkNvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlci5nZXRMb2NhdGlvbnMgPSBmdW5jdGlvbiBnZXRMb2NhdGlvbnMgKGdlb20pIHtcbiAgdmFyIGxvY2F0aW9ucyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZ2VvbS5hcHBseShuZXcgQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyKGxvY2F0aW9ucykpO1xuICByZXR1cm4gbG9jYXRpb25zXG59O1xuXG52YXIgRGlzdGFuY2VPcCA9IGZ1bmN0aW9uIERpc3RhbmNlT3AgKCkge1xuICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgdGhpcy5fdGVybWluYXRlRGlzdGFuY2UgPSAwLjA7XG4gIHRoaXMuX3B0TG9jYXRvciA9IG5ldyBQb2ludExvY2F0b3IoKTtcbiAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvbiA9IG51bGw7XG4gIHRoaXMuX21pbkRpc3RhbmNlID0gRG91YmxlLk1BWF9WQUxVRTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2dlb20gPSBbZzAsIGcxXTtcbiAgICB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSA9IDAuMDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGcwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHRlcm1pbmF0ZURpc3RhbmNlID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX2dlb20gPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgICB0aGlzLl9nZW9tWzBdID0gZzAkMTtcbiAgICB0aGlzLl9nZW9tWzFdID0gZzEkMTtcbiAgICB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSA9IHRlcm1pbmF0ZURpc3RhbmNlO1xuICB9XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB2YXIgbG9jUHRQb2x5ID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gICAgdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgwLCBsb2NQdFBvbHkpO1xuICAgIGlmICh0aGlzLl9taW5EaXN0YW5jZSA8PSB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgxLCBsb2NQdFBvbHkpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcG9seUdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG9jUHRQb2x5JDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGxvY2F0aW9uc0luZGV4ID0gMSAtIHBvbHlHZW9tSW5kZXg7XG4gICAgdmFyIHBvbHlzID0gUG9seWdvbkV4dHJhY3Rlci5nZXRQb2x5Z29ucyh0aGlzLl9nZW9tW3BvbHlHZW9tSW5kZXhdKTtcbiAgICBpZiAocG9seXMuc2l6ZSgpID4gMCkge1xuICAgICAgdmFyIGluc2lkZUxvY3MgPSBDb25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXIuZ2V0TG9jYXRpb25zKHRoaXMuX2dlb21bbG9jYXRpb25zSW5kZXhdKTtcbiAgICAgIHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoaW5zaWRlTG9jcywgcG9seXMsIGxvY1B0UG9seSQxKTtcbiAgICAgIGlmICh0aGlzLl9taW5EaXN0YW5jZSA8PSB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSkge1xuICAgICAgICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uW2xvY2F0aW9uc0luZGV4XSA9IGxvY1B0UG9seSQxWzBdO1xuICAgICAgICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uW3BvbHlHZW9tSW5kZXhdID0gbG9jUHRQb2x5JDFbMV07XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgQXJyYXkgJiYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIExpc3QpICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIExpc3QpKSkge1xuICAgICAgdmFyIGxvY3MgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcG9seXMkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsb2NQdFBvbHkkMiA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5zaXplKCk7IGkrKykge1xuICAgICAgICB2YXIgbG9jID0gbG9jcy5nZXQoaSk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9seXMkMS5zaXplKCk7IGorKykge1xuICAgICAgICAgIHRoaXMkMS5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShsb2MsIHBvbHlzJDEuZ2V0KGopLCBsb2NQdFBvbHkkMik7XG4gICAgICAgICAgaWYgKHRoaXMkMS5fbWluRGlzdGFuY2UgPD0gdGhpcyQxLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIEFycmF5ICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeUxvY2F0aW9uICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFBvbHlnb24pKSB7XG4gICAgICB2YXIgcHRMb2MgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcG9seSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsb2NQdFBvbHkkMyA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBwdCA9IHB0TG9jLmdldENvb3JkaW5hdGUoKTtcbiAgICAgIGlmIChMb2NhdGlvbi5FWFRFUklPUiAhPT0gdGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShwdCwgcG9seSkpIHtcbiAgICAgICAgdGhpcy5fbWluRGlzdGFuY2UgPSAwLjA7XG4gICAgICAgIGxvY1B0UG9seSQzWzBdID0gcHRMb2M7XG4gICAgICAgIGxvY1B0UG9seSQzWzFdID0gbmV3IEdlb21ldHJ5TG9jYXRpb24ocG9seSwgcHQpO1xuXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMgPSBmdW5jdGlvbiBjb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyAobGluZXMsIHBvaW50cywgbG9jR2VvbSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMuc2l6ZSgpOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGxpbmVzLmdldChpKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5zaXplKCk7IGorKykge1xuICAgICAgdmFyIHB0ID0gcG9pbnRzLmdldChqKTtcbiAgICAgIHRoaXMkMS5jb21wdXRlTWluRGlzdGFuY2UobGluZSwgcHQsIGxvY0dlb20pO1xuICAgICAgaWYgKHRoaXMkMS5fbWluRGlzdGFuY2UgPD0gdGhpcyQxLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgfVxuICB9XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuY29tcHV0ZUZhY2V0RGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlRmFjZXREaXN0YW5jZSAoKSB7XG4gIHZhciBsb2NHZW9tID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHZhciBsaW5lczAgPSBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXModGhpcy5fZ2VvbVswXSk7XG4gIHZhciBsaW5lczEgPSBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXModGhpcy5fZ2VvbVsxXSk7XG4gIHZhciBwdHMwID0gUG9pbnRFeHRyYWN0ZXIuZ2V0UG9pbnRzKHRoaXMuX2dlb21bMF0pO1xuICB2YXIgcHRzMSA9IFBvaW50RXh0cmFjdGVyLmdldFBvaW50cyh0aGlzLl9nZW9tWzFdKTtcbiAgdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lcyhsaW5lczAsIGxpbmVzMSwgbG9jR2VvbSk7XG4gIHRoaXMudXBkYXRlTWluRGlzdGFuY2UobG9jR2VvbSwgZmFsc2UpO1xuICBpZiAodGhpcy5fbWluRGlzdGFuY2UgPD0gdGhpcy5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICBsb2NHZW9tWzBdID0gbnVsbDtcbiAgbG9jR2VvbVsxXSA9IG51bGw7XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMobGluZXMwLCBwdHMxLCBsb2NHZW9tKTtcbiAgdGhpcy51cGRhdGVNaW5EaXN0YW5jZShsb2NHZW9tLCBmYWxzZSk7XG4gIGlmICh0aGlzLl9taW5EaXN0YW5jZSA8PSB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gIGxvY0dlb21bMF0gPSBudWxsO1xuICBsb2NHZW9tWzFdID0gbnVsbDtcbiAgdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhsaW5lczEsIHB0czAsIGxvY0dlb20pO1xuICB0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKGxvY0dlb20sIHRydWUpO1xuICBpZiAodGhpcy5fbWluRGlzdGFuY2UgPD0gdGhpcy5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICBsb2NHZW9tWzBdID0gbnVsbDtcbiAgbG9jR2VvbVsxXSA9IG51bGw7XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzKHB0czAsIHB0czEsIGxvY0dlb20pO1xuICB0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKGxvY0dlb20sIGZhbHNlKTtcbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5uZWFyZXN0TG9jYXRpb25zID0gZnVuY3Rpb24gbmVhcmVzdExvY2F0aW9ucyAoKSB7XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCk7XG4gIHJldHVybiB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uXG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUudXBkYXRlTWluRGlzdGFuY2UgPSBmdW5jdGlvbiB1cGRhdGVNaW5EaXN0YW5jZSAobG9jR2VvbSwgZmxpcCkge1xuICBpZiAobG9jR2VvbVswXSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChmbGlwKSB7XG4gICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXSA9IGxvY0dlb21bMV07XG4gICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXSA9IGxvY0dlb21bMF07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXSA9IGxvY0dlb21bMF07XG4gICAgdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblsxXSA9IGxvY0dlb21bMV07XG4gIH1cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5uZWFyZXN0UG9pbnRzID0gZnVuY3Rpb24gbmVhcmVzdFBvaW50cyAoKSB7XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCk7XG4gIHZhciBuZWFyZXN0UHRzID0gW3RoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMF0uZ2V0Q29vcmRpbmF0ZSgpLCB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdLmdldENvb3JkaW5hdGUoKV07XG4gIHJldHVybiBuZWFyZXN0UHRzXG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuY29tcHV0ZU1pbkRpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZU1pbkRpc3RhbmNlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uICE9PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gICAgdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgpO1xuICAgIGlmICh0aGlzLl9taW5EaXN0YW5jZSA8PSB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdGhpcy5jb21wdXRlRmFjZXREaXN0YW5jZSgpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgQXJyYXkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTdHJpbmcgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgICB2YXIgbGluZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwdCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsb2NHZW9tID0gYXJndW1lbnRzWzJdO1xuICAgICAgaWYgKGxpbmUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKHB0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkgPiB0aGlzLl9taW5EaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICB2YXIgY29vcmQwID0gbGluZS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgdmFyIGNvb3JkID0gcHQuZ2V0Q29vcmRpbmF0ZSgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZDAubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBkaXN0ID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKGNvb3JkLCBjb29yZDBbaV0sIGNvb3JkMFtpICsgMV0pO1xuICAgICAgICBpZiAoZGlzdCA8IHRoaXMkMS5fbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICB0aGlzJDEuX21pbkRpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgICB2YXIgc2VnID0gbmV3IExpbmVTZWdtZW50KGNvb3JkMFtpXSwgY29vcmQwW2kgKyAxXSk7XG4gICAgICAgICAgdmFyIHNlZ0Nsb3Nlc3RQb2ludCA9IHNlZy5jbG9zZXN0UG9pbnQoY29vcmQpO1xuICAgICAgICAgIGxvY0dlb21bMF0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihsaW5lLCBpLCBzZWdDbG9zZXN0UG9pbnQpO1xuICAgICAgICAgIGxvY0dlb21bMV0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihwdCwgMCwgY29vcmQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzJDEuX21pbkRpc3RhbmNlIDw9IHRoaXMkMS5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgQXJyYXkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTdHJpbmcgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgTGluZVN0cmluZykpIHtcbiAgICAgIHZhciBsaW5lMCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsaW5lMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBsb2NHZW9tJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICBpZiAobGluZTAuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGxpbmUxLmdldEVudmVsb3BlSW50ZXJuYWwoKSkgPiB0aGlzLl9taW5EaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICB2YXIgY29vcmQwJDEgPSBsaW5lMC5nZXRDb29yZGluYXRlcygpO1xuICAgICAgdmFyIGNvb3JkMSA9IGxpbmUxLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjb29yZDAkMS5sZW5ndGggLSAxOyBpJDErKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvb3JkMS5sZW5ndGggLSAxOyBqKyspIHtcbiAgICAgICAgICB2YXIgZGlzdCQxID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlTGluZUxpbmUoY29vcmQwJDFbaSQxXSwgY29vcmQwJDFbaSQxICsgMV0sIGNvb3JkMVtqXSwgY29vcmQxW2ogKyAxXSk7XG4gICAgICAgICAgaWYgKGRpc3QkMSA8IHRoaXMkMS5fbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMkMS5fbWluRGlzdGFuY2UgPSBkaXN0JDE7XG4gICAgICAgICAgICB2YXIgc2VnMCA9IG5ldyBMaW5lU2VnbWVudChjb29yZDAkMVtpJDFdLCBjb29yZDAkMVtpJDEgKyAxXSk7XG4gICAgICAgICAgICB2YXIgc2VnMSA9IG5ldyBMaW5lU2VnbWVudChjb29yZDFbal0sIGNvb3JkMVtqICsgMV0pO1xuICAgICAgICAgICAgdmFyIGNsb3Nlc3RQdCA9IHNlZzAuY2xvc2VzdFBvaW50cyhzZWcxKTtcbiAgICAgICAgICAgIGxvY0dlb20kMVswXSA9IG5ldyBHZW9tZXRyeUxvY2F0aW9uKGxpbmUwLCBpJDEsIGNsb3Nlc3RQdFswXSk7XG4gICAgICAgICAgICBsb2NHZW9tJDFbMV0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihsaW5lMSwgaiwgY2xvc2VzdFB0WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMkMS5fbWluRGlzdGFuY2UgPD0gdGhpcyQxLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5jb21wdXRlTWluRGlzdGFuY2VQb2ludHMgPSBmdW5jdGlvbiBjb21wdXRlTWluRGlzdGFuY2VQb2ludHMgKHBvaW50czAsIHBvaW50czEsIGxvY0dlb20pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czAuc2l6ZSgpOyBpKyspIHtcbiAgICB2YXIgcHQwID0gcG9pbnRzMC5nZXQoaSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2ludHMxLnNpemUoKTsgaisrKSB7XG4gICAgICB2YXIgcHQxID0gcG9pbnRzMS5nZXQoaik7XG4gICAgICB2YXIgZGlzdCA9IHB0MC5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2UocHQxLmdldENvb3JkaW5hdGUoKSk7XG4gICAgICBpZiAoZGlzdCA8IHRoaXMkMS5fbWluRGlzdGFuY2UpIHtcbiAgICAgICAgdGhpcyQxLl9taW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgIGxvY0dlb21bMF0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihwdDAsIDAsIHB0MC5nZXRDb29yZGluYXRlKCkpO1xuICAgICAgICBsb2NHZW9tWzFdID0gbmV3IEdlb21ldHJ5TG9jYXRpb24ocHQxLCAwLCBwdDEuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzJDEuX21pbkRpc3RhbmNlIDw9IHRoaXMkMS5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgIH1cbiAgfVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKCkge1xuICBpZiAodGhpcy5fZ2VvbVswXSA9PT0gbnVsbCB8fCB0aGlzLl9nZW9tWzFdID09PSBudWxsKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ251bGwgZ2VvbWV0cmllcyBhcmUgbm90IHN1cHBvcnRlZCcpIH1cbiAgaWYgKHRoaXMuX2dlb21bMF0uaXNFbXB0eSgpIHx8IHRoaXMuX2dlb21bMV0uaXNFbXB0eSgpKSB7IHJldHVybiAwLjAgfVxuICB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpO1xuICByZXR1cm4gdGhpcy5fbWluRGlzdGFuY2Vcbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5jb21wdXRlTWluRGlzdGFuY2VMaW5lcyA9IGZ1bmN0aW9uIGNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzIChsaW5lczAsIGxpbmVzMSwgbG9jR2VvbSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMwLnNpemUoKTsgaSsrKSB7XG4gICAgdmFyIGxpbmUwID0gbGluZXMwLmdldChpKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmVzMS5zaXplKCk7IGorKykge1xuICAgICAgdmFyIGxpbmUxID0gbGluZXMxLmdldChqKTtcbiAgICAgIHRoaXMkMS5jb21wdXRlTWluRGlzdGFuY2UobGluZTAsIGxpbmUxLCBsb2NHZW9tKTtcbiAgICAgIGlmICh0aGlzJDEuX21pbkRpc3RhbmNlIDw9IHRoaXMkMS5fdGVybWluYXRlRGlzdGFuY2UpIHsgcmV0dXJuIG51bGwgfVxuICAgIH1cbiAgfVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIERpc3RhbmNlT3Bcbn07XG5EaXN0YW5jZU9wLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKGcwLCBnMSkge1xuICB2YXIgZGlzdE9wID0gbmV3IERpc3RhbmNlT3AoZzAsIGcxKTtcbiAgcmV0dXJuIGRpc3RPcC5kaXN0YW5jZSgpXG59O1xuRGlzdGFuY2VPcC5pc1dpdGhpbkRpc3RhbmNlID0gZnVuY3Rpb24gaXNXaXRoaW5EaXN0YW5jZSAoZzAsIGcxLCBkaXN0YW5jZSkge1xuICB2YXIgZGlzdE9wID0gbmV3IERpc3RhbmNlT3AoZzAsIGcxLCBkaXN0YW5jZSk7XG4gIHJldHVybiBkaXN0T3AuZGlzdGFuY2UoKSA8PSBkaXN0YW5jZVxufTtcbkRpc3RhbmNlT3AubmVhcmVzdFBvaW50cyA9IGZ1bmN0aW9uIG5lYXJlc3RQb2ludHMgKGcwLCBnMSkge1xuICB2YXIgZGlzdE9wID0gbmV3IERpc3RhbmNlT3AoZzAsIGcxKTtcbiAgcmV0dXJuIGRpc3RPcC5uZWFyZXN0UG9pbnRzKClcbn07XG5cbnZhciBQb2ludFBhaXJEaXN0YW5jZSQyID0gZnVuY3Rpb24gUG9pbnRQYWlyRGlzdGFuY2UgKCkge1xuICB0aGlzLl9wdCA9IFtuZXcgQ29vcmRpbmF0ZSgpLCBuZXcgQ29vcmRpbmF0ZSgpXTtcbiAgdGhpcy5fZGlzdGFuY2UgPSBEb3VibGUuTmFOO1xuICB0aGlzLl9pc051bGwgPSB0cnVlO1xufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICByZXR1cm4gdGhpcy5fcHRcbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge1xuICByZXR1cm4gdGhpcy5fcHRbaV1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5zZXRNaW5pbXVtID0gZnVuY3Rpb24gc2V0TWluaW11bSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHB0RGlzdCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldE1pbmltdW0ocHREaXN0Ll9wdFswXSwgcHREaXN0Ll9wdFsxXSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuX2lzTnVsbCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKHAwLCBwMSk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YXIgZGlzdCA9IHAwLmRpc3RhbmNlKHAxKTtcbiAgICBpZiAoZGlzdCA8IHRoaXMuX2Rpc3RhbmNlKSB7IHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEsIGRpc3QpOyB9XG4gIH1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gaW5pdGlhbGl6ZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5faXNOdWxsID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHAwKTtcbiAgICB0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKHAxKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IHAwLmRpc3RhbmNlKHAxKTtcbiAgICB0aGlzLl9pc051bGwgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIHAwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUocDAkMSk7XG4gICAgdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShwMSQxKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIHRoaXMuX2lzTnVsbCA9IGZhbHNlO1xuICB9XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKHRoaXMuX3B0WzBdLCB0aGlzLl9wdFsxXSlcbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlXG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUuc2V0TWF4aW11bSA9IGZ1bmN0aW9uIHNldE1heGltdW0gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwdERpc3QgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRNYXhpbXVtKHB0RGlzdC5fcHRbMF0sIHB0RGlzdC5fcHRbMV0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLl9pc051bGwpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdmFyIGRpc3QgPSBwMC5kaXN0YW5jZShwMSk7XG4gICAgaWYgKGRpc3QgPiB0aGlzLl9kaXN0YW5jZSkgeyB0aGlzLmluaXRpYWxpemUocDAsIHAxLCBkaXN0KTsgfVxuICB9XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9pbnRQYWlyRGlzdGFuY2UkMlxufTtcblxudmFyIERpc3RhbmNlVG9Qb2ludCA9IGZ1bmN0aW9uIERpc3RhbmNlVG9Qb2ludCAoKSB7fTtcblxuRGlzdGFuY2VUb1BvaW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRGlzdGFuY2VUb1BvaW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIERpc3RhbmNlVG9Qb2ludFxufTtcbkRpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlRGlzdGFuY2UgKCkge1xuICBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UkMiAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVN0cmluZyAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBsaW5lID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHREaXN0ID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciB0ZW1wU2VnbWVudCA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICAgIHZhciBjb29yZHMgPSBsaW5lLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB0ZW1wU2VnbWVudC5zZXRDb29yZGluYXRlcyhjb29yZHNbaV0sIGNvb3Jkc1tpICsgMV0pO1xuICAgICAgdmFyIGNsb3Nlc3RQdCA9IHRlbXBTZWdtZW50LmNsb3Nlc3RQb2ludChwdCk7XG4gICAgICBwdERpc3Quc2V0TWluaW11bShjbG9zZXN0UHQsIHB0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UkMiAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUG9seWdvbiAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBwb2x5ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QkMSA9IGFyZ3VtZW50c1syXTtcbiAgICBEaXN0YW5jZVRvUG9pbnQuY29tcHV0ZURpc3RhbmNlKHBvbHkuZ2V0RXh0ZXJpb3JSaW5nKCksIHB0JDEsIHB0RGlzdCQxKTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb2x5LmdldE51bUludGVyaW9yUmluZygpOyBpJDErKykge1xuICAgICAgRGlzdGFuY2VUb1BvaW50LmNvbXB1dGVEaXN0YW5jZShwb2x5LmdldEludGVyaW9yUmluZ04oaSQxKSwgcHQkMSwgcHREaXN0JDEpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSQyICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQyID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QkMiA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoZ2VvbSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICAgIERpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UoZ2VvbSwgcHQkMiwgcHREaXN0JDIpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICAgIERpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UoZ2VvbSwgcHQkMiwgcHREaXN0JDIpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgICAgdmFyIGdjID0gZ2VvbTtcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGdjLmdldE51bUdlb21ldHJpZXMoKTsgaSQyKyspIHtcbiAgICAgICAgdmFyIGcgPSBnYy5nZXRHZW9tZXRyeU4oaSQyKTtcbiAgICAgICAgRGlzdGFuY2VUb1BvaW50LmNvbXB1dGVEaXN0YW5jZShnLCBwdCQyLCBwdERpc3QkMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHB0RGlzdCQyLnNldE1pbmltdW0oZ2VvbS5nZXRDb29yZGluYXRlKCksIHB0JDIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSQyICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU2VnbWVudCAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBzZWdtZW50ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQzID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QkMyA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgY2xvc2VzdFB0JDEgPSBzZWdtZW50LmNsb3Nlc3RQb2ludChwdCQzKTtcbiAgICBwdERpc3QkMy5zZXRNaW5pbXVtKGNsb3Nlc3RQdCQxLCBwdCQzKTtcbiAgfVxufTtcblxudmFyIERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UgPSBmdW5jdGlvbiBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlICgpIHtcbiAgdGhpcy5fZzAgPSBudWxsO1xuICB0aGlzLl9nMSA9IG51bGw7XG4gIHRoaXMuX3B0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSQyKCk7XG4gIHRoaXMuX2RlbnNpZnlGcmFjID0gMC4wO1xuICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gIHZhciBnMSA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fZzAgPSBnMDtcbiAgdGhpcy5fZzEgPSBnMTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzkgPSB7IE1heFBvaW50RGlzdGFuY2VGaWx0ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0RGlzdC5nZXRDb29yZGluYXRlcygpXG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5wcm90b3R5cGUuc2V0RGVuc2lmeUZyYWN0aW9uID0gZnVuY3Rpb24gc2V0RGVuc2lmeUZyYWN0aW9uIChkZW5zaWZ5RnJhYykge1xuICBpZiAoZGVuc2lmeUZyYWMgPiAxLjAgfHwgZGVuc2lmeUZyYWMgPD0gMC4wKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0ZyYWN0aW9uIGlzIG5vdCBpbiByYW5nZSAoMC4wIC0gMS4wXScpIH1cbiAgdGhpcy5fZGVuc2lmeUZyYWMgPSBkZW5zaWZ5RnJhYztcbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5jb21wdXRlID0gZnVuY3Rpb24gY29tcHV0ZSAoZzAsIGcxKSB7XG4gIHRoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UoZzAsIGcxLCB0aGlzLl9wdERpc3QpO1xuICB0aGlzLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlKGcxLCBnMCwgdGhpcy5fcHREaXN0KTtcbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlICgpIHtcbiAgdGhpcy5jb21wdXRlKHRoaXMuX2cwLCB0aGlzLl9nMSk7XG4gIHJldHVybiB0aGlzLl9wdERpc3QuZ2V0RGlzdGFuY2UoKVxufTtcbkRpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UucHJvdG90eXBlLmNvbXB1dGVPcmllbnRlZERpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UgKGRpc2NyZXRlR2VvbSwgZ2VvbSwgcHREaXN0KSB7XG4gIHZhciBkaXN0RmlsdGVyID0gbmV3IE1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMShnZW9tKTtcbiAgZGlzY3JldGVHZW9tLmFwcGx5KGRpc3RGaWx0ZXIpO1xuICBwdERpc3Quc2V0TWF4aW11bShkaXN0RmlsdGVyLmdldE1heFBvaW50RGlzdGFuY2UoKSk7XG4gIGlmICh0aGlzLl9kZW5zaWZ5RnJhYyA+IDApIHtcbiAgICB2YXIgZnJhY0ZpbHRlciA9IG5ldyBNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIoZ2VvbSwgdGhpcy5fZGVuc2lmeUZyYWMpO1xuICAgIGRpc2NyZXRlR2VvbS5hcHBseShmcmFjRmlsdGVyKTtcbiAgICBwdERpc3Quc2V0TWF4aW11bShmcmFjRmlsdGVyLmdldE1heFBvaW50RGlzdGFuY2UoKSk7XG4gIH1cbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5vcmllbnRlZERpc3RhbmNlID0gZnVuY3Rpb24gb3JpZW50ZWREaXN0YW5jZSAoKSB7XG4gIHRoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UodGhpcy5fZzAsIHRoaXMuX2cxLCB0aGlzLl9wdERpc3QpO1xuICByZXR1cm4gdGhpcy5fcHREaXN0LmdldERpc3RhbmNlKClcbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlXG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBkaXN0ID0gbmV3IERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UoZzAsIGcxKTtcbiAgICByZXR1cm4gZGlzdC5kaXN0YW5jZSgpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBkZW5zaWZ5RnJhYyA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgZGlzdCQxID0gbmV3IERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UoZzAkMSwgZzEkMSk7XG4gICAgZGlzdCQxLnNldERlbnNpZnlGcmFjdGlvbihkZW5zaWZ5RnJhYyk7XG4gICAgcmV0dXJuIGRpc3QkMS5kaXN0YW5jZSgpXG4gIH1cbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzkuTWF4UG9pbnREaXN0YW5jZUZpbHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXhQb2ludERpc3RhbmNlRmlsdGVyJDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQzOS5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLCBzdGF0aWNBY2Nlc3NvcnMkMzkgKTtcblxudmFyIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMSA9IGZ1bmN0aW9uIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIgKCkge1xuICB0aGlzLl9tYXhQdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UkMigpO1xuICB0aGlzLl9taW5QdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UkMigpO1xuICB0aGlzLl9ldWNsaWRlYW5EaXN0ID0gbmV3IERpc3RhbmNlVG9Qb2ludCgpO1xuICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2dlb20gPSBnZW9tO1xufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChwdCkge1xuICB0aGlzLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpO1xuICBEaXN0YW5jZVRvUG9pbnQuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sIHB0LCB0aGlzLl9taW5QdERpc3QpO1xuICB0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bSh0aGlzLl9taW5QdERpc3QpO1xufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMS5wcm90b3R5cGUuZ2V0TWF4UG9pbnREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldE1heFBvaW50RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4UHREaXN0XG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlciQxLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb29yZGluYXRlRmlsdGVyXVxufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNYXhQb2ludERpc3RhbmNlRmlsdGVyJDFcbn07XG5cbnZhciBNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIgPSBmdW5jdGlvbiBNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIgKCkge1xuICB0aGlzLl9tYXhQdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UkMigpO1xuICB0aGlzLl9taW5QdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UkMigpO1xuICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgdGhpcy5fbnVtU3ViU2VncyA9IDA7XG4gIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZnJhY3Rpb24gPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX2dlb20gPSBnZW9tO1xuICB0aGlzLl9udW1TdWJTZWdzID0gTWF0aC50cnVuYyhNYXRoLnJvdW5kKDEuMCAvIGZyYWN0aW9uKSk7XG59O1xuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHNlcSwgaW5kZXgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoaW5kZXggPT09IDApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgcDAgPSBzZXEuZ2V0Q29vcmRpbmF0ZShpbmRleCAtIDEpO1xuICB2YXIgcDEgPSBzZXEuZ2V0Q29vcmRpbmF0ZShpbmRleCk7XG4gIHZhciBkZWx4ID0gKHAxLnggLSBwMC54KSAvIHRoaXMuX251bVN1YlNlZ3M7XG4gIHZhciBkZWx5ID0gKHAxLnkgLSBwMC55KSAvIHRoaXMuX251bVN1YlNlZ3M7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbnVtU3ViU2VnczsgaSsrKSB7XG4gICAgdmFyIHggPSBwMC54ICsgaSAqIGRlbHg7XG4gICAgdmFyIHkgPSBwMC55ICsgaSAqIGRlbHk7XG4gICAgdmFyIHB0ID0gbmV3IENvb3JkaW5hdGUoeCwgeSk7XG4gICAgdGhpcyQxLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpO1xuICAgIERpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UodGhpcyQxLl9nZW9tLCBwdCwgdGhpcyQxLl9taW5QdERpc3QpO1xuICAgIHRoaXMkMS5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcyQxLl9taW5QdERpc3QpO1xuICB9XG59O1xuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmlzR2VvbWV0cnlDaGFuZ2VkID0gZnVuY3Rpb24gaXNHZW9tZXRyeUNoYW5nZWQgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmdldE1heFBvaW50RGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRNYXhQb2ludERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuX21heFB0RGlzdFxufTtcbk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyXVxufTtcbk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXJcbn07XG5cbnZhciBCdWZmZXJEaXN0YW5jZVZhbGlkYXRvciA9IGZ1bmN0aW9uIEJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yIChpbnB1dCwgYnVmRGlzdGFuY2UsIHJlc3VsdCkge1xuICB0aGlzLl9taW5WYWxpZERpc3RhbmNlID0gbnVsbDtcbiAgdGhpcy5fbWF4VmFsaWREaXN0YW5jZSA9IG51bGw7XG4gIHRoaXMuX21pbkRpc3RhbmNlRm91bmQgPSBudWxsO1xuICB0aGlzLl9tYXhEaXN0YW5jZUZvdW5kID0gbnVsbDtcbiAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gIHRoaXMuX2Vyck1zZyA9IG51bGw7XG4gIHRoaXMuX2Vycm9yTG9jYXRpb24gPSBudWxsO1xuICB0aGlzLl9lcnJvckluZGljYXRvciA9IG51bGw7XG4gIHRoaXMuX2lucHV0ID0gaW5wdXQgfHwgbnVsbDtcbiAgdGhpcy5fYnVmRGlzdGFuY2UgPSBidWZEaXN0YW5jZSB8fCBudWxsO1xuICB0aGlzLl9yZXN1bHQgPSByZXN1bHQgfHwgbnVsbDtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzcgPSB7IFZFUkJPU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTUFYX0RJU1RBTkNFX0RJRkZfRlJBQzogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrTWF4aW11bURpc3RhbmNlID0gZnVuY3Rpb24gY2hlY2tNYXhpbXVtRGlzdGFuY2UgKGlucHV0LCBidWZDdXJ2ZSwgbWF4RGlzdCkge1xuICB2YXIgaGF1cyA9IG5ldyBEaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlKGJ1ZkN1cnZlLCBpbnB1dCk7XG4gIGhhdXMuc2V0RGVuc2lmeUZyYWN0aW9uKDAuMjUpO1xuICB0aGlzLl9tYXhEaXN0YW5jZUZvdW5kID0gaGF1cy5vcmllbnRlZERpc3RhbmNlKCk7XG4gIGlmICh0aGlzLl9tYXhEaXN0YW5jZUZvdW5kID4gbWF4RGlzdCkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgcHRzID0gaGF1cy5nZXRDb29yZGluYXRlcygpO1xuICAgIHRoaXMuX2Vycm9yTG9jYXRpb24gPSBwdHNbMV07XG4gICAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSBpbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhwdHMpO1xuICAgIHRoaXMuX2Vyck1zZyA9ICdEaXN0YW5jZSBiZXR3ZWVuIGJ1ZmZlciBjdXJ2ZSBhbmQgaW5wdXQgaXMgdG9vIGxhcmdlICgnICsgdGhpcy5fbWF4RGlzdGFuY2VGb3VuZCArICcgYXQgJyArIFdLVFdyaXRlci50b0xpbmVTdHJpbmcocHRzWzBdLCBwdHNbMV0pICsgJyknO1xuICB9XG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkICgpIHtcbiAgdmFyIHBvc0Rpc3RhbmNlID0gTWF0aC5hYnModGhpcy5fYnVmRGlzdGFuY2UpO1xuICB2YXIgZGlzdERlbHRhID0gQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IuTUFYX0RJU1RBTkNFX0RJRkZfRlJBQyAqIHBvc0Rpc3RhbmNlO1xuICB0aGlzLl9taW5WYWxpZERpc3RhbmNlID0gcG9zRGlzdGFuY2UgLSBkaXN0RGVsdGE7XG4gIHRoaXMuX21heFZhbGlkRGlzdGFuY2UgPSBwb3NEaXN0YW5jZSArIGRpc3REZWx0YTtcbiAgaWYgKHRoaXMuX2lucHV0LmlzRW1wdHkoKSB8fCB0aGlzLl9yZXN1bHQuaXNFbXB0eSgpKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHRoaXMuX2J1ZkRpc3RhbmNlID4gMC4wKSB7XG4gICAgdGhpcy5jaGVja1Bvc2l0aXZlVmFsaWQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmNoZWNrTmVnYXRpdmVWYWxpZCgpO1xuICB9XG4gIGlmIChCdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5WRVJCT1NFKSB7XG4gICAgU3lzdGVtLm91dC5wcmludGxuKCdNaW4gRGlzdD0gJyArIHRoaXMuX21pbkRpc3RhbmNlRm91bmQgKyAnICBlcnI9ICcgKyAoMS4wIC0gdGhpcy5fbWluRGlzdGFuY2VGb3VuZCAvIHRoaXMuX2J1ZkRpc3RhbmNlKSArICcgIE1heCBEaXN0PSAnICsgdGhpcy5fbWF4RGlzdGFuY2VGb3VuZCArICcgIGVycj0gJyArICh0aGlzLl9tYXhEaXN0YW5jZUZvdW5kIC8gdGhpcy5fYnVmRGlzdGFuY2UgLSAxLjApKTtcbiAgfVxuICByZXR1cm4gdGhpcy5faXNWYWxpZFxufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja05lZ2F0aXZlVmFsaWQgPSBmdW5jdGlvbiBjaGVja05lZ2F0aXZlVmFsaWQgKCkge1xuICBpZiAoISh0aGlzLl9pbnB1dCBpbnN0YW5jZW9mIFBvbHlnb24gfHwgdGhpcy5faW5wdXQgaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24gfHwgdGhpcy5faW5wdXQgaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2YXIgaW5wdXRDdXJ2ZSA9IHRoaXMuZ2V0UG9seWdvbkxpbmVzKHRoaXMuX2lucHV0KTtcbiAgdGhpcy5jaGVja01pbmltdW1EaXN0YW5jZShpbnB1dEN1cnZlLCB0aGlzLl9yZXN1bHQsIHRoaXMuX21pblZhbGlkRGlzdGFuY2UpO1xuICBpZiAoIXRoaXMuX2lzVmFsaWQpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLmNoZWNrTWF4aW11bURpc3RhbmNlKGlucHV0Q3VydmUsIHRoaXMuX3Jlc3VsdCwgdGhpcy5fbWF4VmFsaWREaXN0YW5jZSk7XG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmdldEVycm9ySW5kaWNhdG9yID0gZnVuY3Rpb24gZ2V0RXJyb3JJbmRpY2F0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fZXJyb3JJbmRpY2F0b3Jcbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tNaW5pbXVtRGlzdGFuY2UgPSBmdW5jdGlvbiBjaGVja01pbmltdW1EaXN0YW5jZSAoZzEsIGcyLCBtaW5EaXN0KSB7XG4gIHZhciBkaXN0T3AgPSBuZXcgRGlzdGFuY2VPcChnMSwgZzIsIG1pbkRpc3QpO1xuICB0aGlzLl9taW5EaXN0YW5jZUZvdW5kID0gZGlzdE9wLmRpc3RhbmNlKCk7XG4gIGlmICh0aGlzLl9taW5EaXN0YW5jZUZvdW5kIDwgbWluRGlzdCkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgcHRzID0gZGlzdE9wLm5lYXJlc3RQb2ludHMoKTtcbiAgICB0aGlzLl9lcnJvckxvY2F0aW9uID0gZGlzdE9wLm5lYXJlc3RQb2ludHMoKVsxXTtcbiAgICB0aGlzLl9lcnJvckluZGljYXRvciA9IGcxLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHB0cyk7XG4gICAgdGhpcy5fZXJyTXNnID0gJ0Rpc3RhbmNlIGJldHdlZW4gYnVmZmVyIGN1cnZlIGFuZCBpbnB1dCBpcyB0b28gc21hbGwgKCcgKyB0aGlzLl9taW5EaXN0YW5jZUZvdW5kICsgJyBhdCAnICsgV0tUV3JpdGVyLnRvTGluZVN0cmluZyhwdHNbMF0sIHB0c1sxXSkgKyAnICknO1xuICB9XG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrUG9zaXRpdmVWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrUG9zaXRpdmVWYWxpZCAoKSB7XG4gIHZhciBidWZDdXJ2ZSA9IHRoaXMuX3Jlc3VsdC5nZXRCb3VuZGFyeSgpO1xuICB0aGlzLmNoZWNrTWluaW11bURpc3RhbmNlKHRoaXMuX2lucHV0LCBidWZDdXJ2ZSwgdGhpcy5fbWluVmFsaWREaXN0YW5jZSk7XG4gIGlmICghdGhpcy5faXNWYWxpZCkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuY2hlY2tNYXhpbXVtRGlzdGFuY2UodGhpcy5faW5wdXQsIGJ1ZkN1cnZlLCB0aGlzLl9tYXhWYWxpZERpc3RhbmNlKTtcbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuZ2V0RXJyb3JMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEVycm9yTG9jYXRpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZXJyb3JMb2NhdGlvblxufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRQb2x5Z29uTGluZXMgPSBmdW5jdGlvbiBnZXRQb2x5Z29uTGluZXMgKGcpIHtcbiAgdmFyIGxpbmVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgbGluZUV4dHJhY3RlciA9IG5ldyBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIobGluZXMpO1xuICB2YXIgcG9seXMgPSBQb2x5Z29uRXh0cmFjdGVyLmdldFBvbHlnb25zKGcpO1xuICBmb3IgKHZhciBpID0gcG9seXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIHBvbHkgPSBpLm5leHQoKTtcbiAgICBwb2x5LmFwcGx5KGxpbmVFeHRyYWN0ZXIpO1xuICB9XG4gIHJldHVybiBnLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KGxpbmVzKVxufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UgKCkge1xuICByZXR1cm4gdGhpcy5fZXJyTXNnXG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJEaXN0YW5jZVZhbGlkYXRvclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzNy5WRVJCT1NFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5zdGF0aWNBY2Nlc3NvcnMkMzcuTUFYX0RJU1RBTkNFX0RJRkZfRlJBQy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwLjAxMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IsIHN0YXRpY0FjY2Vzc29ycyQzNyApO1xuXG52YXIgQnVmZmVyUmVzdWx0VmFsaWRhdG9yID0gZnVuY3Rpb24gQnVmZmVyUmVzdWx0VmFsaWRhdG9yIChpbnB1dCwgZGlzdGFuY2UsIHJlc3VsdCkge1xuICB0aGlzLl9pc1ZhbGlkID0gdHJ1ZTtcbiAgdGhpcy5fZXJyb3JNc2cgPSBudWxsO1xuICB0aGlzLl9lcnJvckxvY2F0aW9uID0gbnVsbDtcbiAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSBudWxsO1xuICB0aGlzLl9pbnB1dCA9IGlucHV0IHx8IG51bGw7XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2UgfHwgbnVsbDtcbiAgdGhpcy5fcmVzdWx0ID0gcmVzdWx0IHx8IG51bGw7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQwID0geyBWRVJCT1NFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1BWF9FTlZfRElGRl9GUkFDOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkICgpIHtcbiAgdGhpcy5jaGVja1BvbHlnb25hbCgpO1xuICBpZiAoIXRoaXMuX2lzVmFsaWQpIHsgcmV0dXJuIHRoaXMuX2lzVmFsaWQgfVxuICB0aGlzLmNoZWNrRXhwZWN0ZWRFbXB0eSgpO1xuICBpZiAoIXRoaXMuX2lzVmFsaWQpIHsgcmV0dXJuIHRoaXMuX2lzVmFsaWQgfVxuICB0aGlzLmNoZWNrRW52ZWxvcGUoKTtcbiAgaWYgKCF0aGlzLl9pc1ZhbGlkKSB7IHJldHVybiB0aGlzLl9pc1ZhbGlkIH1cbiAgdGhpcy5jaGVja0FyZWEoKTtcbiAgaWYgKCF0aGlzLl9pc1ZhbGlkKSB7IHJldHVybiB0aGlzLl9pc1ZhbGlkIH1cbiAgdGhpcy5jaGVja0Rpc3RhbmNlKCk7XG4gIHJldHVybiB0aGlzLl9pc1ZhbGlkXG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0VudmVsb3BlID0gZnVuY3Rpb24gY2hlY2tFbnZlbG9wZSAoKSB7XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8IDAuMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBwYWRkaW5nID0gdGhpcy5fZGlzdGFuY2UgKiBCdWZmZXJSZXN1bHRWYWxpZGF0b3IuTUFYX0VOVl9ESUZGX0ZSQUM7XG4gIGlmIChwYWRkaW5nID09PSAwLjApIHsgcGFkZGluZyA9IDAuMDAxOyB9XG4gIHZhciBleHBlY3RlZEVudiA9IG5ldyBFbnZlbG9wZSh0aGlzLl9pbnB1dC5nZXRFbnZlbG9wZUludGVybmFsKCkpO1xuICBleHBlY3RlZEVudi5leHBhbmRCeSh0aGlzLl9kaXN0YW5jZSk7XG4gIHZhciBidWZFbnYgPSBuZXcgRW52ZWxvcGUodGhpcy5fcmVzdWx0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk7XG4gIGJ1ZkVudi5leHBhbmRCeShwYWRkaW5nKTtcbiAgaWYgKCFidWZFbnYuY29udGFpbnMoZXhwZWN0ZWRFbnYpKSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yTXNnID0gJ0J1ZmZlciBlbnZlbG9wZSBpcyBpbmNvcnJlY3QnO1xuICAgIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gdGhpcy5faW5wdXQuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkoYnVmRW52KTtcbiAgfVxuICB0aGlzLnJlcG9ydCgnRW52ZWxvcGUnKTtcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrRGlzdGFuY2UgPSBmdW5jdGlvbiBjaGVja0Rpc3RhbmNlICgpIHtcbiAgdmFyIGRpc3RWYWxpZCA9IG5ldyBCdWZmZXJEaXN0YW5jZVZhbGlkYXRvcih0aGlzLl9pbnB1dCwgdGhpcy5fZGlzdGFuY2UsIHRoaXMuX3Jlc3VsdCk7XG4gIGlmICghZGlzdFZhbGlkLmlzVmFsaWQoKSkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lcnJvck1zZyA9IGRpc3RWYWxpZC5nZXRFcnJvck1lc3NhZ2UoKTtcbiAgICB0aGlzLl9lcnJvckxvY2F0aW9uID0gZGlzdFZhbGlkLmdldEVycm9yTG9jYXRpb24oKTtcbiAgICB0aGlzLl9lcnJvckluZGljYXRvciA9IGRpc3RWYWxpZC5nZXRFcnJvckluZGljYXRvcigpO1xuICB9XG4gIHRoaXMucmVwb3J0KCdEaXN0YW5jZScpO1xufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tBcmVhID0gZnVuY3Rpb24gY2hlY2tBcmVhICgpIHtcbiAgdmFyIGlucHV0QXJlYSA9IHRoaXMuX2lucHV0LmdldEFyZWEoKTtcbiAgdmFyIHJlc3VsdEFyZWEgPSB0aGlzLl9yZXN1bHQuZ2V0QXJlYSgpO1xuICBpZiAodGhpcy5fZGlzdGFuY2UgPiAwLjAgJiYgaW5wdXRBcmVhID4gcmVzdWx0QXJlYSkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lcnJvck1zZyA9ICdBcmVhIG9mIHBvc2l0aXZlIGJ1ZmZlciBpcyBzbWFsbGVyIHRoYW4gaW5wdXQnO1xuICAgIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gdGhpcy5fcmVzdWx0O1xuICB9XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8IDAuMCAmJiBpbnB1dEFyZWEgPCByZXN1bHRBcmVhKSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yTXNnID0gJ0FyZWEgb2YgbmVnYXRpdmUgYnVmZmVyIGlzIGxhcmdlciB0aGFuIGlucHV0JztcbiAgICB0aGlzLl9lcnJvckluZGljYXRvciA9IHRoaXMuX3Jlc3VsdDtcbiAgfVxuICB0aGlzLnJlcG9ydCgnQXJlYScpO1xufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tQb2x5Z29uYWwgPSBmdW5jdGlvbiBjaGVja1BvbHlnb25hbCAoKSB7XG4gIGlmICghKHRoaXMuX3Jlc3VsdCBpbnN0YW5jZW9mIFBvbHlnb24gfHwgdGhpcy5fcmVzdWx0IGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uKSkgeyB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7IH1cbiAgdGhpcy5fZXJyb3JNc2cgPSAnUmVzdWx0IGlzIG5vdCBwb2x5Z29uYWwnO1xuICB0aGlzLl9lcnJvckluZGljYXRvciA9IHRoaXMuX3Jlc3VsdDtcbiAgdGhpcy5yZXBvcnQoJ1BvbHlnb25hbCcpO1xufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0RXJyb3JJbmRpY2F0b3IgPSBmdW5jdGlvbiBnZXRFcnJvckluZGljYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9lcnJvckluZGljYXRvclxufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0RXJyb3JMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEVycm9yTG9jYXRpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZXJyb3JMb2NhdGlvblxufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tFeHBlY3RlZEVtcHR5ID0gZnVuY3Rpb24gY2hlY2tFeHBlY3RlZEVtcHR5ICgpIHtcbiAgaWYgKHRoaXMuX2lucHV0LmdldERpbWVuc2lvbigpID49IDIpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAodGhpcy5fZGlzdGFuY2UgPiAwLjApIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoIXRoaXMuX3Jlc3VsdC5pc0VtcHR5KCkpIHtcbiAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy5fZXJyb3JNc2cgPSAnUmVzdWx0IGlzIG5vbi1lbXB0eSc7XG4gICAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSB0aGlzLl9yZXN1bHQ7XG4gIH1cbiAgdGhpcy5yZXBvcnQoJ0V4cGVjdGVkRW1wdHknKTtcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLnJlcG9ydCA9IGZ1bmN0aW9uIHJlcG9ydCAoY2hlY2tOYW1lKSB7XG4gIGlmICghQnVmZmVyUmVzdWx0VmFsaWRhdG9yLlZFUkJPU0UpIHsgcmV0dXJuIG51bGwgfVxuICBTeXN0ZW0ub3V0LnByaW50bG4oJ0NoZWNrICcgKyBjaGVja05hbWUgKyAnOiAnICsgKHRoaXMuX2lzVmFsaWQgPyAncGFzc2VkJyA6ICdGQUlMRUQnKSk7XG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5nZXRFcnJvck1lc3NhZ2UgPSBmdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UgKCkge1xuICByZXR1cm4gdGhpcy5fZXJyb3JNc2dcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVyUmVzdWx0VmFsaWRhdG9yXG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLmlzVmFsaWRNc2cgPSBmdW5jdGlvbiBpc1ZhbGlkTXNnIChnLCBkaXN0YW5jZSwgcmVzdWx0KSB7XG4gIHZhciB2YWxpZGF0b3IgPSBuZXcgQnVmZmVyUmVzdWx0VmFsaWRhdG9yKGcsIGRpc3RhbmNlLCByZXN1bHQpO1xuICBpZiAoIXZhbGlkYXRvci5pc1ZhbGlkKCkpIHsgcmV0dXJuIHZhbGlkYXRvci5nZXRFcnJvck1lc3NhZ2UoKSB9XG4gIHJldHVybiBudWxsXG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkIChnLCBkaXN0YW5jZSwgcmVzdWx0KSB7XG4gIHZhciB2YWxpZGF0b3IgPSBuZXcgQnVmZmVyUmVzdWx0VmFsaWRhdG9yKGcsIGRpc3RhbmNlLCByZXN1bHQpO1xuICBpZiAodmFsaWRhdG9yLmlzVmFsaWQoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0MC5WRVJCT1NFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlIH07XG5zdGF0aWNBY2Nlc3NvcnMkNDAuTUFYX0VOVl9ESUZGX0ZSQUMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMC4wMTIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlclJlc3VsdFZhbGlkYXRvciwgc3RhdGljQWNjZXNzb3JzJDQwICk7XG5cbi8vIG9wZXJhdGlvbi5idWZmZXJcblxudmFyIEJhc2ljU2VnbWVudFN0cmluZyA9IGZ1bmN0aW9uIEJhc2ljU2VnbWVudFN0cmluZyAoKSB7XG4gIHRoaXMuX3B0cyA9IG51bGw7XG4gIHRoaXMuX2RhdGEgPSBudWxsO1xuICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICB2YXIgZGF0YSA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fcHRzID0gcHRzO1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICByZXR1cm4gdGhpcy5fcHRzXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9wdHMubGVuZ3RoXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge1xuICByZXR1cm4gdGhpcy5fcHRzW2ldXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0c1swXS5lcXVhbHModGhpcy5fcHRzW3RoaXMuX3B0cy5sZW5ndGggLSAxXSlcbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldFNlZ21lbnRPY3RhbnQgPSBmdW5jdGlvbiBnZXRTZWdtZW50T2N0YW50IChpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHRoaXMuX3B0cy5sZW5ndGggLSAxKSB7IHJldHVybiAtMSB9XG4gIHJldHVybiBPY3RhbnQub2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZShpbmRleCksIHRoaXMuZ2V0Q29vcmRpbmF0ZShpbmRleCArIDEpKVxufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIHNldERhdGEgKGRhdGEpIHtcbiAgdGhpcy5fZGF0YSA9IGRhdGE7XG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gZ2V0RGF0YSAoKSB7XG4gIHJldHVybiB0aGlzLl9kYXRhXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIFdLVFdyaXRlci50b0xpbmVTdHJpbmcobmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKHRoaXMuX3B0cykpXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZWdtZW50U3RyaW5nXVxufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCYXNpY1NlZ21lbnRTdHJpbmdcbn07XG5cbnZhciBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlciA9IGZ1bmN0aW9uIEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyICgpIHtcbiAgdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMgPSBmYWxzZTtcbiAgdGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seSA9IGZhbHNlO1xuICB0aGlzLl9saSA9IG51bGw7XG4gIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uID0gbnVsbDtcbiAgdGhpcy5faW50U2VnbWVudHMgPSBudWxsO1xuICB0aGlzLl9pbnRlcnNlY3Rpb25zID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9pbnRlcnNlY3Rpb25Db3VudCA9IDA7XG4gIHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zID0gdHJ1ZTtcbiAgdmFyIGxpID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9saSA9IGxpO1xuICB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiA9IG51bGw7XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmdldEludGVyaW9ySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25cbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuc2V0Q2hlY2tFbmRTZWdtZW50c09ubHkgPSBmdW5jdGlvbiBzZXRDaGVja0VuZFNlZ21lbnRzT25seSAoaXNDaGVja0VuZFNlZ21lbnRzT25seSkge1xuICB0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5ID0gaXNDaGVja0VuZFNlZ21lbnRzT25seTtcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW9uU2VnbWVudHMgPSBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25TZWdtZW50cyAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnRTZWdtZW50c1xufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uIGNvdW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbkNvdW50XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmdldEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25zICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbnNcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBzZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyAoZmluZEFsbEludGVyc2VjdGlvbnMpIHtcbiAgdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMgPSBmaW5kQWxsSW50ZXJzZWN0aW9ucztcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuc2V0S2VlcEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBzZXRLZWVwSW50ZXJzZWN0aW9ucyAoa2VlcEludGVyc2VjdGlvbnMpIHtcbiAgdGhpcy5fa2VlcEludGVyc2VjdGlvbnMgPSBrZWVwSW50ZXJzZWN0aW9ucztcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUucHJvY2Vzc0ludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBwcm9jZXNzSW50ZXJzZWN0aW9ucyAoZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkge1xuICBpZiAoIXRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zICYmIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZTAgPT09IGUxICYmIHNlZ0luZGV4MCA9PT0gc2VnSW5kZXgxKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKHRoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHkpIHtcbiAgICB2YXIgaXNFbmRTZWdQcmVzZW50ID0gdGhpcy5pc0VuZFNlZ21lbnQoZTAsIHNlZ0luZGV4MCkgfHwgdGhpcy5pc0VuZFNlZ21lbnQoZTEsIHNlZ0luZGV4MSk7XG4gICAgaWYgKCFpc0VuZFNlZ1ByZXNlbnQpIHsgcmV0dXJuIG51bGwgfVxuICB9XG4gIHZhciBwMDAgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MF07XG4gIHZhciBwMDEgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MCArIDFdO1xuICB2YXIgcDEwID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDFdO1xuICB2YXIgcDExID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDEgKyAxXTtcbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMDAsIHAwMSwgcDEwLCBwMTEpO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICBpZiAodGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKSB7XG4gICAgICB0aGlzLl9pbnRTZWdtZW50cyA9IG5ldyBBcnJheSg0KS5maWxsKG51bGwpO1xuICAgICAgdGhpcy5faW50U2VnbWVudHNbMF0gPSBwMDA7XG4gICAgICB0aGlzLl9pbnRTZWdtZW50c1sxXSA9IHAwMTtcbiAgICAgIHRoaXMuX2ludFNlZ21lbnRzWzJdID0gcDEwO1xuICAgICAgdGhpcy5faW50U2VnbWVudHNbM10gPSBwMTE7XG4gICAgICB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiA9IHRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKTtcbiAgICAgIGlmICh0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucykgeyB0aGlzLl9pbnRlcnNlY3Rpb25zLmFkZCh0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbik7IH1cbiAgICAgIHRoaXMuX2ludGVyc2VjdGlvbkNvdW50Kys7XG4gICAgfVxuICB9XG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmlzRW5kU2VnbWVudCA9IGZ1bmN0aW9uIGlzRW5kU2VnbWVudCAoc2VnU3RyLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IDApIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoaW5kZXggPj0gc2VnU3RyLnNpemUoKSAtIDIpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuaGFzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uICE9PSBudWxsXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7XG4gIGlmICh0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucykgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb24gIT09IG51bGxcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VnbWVudEludGVyc2VjdG9yXVxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIuY3JlYXRlQWxsSW50ZXJzZWN0aW9uc0ZpbmRlciA9IGZ1bmN0aW9uIGNyZWF0ZUFsbEludGVyc2VjdGlvbnNGaW5kZXIgKGxpKSB7XG4gIHZhciBmaW5kZXIgPSBuZXcgSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIobGkpO1xuICBmaW5kZXIuc2V0RmluZEFsbEludGVyc2VjdGlvbnModHJ1ZSk7XG4gIHJldHVybiBmaW5kZXJcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5jcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXIgPSBmdW5jdGlvbiBjcmVhdGVBbnlJbnRlcnNlY3Rpb25GaW5kZXIgKGxpKSB7XG4gIHJldHVybiBuZXcgSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIobGkpXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIuY3JlYXRlSW50ZXJzZWN0aW9uQ291bnRlciA9IGZ1bmN0aW9uIGNyZWF0ZUludGVyc2VjdGlvbkNvdW50ZXIgKGxpKSB7XG4gIHZhciBmaW5kZXIgPSBuZXcgSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIobGkpO1xuICBmaW5kZXIuc2V0RmluZEFsbEludGVyc2VjdGlvbnModHJ1ZSk7XG4gIGZpbmRlci5zZXRLZWVwSW50ZXJzZWN0aW9ucyhmYWxzZSk7XG4gIHJldHVybiBmaW5kZXJcbn07XG5cbnZhciBGYXN0Tm9kaW5nVmFsaWRhdG9yID0gZnVuY3Rpb24gRmFzdE5vZGluZ1ZhbGlkYXRvciAoKSB7XG4gIHRoaXMuX2xpID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICB0aGlzLl9zZWdTdHJpbmdzID0gbnVsbDtcbiAgdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMgPSBmYWxzZTtcbiAgdGhpcy5fc2VnSW50ID0gbnVsbDtcbiAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gIHZhciBzZWdTdHJpbmdzID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9zZWdTdHJpbmdzID0gc2VnU3RyaW5ncztcbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gZXhlY3V0ZSAoKSB7XG4gIGlmICh0aGlzLl9zZWdJbnQgIT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCk7XG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbnMgKCkge1xuICByZXR1cm4gdGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvbnMoKVxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkICgpIHtcbiAgdGhpcy5leGVjdXRlKCk7XG4gIHJldHVybiB0aGlzLl9pc1ZhbGlkXG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBzZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyAoZmluZEFsbEludGVyc2VjdGlvbnMpIHtcbiAgdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMgPSBmaW5kQWxsSW50ZXJzZWN0aW9ucztcbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zICgpIHtcbiAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gIHRoaXMuX3NlZ0ludCA9IG5ldyBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlcih0aGlzLl9saSk7XG4gIHRoaXMuX3NlZ0ludC5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyk7XG4gIHZhciBub2RlciA9IG5ldyBNQ0luZGV4Tm9kZXIoKTtcbiAgbm9kZXIuc2V0U2VnbWVudEludGVyc2VjdG9yKHRoaXMuX3NlZ0ludCk7XG4gIG5vZGVyLmNvbXB1dGVOb2Rlcyh0aGlzLl9zZWdTdHJpbmdzKTtcbiAgaWYgKHRoaXMuX3NlZ0ludC5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrVmFsaWQgKCkge1xuICB0aGlzLmV4ZWN1dGUoKTtcbiAgaWYgKCF0aGlzLl9pc1ZhbGlkKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbih0aGlzLmdldEVycm9yTWVzc2FnZSgpLCB0aGlzLl9zZWdJbnQuZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb24oKSkgfVxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmdldEVycm9yTWVzc2FnZSA9IGZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZSAoKSB7XG4gIGlmICh0aGlzLl9pc1ZhbGlkKSB7IHJldHVybiAnbm8gaW50ZXJzZWN0aW9ucyBmb3VuZCcgfVxuICB2YXIgaW50U2VncyA9IHRoaXMuX3NlZ0ludC5nZXRJbnRlcnNlY3Rpb25TZWdtZW50cygpO1xuICByZXR1cm4gJ2ZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYmV0d2VlbiAnICsgV0tUV3JpdGVyLnRvTGluZVN0cmluZyhpbnRTZWdzWzBdLCBpbnRTZWdzWzFdKSArICcgYW5kICcgKyBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKGludFNlZ3NbMl0sIGludFNlZ3NbM10pXG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRmFzdE5vZGluZ1ZhbGlkYXRvclxufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IuY29tcHV0ZUludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0aW9ucyAoc2VnU3RyaW5ncykge1xuICB2YXIgbnYgPSBuZXcgRmFzdE5vZGluZ1ZhbGlkYXRvcihzZWdTdHJpbmdzKTtcbiAgbnYuc2V0RmluZEFsbEludGVyc2VjdGlvbnModHJ1ZSk7XG4gIG52LmlzVmFsaWQoKTtcbiAgcmV0dXJuIG52LmdldEludGVyc2VjdGlvbnMoKVxufTtcblxudmFyIEVkZ2VOb2RpbmdWYWxpZGF0b3IgPSBmdW5jdGlvbiBFZGdlTm9kaW5nVmFsaWRhdG9yICgpIHtcbiAgdGhpcy5fbnYgPSBudWxsO1xuICB2YXIgZWRnZXMgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX252ID0gbmV3IEZhc3ROb2RpbmdWYWxpZGF0b3IoRWRnZU5vZGluZ1ZhbGlkYXRvci50b1NlZ21lbnRTdHJpbmdzKGVkZ2VzKSk7XG59O1xuRWRnZU5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrVmFsaWQgKCkge1xuICB0aGlzLl9udi5jaGVja1ZhbGlkKCk7XG59O1xuRWRnZU5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkVkZ2VOb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZU5vZGluZ1ZhbGlkYXRvclxufTtcbkVkZ2VOb2RpbmdWYWxpZGF0b3IudG9TZWdtZW50U3RyaW5ncyA9IGZ1bmN0aW9uIHRvU2VnbWVudFN0cmluZ3MgKGVkZ2VzKSB7XG4gIHZhciBzZWdTdHJpbmdzID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gZWRnZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUgPSBpLm5leHQoKTtcbiAgICBzZWdTdHJpbmdzLmFkZChuZXcgQmFzaWNTZWdtZW50U3RyaW5nKGUuZ2V0Q29vcmRpbmF0ZXMoKSwgZSkpO1xuICB9XG4gIHJldHVybiBzZWdTdHJpbmdzXG59O1xuRWRnZU5vZGluZ1ZhbGlkYXRvci5jaGVja1ZhbGlkID0gZnVuY3Rpb24gY2hlY2tWYWxpZCAoZWRnZXMpIHtcbiAgdmFyIHZhbGlkYXRvciA9IG5ldyBFZGdlTm9kaW5nVmFsaWRhdG9yKGVkZ2VzKTtcbiAgdmFsaWRhdG9yLmNoZWNrVmFsaWQoKTtcbn07XG5cbnZhciBHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXIgPSBmdW5jdGlvbiBHZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXIgKG1hcE9wKSB7XG4gIHRoaXMuX21hcE9wID0gbWFwT3A7XG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiBtYXAgKGdjKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG1hcHBlZCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYy5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciBnID0gdGhpcyQxLl9tYXBPcC5tYXAoZ2MuZ2V0R2VvbWV0cnlOKGkpKTtcbiAgICBpZiAoIWcuaXNFbXB0eSgpKSB7IG1hcHBlZC5hZGQoZyk7IH1cbiAgfVxuICByZXR1cm4gZ2MuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihHZW9tZXRyeUZhY3RvcnkudG9HZW9tZXRyeUFycmF5KG1hcHBlZCkpXG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlclxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlci5tYXAgPSBmdW5jdGlvbiBtYXAgKGdjLCBvcCkge1xuICB2YXIgbWFwcGVyID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlcihvcCk7XG4gIHJldHVybiBtYXBwZXIubWFwKGdjKVxufTtcblxudmFyIExpbmVCdWlsZGVyID0gZnVuY3Rpb24gTGluZUJ1aWxkZXIgKCkge1xuICB0aGlzLl9vcCA9IG51bGw7XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IG51bGw7XG4gIHRoaXMuX3B0TG9jYXRvciA9IG51bGw7XG4gIHRoaXMuX2xpbmVFZGdlc0xpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX3Jlc3VsdExpbmVMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgb3AgPSBhcmd1bWVudHNbMF07XG4gIHZhciBnZW9tZXRyeUZhY3RvcnkgPSBhcmd1bWVudHNbMV07XG4gIHZhciBwdExvY2F0b3IgPSBhcmd1bWVudHNbMl07XG4gIHRoaXMuX29wID0gb3A7XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeTtcbiAgdGhpcy5fcHRMb2NhdG9yID0gcHRMb2NhdG9yO1xufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5jb2xsZWN0TGluZXMgPSBmdW5jdGlvbiBjb2xsZWN0TGluZXMgKG9wQ29kZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGl0ID0gdGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgdGhpcyQxLmNvbGxlY3RMaW5lRWRnZShkZSwgb3BDb2RlLCB0aGlzJDEuX2xpbmVFZGdlc0xpc3QpO1xuICAgIHRoaXMkMS5jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2UoZGUsIG9wQ29kZSwgdGhpcyQxLl9saW5lRWRnZXNMaXN0KTtcbiAgfVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5sYWJlbElzb2xhdGVkTGluZSA9IGZ1bmN0aW9uIGxhYmVsSXNvbGF0ZWRMaW5lIChlLCB0YXJnZXRJbmRleCkge1xuICB2YXIgbG9jID0gdGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShlLmdldENvb3JkaW5hdGUoKSwgdGhpcy5fb3AuZ2V0QXJnR2VvbWV0cnkodGFyZ2V0SW5kZXgpKTtcbiAgZS5nZXRMYWJlbCgpLnNldExvY2F0aW9uKHRhcmdldEluZGV4LCBsb2MpO1xufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIGJ1aWxkIChvcENvZGUpIHtcbiAgdGhpcy5maW5kQ292ZXJlZExpbmVFZGdlcygpO1xuICB0aGlzLmNvbGxlY3RMaW5lcyhvcENvZGUpO1xuICB0aGlzLmJ1aWxkTGluZXMob3BDb2RlKTtcbiAgcmV0dXJuIHRoaXMuX3Jlc3VsdExpbmVMaXN0XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmNvbGxlY3RMaW5lRWRnZSA9IGZ1bmN0aW9uIGNvbGxlY3RMaW5lRWRnZSAoZGUsIG9wQ29kZSwgZWRnZXMpIHtcbiAgdmFyIGxhYmVsID0gZGUuZ2V0TGFiZWwoKTtcbiAgdmFyIGUgPSBkZS5nZXRFZGdlKCk7XG4gIGlmIChkZS5pc0xpbmVFZGdlKCkpIHtcbiAgICBpZiAoIWRlLmlzVmlzaXRlZCgpICYmIE92ZXJsYXlPcC5pc1Jlc3VsdE9mT3AobGFiZWwsIG9wQ29kZSkgJiYgIWUuaXNDb3ZlcmVkKCkpIHtcbiAgICAgIGVkZ2VzLmFkZChlKTtcbiAgICAgIGRlLnNldFZpc2l0ZWRFZGdlKHRydWUpO1xuICAgIH1cbiAgfVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5maW5kQ292ZXJlZExpbmVFZGdlcyA9IGZ1bmN0aW9uIGZpbmRDb3ZlcmVkTGluZUVkZ2VzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBub2RlaXQgPSB0aGlzLl9vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgbm9kZS5nZXRFZGdlcygpLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCk7XG4gIH1cbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgZSA9IGRlLmdldEVkZ2UoKTtcbiAgICBpZiAoZGUuaXNMaW5lRWRnZSgpICYmICFlLmlzQ292ZXJlZFNldCgpKSB7XG4gICAgICB2YXIgaXNDb3ZlcmVkID0gdGhpcyQxLl9vcC5pc0NvdmVyZWRCeUEoZGUuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICAgIGUuc2V0Q292ZXJlZChpc0NvdmVyZWQpO1xuICAgIH1cbiAgfVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5sYWJlbElzb2xhdGVkTGluZXMgPSBmdW5jdGlvbiBsYWJlbElzb2xhdGVkTGluZXMgKGVkZ2VzTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGl0ID0gZWRnZXNMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgbGFiZWwgPSBlLmdldExhYmVsKCk7XG4gICAgaWYgKGUuaXNJc29sYXRlZCgpKSB7XG4gICAgICBpZiAobGFiZWwuaXNOdWxsKDApKSB7IHRoaXMkMS5sYWJlbElzb2xhdGVkTGluZShlLCAwKTsgfSBlbHNlIHsgdGhpcyQxLmxhYmVsSXNvbGF0ZWRMaW5lKGUsIDEpOyB9XG4gICAgfVxuICB9XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkTGluZXMgPSBmdW5jdGlvbiBidWlsZExpbmVzIChvcENvZGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpdCA9IHRoaXMuX2xpbmVFZGdlc0xpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIC8vIGNvbnN0IGxhYmVsID0gZS5nZXRMYWJlbCgpXG4gICAgdmFyIGxpbmUgPSB0aGlzJDEuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGUuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgdGhpcyQxLl9yZXN1bHRMaW5lTGlzdC5hZGQobGluZSk7XG4gICAgZS5zZXRJblJlc3VsdCh0cnVlKTtcbiAgfVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2UgPSBmdW5jdGlvbiBjb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2UgKGRlLCBvcENvZGUsIGVkZ2VzKSB7XG4gIHZhciBsYWJlbCA9IGRlLmdldExhYmVsKCk7XG4gIGlmIChkZS5pc0xpbmVFZGdlKCkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZGUuaXNWaXNpdGVkKCkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZGUuaXNJbnRlcmlvckFyZWFFZGdlKCkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZGUuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSkgeyByZXR1cm4gbnVsbCB9XG4gIEFzc2VydC5pc1RydWUoIShkZS5pc0luUmVzdWx0KCkgfHwgZGUuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKSB8fCAhZGUuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSk7XG4gIGlmIChPdmVybGF5T3AuaXNSZXN1bHRPZk9wKGxhYmVsLCBvcENvZGUpICYmIG9wQ29kZSA9PT0gT3ZlcmxheU9wLklOVEVSU0VDVElPTikge1xuICAgIGVkZ2VzLmFkZChkZS5nZXRFZGdlKCkpO1xuICAgIGRlLnNldFZpc2l0ZWRFZGdlKHRydWUpO1xuICB9XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBMaW5lQnVpbGRlclxufTtcblxudmFyIFBvaW50QnVpbGRlciA9IGZ1bmN0aW9uIFBvaW50QnVpbGRlciAoKSB7XG4gIHRoaXMuX29wID0gbnVsbDtcbiAgdGhpcy5fZ2VvbWV0cnlGYWN0b3J5ID0gbnVsbDtcbiAgdGhpcy5fcmVzdWx0UG9pbnRMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgb3AgPSBhcmd1bWVudHNbMF07XG4gIHZhciBnZW9tZXRyeUZhY3RvcnkgPSBhcmd1bWVudHNbMV07XG4gIC8vIGNvbnN0IHB0TG9jYXRvciA9IGFyZ3VtZW50c1syXVxuICB0aGlzLl9vcCA9IG9wO1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBnZW9tZXRyeUZhY3Rvcnk7XG59O1xuUG9pbnRCdWlsZGVyLnByb3RvdHlwZS5maWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQgPSBmdW5jdGlvbiBmaWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQgKG4pIHtcbiAgdmFyIGNvb3JkID0gbi5nZXRDb29yZGluYXRlKCk7XG4gIGlmICghdGhpcy5fb3AuaXNDb3ZlcmVkQnlMQShjb29yZCkpIHtcbiAgICB2YXIgcHQgPSB0aGlzLl9nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoY29vcmQpO1xuICAgIHRoaXMuX3Jlc3VsdFBvaW50TGlzdC5hZGQocHQpO1xuICB9XG59O1xuUG9pbnRCdWlsZGVyLnByb3RvdHlwZS5leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzID0gZnVuY3Rpb24gZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2RlcyAob3BDb2RlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fb3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7IG5vZGVpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG4gPSBub2RlaXQubmV4dCgpO1xuICAgIGlmIChuLmlzSW5SZXN1bHQoKSkgeyBjb250aW51ZSB9XG4gICAgaWYgKG4uaXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAobi5nZXRFZGdlcygpLmdldERlZ3JlZSgpID09PSAwIHx8IG9wQ29kZSA9PT0gT3ZlcmxheU9wLklOVEVSU0VDVElPTikge1xuICAgICAgdmFyIGxhYmVsID0gbi5nZXRMYWJlbCgpO1xuICAgICAgaWYgKE92ZXJsYXlPcC5pc1Jlc3VsdE9mT3AobGFiZWwsIG9wQ29kZSkpIHtcbiAgICAgICAgdGhpcyQxLmZpbHRlckNvdmVyZWROb2RlVG9Qb2ludChuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5Qb2ludEJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gYnVpbGQgKG9wQ29kZSkge1xuICB0aGlzLmV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXMob3BDb2RlKTtcbiAgcmV0dXJuIHRoaXMuX3Jlc3VsdFBvaW50TGlzdFxufTtcblBvaW50QnVpbGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvaW50QnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2ludEJ1aWxkZXJcbn07XG5cbnZhciBHZW9tZXRyeVRyYW5zZm9ybWVyID0gZnVuY3Rpb24gR2VvbWV0cnlUcmFuc2Zvcm1lciAoKSB7XG4gIHRoaXMuX2lucHV0R2VvbSA9IG51bGw7XG4gIHRoaXMuX2ZhY3RvcnkgPSBudWxsO1xuICB0aGlzLl9wcnVuZUVtcHR5R2VvbWV0cnkgPSB0cnVlO1xuICB0aGlzLl9wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGUgPSB0cnVlO1xuICB0aGlzLl9wcmVzZXJ2ZUNvbGxlY3Rpb25zID0gZmFsc2U7XG4gIHRoaXMuX3ByZXNlcnZlVHlwZSA9IGZhbHNlO1xufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybVBvaW50ID0gZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQgKGdlb20sIHBhcmVudCkge1xuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKGdlb20uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksIGdlb20pKVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybVBvbHlnb24gPSBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2x5Z29uIChnZW9tLCBwYXJlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaXNBbGxWYWxpZExpbmVhclJpbmdzID0gdHJ1ZTtcbiAgdmFyIHNoZWxsID0gdGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKGdlb20uZ2V0RXh0ZXJpb3JSaW5nKCksIGdlb20pO1xuICBpZiAoc2hlbGwgPT09IG51bGwgfHwgIShzaGVsbCBpbnN0YW5jZW9mIExpbmVhclJpbmcpIHx8IHNoZWxsLmlzRW1wdHkoKSkgeyBpc0FsbFZhbGlkTGluZWFyUmluZ3MgPSBmYWxzZTsgfVxuICB2YXIgaG9sZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSsrKSB7XG4gICAgdmFyIGhvbGUgPSB0aGlzJDEudHJhbnNmb3JtTGluZWFyUmluZyhnZW9tLmdldEludGVyaW9yUmluZ04oaSksIGdlb20pO1xuICAgIGlmIChob2xlID09PSBudWxsIHx8IGhvbGUuaXNFbXB0eSgpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoIShob2xlIGluc3RhbmNlb2YgTGluZWFyUmluZykpIHsgaXNBbGxWYWxpZExpbmVhclJpbmdzID0gZmFsc2U7IH1cbiAgICBob2xlcy5hZGQoaG9sZSk7XG4gIH1cbiAgaWYgKGlzQWxsVmFsaWRMaW5lYXJSaW5ncykgeyByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVQb2x5Z29uKHNoZWxsLCBob2xlcy50b0FycmF5KFtdKSk7IH0gZWxzZSB7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgaWYgKHNoZWxsICE9PSBudWxsKSB7IGNvbXBvbmVudHMuYWRkKHNoZWxsKTsgfVxuICAgIGNvbXBvbmVudHMuYWRkQWxsKGhvbGVzKTtcbiAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KGNvbXBvbmVudHMpXG4gIH1cbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS5jcmVhdGVDb29yZGluYXRlU2VxdWVuY2UgPSBmdW5jdGlvbiBjcmVhdGVDb29yZGluYXRlU2VxdWVuY2UgKGNvb3Jkcykge1xuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGNvb3Jkcylcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS5nZXRJbnB1dEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0SW5wdXRHZW9tZXRyeSAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnB1dEdlb21cbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiB0cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcgKGdlb20sIHBhcmVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB0cmFuc0dlb21MaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgdHJhbnNmb3JtR2VvbSA9IHRoaXMkMS50cmFuc2Zvcm1MaW5lU3RyaW5nKGdlb20uZ2V0R2VvbWV0cnlOKGkpLCBnZW9tKTtcbiAgICBpZiAodHJhbnNmb3JtR2VvbSA9PT0gbnVsbCkgeyBjb250aW51ZSB9XG4gICAgaWYgKHRyYW5zZm9ybUdlb20uaXNFbXB0eSgpKSB7IGNvbnRpbnVlIH1cbiAgICB0cmFuc0dlb21MaXN0LmFkZCh0cmFuc2Zvcm1HZW9tKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHRyYW5zR2VvbUxpc3QpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Db29yZGluYXRlcyAoY29vcmRzLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHRoaXMuY29weShjb29yZHMpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtTGluZVN0cmluZyA9IGZ1bmN0aW9uIHRyYW5zZm9ybUxpbmVTdHJpbmcgKGdlb20sIHBhcmVudCkge1xuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXMoZ2VvbS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSwgZ2VvbSkpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtTXVsdGlQb2ludCA9IGZ1bmN0aW9uIHRyYW5zZm9ybU11bHRpUG9pbnQgKGdlb20sIHBhcmVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB0cmFuc0dlb21MaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgdHJhbnNmb3JtR2VvbSA9IHRoaXMkMS50cmFuc2Zvcm1Qb2ludChnZW9tLmdldEdlb21ldHJ5TihpKSwgZ2VvbSk7XG4gICAgaWYgKHRyYW5zZm9ybUdlb20gPT09IG51bGwpIHsgY29udGludWUgfVxuICAgIGlmICh0cmFuc2Zvcm1HZW9tLmlzRW1wdHkoKSkgeyBjb250aW51ZSB9XG4gICAgdHJhbnNHZW9tTGlzdC5hZGQodHJhbnNmb3JtR2VvbSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0cmFuc0dlb21MaXN0KVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybU11bHRpUG9seWdvbiA9IGZ1bmN0aW9uIHRyYW5zZm9ybU11bHRpUG9seWdvbiAoZ2VvbSwgcGFyZW50KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHRyYW5zR2VvbUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciB0cmFuc2Zvcm1HZW9tID0gdGhpcyQxLnRyYW5zZm9ybVBvbHlnb24oZ2VvbS5nZXRHZW9tZXRyeU4oaSksIGdlb20pO1xuICAgIGlmICh0cmFuc2Zvcm1HZW9tID09PSBudWxsKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAodHJhbnNmb3JtR2VvbS5pc0VtcHR5KCkpIHsgY29udGludWUgfVxuICAgIHRyYW5zR2VvbUxpc3QuYWRkKHRyYW5zZm9ybUdlb20pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodHJhbnNHZW9tTGlzdClcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoc2VxKSB7XG4gIHJldHVybiBzZXEuY29weSgpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uID0gZnVuY3Rpb24gdHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uIChnZW9tLCBwYXJlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgdHJhbnNHZW9tTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIHRyYW5zZm9ybUdlb20gPSB0aGlzJDEudHJhbnNmb3JtKGdlb20uZ2V0R2VvbWV0cnlOKGkpKTtcbiAgICBpZiAodHJhbnNmb3JtR2VvbSA9PT0gbnVsbCkgeyBjb250aW51ZSB9XG4gICAgaWYgKHRoaXMkMS5fcHJ1bmVFbXB0eUdlb21ldHJ5ICYmIHRyYW5zZm9ybUdlb20uaXNFbXB0eSgpKSB7IGNvbnRpbnVlIH1cbiAgICB0cmFuc0dlb21MaXN0LmFkZCh0cmFuc2Zvcm1HZW9tKTtcbiAgfVxuICBpZiAodGhpcy5fcHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlKSB7IHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihHZW9tZXRyeUZhY3RvcnkudG9HZW9tZXRyeUFycmF5KHRyYW5zR2VvbUxpc3QpKSB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodHJhbnNHZW9tTGlzdClcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiB0cmFuc2Zvcm0gKGlucHV0R2VvbSkge1xuICB0aGlzLl9pbnB1dEdlb20gPSBpbnB1dEdlb207XG4gIHRoaXMuX2ZhY3RvcnkgPSBpbnB1dEdlb20uZ2V0RmFjdG9yeSgpO1xuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgUG9pbnQpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9pbnQoaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBNdWx0aVBvaW50KSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9pbnQoaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcoaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcoaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBNdWx0aUxpbmVTdHJpbmcpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlMaW5lU3RyaW5nKGlucHV0R2VvbSwgbnVsbCkgfVxuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgUG9seWdvbikgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2x5Z29uKGlucHV0R2VvbSwgbnVsbCkgfVxuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9seWdvbihpbnB1dEdlb20sIG51bGwpIH1cbiAgaWYgKGlucHV0R2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24oaW5wdXRHZW9tLCBudWxsKSB9XG4gIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1Vua25vd24gR2VvbWV0cnkgc3VidHlwZTogJyArIGlucHV0R2VvbS5nZXRDbGFzcygpLmdldE5hbWUoKSlcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1MaW5lYXJSaW5nID0gZnVuY3Rpb24gdHJhbnNmb3JtTGluZWFyUmluZyAoZ2VvbSwgcGFyZW50KSB7XG4gIHZhciBzZXEgPSB0aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKGdlb20uZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksIGdlb20pO1xuICBpZiAoc2VxID09PSBudWxsKSB7IHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobnVsbCkgfVxuICB2YXIgc2VxU2l6ZSA9IHNlcS5zaXplKCk7XG4gIGlmIChzZXFTaXplID4gMCAmJiBzZXFTaXplIDwgNCAmJiAhdGhpcy5fcHJlc2VydmVUeXBlKSB7IHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoc2VxKSB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoc2VxKVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5VHJhbnNmb3JtZXJcbn07XG5cbnZhciBMaW5lU3RyaW5nU25hcHBlciA9IGZ1bmN0aW9uIExpbmVTdHJpbmdTbmFwcGVyICgpIHtcbiAgdGhpcy5fc25hcFRvbGVyYW5jZSA9IDAuMDtcbiAgdGhpcy5fc3JjUHRzID0gbnVsbDtcbiAgdGhpcy5fc2VnID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzID0gZmFsc2U7XG4gIHRoaXMuX2lzQ2xvc2VkID0gZmFsc2U7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU3RyaW5nICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHNyY0xpbmUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNuYXBUb2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgTGluZVN0cmluZ1NuYXBwZXIuY2FsbCh0aGlzLCBzcmNMaW5lLmdldENvb3JkaW5hdGVzKCksIHNuYXBUb2xlcmFuY2UpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHNyY1B0cyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc25hcFRvbGVyYW5jZSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX3NyY1B0cyA9IHNyY1B0cztcbiAgICB0aGlzLl9pc0Nsb3NlZCA9IExpbmVTdHJpbmdTbmFwcGVyLmlzQ2xvc2VkKHNyY1B0cyk7XG4gICAgdGhpcy5fc25hcFRvbGVyYW5jZSA9IHNuYXBUb2xlcmFuY2UkMTtcbiAgfVxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5zbmFwVmVydGljZXMgPSBmdW5jdGlvbiBzbmFwVmVydGljZXMgKHNyY0Nvb3Jkcywgc25hcFB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbmQgPSB0aGlzLl9pc0Nsb3NlZCA/IHNyY0Nvb3Jkcy5zaXplKCkgLSAxIDogc3JjQ29vcmRzLnNpemUoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmQ7IGkrKykge1xuICAgIHZhciBzcmNQdCA9IHNyY0Nvb3Jkcy5nZXQoaSk7XG4gICAgdmFyIHNuYXBWZXJ0ID0gdGhpcyQxLmZpbmRTbmFwRm9yVmVydGV4KHNyY1B0LCBzbmFwUHRzKTtcbiAgICBpZiAoc25hcFZlcnQgIT09IG51bGwpIHtcbiAgICAgIHNyY0Nvb3Jkcy5zZXQoaSwgbmV3IENvb3JkaW5hdGUoc25hcFZlcnQpKTtcbiAgICAgIGlmIChpID09PSAwICYmIHRoaXMkMS5faXNDbG9zZWQpIHsgc3JjQ29vcmRzLnNldChzcmNDb29yZHMuc2l6ZSgpIC0gMSwgbmV3IENvb3JkaW5hdGUoc25hcFZlcnQpKTsgfVxuICAgIH1cbiAgfVxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5maW5kU25hcEZvclZlcnRleCA9IGZ1bmN0aW9uIGZpbmRTbmFwRm9yVmVydGV4IChwdCwgc25hcFB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc25hcFB0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwdC5lcXVhbHMyRChzbmFwUHRzW2ldKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKHB0LmRpc3RhbmNlKHNuYXBQdHNbaV0pIDwgdGhpcyQxLl9zbmFwVG9sZXJhbmNlKSB7IHJldHVybiBzbmFwUHRzW2ldIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5zbmFwVG8gPSBmdW5jdGlvbiBzbmFwVG8gKHNuYXBQdHMpIHtcbiAgdmFyIGNvb3JkTGlzdCA9IG5ldyBDb29yZGluYXRlTGlzdCh0aGlzLl9zcmNQdHMpO1xuICB0aGlzLnNuYXBWZXJ0aWNlcyhjb29yZExpc3QsIHNuYXBQdHMpO1xuICB0aGlzLnNuYXBTZWdtZW50cyhjb29yZExpc3QsIHNuYXBQdHMpO1xuICB2YXIgbmV3UHRzID0gY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7XG4gIHJldHVybiBuZXdQdHNcbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuc25hcFNlZ21lbnRzID0gZnVuY3Rpb24gc25hcFNlZ21lbnRzIChzcmNDb29yZHMsIHNuYXBQdHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoc25hcFB0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgZGlzdGluY3RQdENvdW50ID0gc25hcFB0cy5sZW5ndGg7XG4gIGlmIChzbmFwUHRzWzBdLmVxdWFsczJEKHNuYXBQdHNbc25hcFB0cy5sZW5ndGggLSAxXSkpIHsgZGlzdGluY3RQdENvdW50ID0gc25hcFB0cy5sZW5ndGggLSAxOyB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdGluY3RQdENvdW50OyBpKyspIHtcbiAgICB2YXIgc25hcFB0ID0gc25hcFB0c1tpXTtcbiAgICB2YXIgaW5kZXggPSB0aGlzJDEuZmluZFNlZ21lbnRJbmRleFRvU25hcChzbmFwUHQsIHNyY0Nvb3Jkcyk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHNyY0Nvb3Jkcy5hZGQoaW5kZXggKyAxLCBuZXcgQ29vcmRpbmF0ZShzbmFwUHQpLCBmYWxzZSk7XG4gICAgfVxuICB9XG59O1xuTGluZVN0cmluZ1NuYXBwZXIucHJvdG90eXBlLmZpbmRTZWdtZW50SW5kZXhUb1NuYXAgPSBmdW5jdGlvbiBmaW5kU2VnbWVudEluZGV4VG9TbmFwIChzbmFwUHQsIHNyY0Nvb3Jkcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBtaW5EaXN0ID0gRG91YmxlLk1BWF9WQUxVRTtcbiAgdmFyIHNuYXBJbmRleCA9IC0xO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNyY0Nvb3Jkcy5zaXplKCkgLSAxOyBpKyspIHtcbiAgICB0aGlzJDEuX3NlZy5wMCA9IHNyY0Nvb3Jkcy5nZXQoaSk7XG4gICAgdGhpcyQxLl9zZWcucDEgPSBzcmNDb29yZHMuZ2V0KGkgKyAxKTtcbiAgICBpZiAodGhpcyQxLl9zZWcucDAuZXF1YWxzMkQoc25hcFB0KSB8fCB0aGlzJDEuX3NlZy5wMS5lcXVhbHMyRChzbmFwUHQpKSB7XG4gICAgICBpZiAodGhpcyQxLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcykgeyBjb250aW51ZTsgfSBlbHNlIHsgcmV0dXJuIC0xIH1cbiAgICB9XG4gICAgdmFyIGRpc3QgPSB0aGlzJDEuX3NlZy5kaXN0YW5jZShzbmFwUHQpO1xuICAgIGlmIChkaXN0IDwgdGhpcyQxLl9zbmFwVG9sZXJhbmNlICYmIGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgIHNuYXBJbmRleCA9IGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzbmFwSW5kZXhcbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMgPSBmdW5jdGlvbiBzZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyAoYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMpIHtcbiAgdGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMgPSBhbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcztcbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExpbmVTdHJpbmdTbmFwcGVyXG59O1xuTGluZVN0cmluZ1NuYXBwZXIuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAocHRzKSB7XG4gIGlmIChwdHMubGVuZ3RoIDw9IDEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIHB0c1swXS5lcXVhbHMyRChwdHNbcHRzLmxlbmd0aCAtIDFdKVxufTtcblxudmFyIEdlb21ldHJ5U25hcHBlciA9IGZ1bmN0aW9uIEdlb21ldHJ5U25hcHBlciAoc3JjR2VvbSkge1xuICB0aGlzLl9zcmNHZW9tID0gc3JjR2VvbSB8fCBudWxsO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0MSA9IHsgU05BUF9QUkVDSVNJT05fRkFDVE9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLnNuYXBUbyA9IGZ1bmN0aW9uIHNuYXBUbyAoc25hcEdlb20sIHNuYXBUb2xlcmFuY2UpIHtcbiAgdmFyIHNuYXBQdHMgPSB0aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyhzbmFwR2VvbSk7XG4gIHZhciBzbmFwVHJhbnMgPSBuZXcgU25hcFRyYW5zZm9ybWVyKHNuYXBUb2xlcmFuY2UsIHNuYXBQdHMpO1xuICByZXR1cm4gc25hcFRyYW5zLnRyYW5zZm9ybSh0aGlzLl9zcmNHZW9tKVxufTtcbkdlb21ldHJ5U25hcHBlci5wcm90b3R5cGUuc25hcFRvU2VsZiA9IGZ1bmN0aW9uIHNuYXBUb1NlbGYgKHNuYXBUb2xlcmFuY2UsIGNsZWFuUmVzdWx0KSB7XG4gIHZhciBzbmFwUHRzID0gdGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModGhpcy5fc3JjR2VvbSk7XG4gIHZhciBzbmFwVHJhbnMgPSBuZXcgU25hcFRyYW5zZm9ybWVyKHNuYXBUb2xlcmFuY2UsIHNuYXBQdHMsIHRydWUpO1xuICB2YXIgc25hcHBlZEdlb20gPSBzbmFwVHJhbnMudHJhbnNmb3JtKHRoaXMuX3NyY0dlb20pO1xuICB2YXIgcmVzdWx0ID0gc25hcHBlZEdlb207XG4gIGlmIChjbGVhblJlc3VsdCAmJiBoYXNJbnRlcmZhY2UocmVzdWx0LCBQb2x5Z29uYWwpKSB7XG4gICAgcmVzdWx0ID0gc25hcHBlZEdlb20uYnVmZmVyKDApO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLmNvbXB1dGVTbmFwVG9sZXJhbmNlID0gZnVuY3Rpb24gY29tcHV0ZVNuYXBUb2xlcmFuY2UgKHJpbmdQdHMpIHtcbiAgdmFyIG1pblNlZ0xlbiA9IHRoaXMuY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHJpbmdQdHMpO1xuICB2YXIgc25hcFRvbCA9IG1pblNlZ0xlbiAvIDEwO1xuICByZXR1cm4gc25hcFRvbFxufTtcbkdlb21ldHJ5U25hcHBlci5wcm90b3R5cGUuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzIChnKSB7XG4gIHZhciBwdFNldCA9IG5ldyBUcmVlU2V0KCk7XG4gIHZhciBwdHMgPSBnLmdldENvb3JkaW5hdGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcHRTZXQuYWRkKHB0c1tpXSk7XG4gIH1cbiAgcmV0dXJuIHB0U2V0LnRvQXJyYXkobmV3IEFycmF5KDApLmZpbGwobnVsbCkpXG59O1xuR2VvbWV0cnlTbmFwcGVyLnByb3RvdHlwZS5jb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGggPSBmdW5jdGlvbiBjb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGggKHB0cykge1xuICB2YXIgbWluU2VnTGVuID0gRG91YmxlLk1BWF9WQUxVRTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIHNlZ0xlbiA9IHB0c1tpXS5kaXN0YW5jZShwdHNbaSArIDFdKTtcbiAgICBpZiAoc2VnTGVuIDwgbWluU2VnTGVuKSB7IG1pblNlZ0xlbiA9IHNlZ0xlbjsgfVxuICB9XG4gIHJldHVybiBtaW5TZWdMZW5cbn07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlTbmFwcGVyXG59O1xuR2VvbWV0cnlTbmFwcGVyLnNuYXAgPSBmdW5jdGlvbiBzbmFwIChnMCwgZzEsIHNuYXBUb2xlcmFuY2UpIHtcbiAgdmFyIHNuYXBHZW9tID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHZhciBzbmFwcGVyMCA9IG5ldyBHZW9tZXRyeVNuYXBwZXIoZzApO1xuICBzbmFwR2VvbVswXSA9IHNuYXBwZXIwLnNuYXBUbyhnMSwgc25hcFRvbGVyYW5jZSk7XG4gIHZhciBzbmFwcGVyMSA9IG5ldyBHZW9tZXRyeVNuYXBwZXIoZzEpO1xuICBzbmFwR2VvbVsxXSA9IHNuYXBwZXIxLnNuYXBUbyhzbmFwR2VvbVswXSwgc25hcFRvbGVyYW5jZSk7XG4gIHJldHVybiBzbmFwR2VvbVxufTtcbkdlb21ldHJ5U25hcHBlci5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UgPSBmdW5jdGlvbiBjb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzbmFwVG9sZXJhbmNlID0gR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKGcpO1xuICAgIHZhciBwbSA9IGcuZ2V0UHJlY2lzaW9uTW9kZWwoKTtcbiAgICBpZiAocG0uZ2V0VHlwZSgpID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkge1xuICAgICAgdmFyIGZpeGVkU25hcFRvbCA9IDEgLyBwbS5nZXRTY2FsZSgpICogMiAvIDEuNDE1O1xuICAgICAgaWYgKGZpeGVkU25hcFRvbCA+IHNuYXBUb2xlcmFuY2UpIHsgc25hcFRvbGVyYW5jZSA9IGZpeGVkU25hcFRvbDsgfVxuICAgIH1cbiAgICByZXR1cm4gc25hcFRvbGVyYW5jZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiBNYXRoLm1pbihHZW9tZXRyeVNuYXBwZXIuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKGcwKSwgR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShnMSkpXG4gIH1cbn07XG5HZW9tZXRyeVNuYXBwZXIuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UgPSBmdW5jdGlvbiBjb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSAoZykge1xuICB2YXIgZW52ID0gZy5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gIHZhciBtaW5EaW1lbnNpb24gPSBNYXRoLm1pbihlbnYuZ2V0SGVpZ2h0KCksIGVudi5nZXRXaWR0aCgpKTtcbiAgdmFyIHNuYXBUb2wgPSBtaW5EaW1lbnNpb24gKiBHZW9tZXRyeVNuYXBwZXIuU05BUF9QUkVDSVNJT05fRkFDVE9SO1xuICByZXR1cm4gc25hcFRvbFxufTtcbkdlb21ldHJ5U25hcHBlci5zbmFwVG9TZWxmID0gZnVuY3Rpb24gc25hcFRvU2VsZiAoZ2VvbSwgc25hcFRvbGVyYW5jZSwgY2xlYW5SZXN1bHQpIHtcbiAgdmFyIHNuYXBwZXIwID0gbmV3IEdlb21ldHJ5U25hcHBlcihnZW9tKTtcbiAgcmV0dXJuIHNuYXBwZXIwLnNuYXBUb1NlbGYoc25hcFRvbGVyYW5jZSwgY2xlYW5SZXN1bHQpXG59O1xuc3RhdGljQWNjZXNzb3JzJDQxLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxZS05IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBHZW9tZXRyeVNuYXBwZXIsIHN0YXRpY0FjY2Vzc29ycyQ0MSApO1xuXG52YXIgU25hcFRyYW5zZm9ybWVyID0gKGZ1bmN0aW9uIChHZW9tZXRyeVRyYW5zZm9ybWVyJCQxKSB7XG4gIGZ1bmN0aW9uIFNuYXBUcmFuc2Zvcm1lciAoc25hcFRvbGVyYW5jZSwgc25hcFB0cywgaXNTZWxmU25hcCkge1xuICAgIEdlb21ldHJ5VHJhbnNmb3JtZXIkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9zbmFwVG9sZXJhbmNlID0gc25hcFRvbGVyYW5jZSB8fCBudWxsO1xuICAgIHRoaXMuX3NuYXBQdHMgPSBzbmFwUHRzIHx8IG51bGw7XG4gICAgdGhpcy5faXNTZWxmU25hcCA9IChpc1NlbGZTbmFwICE9PSB1bmRlZmluZWQpID8gaXNTZWxmU25hcCA6IGZhbHNlO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeVRyYW5zZm9ybWVyJCQxICkgU25hcFRyYW5zZm9ybWVyLl9fcHJvdG9fXyA9IEdlb21ldHJ5VHJhbnNmb3JtZXIkJDE7XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeVRyYW5zZm9ybWVyJCQxICYmIEdlb21ldHJ5VHJhbnNmb3JtZXIkJDEucHJvdG90eXBlICk7XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTbmFwVHJhbnNmb3JtZXI7XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUuc25hcExpbmUgPSBmdW5jdGlvbiBzbmFwTGluZSAoc3JjUHRzLCBzbmFwUHRzKSB7XG4gICAgdmFyIHNuYXBwZXIgPSBuZXcgTGluZVN0cmluZ1NuYXBwZXIoc3JjUHRzLCB0aGlzLl9zbmFwVG9sZXJhbmNlKTtcbiAgICBzbmFwcGVyLnNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKHRoaXMuX2lzU2VsZlNuYXApO1xuICAgIHJldHVybiBzbmFwcGVyLnNuYXBUbyhzbmFwUHRzKVxuICB9O1xuICBTbmFwVHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gdHJhbnNmb3JtQ29vcmRpbmF0ZXMgKGNvb3JkcywgcGFyZW50KSB7XG4gICAgdmFyIHNyY1B0cyA9IGNvb3Jkcy50b0Nvb3JkaW5hdGVBcnJheSgpO1xuICAgIHZhciBuZXdQdHMgPSB0aGlzLnNuYXBMaW5lKHNyY1B0cywgdGhpcy5fc25hcFB0cyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShuZXdQdHMpXG4gIH07XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFNuYXBUcmFuc2Zvcm1lclxuICB9O1xuXG4gIHJldHVybiBTbmFwVHJhbnNmb3JtZXI7XG59KEdlb21ldHJ5VHJhbnNmb3JtZXIpKTtcblxudmFyIENvbW1vbkJpdHMgPSBmdW5jdGlvbiBDb21tb25CaXRzICgpIHtcbiAgdGhpcy5faXNGaXJzdCA9IHRydWU7XG4gIHRoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50ID0gNTM7XG4gIHRoaXMuX2NvbW1vbkJpdHMgPSAwO1xuICB0aGlzLl9jb21tb25TaWduRXhwID0gbnVsbDtcbn07XG5Db21tb25CaXRzLnByb3RvdHlwZS5nZXRDb21tb24gPSBmdW5jdGlvbiBnZXRDb21tb24gKCkge1xuICByZXR1cm4gRG91YmxlLmxvbmdCaXRzVG9Eb3VibGUodGhpcy5fY29tbW9uQml0cylcbn07XG5Db21tb25CaXRzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICB2YXIgbnVtQml0cyA9IERvdWJsZS5kb3VibGVUb0xvbmdCaXRzKG51bSk7XG4gIGlmICh0aGlzLl9pc0ZpcnN0KSB7XG4gICAgdGhpcy5fY29tbW9uQml0cyA9IG51bUJpdHM7XG4gICAgdGhpcy5fY29tbW9uU2lnbkV4cCA9IENvbW1vbkJpdHMuc2lnbkV4cEJpdHModGhpcy5fY29tbW9uQml0cyk7XG4gICAgdGhpcy5faXNGaXJzdCA9IGZhbHNlO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFyIG51bVNpZ25FeHAgPSBDb21tb25CaXRzLnNpZ25FeHBCaXRzKG51bUJpdHMpO1xuICBpZiAobnVtU2lnbkV4cCAhPT0gdGhpcy5fY29tbW9uU2lnbkV4cCkge1xuICAgIHRoaXMuX2NvbW1vbkJpdHMgPSAwO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQgPSBDb21tb25CaXRzLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHModGhpcy5fY29tbW9uQml0cywgbnVtQml0cyk7XG4gIHRoaXMuX2NvbW1vbkJpdHMgPSBDb21tb25CaXRzLnplcm9Mb3dlckJpdHModGhpcy5fY29tbW9uQml0cywgNjQgLSAoMTIgKyB0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudCkpO1xufTtcbkNvbW1vbkJpdHMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBiaXRzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB4ID0gRG91YmxlLmxvbmdCaXRzVG9Eb3VibGUoYml0cyk7XG4gICAgdmFyIG51bVN0ciA9IERvdWJsZS50b0JpbmFyeVN0cmluZyhiaXRzKTtcbiAgICB2YXIgcGFkU3RyID0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnICsgbnVtU3RyO1xuICAgIHZhciBiaXRTdHIgPSBwYWRTdHIuc3Vic3RyaW5nKHBhZFN0ci5sZW5ndGggLSA2NCk7XG4gICAgdmFyIHN0ciA9IGJpdFN0ci5zdWJzdHJpbmcoMCwgMSkgKyAnICAnICsgYml0U3RyLnN1YnN0cmluZygxLCAxMikgKyAnKGV4cCkgJyArIGJpdFN0ci5zdWJzdHJpbmcoMTIpICsgJyBbICcgKyB4ICsgJyBdJztcbiAgICByZXR1cm4gc3RyXG4gIH1cbn07XG5Db21tb25CaXRzLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29tbW9uQml0cy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb21tb25CaXRzXG59O1xuQ29tbW9uQml0cy5nZXRCaXQgPSBmdW5jdGlvbiBnZXRCaXQgKGJpdHMsIGkpIHtcbiAgdmFyIG1hc2sgPSAxIDw8IGk7XG4gIHJldHVybiAoYml0cyAmIG1hc2spICE9PSAwID8gMSA6IDBcbn07XG5Db21tb25CaXRzLnNpZ25FeHBCaXRzID0gZnVuY3Rpb24gc2lnbkV4cEJpdHMgKG51bSkge1xuICByZXR1cm4gbnVtID4+IDUyXG59O1xuQ29tbW9uQml0cy56ZXJvTG93ZXJCaXRzID0gZnVuY3Rpb24gemVyb0xvd2VyQml0cyAoYml0cywgbkJpdHMpIHtcbiAgdmFyIGludk1hc2sgPSAoMSA8PCBuQml0cykgLSAxO1xuICB2YXIgbWFzayA9IH5pbnZNYXNrO1xuICB2YXIgemVyb2VkID0gYml0cyAmIG1hc2s7XG4gIHJldHVybiB6ZXJvZWRcbn07XG5Db21tb25CaXRzLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHMgPSBmdW5jdGlvbiBudW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzIChudW0xLCBudW0yKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAodmFyIGkgPSA1MjsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoQ29tbW9uQml0cy5nZXRCaXQobnVtMSwgaSkgIT09IENvbW1vbkJpdHMuZ2V0Qml0KG51bTIsIGkpKSB7IHJldHVybiBjb3VudCB9XG4gICAgY291bnQrKztcbiAgfVxuICByZXR1cm4gNTJcbn07XG5cbnZhciBDb21tb25CaXRzUmVtb3ZlciA9IGZ1bmN0aW9uIENvbW1vbkJpdHNSZW1vdmVyICgpIHtcbiAgdGhpcy5fY29tbW9uQ29vcmQgPSBudWxsO1xuICB0aGlzLl9jY0ZpbHRlciA9IG5ldyBDb21tb25Db29yZGluYXRlRmlsdGVyKCk7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQyID0geyBDb21tb25Db29yZGluYXRlRmlsdGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFRyYW5zbGF0ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkNvbW1vbkJpdHNSZW1vdmVyLnByb3RvdHlwZS5hZGRDb21tb25CaXRzID0gZnVuY3Rpb24gYWRkQ29tbW9uQml0cyAoZ2VvbSkge1xuICB2YXIgdHJhbnMgPSBuZXcgVHJhbnNsYXRlcih0aGlzLl9jb21tb25Db29yZCk7XG4gIGdlb20uYXBwbHkodHJhbnMpO1xuICBnZW9tLmdlb21ldHJ5Q2hhbmdlZCgpO1xufTtcbkNvbW1vbkJpdHNSZW1vdmVyLnByb3RvdHlwZS5yZW1vdmVDb21tb25CaXRzID0gZnVuY3Rpb24gcmVtb3ZlQ29tbW9uQml0cyAoZ2VvbSkge1xuICBpZiAodGhpcy5fY29tbW9uQ29vcmQueCA9PT0gMC4wICYmIHRoaXMuX2NvbW1vbkNvb3JkLnkgPT09IDAuMCkgeyByZXR1cm4gZ2VvbSB9XG4gIHZhciBpbnZDb29yZCA9IG5ldyBDb29yZGluYXRlKHRoaXMuX2NvbW1vbkNvb3JkKTtcbiAgaW52Q29vcmQueCA9IC1pbnZDb29yZC54O1xuICBpbnZDb29yZC55ID0gLWludkNvb3JkLnk7XG4gIHZhciB0cmFucyA9IG5ldyBUcmFuc2xhdGVyKGludkNvb3JkKTtcbiAgZ2VvbS5hcHBseSh0cmFucyk7XG4gIGdlb20uZ2VvbWV0cnlDaGFuZ2VkKCk7XG4gIHJldHVybiBnZW9tXG59O1xuQ29tbW9uQml0c1JlbW92ZXIucHJvdG90eXBlLmdldENvbW1vbkNvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb21tb25Db29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbW1vbkNvb3JkXG59O1xuQ29tbW9uQml0c1JlbW92ZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZ2VvbSkge1xuICBnZW9tLmFwcGx5KHRoaXMuX2NjRmlsdGVyKTtcbiAgdGhpcy5fY29tbW9uQ29vcmQgPSB0aGlzLl9jY0ZpbHRlci5nZXRDb21tb25Db29yZGluYXRlKCk7XG59O1xuQ29tbW9uQml0c1JlbW92ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Db21tb25CaXRzUmVtb3Zlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb21tb25CaXRzUmVtb3ZlclxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0Mi5Db21tb25Db29yZGluYXRlRmlsdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbW1vbkNvb3JkaW5hdGVGaWx0ZXIgfTtcbnN0YXRpY0FjY2Vzc29ycyQ0Mi5UcmFuc2xhdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFRyYW5zbGF0ZXIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENvbW1vbkJpdHNSZW1vdmVyLCBzdGF0aWNBY2Nlc3NvcnMkNDIgKTtcblxudmFyIENvbW1vbkNvb3JkaW5hdGVGaWx0ZXIgPSBmdW5jdGlvbiBDb21tb25Db29yZGluYXRlRmlsdGVyICgpIHtcbiAgdGhpcy5fY29tbW9uQml0c1ggPSBuZXcgQ29tbW9uQml0cygpO1xuICB0aGlzLl9jb21tb25CaXRzWSA9IG5ldyBDb21tb25CaXRzKCk7XG59O1xuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChjb29yZCkge1xuICB0aGlzLl9jb21tb25CaXRzWC5hZGQoY29vcmQueCk7XG4gIHRoaXMuX2NvbW1vbkJpdHNZLmFkZChjb29yZC55KTtcbn07XG5Db21tb25Db29yZGluYXRlRmlsdGVyLnByb3RvdHlwZS5nZXRDb21tb25Db29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29tbW9uQ29vcmRpbmF0ZSAoKSB7XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9jb21tb25CaXRzWC5nZXRDb21tb24oKSwgdGhpcy5fY29tbW9uQml0c1kuZ2V0Q29tbW9uKCkpXG59O1xuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29vcmRpbmF0ZUZpbHRlcl1cbn07XG5Db21tb25Db29yZGluYXRlRmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvbW1vbkNvb3JkaW5hdGVGaWx0ZXJcbn07XG5cbnZhciBUcmFuc2xhdGVyID0gZnVuY3Rpb24gVHJhbnNsYXRlciAoKSB7XG4gIHRoaXMudHJhbnMgPSBudWxsO1xuICB2YXIgdHJhbnMgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMudHJhbnMgPSB0cmFucztcbn07XG5UcmFuc2xhdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHNlcSwgaSkge1xuICB2YXIgeHAgPSBzZXEuZ2V0T3JkaW5hdGUoaSwgMCkgKyB0aGlzLnRyYW5zLng7XG4gIHZhciB5cCA9IHNlcS5nZXRPcmRpbmF0ZShpLCAxKSArIHRoaXMudHJhbnMueTtcbiAgc2VxLnNldE9yZGluYXRlKGksIDAsIHhwKTtcbiAgc2VxLnNldE9yZGluYXRlKGksIDEsIHlwKTtcbn07XG5UcmFuc2xhdGVyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5UcmFuc2xhdGVyLnByb3RvdHlwZS5pc0dlb21ldHJ5Q2hhbmdlZCA9IGZ1bmN0aW9uIGlzR2VvbWV0cnlDaGFuZ2VkICgpIHtcbiAgcmV0dXJuIHRydWVcbn07XG5UcmFuc2xhdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXJdXG59O1xuVHJhbnNsYXRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBUcmFuc2xhdGVyXG59O1xuXG52YXIgU25hcE92ZXJsYXlPcCA9IGZ1bmN0aW9uIFNuYXBPdmVybGF5T3AgKGcxLCBnMikge1xuICB0aGlzLl9nZW9tID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHRoaXMuX3NuYXBUb2xlcmFuY2UgPSBudWxsO1xuICB0aGlzLl9jYnIgPSBudWxsO1xuICB0aGlzLl9nZW9tWzBdID0gZzE7XG4gIHRoaXMuX2dlb21bMV0gPSBnMjtcbiAgdGhpcy5jb21wdXRlU25hcFRvbGVyYW5jZSgpO1xufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLnNlbGZTbmFwID0gZnVuY3Rpb24gc2VsZlNuYXAgKGdlb20pIHtcbiAgdmFyIHNuYXBwZXIwID0gbmV3IEdlb21ldHJ5U25hcHBlcihnZW9tKTtcbiAgdmFyIHNuYXBHZW9tID0gc25hcHBlcjAuc25hcFRvKGdlb20sIHRoaXMuX3NuYXBUb2xlcmFuY2UpO1xuICByZXR1cm4gc25hcEdlb21cbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5yZW1vdmVDb21tb25CaXRzID0gZnVuY3Rpb24gcmVtb3ZlQ29tbW9uQml0cyAoZ2VvbSkge1xuICB0aGlzLl9jYnIgPSBuZXcgQ29tbW9uQml0c1JlbW92ZXIoKTtcbiAgdGhpcy5fY2JyLmFkZChnZW9tWzBdKTtcbiAgdGhpcy5fY2JyLmFkZChnZW9tWzFdKTtcbiAgdmFyIHJlbUdlb20gPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgcmVtR2VvbVswXSA9IHRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKGdlb21bMF0uY29weSgpKTtcbiAgcmVtR2VvbVsxXSA9IHRoaXMuX2Nici5yZW1vdmVDb21tb25CaXRzKGdlb21bMV0uY29weSgpKTtcbiAgcmV0dXJuIHJlbUdlb21cbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5wcmVwYXJlUmVzdWx0ID0gZnVuY3Rpb24gcHJlcGFyZVJlc3VsdCAoZ2VvbSkge1xuICB0aGlzLl9jYnIuYWRkQ29tbW9uQml0cyhnZW9tKTtcbiAgcmV0dXJuIGdlb21cbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5nZXRSZXN1bHRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldFJlc3VsdEdlb21ldHJ5IChvcENvZGUpIHtcbiAgdmFyIHByZXBHZW9tID0gdGhpcy5zbmFwKHRoaXMuX2dlb20pO1xuICB2YXIgcmVzdWx0ID0gT3ZlcmxheU9wLm92ZXJsYXlPcChwcmVwR2VvbVswXSwgcHJlcEdlb21bMV0sIG9wQ29kZSk7XG4gIHJldHVybiB0aGlzLnByZXBhcmVSZXN1bHQocmVzdWx0KVxufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLmNoZWNrVmFsaWQgPSBmdW5jdGlvbiBjaGVja1ZhbGlkIChnKSB7XG4gIGlmICghZy5pc1ZhbGlkKCkpIHtcbiAgICBTeXN0ZW0ub3V0LnByaW50bG4oJ1NuYXBwZWQgZ2VvbWV0cnkgaXMgaW52YWxpZCcpO1xuICB9XG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUuY29tcHV0ZVNuYXBUb2xlcmFuY2UgPSBmdW5jdGlvbiBjb21wdXRlU25hcFRvbGVyYW5jZSAoKSB7XG4gIHRoaXMuX3NuYXBUb2xlcmFuY2UgPSBHZW9tZXRyeVNuYXBwZXIuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHRoaXMuX2dlb21bMF0sIHRoaXMuX2dlb21bMV0pO1xufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLnNuYXAgPSBmdW5jdGlvbiBzbmFwIChnZW9tKSB7XG4gIHZhciByZW1HZW9tID0gdGhpcy5yZW1vdmVDb21tb25CaXRzKGdlb20pO1xuICB2YXIgc25hcEdlb20gPSBHZW9tZXRyeVNuYXBwZXIuc25hcChyZW1HZW9tWzBdLCByZW1HZW9tWzFdLCB0aGlzLl9zbmFwVG9sZXJhbmNlKTtcbiAgcmV0dXJuIHNuYXBHZW9tXG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU25hcE92ZXJsYXlPcFxufTtcblNuYXBPdmVybGF5T3Aub3ZlcmxheU9wID0gZnVuY3Rpb24gb3ZlcmxheU9wIChnMCwgZzEsIG9wQ29kZSkge1xuICB2YXIgb3AgPSBuZXcgU25hcE92ZXJsYXlPcChnMCwgZzEpO1xuICByZXR1cm4gb3AuZ2V0UmVzdWx0R2VvbWV0cnkob3BDb2RlKVxufTtcblNuYXBPdmVybGF5T3AudW5pb24gPSBmdW5jdGlvbiB1bmlvbiAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5VTklPTilcbn07XG5TbmFwT3ZlcmxheU9wLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5JTlRFUlNFQ1RJT04pXG59O1xuU25hcE92ZXJsYXlPcC5zeW1EaWZmZXJlbmNlID0gZnVuY3Rpb24gc3ltRGlmZmVyZW5jZSAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFKVxufTtcblNuYXBPdmVybGF5T3AuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIGRpZmZlcmVuY2UgKGcwLCBnMSkge1xuICByZXR1cm4gU25hcE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuRElGRkVSRU5DRSlcbn07XG5cbnZhciBTbmFwSWZOZWVkZWRPdmVybGF5T3AgPSBmdW5jdGlvbiBTbmFwSWZOZWVkZWRPdmVybGF5T3AgKGcxLCBnMikge1xuICB0aGlzLl9nZW9tID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHRoaXMuX2dlb21bMF0gPSBnMTtcbiAgdGhpcy5fZ2VvbVsxXSA9IGcyO1xufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5wcm90b3R5cGUuZ2V0UmVzdWx0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRSZXN1bHRHZW9tZXRyeSAob3BDb2RlKSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICB2YXIgaXNTdWNjZXNzID0gZmFsc2U7XG4gIHZhciBzYXZlZEV4Y2VwdGlvbiA9IG51bGw7XG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gT3ZlcmxheU9wLm92ZXJsYXlPcCh0aGlzLl9nZW9tWzBdLCB0aGlzLl9nZW9tWzFdLCBvcENvZGUpO1xuICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcbiAgICBpZiAoaXNWYWxpZCkgeyBpc1N1Y2Nlc3MgPSB0cnVlOyB9XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgUnVudGltZUV4Y2VwdGlvbikge1xuICAgICAgc2F2ZWRFeGNlcHRpb24gPSBleDtcbiAgICB9IGVsc2UgeyB0aHJvdyBleCB9XG4gIH0gZmluYWxseSB7fVxuICBpZiAoIWlzU3VjY2Vzcykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBTbmFwT3ZlcmxheU9wLm92ZXJsYXlPcCh0aGlzLl9nZW9tWzBdLCB0aGlzLl9nZW9tWzFdLCBvcENvZGUpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBSdW50aW1lRXhjZXB0aW9uKSB7XG4gICAgICAgIHRocm93IHNhdmVkRXhjZXB0aW9uXG4gICAgICB9IGVsc2UgeyB0aHJvdyBleCB9XG4gICAgfSBmaW5hbGx5IHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Bcbn07XG5TbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wID0gZnVuY3Rpb24gb3ZlcmxheU9wIChnMCwgZzEsIG9wQ29kZSkge1xuICB2YXIgb3AgPSBuZXcgU25hcElmTmVlZGVkT3ZlcmxheU9wKGcwLCBnMSk7XG4gIHJldHVybiBvcC5nZXRSZXN1bHRHZW9tZXRyeShvcENvZGUpXG59O1xuU25hcElmTmVlZGVkT3ZlcmxheU9wLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKGcwLCBnMSkge1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5VTklPTilcbn07XG5TbmFwSWZOZWVkZWRPdmVybGF5T3AuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChnMCwgZzEpIHtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuSU5URVJTRUNUSU9OKVxufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5zeW1EaWZmZXJlbmNlID0gZnVuY3Rpb24gc3ltRGlmZmVyZW5jZSAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcwLCBnMSwgT3ZlcmxheU9wLlNZTURJRkZFUkVOQ0UpXG59O1xuU25hcElmTmVlZGVkT3ZlcmxheU9wLmRpZmZlcmVuY2UgPSBmdW5jdGlvbiBkaWZmZXJlbmNlIChnMCwgZzEpIHtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuRElGRkVSRU5DRSlcbn07XG5cbnZhciBNb25vdG9uZUNoYWluJDIgPSBmdW5jdGlvbiBNb25vdG9uZUNoYWluICgpIHtcbiAgdGhpcy5tY2UgPSBudWxsO1xuICB0aGlzLmNoYWluSW5kZXggPSBudWxsO1xuICB2YXIgbWNlID0gYXJndW1lbnRzWzBdO1xuICB2YXIgY2hhaW5JbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5tY2UgPSBtY2U7XG4gIHRoaXMuY2hhaW5JbmRleCA9IGNoYWluSW5kZXg7XG59O1xuTW9ub3RvbmVDaGFpbiQyLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb25zIChtYywgc2kpIHtcbiAgdGhpcy5tY2UuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLmNoYWluSW5kZXgsIG1jLm1jZSwgbWMuY2hhaW5JbmRleCwgc2kpO1xufTtcbk1vbm90b25lQ2hhaW4kMi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1vbm90b25lQ2hhaW4kMi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vdG9uZUNoYWluJDJcbn07XG5cbnZhciBTd2VlcExpbmVFdmVudCA9IGZ1bmN0aW9uIFN3ZWVwTGluZUV2ZW50ICgpIHtcbiAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICB0aGlzLl94VmFsdWUgPSBudWxsO1xuICB0aGlzLl9ldmVudFR5cGUgPSBudWxsO1xuICB0aGlzLl9pbnNlcnRFdmVudCA9IG51bGw7XG4gIHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXggPSBudWxsO1xuICB0aGlzLl9vYmogPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBpbnNlcnRFdmVudCA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9ldmVudFR5cGUgPSBTd2VlcExpbmVFdmVudC5ERUxFVEU7XG4gICAgdGhpcy5feFZhbHVlID0geDtcbiAgICB0aGlzLl9pbnNlcnRFdmVudCA9IGluc2VydEV2ZW50O1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgbGFiZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHgkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgb2JqID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX2V2ZW50VHlwZSA9IFN3ZWVwTGluZUV2ZW50LklOU0VSVDtcbiAgICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMuX3hWYWx1ZSA9IHgkMTtcbiAgICB0aGlzLl9vYmogPSBvYmo7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDMgPSB7IElOU0VSVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUxFVEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5pc0RlbGV0ZSA9IGZ1bmN0aW9uIGlzRGVsZXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50VHlwZSA9PT0gU3dlZXBMaW5lRXZlbnQuREVMRVRFXG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLnNldERlbGV0ZUV2ZW50SW5kZXggPSBmdW5jdGlvbiBzZXREZWxldGVFdmVudEluZGV4IChkZWxldGVFdmVudEluZGV4KSB7XG4gIHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXggPSBkZWxldGVFdmVudEluZGV4O1xufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5nZXRPYmplY3QgPSBmdW5jdGlvbiBnZXRPYmplY3QgKCkge1xuICByZXR1cm4gdGhpcy5fb2JqXG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgcGUgPSBvO1xuICBpZiAodGhpcy5feFZhbHVlIDwgcGUuX3hWYWx1ZSkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5feFZhbHVlID4gcGUuX3hWYWx1ZSkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl9ldmVudFR5cGUgPCBwZS5fZXZlbnRUeXBlKSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9ldmVudFR5cGUgPiBwZS5fZXZlbnRUeXBlKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuZ2V0SW5zZXJ0RXZlbnQgPSBmdW5jdGlvbiBnZXRJbnNlcnRFdmVudCAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnNlcnRFdmVudFxufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5pc0luc2VydCA9IGZ1bmN0aW9uIGlzSW5zZXJ0ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50VHlwZSA9PT0gU3dlZXBMaW5lRXZlbnQuSU5TRVJUXG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmlzU2FtZUxhYmVsID0gZnVuY3Rpb24gaXNTYW1lTGFiZWwgKGV2KSB7XG4gIGlmICh0aGlzLl9sYWJlbCA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdGhpcy5fbGFiZWwgPT09IGV2Ll9sYWJlbFxufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5nZXREZWxldGVFdmVudEluZGV4ID0gZnVuY3Rpb24gZ2V0RGVsZXRlRXZlbnRJbmRleCAoKSB7XG4gIHJldHVybiB0aGlzLl9kZWxldGVFdmVudEluZGV4XG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGVdXG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU3dlZXBMaW5lRXZlbnRcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDMuSU5TRVJULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQ0My5ERUxFVEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggU3dlZXBMaW5lRXZlbnQsIHN0YXRpY0FjY2Vzc29ycyQ0MyApO1xuXG52YXIgRWRnZVNldEludGVyc2VjdG9yID0gZnVuY3Rpb24gRWRnZVNldEludGVyc2VjdG9yICgpIHt9O1xuXG5FZGdlU2V0SW50ZXJzZWN0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5FZGdlU2V0SW50ZXJzZWN0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZVNldEludGVyc2VjdG9yXG59O1xuXG52YXIgU2VnbWVudEludGVyc2VjdG9yJDIgPSBmdW5jdGlvbiBTZWdtZW50SW50ZXJzZWN0b3IgKCkge1xuICB0aGlzLl9oYXNJbnRlcnNlY3Rpb24gPSBmYWxzZTtcbiAgdGhpcy5faGFzUHJvcGVyID0gZmFsc2U7XG4gIHRoaXMuX2hhc1Byb3BlckludGVyaW9yID0gZmFsc2U7XG4gIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50ID0gbnVsbDtcbiAgdGhpcy5fbGkgPSBudWxsO1xuICB0aGlzLl9pbmNsdWRlUHJvcGVyID0gbnVsbDtcbiAgdGhpcy5fcmVjb3JkSXNvbGF0ZWQgPSBudWxsO1xuICB0aGlzLl9pc1NlbGZJbnRlcnNlY3Rpb24gPSBudWxsO1xuICB0aGlzLl9udW1JbnRlcnNlY3Rpb25zID0gMDtcbiAgdGhpcy5udW1UZXN0cyA9IDA7XG4gIHRoaXMuX2JkeU5vZGVzID0gbnVsbDtcbiAgdGhpcy5faXNEb25lID0gZmFsc2U7XG4gIHRoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQgPSBmYWxzZTtcbiAgdmFyIGxpID0gYXJndW1lbnRzWzBdO1xuICB2YXIgaW5jbHVkZVByb3BlciA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIHJlY29yZElzb2xhdGVkID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLl9saSA9IGxpO1xuICB0aGlzLl9pbmNsdWRlUHJvcGVyID0gaW5jbHVkZVByb3BlcjtcbiAgdGhpcy5fcmVjb3JkSXNvbGF0ZWQgPSByZWNvcmRJc29sYXRlZDtcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaXNUcml2aWFsSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaXNUcml2aWFsSW50ZXJzZWN0aW9uIChlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSB7XG4gIGlmIChlMCA9PT0gZTEpIHtcbiAgICBpZiAodGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkgPT09IDEpIHtcbiAgICAgIGlmIChTZWdtZW50SW50ZXJzZWN0b3IkMi5pc0FkamFjZW50U2VnbWVudHMoc2VnSW5kZXgwLCBzZWdJbmRleDEpKSB7IHJldHVybiB0cnVlIH1cbiAgICAgIGlmIChlMC5pc0Nsb3NlZCgpKSB7XG4gICAgICAgIHZhciBtYXhTZWdJbmRleCA9IGUwLmdldE51bVBvaW50cygpIC0gMTtcbiAgICAgICAgaWYgKChzZWdJbmRleDAgPT09IDAgJiYgc2VnSW5kZXgxID09PSBtYXhTZWdJbmRleCkgfHxcbiAgICAgICAgICAgIChzZWdJbmRleDEgPT09IDAgJiYgc2VnSW5kZXgwID09PSBtYXhTZWdJbmRleCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5nZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCA9IGZ1bmN0aW9uIGdldFByb3BlckludGVyc2VjdGlvblBvaW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50XG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLnNldElzRG9uZUlmUHJvcGVySW50ID0gZnVuY3Rpb24gc2V0SXNEb25lSWZQcm9wZXJJbnQgKGlzRG9uZVdoZW5Qcm9wZXJJbnQpIHtcbiAgdGhpcy5faXNEb25lV2hlblByb3BlckludCA9IGlzRG9uZVdoZW5Qcm9wZXJJbnQ7XG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzUHJvcGVySW50ZXJpb3Jcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwgPSBmdW5jdGlvbiBpc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCAobGksIGJkeU5vZGVzKSB7XG4gIGZvciAodmFyIGkgPSBiZHlOb2Rlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IGkubmV4dCgpO1xuICAgIHZhciBwdCA9IG5vZGUuZ2V0Q29vcmRpbmF0ZSgpO1xuICAgIGlmIChsaS5pc0ludGVyc2VjdGlvbihwdCkpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5oYXNQcm9wZXJJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNQcm9wZXJJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzUHJvcGVyXG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmhhc0ludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc0ludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb25cbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gaXNEb25lICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzRG9uZVxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5pc0JvdW5kYXJ5UG9pbnQgPSBmdW5jdGlvbiBpc0JvdW5kYXJ5UG9pbnQgKGxpLCBiZHlOb2Rlcykge1xuICBpZiAoYmR5Tm9kZXMgPT09IG51bGwpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKHRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwobGksIGJkeU5vZGVzWzBdKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICh0aGlzLmlzQm91bmRhcnlQb2ludEludGVybmFsKGxpLCBiZHlOb2Rlc1sxXSkpIHsgcmV0dXJuIHRydWUgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuc2V0Qm91bmRhcnlOb2RlcyA9IGZ1bmN0aW9uIHNldEJvdW5kYXJ5Tm9kZXMgKGJkeU5vZGVzMCwgYmR5Tm9kZXMxKSB7XG4gIHRoaXMuX2JkeU5vZGVzID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHRoaXMuX2JkeU5vZGVzWzBdID0gYmR5Tm9kZXMwO1xuICB0aGlzLl9iZHlOb2Rlc1sxXSA9IGJkeU5vZGVzMTtcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbnMgKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpIHtcbiAgaWYgKGUwID09PSBlMSAmJiBzZWdJbmRleDAgPT09IHNlZ0luZGV4MSkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMubnVtVGVzdHMrKztcbiAgdmFyIHAwMCA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwXTtcbiAgdmFyIHAwMSA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwICsgMV07XG4gIHZhciBwMTAgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MV07XG4gIHZhciBwMTEgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MSArIDFdO1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwMCwgcDAxLCBwMTAsIHAxMSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgIGlmICh0aGlzLl9yZWNvcmRJc29sYXRlZCkge1xuICAgICAgZTAuc2V0SXNvbGF0ZWQoZmFsc2UpO1xuICAgICAgZTEuc2V0SXNvbGF0ZWQoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLl9udW1JbnRlcnNlY3Rpb25zKys7XG4gICAgaWYgKCF0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbihlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSkge1xuICAgICAgdGhpcy5faGFzSW50ZXJzZWN0aW9uID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLl9pbmNsdWRlUHJvcGVyIHx8ICF0aGlzLl9saS5pc1Byb3BlcigpKSB7XG4gICAgICAgIGUwLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksIHNlZ0luZGV4MCwgMCk7XG4gICAgICAgIGUxLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksIHNlZ0luZGV4MSwgMSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSkge1xuICAgICAgICB0aGlzLl9wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludCA9IHRoaXMuX2xpLmdldEludGVyc2VjdGlvbigwKS5jb3B5KCk7XG4gICAgICAgIHRoaXMuX2hhc1Byb3BlciA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50KSB7XG4gICAgICAgICAgdGhpcy5faXNEb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNCb3VuZGFyeVBvaW50KHRoaXMuX2xpLCB0aGlzLl9iZHlOb2RlcykpIHsgdGhpcy5faGFzUHJvcGVySW50ZXJpb3IgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTZWdtZW50SW50ZXJzZWN0b3IkMlxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLmlzQWRqYWNlbnRTZWdtZW50cyA9IGZ1bmN0aW9uIGlzQWRqYWNlbnRTZWdtZW50cyAoaTEsIGkyKSB7XG4gIHJldHVybiBNYXRoLmFicyhpMSAtIGkyKSA9PT0gMVxufTtcblxudmFyIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IgPSAoZnVuY3Rpb24gKEVkZ2VTZXRJbnRlcnNlY3RvciQkMSkge1xuICBmdW5jdGlvbiBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yICgpIHtcbiAgICBFZGdlU2V0SW50ZXJzZWN0b3IkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmV2ZW50cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB0aGlzLm5PdmVybGFwcyA9IG51bGw7XG4gIH1cblxuICBpZiAoIEVkZ2VTZXRJbnRlcnNlY3RvciQkMSApIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IuX19wcm90b19fID0gRWRnZVNldEludGVyc2VjdG9yJCQxO1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVkZ2VTZXRJbnRlcnNlY3RvciQkMSAmJiBFZGdlU2V0SW50ZXJzZWN0b3IkJDEucHJvdG90eXBlICk7XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3RvcjtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUucHJlcGFyZUV2ZW50cyA9IGZ1bmN0aW9uIHByZXBhcmVFdmVudHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgQ29sbGVjdGlvbnMuc29ydCh0aGlzLmV2ZW50cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50cy5zaXplKCk7IGkrKykge1xuICAgICAgdmFyIGV2ID0gdGhpcyQxLmV2ZW50cy5nZXQoaSk7XG4gICAgICBpZiAoZXYuaXNEZWxldGUoKSkge1xuICAgICAgICBldi5nZXRJbnNlcnRFdmVudCgpLnNldERlbGV0ZUV2ZW50SW5kZXgoaSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb25zICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgc2kgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLm5PdmVybGFwcyA9IDA7XG4gICAgICB0aGlzLnByZXBhcmVFdmVudHMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgdmFyIGV2ID0gdGhpcyQxLmV2ZW50cy5nZXQoaSk7XG4gICAgICAgIGlmIChldi5pc0luc2VydCgpKSB7XG4gICAgICAgICAgdGhpcyQxLnByb2Nlc3NPdmVybGFwcyhpLCBldi5nZXREZWxldGVFdmVudEluZGV4KCksIGV2LCBzaSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpLmlzRG9uZSgpKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFNlZ21lbnRJbnRlcnNlY3RvciQyICYmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBMaXN0KSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBMaXN0KSkpIHtcbiAgICAgICAgdmFyIGVkZ2VzMCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGVkZ2VzMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHNpJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIHRoaXMuYWRkRWRnZXMoZWRnZXMwLCBlZGdlczApO1xuICAgICAgICB0aGlzLmFkZEVkZ2VzKGVkZ2VzMSwgZWRnZXMxKTtcbiAgICAgICAgdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhzaSQxKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Jvb2xlYW4nICYmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBMaXN0KSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBTZWdtZW50SW50ZXJzZWN0b3IkMikpIHtcbiAgICAgICAgdmFyIGVkZ2VzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgc2kkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIHRlc3RBbGxTZWdtZW50cyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgaWYgKHRlc3RBbGxTZWdtZW50cykgeyB0aGlzLmFkZEVkZ2VzKGVkZ2VzLCBudWxsKTsgfSBlbHNlIHsgdGhpcy5hZGRFZGdlcyhlZGdlcyk7IH1cbiAgICAgICAgdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhzaSQyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmFkZEVkZ2UgPSBmdW5jdGlvbiBhZGRFZGdlIChlZGdlLCBlZGdlU2V0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbWNlID0gZWRnZS5nZXRNb25vdG9uZUNoYWluRWRnZSgpO1xuICAgIHZhciBzdGFydEluZGV4ID0gbWNlLmdldFN0YXJ0SW5kZXhlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnRJbmRleC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciBtYyA9IG5ldyBNb25vdG9uZUNoYWluJDIobWNlLCBpKTtcbiAgICAgIHZhciBpbnNlcnRFdmVudCA9IG5ldyBTd2VlcExpbmVFdmVudChlZGdlU2V0LCBtY2UuZ2V0TWluWChpKSwgbWMpO1xuICAgICAgdGhpcyQxLmV2ZW50cy5hZGQoaW5zZXJ0RXZlbnQpO1xuICAgICAgdGhpcyQxLmV2ZW50cy5hZGQobmV3IFN3ZWVwTGluZUV2ZW50KG1jZS5nZXRNYXhYKGkpLCBpbnNlcnRFdmVudCkpO1xuICAgIH1cbiAgfTtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUucHJvY2Vzc092ZXJsYXBzID0gZnVuY3Rpb24gcHJvY2Vzc092ZXJsYXBzIChzdGFydCwgZW5kLCBldjAsIHNpKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbWMwID0gZXYwLmdldE9iamVjdCgpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgZXYxID0gdGhpcyQxLmV2ZW50cy5nZXQoaSk7XG4gICAgICBpZiAoZXYxLmlzSW5zZXJ0KCkpIHtcbiAgICAgICAgdmFyIG1jMSA9IGV2MS5nZXRPYmplY3QoKTtcbiAgICAgICAgaWYgKCFldjAuaXNTYW1lTGFiZWwoZXYxKSkge1xuICAgICAgICAgIG1jMC5jb21wdXRlSW50ZXJzZWN0aW9ucyhtYzEsIHNpKTtcbiAgICAgICAgICB0aGlzJDEubk92ZXJsYXBzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmFkZEVkZ2VzID0gZnVuY3Rpb24gYWRkRWRnZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBlZGdlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAodmFyIGkgPSBlZGdlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBpLm5leHQoKTtcbiAgICAgICAgdGhpcyQxLmFkZEVkZ2UoZWRnZSwgZWRnZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgZWRnZXMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBlZGdlU2V0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgZm9yICh2YXIgaSQxID0gZWRnZXMkMS5pdGVyYXRvcigpOyBpJDEuaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgZWRnZSQxID0gaSQxLm5leHQoKTtcbiAgICAgICAgdGhpcyQxLmFkZEVkZ2UoZWRnZSQxLCBlZGdlU2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3RvclxuICB9O1xuXG4gIHJldHVybiBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yO1xufShFZGdlU2V0SW50ZXJzZWN0b3IpKTtcblxudmFyIEludGVydmFsUlRyZWVOb2RlID0gZnVuY3Rpb24gSW50ZXJ2YWxSVHJlZU5vZGUgKCkge1xuICB0aGlzLl9taW4gPSBEb3VibGUuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIHRoaXMuX21heCA9IERvdWJsZS5ORUdBVElWRV9JTkZJTklUWTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDUgPSB7IE5vZGVDb21wYXJhdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5JbnRlcnZhbFJUcmVlTm9kZS5wcm90b3R5cGUuZ2V0TWluID0gZnVuY3Rpb24gZ2V0TWluICgpIHtcbiAgcmV0dXJuIHRoaXMuX21pblxufTtcbkludGVydmFsUlRyZWVOb2RlLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cyAocXVlcnlNaW4sIHF1ZXJ5TWF4KSB7XG4gIGlmICh0aGlzLl9taW4gPiBxdWVyeU1heCB8fCB0aGlzLl9tYXggPCBxdWVyeU1pbikgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkludGVydmFsUlRyZWVOb2RlLnByb3RvdHlwZS5nZXRNYXggPSBmdW5jdGlvbiBnZXRNYXggKCkge1xuICByZXR1cm4gdGhpcy5fbWF4XG59O1xuSW50ZXJ2YWxSVHJlZU5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gV0tUV3JpdGVyLnRvTGluZVN0cmluZyhuZXcgQ29vcmRpbmF0ZSh0aGlzLl9taW4sIDApLCBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9tYXgsIDApKVxufTtcbkludGVydmFsUlRyZWVOb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuSW50ZXJ2YWxSVHJlZU5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSW50ZXJ2YWxSVHJlZU5vZGVcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDUuTm9kZUNvbXBhcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTm9kZUNvbXBhcmF0b3IgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEludGVydmFsUlRyZWVOb2RlLCBzdGF0aWNBY2Nlc3NvcnMkNDUgKTtcblxudmFyIE5vZGVDb21wYXJhdG9yID0gZnVuY3Rpb24gTm9kZUNvbXBhcmF0b3IgKCkge307XG5cbk5vZGVDb21wYXJhdG9yLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAobzEsIG8yKSB7XG4gIHZhciBuMSA9IG8xO1xuICB2YXIgbjIgPSBvMjtcbiAgdmFyIG1pZDEgPSAobjEuX21pbiArIG4xLl9tYXgpIC8gMjtcbiAgdmFyIG1pZDIgPSAobjIuX21pbiArIG4yLl9tYXgpIC8gMjtcbiAgaWYgKG1pZDEgPCBtaWQyKSB7IHJldHVybiAtMSB9XG4gIGlmIChtaWQxID4gbWlkMikgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuTm9kZUNvbXBhcmF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmF0b3JdXG59O1xuTm9kZUNvbXBhcmF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9kZUNvbXBhcmF0b3Jcbn07XG5cbnZhciBJbnRlcnZhbFJUcmVlTGVhZk5vZGUgPSAoZnVuY3Rpb24gKEludGVydmFsUlRyZWVOb2RlJCQxKSB7XG4gIGZ1bmN0aW9uIEludGVydmFsUlRyZWVMZWFmTm9kZSAoKSB7XG4gICAgSW50ZXJ2YWxSVHJlZU5vZGUkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9pdGVtID0gbnVsbDtcbiAgICB2YXIgbWluID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtYXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5fbWluID0gbWluO1xuICAgIHRoaXMuX21heCA9IG1heDtcbiAgICB0aGlzLl9pdGVtID0gaXRlbTtcbiAgfVxuXG4gIGlmICggSW50ZXJ2YWxSVHJlZU5vZGUkJDEgKSBJbnRlcnZhbFJUcmVlTGVhZk5vZGUuX19wcm90b19fID0gSW50ZXJ2YWxSVHJlZU5vZGUkJDE7XG4gIEludGVydmFsUlRyZWVMZWFmTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcnZhbFJUcmVlTm9kZSQkMSAmJiBJbnRlcnZhbFJUcmVlTm9kZSQkMS5wcm90b3R5cGUgKTtcbiAgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludGVydmFsUlRyZWVMZWFmTm9kZTtcbiAgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5IChxdWVyeU1pbiwgcXVlcnlNYXgsIHZpc2l0b3IpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhxdWVyeU1pbiwgcXVlcnlNYXgpKSB7IHJldHVybiBudWxsIH1cbiAgICB2aXNpdG9yLnZpc2l0SXRlbSh0aGlzLl9pdGVtKTtcbiAgfTtcbiAgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gSW50ZXJ2YWxSVHJlZUxlYWZOb2RlXG4gIH07XG5cbiAgcmV0dXJuIEludGVydmFsUlRyZWVMZWFmTm9kZTtcbn0oSW50ZXJ2YWxSVHJlZU5vZGUpKTtcblxudmFyIEludGVydmFsUlRyZWVCcmFuY2hOb2RlID0gKGZ1bmN0aW9uIChJbnRlcnZhbFJUcmVlTm9kZSQkMSkge1xuICBmdW5jdGlvbiBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZSAoKSB7XG4gICAgSW50ZXJ2YWxSVHJlZU5vZGUkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9ub2RlMSA9IG51bGw7XG4gICAgdGhpcy5fbm9kZTIgPSBudWxsO1xuICAgIHZhciBuMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbjIgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fbm9kZTEgPSBuMTtcbiAgICB0aGlzLl9ub2RlMiA9IG4yO1xuICAgIHRoaXMuYnVpbGRFeHRlbnQodGhpcy5fbm9kZTEsIHRoaXMuX25vZGUyKTtcbiAgfVxuXG4gIGlmICggSW50ZXJ2YWxSVHJlZU5vZGUkJDEgKSBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZS5fX3Byb3RvX18gPSBJbnRlcnZhbFJUcmVlTm9kZSQkMTtcbiAgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggSW50ZXJ2YWxSVHJlZU5vZGUkJDEgJiYgSW50ZXJ2YWxSVHJlZU5vZGUkJDEucHJvdG90eXBlICk7XG4gIEludGVydmFsUlRyZWVCcmFuY2hOb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludGVydmFsUlRyZWVCcmFuY2hOb2RlO1xuICBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZS5wcm90b3R5cGUuYnVpbGRFeHRlbnQgPSBmdW5jdGlvbiBidWlsZEV4dGVudCAobjEsIG4yKSB7XG4gICAgdGhpcy5fbWluID0gTWF0aC5taW4objEuX21pbiwgbjIuX21pbik7XG4gICAgdGhpcy5fbWF4ID0gTWF0aC5tYXgobjEuX21heCwgbjIuX21heCk7XG4gIH07XG4gIEludGVydmFsUlRyZWVCcmFuY2hOb2RlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5IChxdWVyeU1pbiwgcXVlcnlNYXgsIHZpc2l0b3IpIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhxdWVyeU1pbiwgcXVlcnlNYXgpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy5fbm9kZTEgIT09IG51bGwpIHsgdGhpcy5fbm9kZTEucXVlcnkocXVlcnlNaW4sIHF1ZXJ5TWF4LCB2aXNpdG9yKTsgfVxuICAgIGlmICh0aGlzLl9ub2RlMiAhPT0gbnVsbCkgeyB0aGlzLl9ub2RlMi5xdWVyeShxdWVyeU1pbiwgcXVlcnlNYXgsIHZpc2l0b3IpOyB9XG4gIH07XG4gIEludGVydmFsUlRyZWVCcmFuY2hOb2RlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZVxuICB9O1xuXG4gIHJldHVybiBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZTtcbn0oSW50ZXJ2YWxSVHJlZU5vZGUpKTtcblxudmFyIFNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUgPSBmdW5jdGlvbiBTb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlICgpIHtcbiAgdGhpcy5fbGVhdmVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9yb290ID0gbnVsbDtcbiAgdGhpcy5fbGV2ZWwgPSAwO1xufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLmJ1aWxkVHJlZSA9IGZ1bmN0aW9uIGJ1aWxkVHJlZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgQ29sbGVjdGlvbnMuc29ydCh0aGlzLl9sZWF2ZXMsIG5ldyBJbnRlcnZhbFJUcmVlTm9kZS5Ob2RlQ29tcGFyYXRvcigpKTtcbiAgdmFyIHNyYyA9IHRoaXMuX2xlYXZlcztcbiAgdmFyIHRlbXAgPSBudWxsO1xuICB2YXIgZGVzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB0aGlzJDEuYnVpbGRMZXZlbChzcmMsIGRlc3QpO1xuICAgIGlmIChkZXN0LnNpemUoKSA9PT0gMSkgeyByZXR1cm4gZGVzdC5nZXQoMCkgfVxuICAgIHRlbXAgPSBzcmM7XG4gICAgc3JjID0gZGVzdDtcbiAgICBkZXN0ID0gdGVtcDtcbiAgfVxufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAobWluLCBtYXgsIGl0ZW0pIHtcbiAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHsgdGhyb3cgbmV3IEVycm9yKCdJbmRleCBjYW5ub3QgYmUgYWRkZWQgdG8gb25jZSBpdCBoYXMgYmVlbiBxdWVyaWVkJykgfVxuICB0aGlzLl9sZWF2ZXMuYWRkKG5ldyBJbnRlcnZhbFJUcmVlTGVhZk5vZGUobWluLCBtYXgsIGl0ZW0pKTtcbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5IChtaW4sIG1heCwgdmlzaXRvcikge1xuICB0aGlzLmluaXQoKTtcbiAgdGhpcy5fcm9vdC5xdWVyeShtaW4sIG1heCwgdmlzaXRvcik7XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuYnVpbGRSb290ID0gZnVuY3Rpb24gYnVpbGRSb290ICgpIHtcbiAgaWYgKHRoaXMuX3Jvb3QgIT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLl9yb290ID0gdGhpcy5idWlsZFRyZWUoKTtcbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5wcmludE5vZGUgPSBmdW5jdGlvbiBwcmludE5vZGUgKG5vZGUpIHtcbiAgU3lzdGVtLm91dC5wcmludGxuKFdLVFdyaXRlci50b0xpbmVTdHJpbmcobmV3IENvb3JkaW5hdGUobm9kZS5fbWluLCB0aGlzLl9sZXZlbCksIG5ldyBDb29yZGluYXRlKG5vZGUuX21heCwgdGhpcy5fbGV2ZWwpKSk7XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKCkge1xuICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuYnVpbGRSb290KCk7XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuYnVpbGRMZXZlbCA9IGZ1bmN0aW9uIGJ1aWxkTGV2ZWwgKHNyYywgZGVzdCkge1xuICB0aGlzLl9sZXZlbCsrO1xuICBkZXN0LmNsZWFyKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjLnNpemUoKTsgaSArPSAyKSB7XG4gICAgdmFyIG4xID0gc3JjLmdldChpKTtcbiAgICB2YXIgbjIgPSBpICsgMSA8IHNyYy5zaXplKCkgPyBzcmMuZ2V0KGkpIDogbnVsbDtcbiAgICBpZiAobjIgPT09IG51bGwpIHtcbiAgICAgIGRlc3QuYWRkKG4xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGUgPSBuZXcgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUoc3JjLmdldChpKSwgc3JjLmdldChpICsgMSkpO1xuICAgICAgZGVzdC5hZGQobm9kZSk7XG4gICAgfVxuICB9XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZVxufTtcblxudmFyIEFycmF5TGlzdFZpc2l0b3IgPSBmdW5jdGlvbiBBcnJheUxpc3RWaXNpdG9yICgpIHtcbiAgdGhpcy5faXRlbXMgPSBuZXcgQXJyYXlMaXN0KCk7XG59O1xuQXJyYXlMaXN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRJdGVtID0gZnVuY3Rpb24gdmlzaXRJdGVtIChpdGVtKSB7XG4gIHRoaXMuX2l0ZW1zLmFkZChpdGVtKTtcbn07XG5BcnJheUxpc3RWaXNpdG9yLnByb3RvdHlwZS5nZXRJdGVtcyA9IGZ1bmN0aW9uIGdldEl0ZW1zICgpIHtcbiAgcmV0dXJuIHRoaXMuX2l0ZW1zXG59O1xuQXJyYXlMaXN0VmlzaXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbSXRlbVZpc2l0b3JdXG59O1xuQXJyYXlMaXN0VmlzaXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBBcnJheUxpc3RWaXNpdG9yXG59O1xuXG52YXIgSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvciA9IGZ1bmN0aW9uIEluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3IgKCkge1xuICB0aGlzLl9pbmRleCA9IG51bGw7XG4gIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICBpZiAoIWhhc0ludGVyZmFjZShnLCBQb2x5Z29uYWwpKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0FyZ3VtZW50IG11c3QgYmUgUG9seWdvbmFsJykgfVxuICB0aGlzLl9pbmRleCA9IG5ldyBJbnRlcnZhbEluZGV4ZWRHZW9tZXRyeShnKTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDQgPSB7IFNlZ21lbnRWaXNpdG9yOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEludGVydmFsSW5kZXhlZEdlb21ldHJ5OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5JbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yLnByb3RvdHlwZS5sb2NhdGUgPSBmdW5jdGlvbiBsb2NhdGUgKHApIHtcbiAgdmFyIHJjYyA9IG5ldyBSYXlDcm9zc2luZ0NvdW50ZXIocCk7XG4gIHZhciB2aXNpdG9yID0gbmV3IFNlZ21lbnRWaXNpdG9yKHJjYyk7XG4gIHRoaXMuX2luZGV4LnF1ZXJ5KHAueSwgcC55LCB2aXNpdG9yKTtcbiAgcmV0dXJuIHJjYy5nZXRMb2NhdGlvbigpXG59O1xuSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbUG9pbnRPbkdlb21ldHJ5TG9jYXRvcl1cbn07XG5JbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3Jcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDQuU2VnbWVudFZpc2l0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VnbWVudFZpc2l0b3IgfTtcbnN0YXRpY0FjY2Vzc29ycyQ0NC5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBJbnRlcnZhbEluZGV4ZWRHZW9tZXRyeSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvciwgc3RhdGljQWNjZXNzb3JzJDQ0ICk7XG5cbnZhciBTZWdtZW50VmlzaXRvciA9IGZ1bmN0aW9uIFNlZ21lbnRWaXNpdG9yICgpIHtcbiAgdGhpcy5fY291bnRlciA9IG51bGw7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9jb3VudGVyID0gY291bnRlcjtcbn07XG5TZWdtZW50VmlzaXRvci5wcm90b3R5cGUudmlzaXRJdGVtID0gZnVuY3Rpb24gdmlzaXRJdGVtIChpdGVtKSB7XG4gIHZhciBzZWcgPSBpdGVtO1xuICB0aGlzLl9jb3VudGVyLmNvdW50U2VnbWVudChzZWcuZ2V0Q29vcmRpbmF0ZSgwKSwgc2VnLmdldENvb3JkaW5hdGUoMSkpO1xufTtcblNlZ21lbnRWaXNpdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtJdGVtVmlzaXRvcl1cbn07XG5TZWdtZW50VmlzaXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTZWdtZW50VmlzaXRvclxufTtcblxudmFyIEludGVydmFsSW5kZXhlZEdlb21ldHJ5ID0gZnVuY3Rpb24gSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkgKCkge1xuICB0aGlzLl9pbmRleCA9IG5ldyBTb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlKCk7XG4gIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLmluaXQoZ2VvbSk7XG59O1xuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0IChnZW9tKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGxpbmVzID0gTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKGdlb20pO1xuICBmb3IgKHZhciBpID0gbGluZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGxpbmUgPSBpLm5leHQoKTtcbiAgICB2YXIgcHRzID0gbGluZS5nZXRDb29yZGluYXRlcygpO1xuICAgIHRoaXMkMS5hZGRMaW5lKHB0cyk7XG4gIH1cbn07XG5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeS5wcm90b3R5cGUuYWRkTGluZSA9IGZ1bmN0aW9uIGFkZExpbmUgKHB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNlZyA9IG5ldyBMaW5lU2VnbWVudChwdHNbaSAtIDFdLCBwdHNbaV0pO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihzZWcucDAueSwgc2VnLnAxLnkpO1xuICAgIHZhciBtYXggPSBNYXRoLm1heChzZWcucDAueSwgc2VnLnAxLnkpO1xuICAgIHRoaXMkMS5faW5kZXguaW5zZXJ0KG1pbiwgbWF4LCBzZWcpO1xuICB9XG59O1xuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBtaW4gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG1heCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgdmlzaXRvciA9IG5ldyBBcnJheUxpc3RWaXNpdG9yKCk7XG4gICAgdGhpcy5faW5kZXgucXVlcnkobWluLCBtYXgsIHZpc2l0b3IpO1xuICAgIHJldHVybiB2aXNpdG9yLmdldEl0ZW1zKClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIG1pbiQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBtYXgkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgdmlzaXRvciQxID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX2luZGV4LnF1ZXJ5KG1pbiQxLCBtYXgkMSwgdmlzaXRvciQxKTtcbiAgfVxufTtcbkludGVydmFsSW5kZXhlZEdlb21ldHJ5LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnlcbn07XG5cbnZhciBHZW9tZXRyeUdyYXBoID0gKGZ1bmN0aW9uIChQbGFuYXJHcmFwaCQkMSkge1xuICBmdW5jdGlvbiBHZW9tZXRyeUdyYXBoICgpIHtcbiAgICBQbGFuYXJHcmFwaCQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3BhcmVudEdlb20gPSBudWxsO1xuICAgIHRoaXMuX2xpbmVFZGdlTWFwID0gbmV3IEhhc2hNYXAoKTtcbiAgICB0aGlzLl9ib3VuZGFyeU5vZGVSdWxlID0gbnVsbDtcbiAgICB0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlID0gdHJ1ZTtcbiAgICB0aGlzLl9hcmdJbmRleCA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRhcnlOb2RlcyA9IG51bGw7XG4gICAgdGhpcy5faGFzVG9vRmV3UG9pbnRzID0gZmFsc2U7XG4gICAgdGhpcy5faW52YWxpZFBvaW50ID0gbnVsbDtcbiAgICB0aGlzLl9hcmVhUHRMb2NhdG9yID0gbnVsbDtcbiAgICB0aGlzLl9wdExvY2F0b3IgPSBuZXcgUG9pbnRMb2NhdG9yKCk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwYXJlbnRHZW9tID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGJvdW5kYXJ5Tm9kZVJ1bGUgPSBCb3VuZGFyeU5vZGVSdWxlLk9HQ19TRlNfQk9VTkRBUllfUlVMRTtcbiAgICAgIHRoaXMuX2FyZ0luZGV4ID0gYXJnSW5kZXg7XG4gICAgICB0aGlzLl9wYXJlbnRHZW9tID0gcGFyZW50R2VvbTtcbiAgICAgIHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGUgPSBib3VuZGFyeU5vZGVSdWxlO1xuICAgICAgaWYgKHBhcmVudEdlb20gIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5hZGQocGFyZW50R2VvbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICB2YXIgYXJnSW5kZXgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwYXJlbnRHZW9tJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgYm91bmRhcnlOb2RlUnVsZSQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgdGhpcy5fYXJnSW5kZXggPSBhcmdJbmRleCQxO1xuICAgICAgdGhpcy5fcGFyZW50R2VvbSA9IHBhcmVudEdlb20kMTtcbiAgICAgIHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGUgPSBib3VuZGFyeU5vZGVSdWxlJDE7XG4gICAgICBpZiAocGFyZW50R2VvbSQxICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYWRkKHBhcmVudEdlb20kMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCBQbGFuYXJHcmFwaCQkMSApIEdlb21ldHJ5R3JhcGguX19wcm90b19fID0gUGxhbmFyR3JhcGgkJDE7XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUGxhbmFyR3JhcGgkJDEgJiYgUGxhbmFyR3JhcGgkJDEucHJvdG90eXBlICk7XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VvbWV0cnlHcmFwaDtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuaW5zZXJ0Qm91bmRhcnlQb2ludCA9IGZ1bmN0aW9uIGluc2VydEJvdW5kYXJ5UG9pbnQgKGFyZ0luZGV4LCBjb29yZCkge1xuICAgIHZhciBuID0gdGhpcy5fbm9kZXMuYWRkTm9kZShjb29yZCk7XG4gICAgdmFyIGxibCA9IG4uZ2V0TGFiZWwoKTtcbiAgICB2YXIgYm91bmRhcnlDb3VudCA9IDE7XG4gICAgdmFyIGxvYyA9IExvY2F0aW9uLk5PTkU7XG4gICAgbG9jID0gbGJsLmdldExvY2F0aW9uKGFyZ0luZGV4LCBQb3NpdGlvbi5PTik7XG4gICAgaWYgKGxvYyA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgYm91bmRhcnlDb3VudCsrOyB9XG4gICAgdmFyIG5ld0xvYyA9IEdlb21ldHJ5R3JhcGguZGV0ZXJtaW5lQm91bmRhcnkodGhpcy5fYm91bmRhcnlOb2RlUnVsZSwgYm91bmRhcnlDb3VudCk7XG4gICAgbGJsLnNldExvY2F0aW9uKGFyZ0luZGV4LCBuZXdMb2MpO1xuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5jb21wdXRlU2VsZk5vZGVzID0gZnVuY3Rpb24gY29tcHV0ZVNlbGZOb2RlcyAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBsaSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjb21wdXRlUmluZ1NlbGZOb2RlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVTZWxmTm9kZXMobGksIGNvbXB1dGVSaW5nU2VsZk5vZGVzLCBmYWxzZSlcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHZhciBsaSQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNvbXB1dGVSaW5nU2VsZk5vZGVzJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgaXNEb25lSWZQcm9wZXJJbnQgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgc2kgPSBuZXcgU2VnbWVudEludGVyc2VjdG9yJDIobGkkMSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgc2kuc2V0SXNEb25lSWZQcm9wZXJJbnQoaXNEb25lSWZQcm9wZXJJbnQpO1xuICAgICAgdmFyIGVzaSA9IHRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCk7XG4gICAgICB2YXIgaXNSaW5ncyA9IHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBMaW5lYXJSaW5nIHx8IHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBQb2x5Z29uIHx8IHRoaXMuX3BhcmVudEdlb20gaW5zdGFuY2VvZiBNdWx0aVBvbHlnb247XG4gICAgICB2YXIgY29tcHV0ZUFsbFNlZ21lbnRzID0gY29tcHV0ZVJpbmdTZWxmTm9kZXMkMSB8fCAhaXNSaW5ncztcbiAgICAgIGVzaS5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLl9lZGdlcywgc2ksIGNvbXB1dGVBbGxTZWdtZW50cyk7XG4gICAgICB0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0aGlzLl9hcmdJbmRleCk7XG4gICAgICByZXR1cm4gc2lcbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmNvbXB1dGVTcGxpdEVkZ2VzID0gZnVuY3Rpb24gY29tcHV0ZVNwbGl0RWRnZXMgKGVkZ2VsaXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGUgPSBpLm5leHQoKTtcbiAgICAgIGUuZWlMaXN0LmFkZFNwbGl0RWRnZXMoZWRnZWxpc3QpO1xuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zIChnLCBsaSwgaW5jbHVkZVByb3Blcikge1xuICAgIHZhciBzaSA9IG5ldyBTZWdtZW50SW50ZXJzZWN0b3IkMihsaSwgaW5jbHVkZVByb3BlciwgdHJ1ZSk7XG4gICAgc2kuc2V0Qm91bmRhcnlOb2Rlcyh0aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSwgZy5nZXRCb3VuZGFyeU5vZGVzKCkpO1xuICAgIHZhciBlc2kgPSB0aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpO1xuICAgIGVzaS5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLl9lZGdlcywgZy5fZWRnZXMsIHNpKTtcbiAgICByZXR1cm4gc2lcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEdlb21cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZ2V0Qm91bmRhcnlOb2RlUnVsZSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5Tm9kZVJ1bGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9ib3VuZGFyeU5vZGVSdWxlXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmhhc1Rvb0Zld1BvaW50cyA9IGZ1bmN0aW9uIGhhc1Rvb0Zld1BvaW50cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50c1xuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRQb2ludCA9IGZ1bmN0aW9uIGFkZFBvaW50ICgpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgIHZhciBwID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNvb3JkID0gcC5nZXRDb29yZGluYXRlKCk7XG4gICAgICB0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LCBjb29yZCwgTG9jYXRpb24uSU5URVJJT1IpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHB0ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCwgcHQsIExvY2F0aW9uLklOVEVSSU9SKTtcbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZFBvbHlnb24gPSBmdW5jdGlvbiBhZGRQb2x5Z29uIChwKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLmFkZFBvbHlnb25SaW5nKHAuZ2V0RXh0ZXJpb3JSaW5nKCksIExvY2F0aW9uLkVYVEVSSU9SLCBMb2NhdGlvbi5JTlRFUklPUik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmdldE51bUludGVyaW9yUmluZygpOyBpKyspIHtcbiAgICAgIHZhciBob2xlID0gcC5nZXRJbnRlcmlvclJpbmdOKGkpO1xuICAgICAgdGhpcyQxLmFkZFBvbHlnb25SaW5nKGhvbGUsIExvY2F0aW9uLklOVEVSSU9SLCBMb2NhdGlvbi5FWFRFUklPUik7XG4gICAgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRFZGdlID0gZnVuY3Rpb24gYWRkRWRnZSAoZSkge1xuICAgIHRoaXMuaW5zZXJ0RWRnZShlKTtcbiAgICB2YXIgY29vcmQgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gICAgdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCwgY29vcmRbMF0sIExvY2F0aW9uLkJPVU5EQVJZKTtcbiAgICB0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LCBjb29yZFtjb29yZC5sZW5ndGggLSAxXSwgTG9jYXRpb24uQk9VTkRBUlkpO1xuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRMaW5lU3RyaW5nID0gZnVuY3Rpb24gYWRkTGluZVN0cmluZyAobGluZSkge1xuICAgIHZhciBjb29yZCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMobGluZS5nZXRDb29yZGluYXRlcygpKTtcbiAgICBpZiAoY29vcmQubGVuZ3RoIDwgMikge1xuICAgICAgdGhpcy5faGFzVG9vRmV3UG9pbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ludmFsaWRQb2ludCA9IGNvb3JkWzBdO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdmFyIGUgPSBuZXcgRWRnZShjb29yZCwgbmV3IExhYmVsKHRoaXMuX2FyZ0luZGV4LCBMb2NhdGlvbi5JTlRFUklPUikpO1xuICAgIHRoaXMuX2xpbmVFZGdlTWFwLnB1dChsaW5lLCBlKTtcbiAgICB0aGlzLmluc2VydEVkZ2UoZSk7XG4gICAgQXNzZXJ0LmlzVHJ1ZShjb29yZC5sZW5ndGggPj0gMiwgJ2ZvdW5kIExpbmVTdHJpbmcgd2l0aCBzaW5nbGUgcG9pbnQnKTtcbiAgICB0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5fYXJnSW5kZXgsIGNvb3JkWzBdKTtcbiAgICB0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5fYXJnSW5kZXgsIGNvb3JkW2Nvb3JkLmxlbmd0aCAtIDFdKTtcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZ2V0SW52YWxpZFBvaW50ID0gZnVuY3Rpb24gZ2V0SW52YWxpZFBvaW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW52YWxpZFBvaW50XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmdldEJvdW5kYXJ5UG9pbnRzID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlQb2ludHMgKCkge1xuICAgIHZhciBjb2xsID0gdGhpcy5nZXRCb3VuZGFyeU5vZGVzKCk7XG4gICAgdmFyIHB0cyA9IG5ldyBBcnJheShjb2xsLnNpemUoKSkuZmlsbChudWxsKTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICh2YXIgaXQgPSBjb2xsLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBub2RlID0gaXQubmV4dCgpO1xuICAgICAgcHRzW2krK10gPSBub2RlLmdldENvb3JkaW5hdGUoKS5jb3B5KCk7XG4gICAgfVxuICAgIHJldHVybiBwdHNcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZ2V0Qm91bmRhcnlOb2RlcyA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5Tm9kZXMgKCkge1xuICAgIGlmICh0aGlzLl9ib3VuZGFyeU5vZGVzID09PSBudWxsKSB7IHRoaXMuX2JvdW5kYXJ5Tm9kZXMgPSB0aGlzLl9ub2Rlcy5nZXRCb3VuZGFyeU5vZGVzKHRoaXMuX2FyZ0luZGV4KTsgfVxuICAgIHJldHVybiB0aGlzLl9ib3VuZGFyeU5vZGVzXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlID0gZnVuY3Rpb24gYWRkU2VsZkludGVyc2VjdGlvbk5vZGUgKGFyZ0luZGV4LCBjb29yZCwgbG9jKSB7XG4gICAgaWYgKHRoaXMuaXNCb3VuZGFyeU5vZGUoYXJnSW5kZXgsIGNvb3JkKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgaWYgKGxvYyA9PT0gTG9jYXRpb24uQk9VTkRBUlkgJiYgdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZSkgeyB0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQoYXJnSW5kZXgsIGNvb3JkKTsgfSBlbHNlIHsgdGhpcy5pbnNlcnRQb2ludChhcmdJbmRleCwgY29vcmQsIGxvYyk7IH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkUG9seWdvblJpbmcgPSBmdW5jdGlvbiBhZGRQb2x5Z29uUmluZyAobHIsIGN3TGVmdCwgY3dSaWdodCkge1xuICAgIGlmIChsci5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjb29yZCA9IENvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMobHIuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgaWYgKGNvb3JkLmxlbmd0aCA8IDQpIHtcbiAgICAgIHRoaXMuX2hhc1Rvb0Zld1BvaW50cyA9IHRydWU7XG4gICAgICB0aGlzLl9pbnZhbGlkUG9pbnQgPSBjb29yZFswXTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHZhciBsZWZ0ID0gY3dMZWZ0O1xuICAgIHZhciByaWdodCA9IGN3UmlnaHQ7XG4gICAgaWYgKENHQWxnb3JpdGhtcy5pc0NDVyhjb29yZCkpIHtcbiAgICAgIGxlZnQgPSBjd1JpZ2h0O1xuICAgICAgcmlnaHQgPSBjd0xlZnQ7XG4gICAgfVxuICAgIHZhciBlID0gbmV3IEVkZ2UoY29vcmQsIG5ldyBMYWJlbCh0aGlzLl9hcmdJbmRleCwgTG9jYXRpb24uQk9VTkRBUlksIGxlZnQsIHJpZ2h0KSk7XG4gICAgdGhpcy5fbGluZUVkZ2VNYXAucHV0KGxyLCBlKTtcbiAgICB0aGlzLmluc2VydEVkZ2UoZSk7XG4gICAgdGhpcy5pbnNlcnRQb2ludCh0aGlzLl9hcmdJbmRleCwgY29vcmRbMF0sIExvY2F0aW9uLkJPVU5EQVJZKTtcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuaW5zZXJ0UG9pbnQgPSBmdW5jdGlvbiBpbnNlcnRQb2ludCAoYXJnSW5kZXgsIGNvb3JkLCBvbkxvY2F0aW9uKSB7XG4gICAgdmFyIG4gPSB0aGlzLl9ub2Rlcy5hZGROb2RlKGNvb3JkKTtcbiAgICB2YXIgbGJsID0gbi5nZXRMYWJlbCgpO1xuICAgIGlmIChsYmwgPT09IG51bGwpIHtcbiAgICAgIG4uX2xhYmVsID0gbmV3IExhYmVsKGFyZ0luZGV4LCBvbkxvY2F0aW9uKTtcbiAgICB9IGVsc2UgeyBsYmwuc2V0TG9jYXRpb24oYXJnSW5kZXgsIG9uTG9jYXRpb24pOyB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvciA9IGZ1bmN0aW9uIGNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvciAoKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yKClcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzID0gZnVuY3Rpb24gYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzIChhcmdJbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2VkZ2VzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGUgPSBpLm5leHQoKTtcbiAgICAgIHZhciBlTG9jID0gZS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKGFyZ0luZGV4KTtcbiAgICAgIGZvciAodmFyIGVpSXQgPSBlLmVpTGlzdC5pdGVyYXRvcigpOyBlaUl0Lmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGVpID0gZWlJdC5uZXh0KCk7XG4gICAgICAgIHRoaXMkMS5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZShhcmdJbmRleCwgZWkuY29vcmQsIGVMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGcgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAoZy5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24pIHsgdGhpcy5fdXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZSA9IGZhbHNlOyB9XG4gICAgICBpZiAoZyBpbnN0YW5jZW9mIFBvbHlnb24pIHsgdGhpcy5hZGRQb2x5Z29uKGcpOyB9XG4gICAgICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTGluZVN0cmluZykgeyB0aGlzLmFkZExpbmVTdHJpbmcoZyk7IH1cbiAgICAgIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBQb2ludCkgeyB0aGlzLmFkZFBvaW50KGcpOyB9XG4gICAgICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTXVsdGlQb2ludCkgeyB0aGlzLmFkZENvbGxlY3Rpb24oZyk7IH1cbiAgICAgIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aUxpbmVTdHJpbmcpIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gICAgICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uKSB7IHRoaXMuYWRkQ29sbGVjdGlvbihnKTsgfVxuICAgICAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikgeyB0aGlzLmFkZENvbGxlY3Rpb24oZyk7IH1cbiAgICAgIGVsc2UgeyB0aHJvdyBuZXcgRXJyb3IoZy5nZXRDbGFzcygpLmdldE5hbWUoKSkgfVxuICAgIH0gZWxzZSB7IHJldHVybiBQbGFuYXJHcmFwaCQkMS5wcm90b3R5cGUuYWRkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRDb2xsZWN0aW9uID0gZnVuY3Rpb24gYWRkQ29sbGVjdGlvbiAoZ2MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2MuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICAgIHZhciBnID0gZ2MuZ2V0R2VvbWV0cnlOKGkpO1xuICAgICAgdGhpcyQxLmFkZChnKTtcbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmxvY2F0ZSA9IGZ1bmN0aW9uIGxvY2F0ZSAocHQpIHtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKHRoaXMuX3BhcmVudEdlb20sIFBvbHlnb25hbCkgJiYgdGhpcy5fcGFyZW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCkgPiA1MCkge1xuICAgICAgaWYgKHRoaXMuX2FyZWFQdExvY2F0b3IgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fYXJlYVB0TG9jYXRvciA9IG5ldyBJbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yKHRoaXMuX3BhcmVudEdlb20pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2FyZWFQdExvY2F0b3IubG9jYXRlKHB0KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShwdCwgdGhpcy5fcGFyZW50R2VvbSlcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZmluZEVkZ2UgPSBmdW5jdGlvbiBmaW5kRWRnZSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBsaW5lID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuX2xpbmVFZGdlTWFwLmdldChsaW5lKVxuICAgIH0gZWxzZSB7IHJldHVybiBQbGFuYXJHcmFwaCQkMS5wcm90b3R5cGUuZmluZEVkZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnlHcmFwaFxuICB9O1xuICBHZW9tZXRyeUdyYXBoLmRldGVybWluZUJvdW5kYXJ5ID0gZnVuY3Rpb24gZGV0ZXJtaW5lQm91bmRhcnkgKGJvdW5kYXJ5Tm9kZVJ1bGUsIGJvdW5kYXJ5Q291bnQpIHtcbiAgICByZXR1cm4gYm91bmRhcnlOb2RlUnVsZS5pc0luQm91bmRhcnkoYm91bmRhcnlDb3VudCkgPyBMb2NhdGlvbi5CT1VOREFSWSA6IExvY2F0aW9uLklOVEVSSU9SXG4gIH07XG5cbiAgcmV0dXJuIEdlb21ldHJ5R3JhcGg7XG59KFBsYW5hckdyYXBoKSk7XG5cbnZhciBHZW9tZXRyeUdyYXBoT3AgPSBmdW5jdGlvbiBHZW9tZXRyeUdyYXBoT3AgKCkge1xuICB0aGlzLl9saSA9IG5ldyBSb2J1c3RMaW5lSW50ZXJzZWN0b3IoKTtcbiAgdGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWwgPSBudWxsO1xuICB0aGlzLl9hcmcgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnMCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGcwLmdldFByZWNpc2lvbk1vZGVsKCkpO1xuICAgIHRoaXMuX2FyZyA9IG5ldyBBcnJheSgxKS5maWxsKG51bGwpO1xuICAgIHRoaXMuX2FyZ1swXSA9IG5ldyBHZW9tZXRyeUdyYXBoKDAsIGcwKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGcwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBib3VuZGFyeU5vZGVSdWxlID0gQm91bmRhcnlOb2RlUnVsZS5PR0NfU0ZTX0JPVU5EQVJZX1JVTEU7XG4gICAgaWYgKGcwJDEuZ2V0UHJlY2lzaW9uTW9kZWwoKS5jb21wYXJlVG8oZzEuZ2V0UHJlY2lzaW9uTW9kZWwoKSkgPj0gMCkgeyB0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGcwJDEuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7IH0gZWxzZSB7IHRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZzEuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7IH1cbiAgICB0aGlzLl9hcmcgPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgICB0aGlzLl9hcmdbMF0gPSBuZXcgR2VvbWV0cnlHcmFwaCgwLCBnMCQxLCBib3VuZGFyeU5vZGVSdWxlKTtcbiAgICB0aGlzLl9hcmdbMV0gPSBuZXcgR2VvbWV0cnlHcmFwaCgxLCBnMSwgYm91bmRhcnlOb2RlUnVsZSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnMCQyID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBib3VuZGFyeU5vZGVSdWxlJDEgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGcwJDIuZ2V0UHJlY2lzaW9uTW9kZWwoKS5jb21wYXJlVG8oZzEkMS5nZXRQcmVjaXNpb25Nb2RlbCgpKSA+PSAwKSB7IHRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZzAkMi5nZXRQcmVjaXNpb25Nb2RlbCgpKTsgfSBlbHNlIHsgdGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihnMSQxLmdldFByZWNpc2lvbk1vZGVsKCkpOyB9XG4gICAgdGhpcy5fYXJnID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gICAgdGhpcy5fYXJnWzBdID0gbmV3IEdlb21ldHJ5R3JhcGgoMCwgZzAkMiwgYm91bmRhcnlOb2RlUnVsZSQxKTtcbiAgICB0aGlzLl9hcmdbMV0gPSBuZXcgR2VvbWV0cnlHcmFwaCgxLCBnMSQxLCBib3VuZGFyeU5vZGVSdWxlJDEpO1xuICB9XG59O1xuR2VvbWV0cnlHcmFwaE9wLnByb3RvdHlwZS5nZXRBcmdHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldEFyZ0dlb21ldHJ5IChpKSB7XG4gIHJldHVybiB0aGlzLl9hcmdbaV0uZ2V0R2VvbWV0cnkoKVxufTtcbkdlb21ldHJ5R3JhcGhPcC5wcm90b3R5cGUuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24gPSBmdW5jdGlvbiBzZXRDb21wdXRhdGlvblByZWNpc2lvbiAocG0pIHtcbiAgdGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWwgPSBwbTtcbiAgdGhpcy5fbGkuc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5fcmVzdWx0UHJlY2lzaW9uTW9kZWwpO1xufTtcbkdlb21ldHJ5R3JhcGhPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5R3JhcGhPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUdyYXBoT3Bcbn07XG5cbi8vIG9wZXJhdGlvbi5nZW9tZXRyeWdyYXBoXG5cbnZhciBHZW9tZXRyeU1hcHBlciA9IGZ1bmN0aW9uIEdlb21ldHJ5TWFwcGVyICgpIHt9O1xuXG5HZW9tZXRyeU1hcHBlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5TWFwcGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5TWFwcGVyXG59O1xuR2VvbWV0cnlNYXBwZXIubWFwID0gZnVuY3Rpb24gbWFwICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5ICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIEdlb21ldHJ5TWFwcGVyLk1hcE9wKSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvcCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWFwcGVkID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgICAgdmFyIGcgPSBvcC5tYXAoZ2VvbS5nZXRHZW9tZXRyeU4oaSkpO1xuICAgICAgaWYgKGcgIT09IG51bGwpIHsgbWFwcGVkLmFkZChnKTsgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VvbS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShtYXBwZWQpXG4gIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29sbGVjdGlvbikgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgR2VvbWV0cnlNYXBwZXIuTWFwT3ApKSB7XG4gICAgdmFyIGdlb21zID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvcCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwZWQkMSA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpJDEgPSBnZW9tcy5pdGVyYXRvcigpOyBpJDEuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGckMSA9IGkkMS5uZXh0KCk7XG4gICAgICB2YXIgZ3IgPSBvcCQxLm1hcChnJDEpO1xuICAgICAgaWYgKGdyICE9PSBudWxsKSB7IG1hcHBlZCQxLmFkZChncik7IH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcHBlZCQxXG4gIH1cbn07XG5HZW9tZXRyeU1hcHBlci5NYXBPcCA9IGZ1bmN0aW9uIE1hcE9wICgpIHt9O1xuXG52YXIgT3ZlcmxheU9wID0gKGZ1bmN0aW9uIChHZW9tZXRyeUdyYXBoT3ApIHtcbiAgZnVuY3Rpb24gT3ZlcmxheU9wICgpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIEdlb21ldHJ5R3JhcGhPcC5jYWxsKHRoaXMsIGcwLCBnMSk7XG4gICAgdGhpcy5fcHRMb2NhdG9yID0gbmV3IFBvaW50TG9jYXRvcigpO1xuICAgIHRoaXMuX2dlb21GYWN0ID0gbnVsbDtcbiAgICB0aGlzLl9yZXN1bHRHZW9tID0gbnVsbDtcbiAgICB0aGlzLl9ncmFwaCA9IG51bGw7XG4gICAgdGhpcy5fZWRnZUxpc3QgPSBuZXcgRWRnZUxpc3QoKTtcbiAgICB0aGlzLl9yZXN1bHRQb2x5TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB0aGlzLl9yZXN1bHRMaW5lTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB0aGlzLl9yZXN1bHRQb2ludExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdGhpcy5fZ3JhcGggPSBuZXcgUGxhbmFyR3JhcGgobmV3IE92ZXJsYXlOb2RlRmFjdG9yeSgpKTtcbiAgICB0aGlzLl9nZW9tRmFjdCA9IGcwLmdldEZhY3RvcnkoKTtcbiAgfVxuXG4gIGlmICggR2VvbWV0cnlHcmFwaE9wICkgT3ZlcmxheU9wLl9fcHJvdG9fXyA9IEdlb21ldHJ5R3JhcGhPcDtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5R3JhcGhPcCAmJiBHZW9tZXRyeUdyYXBoT3AucHJvdG90eXBlICk7XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPdmVybGF5T3A7XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuaW5zZXJ0VW5pcXVlRWRnZSA9IGZ1bmN0aW9uIGluc2VydFVuaXF1ZUVkZ2UgKGUpIHtcbiAgICB2YXIgZXhpc3RpbmdFZGdlID0gdGhpcy5fZWRnZUxpc3QuZmluZEVxdWFsRWRnZShlKTtcbiAgICBpZiAoZXhpc3RpbmdFZGdlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZXhpc3RpbmdMYWJlbCA9IGV4aXN0aW5nRWRnZS5nZXRMYWJlbCgpO1xuICAgICAgdmFyIGxhYmVsVG9NZXJnZSA9IGUuZ2V0TGFiZWwoKTtcbiAgICAgIGlmICghZXhpc3RpbmdFZGdlLmlzUG9pbnR3aXNlRXF1YWwoZSkpIHtcbiAgICAgICAgbGFiZWxUb01lcmdlID0gbmV3IExhYmVsKGUuZ2V0TGFiZWwoKSk7XG4gICAgICAgIGxhYmVsVG9NZXJnZS5mbGlwKCk7XG4gICAgICB9XG4gICAgICB2YXIgZGVwdGggPSBleGlzdGluZ0VkZ2UuZ2V0RGVwdGgoKTtcbiAgICAgIGlmIChkZXB0aC5pc051bGwoKSkge1xuICAgICAgICBkZXB0aC5hZGQoZXhpc3RpbmdMYWJlbCk7XG4gICAgICB9XG4gICAgICBkZXB0aC5hZGQobGFiZWxUb01lcmdlKTtcbiAgICAgIGV4aXN0aW5nTGFiZWwubWVyZ2UobGFiZWxUb01lcmdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZWRnZUxpc3QuYWRkKGUpO1xuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5nZXRHcmFwaCA9IGZ1bmN0aW9uIGdldEdyYXBoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGhcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcyA9IGZ1bmN0aW9uIGNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzICgpIHtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuX2dyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgdmFyIHN5bSA9IGRlLmdldFN5bSgpO1xuICAgICAgaWYgKGRlLmlzSW5SZXN1bHQoKSAmJiBzeW0uaXNJblJlc3VsdCgpKSB7XG4gICAgICAgIGRlLnNldEluUmVzdWx0KGZhbHNlKTtcbiAgICAgICAgc3ltLnNldEluUmVzdWx0KGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuaXNDb3ZlcmVkQnlMQSA9IGZ1bmN0aW9uIGlzQ292ZXJlZEJ5TEEgKGNvb3JkKSB7XG4gICAgaWYgKHRoaXMuaXNDb3ZlcmVkKGNvb3JkLCB0aGlzLl9yZXN1bHRMaW5lTGlzdCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmICh0aGlzLmlzQ292ZXJlZChjb29yZCwgdGhpcy5fcmVzdWx0UG9seUxpc3QpKSB7IHJldHVybiB0cnVlIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jb21wdXRlR2VvbWV0cnkgPSBmdW5jdGlvbiBjb21wdXRlR2VvbWV0cnkgKHJlc3VsdFBvaW50TGlzdCwgcmVzdWx0TGluZUxpc3QsIHJlc3VsdFBvbHlMaXN0LCBvcGNvZGUpIHtcbiAgICB2YXIgZ2VvbUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZ2VvbUxpc3QuYWRkQWxsKHJlc3VsdFBvaW50TGlzdCk7XG4gICAgZ2VvbUxpc3QuYWRkQWxsKHJlc3VsdExpbmVMaXN0KTtcbiAgICBnZW9tTGlzdC5hZGRBbGwocmVzdWx0UG9seUxpc3QpO1xuICAgIGlmIChnZW9tTGlzdC5pc0VtcHR5KCkpIHsgcmV0dXJuIE92ZXJsYXlPcC5jcmVhdGVFbXB0eVJlc3VsdChvcGNvZGUsIHRoaXMuX2FyZ1swXS5nZXRHZW9tZXRyeSgpLCB0aGlzLl9hcmdbMV0uZ2V0R2VvbWV0cnkoKSwgdGhpcy5fZ2VvbUZhY3QpIH1cbiAgICByZXR1cm4gdGhpcy5fZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeShnZW9tTGlzdClcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5tZXJnZVN5bUxhYmVscyA9IGZ1bmN0aW9uIG1lcmdlU3ltTGFiZWxzICgpIHtcbiAgICBmb3IgKHZhciBub2RlaXQgPSB0aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7IG5vZGVpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgICBub2RlLmdldEVkZ2VzKCkubWVyZ2VTeW1MYWJlbHMoKTtcbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuaXNDb3ZlcmVkID0gZnVuY3Rpb24gaXNDb3ZlcmVkIChjb29yZCwgZ2VvbUxpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGl0ID0gZ2VvbUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGdlb20gPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgbG9jID0gdGhpcyQxLl9wdExvY2F0b3IubG9jYXRlKGNvb3JkLCBnZW9tKTtcbiAgICAgIGlmIChsb2MgIT09IExvY2F0aW9uLkVYVEVSSU9SKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUucmVwbGFjZUNvbGxhcHNlZEVkZ2VzID0gZnVuY3Rpb24gcmVwbGFjZUNvbGxhcHNlZEVkZ2VzICgpIHtcbiAgICB2YXIgbmV3RWRnZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLl9lZGdlTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgICAgIGlmIChlLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgaXQucmVtb3ZlKCk7XG4gICAgICAgIG5ld0VkZ2VzLmFkZChlLmdldENvbGxhcHNlZEVkZ2UoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2VkZ2VMaXN0LmFkZEFsbChuZXdFZGdlcyk7XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUudXBkYXRlTm9kZUxhYmVsbGluZyA9IGZ1bmN0aW9uIHVwZGF0ZU5vZGVMYWJlbGxpbmcgKCkge1xuICAgIGZvciAodmFyIG5vZGVpdCA9IHRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZWl0Lm5leHQoKTtcbiAgICAgIHZhciBsYmwgPSBub2RlLmdldEVkZ2VzKCkuZ2V0TGFiZWwoKTtcbiAgICAgIG5vZGUuZ2V0TGFiZWwoKS5tZXJnZShsYmwpO1xuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5nZXRSZXN1bHRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldFJlc3VsdEdlb21ldHJ5IChvdmVybGF5T3BDb2RlKSB7XG4gICAgdGhpcy5jb21wdXRlT3ZlcmxheShvdmVybGF5T3BDb2RlKTtcbiAgICByZXR1cm4gdGhpcy5fcmVzdWx0R2VvbVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmluc2VydFVuaXF1ZUVkZ2VzID0gZnVuY3Rpb24gaW5zZXJ0VW5pcXVlRWRnZXMgKGVkZ2VzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gZWRnZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZSA9IGkubmV4dCgpO1xuICAgICAgdGhpcyQxLmluc2VydFVuaXF1ZUVkZ2UoZSk7XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmNvbXB1dGVPdmVybGF5ID0gZnVuY3Rpb24gY29tcHV0ZU92ZXJsYXkgKG9wQ29kZSkge1xuICAgIHRoaXMuY29weVBvaW50cygwKTtcbiAgICB0aGlzLmNvcHlQb2ludHMoMSk7XG4gICAgdGhpcy5fYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5fbGksIGZhbHNlKTtcbiAgICB0aGlzLl9hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwgZmFsc2UpO1xuICAgIHRoaXMuX2FyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5fYXJnWzFdLCB0aGlzLl9saSwgdHJ1ZSk7XG4gICAgdmFyIGJhc2VTcGxpdEVkZ2VzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHRoaXMuX2FyZ1swXS5jb21wdXRlU3BsaXRFZGdlcyhiYXNlU3BsaXRFZGdlcyk7XG4gICAgdGhpcy5fYXJnWzFdLmNvbXB1dGVTcGxpdEVkZ2VzKGJhc2VTcGxpdEVkZ2VzKTtcbiAgICAvLyBjb25zdCBzcGxpdEVkZ2VzID0gYmFzZVNwbGl0RWRnZXNcbiAgICB0aGlzLmluc2VydFVuaXF1ZUVkZ2VzKGJhc2VTcGxpdEVkZ2VzKTtcbiAgICB0aGlzLmNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCk7XG4gICAgdGhpcy5yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKTtcbiAgICBFZGdlTm9kaW5nVmFsaWRhdG9yLmNoZWNrVmFsaWQodGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSk7XG4gICAgdGhpcy5fZ3JhcGguYWRkRWRnZXModGhpcy5fZWRnZUxpc3QuZ2V0RWRnZXMoKSk7XG4gICAgdGhpcy5jb21wdXRlTGFiZWxsaW5nKCk7XG4gICAgdGhpcy5sYWJlbEluY29tcGxldGVOb2RlcygpO1xuICAgIHRoaXMuZmluZFJlc3VsdEFyZWFFZGdlcyhvcENvZGUpO1xuICAgIHRoaXMuY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMoKTtcbiAgICB2YXIgcG9seUJ1aWxkZXIgPSBuZXcgUG9seWdvbkJ1aWxkZXIodGhpcy5fZ2VvbUZhY3QpO1xuICAgIHBvbHlCdWlsZGVyLmFkZCh0aGlzLl9ncmFwaCk7XG4gICAgdGhpcy5fcmVzdWx0UG9seUxpc3QgPSBwb2x5QnVpbGRlci5nZXRQb2x5Z29ucygpO1xuICAgIHZhciBsaW5lQnVpbGRlciA9IG5ldyBMaW5lQnVpbGRlcih0aGlzLCB0aGlzLl9nZW9tRmFjdCwgdGhpcy5fcHRMb2NhdG9yKTtcbiAgICB0aGlzLl9yZXN1bHRMaW5lTGlzdCA9IGxpbmVCdWlsZGVyLmJ1aWxkKG9wQ29kZSk7XG4gICAgdmFyIHBvaW50QnVpbGRlciA9IG5ldyBQb2ludEJ1aWxkZXIodGhpcywgdGhpcy5fZ2VvbUZhY3QsIHRoaXMuX3B0TG9jYXRvcik7XG4gICAgdGhpcy5fcmVzdWx0UG9pbnRMaXN0ID0gcG9pbnRCdWlsZGVyLmJ1aWxkKG9wQ29kZSk7XG4gICAgdGhpcy5fcmVzdWx0R2VvbSA9IHRoaXMuY29tcHV0ZUdlb21ldHJ5KHRoaXMuX3Jlc3VsdFBvaW50TGlzdCwgdGhpcy5fcmVzdWx0TGluZUxpc3QsIHRoaXMuX3Jlc3VsdFBvbHlMaXN0LCBvcENvZGUpO1xuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmxhYmVsSW5jb21wbGV0ZU5vZGUgPSBmdW5jdGlvbiBsYWJlbEluY29tcGxldGVOb2RlIChuLCB0YXJnZXRJbmRleCkge1xuICAgIHZhciBsb2MgPSB0aGlzLl9wdExvY2F0b3IubG9jYXRlKG4uZ2V0Q29vcmRpbmF0ZSgpLCB0aGlzLl9hcmdbdGFyZ2V0SW5kZXhdLmdldEdlb21ldHJ5KCkpO1xuICAgIG4uZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbih0YXJnZXRJbmRleCwgbG9jKTtcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jb3B5UG9pbnRzID0gZnVuY3Rpb24gY29weVBvaW50cyAoYXJnSW5kZXgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSB0aGlzLl9hcmdbYXJnSW5kZXhdLmdldE5vZGVJdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBncmFwaE5vZGUgPSBpLm5leHQoKTtcbiAgICAgIHZhciBuZXdOb2RlID0gdGhpcyQxLl9ncmFwaC5hZGROb2RlKGdyYXBoTm9kZS5nZXRDb29yZGluYXRlKCkpO1xuICAgICAgbmV3Tm9kZS5zZXRMYWJlbChhcmdJbmRleCwgZ3JhcGhOb2RlLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oYXJnSW5kZXgpKTtcbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuZmluZFJlc3VsdEFyZWFFZGdlcyA9IGZ1bmN0aW9uIGZpbmRSZXN1bHRBcmVhRWRnZXMgKG9wQ29kZSkge1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5fZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgbGFiZWwgPSBkZS5nZXRMYWJlbCgpO1xuICAgICAgaWYgKGxhYmVsLmlzQXJlYSgpICYmICFkZS5pc0ludGVyaW9yQXJlYUVkZ2UoKSAmJiBPdmVybGF5T3AuaXNSZXN1bHRPZk9wKGxhYmVsLmdldExvY2F0aW9uKDAsIFBvc2l0aW9uLlJJR0hUKSwgbGFiZWwuZ2V0TG9jYXRpb24oMSwgUG9zaXRpb24uUklHSFQpLCBvcENvZGUpKSB7XG4gICAgICAgIGRlLnNldEluUmVzdWx0KHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jb21wdXRlTGFiZWxzRnJvbURlcHRocyA9IGZ1bmN0aW9uIGNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzICgpIHtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuX2VkZ2VMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgICAgdmFyIGxibCA9IGUuZ2V0TGFiZWwoKTtcbiAgICAgIHZhciBkZXB0aCA9IGUuZ2V0RGVwdGgoKTtcbiAgICAgIGlmICghZGVwdGguaXNOdWxsKCkpIHtcbiAgICAgICAgZGVwdGgubm9ybWFsaXplKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKCFsYmwuaXNOdWxsKGkpICYmIGxibC5pc0FyZWEoKSAmJiAhZGVwdGguaXNOdWxsKGkpKSB7XG4gICAgICAgICAgICBpZiAoZGVwdGguZ2V0RGVsdGEoaSkgPT09IDApIHtcbiAgICAgICAgICAgICAgbGJsLnRvTGluZShpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEFzc2VydC5pc1RydWUoIWRlcHRoLmlzTnVsbChpLCBQb3NpdGlvbi5MRUZUKSwgJ2RlcHRoIG9mIExFRlQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICAgICAgbGJsLnNldExvY2F0aW9uKGksIFBvc2l0aW9uLkxFRlQsIGRlcHRoLmdldExvY2F0aW9uKGksIFBvc2l0aW9uLkxFRlQpKTtcbiAgICAgICAgICAgICAgQXNzZXJ0LmlzVHJ1ZSghZGVwdGguaXNOdWxsKGksIFBvc2l0aW9uLlJJR0hUKSwgJ2RlcHRoIG9mIFJJR0hUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkJyk7XG4gICAgICAgICAgICAgIGxibC5zZXRMb2NhdGlvbihpLCBQb3NpdGlvbi5SSUdIVCwgZGVwdGguZ2V0TG9jYXRpb24oaSwgUG9zaXRpb24uUklHSFQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuY29tcHV0ZUxhYmVsbGluZyA9IGZ1bmN0aW9uIGNvbXB1dGVMYWJlbGxpbmcgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpOyBub2RlaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIG5vZGUgPSBub2RlaXQubmV4dCgpO1xuICAgICAgbm9kZS5nZXRFZGdlcygpLmNvbXB1dGVMYWJlbGxpbmcodGhpcyQxLl9hcmcpO1xuICAgIH1cbiAgICB0aGlzLm1lcmdlU3ltTGFiZWxzKCk7XG4gICAgdGhpcy51cGRhdGVOb2RlTGFiZWxsaW5nKCk7XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUubGFiZWxJbmNvbXBsZXRlTm9kZXMgPSBmdW5jdGlvbiBsYWJlbEluY29tcGxldGVOb2RlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAvLyBsZXQgbm9kZUNvdW50ID0gMFxuICAgIGZvciAodmFyIG5pID0gdGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpOyBuaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbiA9IG5pLm5leHQoKTtcbiAgICAgIHZhciBsYWJlbCA9IG4uZ2V0TGFiZWwoKTtcbiAgICAgIGlmIChuLmlzSXNvbGF0ZWQoKSkge1xuICAgICAgICAvLyBub2RlQ291bnQrK1xuICAgICAgICBpZiAobGFiZWwuaXNOdWxsKDApKSB7IHRoaXMkMS5sYWJlbEluY29tcGxldGVOb2RlKG4sIDApOyB9IGVsc2UgeyB0aGlzJDEubGFiZWxJbmNvbXBsZXRlTm9kZShuLCAxKTsgfVxuICAgICAgfVxuICAgICAgbi5nZXRFZGdlcygpLnVwZGF0ZUxhYmVsbGluZyhsYWJlbCk7XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmlzQ292ZXJlZEJ5QSA9IGZ1bmN0aW9uIGlzQ292ZXJlZEJ5QSAoY29vcmQpIHtcbiAgICBpZiAodGhpcy5pc0NvdmVyZWQoY29vcmQsIHRoaXMuX3Jlc3VsdFBvbHlMaXN0KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE92ZXJsYXlPcFxuICB9O1xuXG4gIHJldHVybiBPdmVybGF5T3A7XG59KEdlb21ldHJ5R3JhcGhPcCkpO1xuXG5PdmVybGF5T3Aub3ZlcmxheU9wID0gZnVuY3Rpb24gKGdlb20wLCBnZW9tMSwgb3BDb2RlKSB7XG4gIHZhciBnb3YgPSBuZXcgT3ZlcmxheU9wKGdlb20wLCBnZW9tMSk7XG4gIHZhciBnZW9tT3YgPSBnb3YuZ2V0UmVzdWx0R2VvbWV0cnkob3BDb2RlKTtcbiAgcmV0dXJuIGdlb21PdlxufTtcbk92ZXJsYXlPcC5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiAoZywgb3RoZXIpIHtcbiAgaWYgKGcuaXNFbXB0eSgpIHx8IG90aGVyLmlzRW1wdHkoKSkgeyByZXR1cm4gT3ZlcmxheU9wLmNyZWF0ZUVtcHR5UmVzdWx0KE92ZXJsYXlPcC5JTlRFUlNFQ1RJT04sIGcsIG90aGVyLCBnLmdldEZhY3RvcnkoKSkgfVxuICBpZiAoZy5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKSB7XG4gICAgdmFyIGcyID0gb3RoZXI7XG4gICAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlci5tYXAoZywge1xuICAgICAgaW50ZXJmYWNlc186IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtHZW9tZXRyeU1hcHBlci5NYXBPcF1cbiAgICAgIH0sXG4gICAgICBtYXA6IGZ1bmN0aW9uIChnKSB7XG4gICAgICAgIHJldHVybiBnLmludGVyc2VjdGlvbihnMilcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZyk7XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24ob3RoZXIpO1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnLCBvdGhlciwgT3ZlcmxheU9wLklOVEVSU0VDVElPTilcbn07XG5PdmVybGF5T3Auc3ltRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChnLCBvdGhlcikge1xuICBpZiAoZy5pc0VtcHR5KCkgfHwgb3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgaWYgKGcuaXNFbXB0eSgpICYmIG90aGVyLmlzRW1wdHkoKSkgeyByZXR1cm4gT3ZlcmxheU9wLmNyZWF0ZUVtcHR5UmVzdWx0KE92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFLCBnLCBvdGhlciwgZy5nZXRGYWN0b3J5KCkpIH1cbiAgICBpZiAoZy5pc0VtcHR5KCkpIHsgcmV0dXJuIG90aGVyLmNvcHkoKSB9XG4gICAgaWYgKG90aGVyLmlzRW1wdHkoKSkgeyByZXR1cm4gZy5jb3B5KCkgfVxuICB9XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZyk7XG4gIGcuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24ob3RoZXIpO1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnLCBvdGhlciwgT3ZlcmxheU9wLlNZTURJRkZFUkVOQ0UpXG59O1xuT3ZlcmxheU9wLnJlc3VsdERpbWVuc2lvbiA9IGZ1bmN0aW9uIChvcENvZGUsIGcwLCBnMSkge1xuICB2YXIgZGltMCA9IGcwLmdldERpbWVuc2lvbigpO1xuICB2YXIgZGltMSA9IGcxLmdldERpbWVuc2lvbigpO1xuICB2YXIgcmVzdWx0RGltZW5zaW9uID0gLTE7XG4gIHN3aXRjaCAob3BDb2RlKSB7XG4gICAgY2FzZSBPdmVybGF5T3AuSU5URVJTRUNUSU9OOlxuICAgICAgcmVzdWx0RGltZW5zaW9uID0gTWF0aC5taW4oZGltMCwgZGltMSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgT3ZlcmxheU9wLlVOSU9OOlxuICAgICAgcmVzdWx0RGltZW5zaW9uID0gTWF0aC5tYXgoZGltMCwgZGltMSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgT3ZlcmxheU9wLkRJRkZFUkVOQ0U6XG4gICAgICByZXN1bHREaW1lbnNpb24gPSBkaW0wO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIE92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFOlxuICAgICAgcmVzdWx0RGltZW5zaW9uID0gTWF0aC5tYXgoZGltMCwgZGltMSk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gIH1cbiAgcmV0dXJuIHJlc3VsdERpbWVuc2lvblxufTtcbk92ZXJsYXlPcC5jcmVhdGVFbXB0eVJlc3VsdCA9IGZ1bmN0aW9uIChvdmVybGF5T3BDb2RlLCBhLCBiLCBnZW9tRmFjdCkge1xuICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgc3dpdGNoIChPdmVybGF5T3AucmVzdWx0RGltZW5zaW9uKG92ZXJsYXlPcENvZGUsIGEsIGIpKSB7XG4gICAgY2FzZSAtMTpcbiAgICAgIHJlc3VsdCA9IGdlb21GYWN0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk7XG4gICAgICBicmVha1xuICAgIGNhc2UgMDpcbiAgICAgIHJlc3VsdCA9IGdlb21GYWN0LmNyZWF0ZVBvaW50KCk7XG4gICAgICBicmVha1xuICAgIGNhc2UgMTpcbiAgICAgIHJlc3VsdCA9IGdlb21GYWN0LmNyZWF0ZUxpbmVTdHJpbmcoKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAyOlxuICAgICAgcmVzdWx0ID0gZ2VvbUZhY3QuY3JlYXRlUG9seWdvbigpO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5PdmVybGF5T3AuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChnLCBvdGhlcikge1xuICBpZiAoZy5pc0VtcHR5KCkpIHsgcmV0dXJuIE92ZXJsYXlPcC5jcmVhdGVFbXB0eVJlc3VsdChPdmVybGF5T3AuRElGRkVSRU5DRSwgZywgb3RoZXIsIGcuZ2V0RmFjdG9yeSgpKSB9XG4gIGlmIChvdGhlci5pc0VtcHR5KCkpIHsgcmV0dXJuIGcuY29weSgpIH1cbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihnKTtcbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihvdGhlcik7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcsIG90aGVyLCBPdmVybGF5T3AuRElGRkVSRU5DRSlcbn07XG5PdmVybGF5T3AuaXNSZXN1bHRPZk9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBsYWJlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb3BDb2RlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBsb2MwID0gbGFiZWwuZ2V0TG9jYXRpb24oMCk7XG4gICAgdmFyIGxvYzEgPSBsYWJlbC5nZXRMb2NhdGlvbigxKTtcbiAgICByZXR1cm4gT3ZlcmxheU9wLmlzUmVzdWx0T2ZPcChsb2MwLCBsb2MxLCBvcENvZGUpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBsb2MwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvYzEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgb3ZlcmxheU9wQ29kZSA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAobG9jMCQxID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyBsb2MwJDEgPSBMb2NhdGlvbi5JTlRFUklPUjsgfVxuICAgIGlmIChsb2MxJDEgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IGxvYzEkMSA9IExvY2F0aW9uLklOVEVSSU9SOyB9XG4gICAgc3dpdGNoIChvdmVybGF5T3BDb2RlKSB7XG4gICAgICBjYXNlIE92ZXJsYXlPcC5JTlRFUlNFQ1RJT046XG4gICAgICAgIHJldHVybiBsb2MwJDEgPT09IExvY2F0aW9uLklOVEVSSU9SICYmIGxvYzEkMSA9PT0gTG9jYXRpb24uSU5URVJJT1JcbiAgICAgIGNhc2UgT3ZlcmxheU9wLlVOSU9OOlxuICAgICAgICByZXR1cm4gbG9jMCQxID09PSBMb2NhdGlvbi5JTlRFUklPUiB8fCBsb2MxJDEgPT09IExvY2F0aW9uLklOVEVSSU9SXG4gICAgICBjYXNlIE92ZXJsYXlPcC5ESUZGRVJFTkNFOlxuICAgICAgICByZXR1cm4gbG9jMCQxID09PSBMb2NhdGlvbi5JTlRFUklPUiAmJiBsb2MxJDEgIT09IExvY2F0aW9uLklOVEVSSU9SXG4gICAgICBjYXNlIE92ZXJsYXlPcC5TWU1ESUZGRVJFTkNFOlxuICAgICAgICByZXR1cm4gKGxvYzAkMSA9PT0gTG9jYXRpb24uSU5URVJJT1IgJiYgbG9jMSQxICE9PSBMb2NhdGlvbi5JTlRFUklPUikgfHwgKGxvYzAkMSAhPT0gTG9jYXRpb24uSU5URVJJT1IgJiYgbG9jMSQxID09PSBMb2NhdGlvbi5JTlRFUklPUilcbiAgICAgIGRlZmF1bHQ6XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuT3ZlcmxheU9wLklOVEVSU0VDVElPTiA9IDE7XG5PdmVybGF5T3AuVU5JT04gPSAyO1xuT3ZlcmxheU9wLkRJRkZFUkVOQ0UgPSAzO1xuT3ZlcmxheU9wLlNZTURJRkZFUkVOQ0UgPSA0O1xuXG52YXIgRnV6enlQb2ludExvY2F0b3IgPSBmdW5jdGlvbiBGdXp6eVBvaW50TG9jYXRvciAoKSB7XG4gIHRoaXMuX2cgPSBudWxsO1xuICB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlID0gbnVsbDtcbiAgdGhpcy5fbGluZXdvcmsgPSBudWxsO1xuICB0aGlzLl9wdExvY2F0b3IgPSBuZXcgUG9pbnRMb2NhdG9yKCk7XG4gIHRoaXMuX3NlZyA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGJvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gIHRoaXMuX2cgPSBnO1xuICB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlID0gYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZTtcbiAgdGhpcy5fbGluZXdvcmsgPSB0aGlzLmV4dHJhY3RMaW5ld29yayhnKTtcbn07XG5GdXp6eVBvaW50TG9jYXRvci5wcm90b3R5cGUuaXNXaXRoaW5Ub2xlcmFuY2VPZkJvdW5kYXJ5ID0gZnVuY3Rpb24gaXNXaXRoaW5Ub2xlcmFuY2VPZkJvdW5kYXJ5IChwdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGluZXdvcmsuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IHRoaXMkMS5fbGluZXdvcmsuZ2V0R2VvbWV0cnlOKGkpO1xuICAgIHZhciBzZXEgPSBsaW5lLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VxLnNpemUoKSAtIDE7IGorKykge1xuICAgICAgc2VxLmdldENvb3JkaW5hdGUoaiwgdGhpcyQxLl9zZWcucDApO1xuICAgICAgc2VxLmdldENvb3JkaW5hdGUoaiArIDEsIHRoaXMkMS5fc2VnLnAxKTtcbiAgICAgIHZhciBkaXN0ID0gdGhpcyQxLl9zZWcuZGlzdGFuY2UocHQpO1xuICAgICAgaWYgKGRpc3QgPD0gdGhpcyQxLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlKSB7IHJldHVybiB0cnVlIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuRnV6enlQb2ludExvY2F0b3IucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0TG9jYXRpb24gKHB0KSB7XG4gIGlmICh0aGlzLmlzV2l0aGluVG9sZXJhbmNlT2ZCb3VuZGFyeShwdCkpIHsgcmV0dXJuIExvY2F0aW9uLkJPVU5EQVJZIH1cbiAgcmV0dXJuIHRoaXMuX3B0TG9jYXRvci5sb2NhdGUocHQsIHRoaXMuX2cpXG59O1xuRnV6enlQb2ludExvY2F0b3IucHJvdG90eXBlLmV4dHJhY3RMaW5ld29yayA9IGZ1bmN0aW9uIGV4dHJhY3RMaW5ld29yayAoZykge1xuICB2YXIgZXh0cmFjdGVyID0gbmV3IFBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyKCk7XG4gIGcuYXBwbHkoZXh0cmFjdGVyKTtcbiAgdmFyIGxpbmV3b3JrID0gZXh0cmFjdGVyLmdldExpbmV3b3JrKCk7XG4gIHZhciBsaW5lcyA9IEdlb21ldHJ5RmFjdG9yeS50b0xpbmVTdHJpbmdBcnJheShsaW5ld29yayk7XG4gIHJldHVybiBnLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobGluZXMpXG59O1xuRnV6enlQb2ludExvY2F0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5GdXp6eVBvaW50TG9jYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBGdXp6eVBvaW50TG9jYXRvclxufTtcblxudmFyIFBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyID0gZnVuY3Rpb24gUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIgKCkge1xuICB0aGlzLl9saW5ld29yayA9IG51bGw7XG4gIHRoaXMuX2xpbmV3b3JrID0gbmV3IEFycmF5TGlzdCgpO1xufTtcblBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyLnByb3RvdHlwZS5nZXRMaW5ld29yayA9IGZ1bmN0aW9uIGdldExpbmV3b3JrICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xpbmV3b3JrXG59O1xuUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoZykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChnIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgIHZhciBwb2x5ID0gZztcbiAgICB0aGlzLl9saW5ld29yay5hZGQocG9seS5nZXRFeHRlcmlvclJpbmcoKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5LmdldE51bUludGVyaW9yUmluZygpOyBpKyspIHtcbiAgICAgIHRoaXMkMS5fbGluZXdvcmsuYWRkKHBvbHkuZ2V0SW50ZXJpb3JSaW5nTihpKSk7XG4gICAgfVxuICB9XG59O1xuUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5RmlsdGVyXVxufTtcblBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvbHlnb25hbExpbmV3b3JrRXh0cmFjdGVyXG59O1xuXG52YXIgT2Zmc2V0UG9pbnRHZW5lcmF0b3IgPSBmdW5jdGlvbiBPZmZzZXRQb2ludEdlbmVyYXRvciAoKSB7XG4gIHRoaXMuX2cgPSBudWxsO1xuICB0aGlzLl9kb0xlZnQgPSB0cnVlO1xuICB0aGlzLl9kb1JpZ2h0ID0gdHJ1ZTtcbiAgdmFyIGcgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2cgPSBnO1xufTtcbk9mZnNldFBvaW50R2VuZXJhdG9yLnByb3RvdHlwZS5leHRyYWN0UG9pbnRzID0gZnVuY3Rpb24gZXh0cmFjdFBvaW50cyAobGluZSwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldFB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBwdHMgPSBsaW5lLmdldENvb3JkaW5hdGVzKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgIHRoaXMkMS5jb21wdXRlT2Zmc2V0UG9pbnRzKHB0c1tpXSwgcHRzW2kgKyAxXSwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldFB0cyk7XG4gIH1cbn07XG5PZmZzZXRQb2ludEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U2lkZXNUb0dlbmVyYXRlID0gZnVuY3Rpb24gc2V0U2lkZXNUb0dlbmVyYXRlIChkb0xlZnQsIGRvUmlnaHQpIHtcbiAgdGhpcy5fZG9MZWZ0ID0gZG9MZWZ0O1xuICB0aGlzLl9kb1JpZ2h0ID0gZG9SaWdodDtcbn07XG5PZmZzZXRQb2ludEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24gZ2V0UG9pbnRzIChvZmZzZXREaXN0YW5jZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBvZmZzZXRQdHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBsaW5lcyA9IExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyh0aGlzLl9nKTtcbiAgZm9yICh2YXIgaSA9IGxpbmVzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBsaW5lID0gaS5uZXh0KCk7XG4gICAgdGhpcyQxLmV4dHJhY3RQb2ludHMobGluZSwgb2Zmc2V0RGlzdGFuY2UsIG9mZnNldFB0cyk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldFB0c1xufTtcbk9mZnNldFBvaW50R2VuZXJhdG9yLnByb3RvdHlwZS5jb21wdXRlT2Zmc2V0UG9pbnRzID0gZnVuY3Rpb24gY29tcHV0ZU9mZnNldFBvaW50cyAocDAsIHAxLCBvZmZzZXREaXN0YW5jZSwgb2Zmc2V0UHRzKSB7XG4gIHZhciBkeCA9IHAxLnggLSBwMC54O1xuICB2YXIgZHkgPSBwMS55IC0gcDAueTtcbiAgdmFyIGxlbiA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIHZhciB1eCA9IG9mZnNldERpc3RhbmNlICogZHggLyBsZW47XG4gIHZhciB1eSA9IG9mZnNldERpc3RhbmNlICogZHkgLyBsZW47XG4gIHZhciBtaWRYID0gKHAxLnggKyBwMC54KSAvIDI7XG4gIHZhciBtaWRZID0gKHAxLnkgKyBwMC55KSAvIDI7XG4gIGlmICh0aGlzLl9kb0xlZnQpIHtcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IG5ldyBDb29yZGluYXRlKG1pZFggLSB1eSwgbWlkWSArIHV4KTtcbiAgICBvZmZzZXRQdHMuYWRkKG9mZnNldExlZnQpO1xuICB9XG4gIGlmICh0aGlzLl9kb1JpZ2h0KSB7XG4gICAgdmFyIG9mZnNldFJpZ2h0ID0gbmV3IENvb3JkaW5hdGUobWlkWCArIHV5LCBtaWRZIC0gdXgpO1xuICAgIG9mZnNldFB0cy5hZGQob2Zmc2V0UmlnaHQpO1xuICB9XG59O1xuT2Zmc2V0UG9pbnRHZW5lcmF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5PZmZzZXRQb2ludEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBPZmZzZXRQb2ludEdlbmVyYXRvclxufTtcblxudmFyIE92ZXJsYXlSZXN1bHRWYWxpZGF0b3IgPSBmdW5jdGlvbiBPdmVybGF5UmVzdWx0VmFsaWRhdG9yICgpIHtcbiAgdGhpcy5fZ2VvbSA9IG51bGw7XG4gIHRoaXMuX2xvY0ZpbmRlciA9IG51bGw7XG4gIHRoaXMuX2xvY2F0aW9uID0gbmV3IEFycmF5KDMpLmZpbGwobnVsbCk7XG4gIHRoaXMuX2ludmFsaWRMb2NhdGlvbiA9IG51bGw7XG4gIHRoaXMuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UgPSBPdmVybGF5UmVzdWx0VmFsaWRhdG9yLlRPTEVSQU5DRTtcbiAgdGhpcy5fdGVzdENvb3JkcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIGEgPSBhcmd1bWVudHNbMF07XG4gIHZhciBiID0gYXJndW1lbnRzWzFdO1xuICB2YXIgcmVzdWx0ID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlID0gT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5jb21wdXRlQm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZShhLCBiKTtcbiAgdGhpcy5fZ2VvbSA9IFthLCBiLCByZXN1bHRdO1xuICB0aGlzLl9sb2NGaW5kZXIgPSBbbmV3IEZ1enp5UG9pbnRMb2NhdG9yKHRoaXMuX2dlb21bMF0sIHRoaXMuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UpLCBuZXcgRnV6enlQb2ludExvY2F0b3IodGhpcy5fZ2VvbVsxXSwgdGhpcy5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSksIG5ldyBGdXp6eVBvaW50TG9jYXRvcih0aGlzLl9nZW9tWzJdLCB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlKV07XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQ2ID0geyBUT0xFUkFOQ0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLnJlcG9ydFJlc3VsdCA9IGZ1bmN0aW9uIHJlcG9ydFJlc3VsdCAob3ZlcmxheU9wLCBsb2NhdGlvbiwgZXhwZWN0ZWRJbnRlcmlvcikge1xuICBTeXN0ZW0ub3V0LnByaW50bG4oJ092ZXJsYXkgcmVzdWx0IGludmFsaWQgLSBBOicgKyBMb2NhdGlvbi50b0xvY2F0aW9uU3ltYm9sKGxvY2F0aW9uWzBdKSArICcgQjonICsgTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbChsb2NhdGlvblsxXSkgKyAnIGV4cGVjdGVkOicgKyAoZXhwZWN0ZWRJbnRlcmlvciA/ICdpJyA6ICdlJykgKyAnIGFjdHVhbDonICsgTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbChsb2NhdGlvblsyXSkpO1xufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkIChvdmVybGF5T3ApIHtcbiAgdGhpcy5hZGRUZXN0UHRzKHRoaXMuX2dlb21bMF0pO1xuICB0aGlzLmFkZFRlc3RQdHModGhpcy5fZ2VvbVsxXSk7XG4gIHZhciBpc1ZhbGlkID0gdGhpcy5jaGVja1ZhbGlkKG92ZXJsYXlPcCk7XG4gIHJldHVybiBpc1ZhbGlkXG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrVmFsaWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG92ZXJsYXlPcCA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Rlc3RDb29yZHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgIHZhciBwdCA9IHRoaXMkMS5fdGVzdENvb3Jkcy5nZXQoaSk7XG4gICAgICBpZiAoIXRoaXMkMS5jaGVja1ZhbGlkKG92ZXJsYXlPcCwgcHQpKSB7XG4gICAgICAgIHRoaXMkMS5faW52YWxpZExvY2F0aW9uID0gcHQ7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgb3ZlcmxheU9wJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0JDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fbG9jYXRpb25bMF0gPSB0aGlzLl9sb2NGaW5kZXJbMF0uZ2V0TG9jYXRpb24ocHQkMSk7XG4gICAgdGhpcy5fbG9jYXRpb25bMV0gPSB0aGlzLl9sb2NGaW5kZXJbMV0uZ2V0TG9jYXRpb24ocHQkMSk7XG4gICAgdGhpcy5fbG9jYXRpb25bMl0gPSB0aGlzLl9sb2NGaW5kZXJbMl0uZ2V0TG9jYXRpb24ocHQkMSk7XG4gICAgaWYgKE92ZXJsYXlSZXN1bHRWYWxpZGF0b3IuaGFzTG9jYXRpb24odGhpcy5fbG9jYXRpb24sIExvY2F0aW9uLkJPVU5EQVJZKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIHRoaXMuaXNWYWxpZFJlc3VsdChvdmVybGF5T3AkMSwgdGhpcy5fbG9jYXRpb24pXG4gIH1cbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5hZGRUZXN0UHRzID0gZnVuY3Rpb24gYWRkVGVzdFB0cyAoZykge1xuICB2YXIgcHRHZW4gPSBuZXcgT2Zmc2V0UG9pbnRHZW5lcmF0b3IoZyk7XG4gIHRoaXMuX3Rlc3RDb29yZHMuYWRkQWxsKHB0R2VuLmdldFBvaW50cyg1ICogdGhpcy5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSkpO1xufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmlzVmFsaWRSZXN1bHQgPSBmdW5jdGlvbiBpc1ZhbGlkUmVzdWx0IChvdmVybGF5T3AsIGxvY2F0aW9uKSB7XG4gIHZhciBleHBlY3RlZEludGVyaW9yID0gT3ZlcmxheU9wLmlzUmVzdWx0T2ZPcChsb2NhdGlvblswXSwgbG9jYXRpb25bMV0sIG92ZXJsYXlPcCk7XG4gIHZhciByZXN1bHRJbkludGVyaW9yID0gbG9jYXRpb25bMl0gPT09IExvY2F0aW9uLklOVEVSSU9SO1xuICB2YXIgaXNWYWxpZCA9ICEoZXhwZWN0ZWRJbnRlcmlvciBeIHJlc3VsdEluSW50ZXJpb3IpO1xuICBpZiAoIWlzVmFsaWQpIHsgdGhpcy5yZXBvcnRSZXN1bHQob3ZlcmxheU9wLCBsb2NhdGlvbiwgZXhwZWN0ZWRJbnRlcmlvcik7IH1cbiAgcmV0dXJuIGlzVmFsaWRcbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5nZXRJbnZhbGlkTG9jYXRpb24gPSBmdW5jdGlvbiBnZXRJbnZhbGlkTG9jYXRpb24gKCkge1xuICByZXR1cm4gdGhpcy5faW52YWxpZExvY2F0aW9uXG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT3ZlcmxheVJlc3VsdFZhbGlkYXRvclxufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IuaGFzTG9jYXRpb24gPSBmdW5jdGlvbiBoYXNMb2NhdGlvbiAobG9jYXRpb24sIGxvYykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIGlmIChsb2NhdGlvbltpXSA9PT0gbG9jKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLmNvbXB1dGVCb3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlID0gZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UgKGcwLCBnMSkge1xuICByZXR1cm4gTWF0aC5taW4oR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKGcwKSwgR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKGcxKSlcbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLmlzVmFsaWQgPSBmdW5jdGlvbiBpc1ZhbGlkIChhLCBiLCBvdmVybGF5T3AsIHJlc3VsdCkge1xuICB2YXIgdmFsaWRhdG9yID0gbmV3IE92ZXJsYXlSZXN1bHRWYWxpZGF0b3IoYSwgYiwgcmVzdWx0KTtcbiAgcmV0dXJuIHZhbGlkYXRvci5pc1ZhbGlkKG92ZXJsYXlPcClcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDYuVE9MRVJBTkNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuMDAwMDAxIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBPdmVybGF5UmVzdWx0VmFsaWRhdG9yLCBzdGF0aWNBY2Nlc3NvcnMkNDYgKTtcblxuLy8gb3BlcmF0aW9uLm92ZXJsYXlcblxudmFyIEdlb21ldHJ5Q29tYmluZXIgPSBmdW5jdGlvbiBHZW9tZXRyeUNvbWJpbmVyIChnZW9tcykge1xuICB0aGlzLl9nZW9tRmFjdG9yeSA9IG51bGw7XG4gIHRoaXMuX3NraXBFbXB0eSA9IGZhbHNlO1xuICB0aGlzLl9pbnB1dEdlb21zID0gbnVsbDtcbiAgdGhpcy5fZ2VvbUZhY3RvcnkgPSBHZW9tZXRyeUNvbWJpbmVyLmV4dHJhY3RGYWN0b3J5KGdlb21zKTtcbiAgdGhpcy5faW5wdXRHZW9tcyA9IGdlb21zO1xufTtcbkdlb21ldHJ5Q29tYmluZXIucHJvdG90eXBlLmV4dHJhY3RFbGVtZW50cyA9IGZ1bmN0aW9uIGV4dHJhY3RFbGVtZW50cyAoZ2VvbSwgZWxlbXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoZ2VvbSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciBlbGVtR2VvbSA9IGdlb20uZ2V0R2VvbWV0cnlOKGkpO1xuICAgIGlmICh0aGlzJDEuX3NraXBFbXB0eSAmJiBlbGVtR2VvbS5pc0VtcHR5KCkpIHsgY29udGludWUgfVxuICAgIGVsZW1zLmFkZChlbGVtR2VvbSk7XG4gIH1cbn07XG5HZW9tZXRyeUNvbWJpbmVyLnByb3RvdHlwZS5jb21iaW5lID0gZnVuY3Rpb24gY29tYmluZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVsZW1zID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gdGhpcy5faW5wdXRHZW9tcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZyA9IGkubmV4dCgpO1xuICAgIHRoaXMkMS5leHRyYWN0RWxlbWVudHMoZywgZWxlbXMpO1xuICB9XG4gIGlmIChlbGVtcy5zaXplKCkgPT09IDApIHtcbiAgICBpZiAodGhpcy5fZ2VvbUZhY3RvcnkgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbClcbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICByZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeShlbGVtcylcbn07XG5HZW9tZXRyeUNvbWJpbmVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlDb21iaW5lci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUNvbWJpbmVyXG59O1xuR2VvbWV0cnlDb21iaW5lci5jb21iaW5lID0gZnVuY3Rpb24gY29tYmluZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb21zID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb21iaW5lciA9IG5ldyBHZW9tZXRyeUNvbWJpbmVyKGdlb21zKTtcbiAgICByZXR1cm4gY29tYmluZXIuY29tYmluZSgpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGNvbWJpbmVyJDEgPSBuZXcgR2VvbWV0cnlDb21iaW5lcihHZW9tZXRyeUNvbWJpbmVyLmNyZWF0ZUxpc3QoZzAsIGcxKSk7XG4gICAgcmV0dXJuIGNvbWJpbmVyJDEuY29tYmluZSgpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBnMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBnMiA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgY29tYmluZXIkMiA9IG5ldyBHZW9tZXRyeUNvbWJpbmVyKEdlb21ldHJ5Q29tYmluZXIuY3JlYXRlTGlzdChnMCQxLCBnMSQxLCBnMikpO1xuICAgIHJldHVybiBjb21iaW5lciQyLmNvbWJpbmUoKVxuICB9XG59O1xuR2VvbWV0cnlDb21iaW5lci5leHRyYWN0RmFjdG9yeSA9IGZ1bmN0aW9uIGV4dHJhY3RGYWN0b3J5IChnZW9tcykge1xuICBpZiAoZ2VvbXMuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgcmV0dXJuIGdlb21zLml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKVxufTtcbkdlb21ldHJ5Q29tYmluZXIuY3JlYXRlTGlzdCA9IGZ1bmN0aW9uIGNyZWF0ZUxpc3QgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBvYmowID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvYmoxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGxpc3QuYWRkKG9iajApO1xuICAgIGxpc3QuYWRkKG9iajEpO1xuICAgIHJldHVybiBsaXN0XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBvYmowJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG9iajEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgb2JqMiA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgbGlzdCQxID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGxpc3QkMS5hZGQob2JqMCQxKTtcbiAgICBsaXN0JDEuYWRkKG9iajEkMSk7XG4gICAgbGlzdCQxLmFkZChvYmoyKTtcbiAgICByZXR1cm4gbGlzdCQxXG4gIH1cbn07XG5cbnZhciBDYXNjYWRlZFBvbHlnb25VbmlvbiA9IGZ1bmN0aW9uIENhc2NhZGVkUG9seWdvblVuaW9uICgpIHtcbiAgdGhpcy5faW5wdXRQb2x5cyA9IG51bGw7XG4gIHRoaXMuX2dlb21GYWN0b3J5ID0gbnVsbDtcbiAgdmFyIHBvbHlzID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9pbnB1dFBvbHlzID0gcG9seXM7XG4gIGlmICh0aGlzLl9pbnB1dFBvbHlzID09PSBudWxsKSB7IHRoaXMuX2lucHV0UG9seXMgPSBuZXcgQXJyYXlMaXN0KCk7IH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDcgPSB7IFNUUlRSRUVfTk9ERV9DQVBBQ0lUWTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnJlZHVjZVRvR2VvbWV0cmllcyA9IGZ1bmN0aW9uIHJlZHVjZVRvR2VvbWV0cmllcyAoZ2VvbVRyZWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZ2VvbXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSBnZW9tVHJlZS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgbyA9IGkubmV4dCgpO1xuICAgIHZhciBnZW9tID0gbnVsbDtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKG8sIExpc3QpKSB7XG4gICAgICBnZW9tID0gdGhpcyQxLnVuaW9uVHJlZShvKTtcbiAgICB9IGVsc2UgaWYgKG8gaW5zdGFuY2VvZiBHZW9tZXRyeSkge1xuICAgICAgZ2VvbSA9IG87XG4gICAgfVxuICAgIGdlb21zLmFkZChnZW9tKTtcbiAgfVxuICByZXR1cm4gZ2VvbXNcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUuZXh0cmFjdEJ5RW52ZWxvcGUgPSBmdW5jdGlvbiBleHRyYWN0QnlFbnZlbG9wZSAoZW52LCBnZW9tLCBkaXNqb2ludEdlb21zKSB7XG4gIHZhciBpbnRlcnNlY3RpbmdHZW9tcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIGVsZW0gPSBnZW9tLmdldEdlb21ldHJ5TihpKTtcbiAgICBpZiAoZWxlbS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlbnYpKSB7IGludGVyc2VjdGluZ0dlb21zLmFkZChlbGVtKTsgfSBlbHNlIHsgZGlzam9pbnRHZW9tcy5hZGQoZWxlbSk7IH1cbiAgfVxuICByZXR1cm4gdGhpcy5fZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeShpbnRlcnNlY3RpbmdHZW9tcylcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUudW5pb25PcHRpbWl6ZWQgPSBmdW5jdGlvbiB1bmlvbk9wdGltaXplZCAoZzAsIGcxKSB7XG4gIHZhciBnMEVudiA9IGcwLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgdmFyIGcxRW52ID0gZzEuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICBpZiAoIWcwRW52LmludGVyc2VjdHMoZzFFbnYpKSB7XG4gICAgdmFyIGNvbWJvID0gR2VvbWV0cnlDb21iaW5lci5jb21iaW5lKGcwLCBnMSk7XG4gICAgcmV0dXJuIGNvbWJvXG4gIH1cbiAgaWYgKGcwLmdldE51bUdlb21ldHJpZXMoKSA8PSAxICYmIGcxLmdldE51bUdlb21ldHJpZXMoKSA8PSAxKSB7IHJldHVybiB0aGlzLnVuaW9uQWN0dWFsKGcwLCBnMSkgfVxuICB2YXIgY29tbW9uRW52ID0gZzBFbnYuaW50ZXJzZWN0aW9uKGcxRW52KTtcbiAgcmV0dXJuIHRoaXMudW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uKGcwLCBnMSwgY29tbW9uRW52KVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uICgpIHtcbiAgaWYgKHRoaXMuX2lucHV0UG9seXMgPT09IG51bGwpIHsgdGhyb3cgbmV3IEVycm9yKCd1bmlvbigpIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlJykgfVxuICBpZiAodGhpcy5faW5wdXRQb2x5cy5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLl9nZW9tRmFjdG9yeSA9IHRoaXMuX2lucHV0UG9seXMuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpO1xuICB2YXIgaW5kZXggPSBuZXcgU1RSdHJlZShDYXNjYWRlZFBvbHlnb25Vbmlvbi5TVFJUUkVFX05PREVfQ0FQQUNJVFkpO1xuICBmb3IgKHZhciBpID0gdGhpcy5faW5wdXRQb2x5cy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgaXRlbSA9IGkubmV4dCgpO1xuICAgIGluZGV4Lmluc2VydChpdGVtLmdldEVudmVsb3BlSW50ZXJuYWwoKSwgaXRlbSk7XG4gIH1cbiAgdGhpcy5faW5wdXRQb2x5cyA9IG51bGw7XG4gIHZhciBpdGVtVHJlZSA9IGluZGV4Lml0ZW1zVHJlZSgpO1xuICB2YXIgdW5pb25BbGwgPSB0aGlzLnVuaW9uVHJlZShpdGVtVHJlZSk7XG4gIHJldHVybiB1bmlvbkFsbFxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS5iaW5hcnlVbmlvbiA9IGZ1bmN0aW9uIGJpbmFyeVVuaW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbXMgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuYmluYXJ5VW5pb24oZ2VvbXMsIDAsIGdlb21zLnNpemUoKSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGdlb21zJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBlbmQgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGVuZCAtIHN0YXJ0IDw9IDEpIHtcbiAgICAgIHZhciBnMCA9IENhc2NhZGVkUG9seWdvblVuaW9uLmdldEdlb21ldHJ5KGdlb21zJDEsIHN0YXJ0KTtcbiAgICAgIHJldHVybiB0aGlzLnVuaW9uU2FmZShnMCwgbnVsbClcbiAgICB9IGVsc2UgaWYgKGVuZCAtIHN0YXJ0ID09PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy51bmlvblNhZmUoQ2FzY2FkZWRQb2x5Z29uVW5pb24uZ2V0R2VvbWV0cnkoZ2VvbXMkMSwgc3RhcnQpLCBDYXNjYWRlZFBvbHlnb25Vbmlvbi5nZXRHZW9tZXRyeShnZW9tcyQxLCBzdGFydCArIDEpKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC50cnVuYygoZW5kICsgc3RhcnQpIC8gMik7XG4gICAgICB2YXIgZzAkMSA9IHRoaXMuYmluYXJ5VW5pb24oZ2VvbXMkMSwgc3RhcnQsIG1pZCk7XG4gICAgICB2YXIgZzEgPSB0aGlzLmJpbmFyeVVuaW9uKGdlb21zJDEsIG1pZCwgZW5kKTtcbiAgICAgIHJldHVybiB0aGlzLnVuaW9uU2FmZShnMCQxLCBnMSlcbiAgICB9XG4gIH1cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUucmVwZWF0ZWRVbmlvbiA9IGZ1bmN0aW9uIHJlcGVhdGVkVW5pb24gKGdlb21zKSB7XG4gIHZhciB1bmlvbiA9IG51bGw7XG4gIGZvciAodmFyIGkgPSBnZW9tcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZyA9IGkubmV4dCgpO1xuICAgIGlmICh1bmlvbiA9PT0gbnVsbCkgeyB1bmlvbiA9IGcuY29weSgpOyB9IGVsc2UgeyB1bmlvbiA9IHVuaW9uLnVuaW9uKGcpOyB9XG4gIH1cbiAgcmV0dXJuIHVuaW9uXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnVuaW9uU2FmZSA9IGZ1bmN0aW9uIHVuaW9uU2FmZSAoZzAsIGcxKSB7XG4gIGlmIChnMCA9PT0gbnVsbCAmJiBnMSA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChnMCA9PT0gbnVsbCkgeyByZXR1cm4gZzEuY29weSgpIH1cbiAgaWYgKGcxID09PSBudWxsKSB7IHJldHVybiBnMC5jb3B5KCkgfVxuICByZXR1cm4gdGhpcy51bmlvbk9wdGltaXplZChnMCwgZzEpXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnVuaW9uQWN0dWFsID0gZnVuY3Rpb24gdW5pb25BY3R1YWwgKGcwLCBnMSkge1xuICByZXR1cm4gQ2FzY2FkZWRQb2x5Z29uVW5pb24ucmVzdHJpY3RUb1BvbHlnb25zKGcwLnVuaW9uKGcxKSlcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUudW5pb25UcmVlID0gZnVuY3Rpb24gdW5pb25UcmVlIChnZW9tVHJlZSkge1xuICB2YXIgZ2VvbXMgPSB0aGlzLnJlZHVjZVRvR2VvbWV0cmllcyhnZW9tVHJlZSk7XG4gIHZhciB1bmlvbiA9IHRoaXMuYmluYXJ5VW5pb24oZ2VvbXMpO1xuICByZXR1cm4gdW5pb25cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUudW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gdW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uIChnMCwgZzEsIGNvbW1vbikge1xuICB2YXIgZGlzam9pbnRQb2x5cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIGcwSW50ID0gdGhpcy5leHRyYWN0QnlFbnZlbG9wZShjb21tb24sIGcwLCBkaXNqb2ludFBvbHlzKTtcbiAgdmFyIGcxSW50ID0gdGhpcy5leHRyYWN0QnlFbnZlbG9wZShjb21tb24sIGcxLCBkaXNqb2ludFBvbHlzKTtcbiAgdmFyIHVuaW9uID0gdGhpcy51bmlvbkFjdHVhbChnMEludCwgZzFJbnQpO1xuICBkaXNqb2ludFBvbHlzLmFkZCh1bmlvbik7XG4gIHZhciBvdmVyYWxsVW5pb24gPSBHZW9tZXRyeUNvbWJpbmVyLmNvbWJpbmUoZGlzam9pbnRQb2x5cyk7XG4gIHJldHVybiBvdmVyYWxsVW5pb25cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUuYnVmZmVyVW5pb24gPSBmdW5jdGlvbiBidWZmZXJVbmlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb21zID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBmYWN0b3J5ID0gZ2VvbXMuZ2V0KDApLmdldEZhY3RvcnkoKTtcbiAgICB2YXIgZ0NvbGwgPSBmYWN0b3J5LmJ1aWxkR2VvbWV0cnkoZ2VvbXMpO1xuICAgIHZhciB1bmlvbkFsbCA9IGdDb2xsLmJ1ZmZlcigwLjApO1xuICAgIHJldHVybiB1bmlvbkFsbFxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZzAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBmYWN0b3J5JDEgPSBnMC5nZXRGYWN0b3J5KCk7XG4gICAgdmFyIGdDb2xsJDEgPSBmYWN0b3J5JDEuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKFtnMCwgZzFdKTtcbiAgICB2YXIgdW5pb25BbGwkMSA9IGdDb2xsJDEuYnVmZmVyKDAuMCk7XG4gICAgcmV0dXJuIHVuaW9uQWxsJDFcbiAgfVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ2FzY2FkZWRQb2x5Z29uVW5pb25cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5yZXN0cmljdFRvUG9seWdvbnMgPSBmdW5jdGlvbiByZXN0cmljdFRvUG9seWdvbnMgKGcpIHtcbiAgaWYgKGhhc0ludGVyZmFjZShnLCBQb2x5Z29uYWwpKSB7XG4gICAgcmV0dXJuIGdcbiAgfVxuICB2YXIgcG9seWdvbnMgPSBQb2x5Z29uRXh0cmFjdGVyLmdldFBvbHlnb25zKGcpO1xuICBpZiAocG9seWdvbnMuc2l6ZSgpID09PSAxKSB7IHJldHVybiBwb2x5Z29ucy5nZXQoMCkgfVxuICByZXR1cm4gZy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKEdlb21ldHJ5RmFjdG9yeS50b1BvbHlnb25BcnJheShwb2x5Z29ucykpXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24uZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAobGlzdCwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID49IGxpc3Quc2l6ZSgpKSB7IHJldHVybiBudWxsIH1cbiAgcmV0dXJuIGxpc3QuZ2V0KGluZGV4KVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKHBvbHlzKSB7XG4gIHZhciBvcCA9IG5ldyBDYXNjYWRlZFBvbHlnb25Vbmlvbihwb2x5cyk7XG4gIHJldHVybiBvcC51bmlvbigpXG59O1xuc3RhdGljQWNjZXNzb3JzJDQ3LlNUUlRSRUVfTk9ERV9DQVBBQ0lUWS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDYXNjYWRlZFBvbHlnb25Vbmlvbiwgc3RhdGljQWNjZXNzb3JzJDQ3ICk7XG5cbnZhciBVbmlvbk9wID0gZnVuY3Rpb24gVW5pb25PcCAoKSB7fTtcblxuVW5pb25PcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblVuaW9uT3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gVW5pb25PcFxufTtcblVuaW9uT3AudW5pb24gPSBmdW5jdGlvbiB1bmlvbiAoZywgb3RoZXIpIHtcbiAgaWYgKGcuaXNFbXB0eSgpIHx8IG90aGVyLmlzRW1wdHkoKSkge1xuICAgIGlmIChnLmlzRW1wdHkoKSAmJiBvdGhlci5pc0VtcHR5KCkpIHsgcmV0dXJuIE92ZXJsYXlPcC5jcmVhdGVFbXB0eVJlc3VsdChPdmVybGF5T3AuVU5JT04sIGcsIG90aGVyLCBnLmdldEZhY3RvcnkoKSkgfVxuICAgIGlmIChnLmlzRW1wdHkoKSkgeyByZXR1cm4gb3RoZXIuY29weSgpIH1cbiAgICBpZiAob3RoZXIuaXNFbXB0eSgpKSB7IHJldHVybiBnLmNvcHkoKSB9XG4gIH1cbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihnKTtcbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihvdGhlcik7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcsIG90aGVyLCBPdmVybGF5T3AuVU5JT04pXG59O1xuXG4vLyBvcGVyYXRpb24udW5pb25cblxuLy8gb3BlcmF0aW9uXG5cbi8qKlxuICogUG9seWZpbGwgZm9yIElFIHN1cHBvcnRcbiAqL1xuXG5leHBvcnQgeyBHZW9KU09OUmVhZGVyLCBHZW9KU09OV3JpdGVyLCBPdmVybGF5T3AsIFVuaW9uT3AsIEJ1ZmZlck9wIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/turf-jsts/jsts.mjs\n");

/***/ })

};
;