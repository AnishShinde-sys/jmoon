"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polygon-clipping";
exports.ids = ["vendor-chunks/polygon-clipping"];
exports.modules = {

/***/ "(ssr)/./node_modules/polygon-clipping/dist/polygon-clipping.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/polygon-clipping/dist/polygon-clipping.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var splaytree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! splaytree */ \"(ssr)/./node_modules/polygon-clipping/node_modules/splaytree/dist/splay.esm.js\");\n/* harmony import */ var robust_predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! robust-predicates */ \"(ssr)/./node_modules/robust-predicates/index.js\");\n\n\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\n\nconst isInBbox = (bbox, point) => {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\nconst getBboxOverlap = (b1, b2) => {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null;\n\n  // find the middle two X values\n  const lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  const upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x;\n\n  // find the middle two Y values\n  const lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  const upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y;\n\n  // put those middle values together to get the overlap\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\n\nlet epsilon = Number.EPSILON;\n\n// IE Polyfill\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nconst EPSILON_SQ = epsilon * epsilon;\n\n/* FLP comparator */\nconst cmp = (a, b) => {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  }\n\n  // check if they're flp equal\n  const ab = a - b;\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  }\n\n  // normal comparison\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nclass PtRounder {\n  constructor() {\n    this.reset();\n  }\n  reset() {\n    this.xRounder = new CoordRounder();\n    this.yRounder = new CoordRounder();\n  }\n  round(x, y) {\n    return {\n      x: this.xRounder.round(x),\n      y: this.yRounder.round(y)\n    };\n  }\n}\nclass CoordRounder {\n  constructor() {\n    this.tree = new splaytree__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    // preseed with 0 so we don't end up with values < Number.EPSILON\n    this.round(0);\n  }\n\n  // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n  round(coord) {\n    const node = this.tree.add(coord);\n    const prevNode = this.tree.prev(node);\n    if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n      this.tree.remove(coord);\n      return prevNode.key;\n    }\n    const nextNode = this.tree.next(node);\n    if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n      this.tree.remove(coord);\n      return nextNode.key;\n    }\n    return coord;\n  }\n}\n\n// singleton available by import\nconst rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\nconst crossProduct = (a, b) => a.x * b.y - a.y * b.x;\n\n/* Dot Product of two vectors with first point at origin */\nconst dotProduct = (a, b) => a.x * b.x + a.y * b.y;\n\n/* Comparator for two vectors with same starting point */\nconst compareVectorAngles = (basePt, endPt1, endPt2) => {\n  const res = (0,robust_predicates__WEBPACK_IMPORTED_MODULE_1__.orient2d)(basePt.x, basePt.y, endPt1.x, endPt1.y, endPt2.x, endPt2.y);\n  if (res > 0) return -1;\n  if (res < 0) return 1;\n  return 0;\n};\nconst length = v => Math.sqrt(dotProduct(v, v));\n\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\nconst sineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  const vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\nconst cosineOfAngle = (pShared, pBase, pAngle) => {\n  const vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  const vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst horizontalIntersection = (pt, v, y) => {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst verticalIntersection = (pt, v, x) => {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\nconst intersection$1 = (pt1, v1, pt2, v2) => {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y);\n\n  // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  const kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  const ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  const d1 = crossProduct(ve, v1) / kross;\n  const d2 = crossProduct(ve, v2) / kross;\n\n  // take the average of the two calculations to minimize rounding error\n  const x1 = pt1.x + d2 * v1.x,\n    x2 = pt2.x + d1 * v2.x;\n  const y1 = pt1.y + d2 * v1.y,\n    y2 = pt2.y + d1 * v2.y;\n  const x = (x1 + x2) / 2;\n  const y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nclass SweepEvent {\n  // for ordering sweep events in the sweep event queue\n  static compare(a, b) {\n    // favor event with a point that the sweep line hits first\n    const ptCmp = SweepEvent.comparePoints(a.point, b.point);\n    if (ptCmp !== 0) return ptCmp;\n\n    // the points are the same, so link them if needed\n    if (a.point !== b.point) a.link(b);\n\n    // favor right events over left\n    if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1;\n\n    // we have two matching left or right endpoints\n    // ordering of this case is the same as for their segments\n    return Segment.compare(a.segment, b.segment);\n  }\n\n  // for ordering points in sweep line order\n  static comparePoints(aPt, bPt) {\n    if (aPt.x < bPt.x) return -1;\n    if (aPt.x > bPt.x) return 1;\n    if (aPt.y < bPt.y) return -1;\n    if (aPt.y > bPt.y) return 1;\n    return 0;\n  }\n\n  // Warning: 'point' input will be modified and re-used (for performance)\n  constructor(point, isLeft) {\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft;\n    // this.segment, this.otherSE set by factory\n  }\n  link(other) {\n    if (other.point === this.point) {\n      throw new Error(\"Tried to link already linked events\");\n    }\n    const otherEvents = other.point.events;\n    for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {\n      const evt = otherEvents[i];\n      this.point.events.push(evt);\n      evt.point = this.point;\n    }\n    this.checkForConsuming();\n  }\n\n  /* Do a pass over our linked events and check to see if any pair\n   * of segments match, and should be consumed. */\n  checkForConsuming() {\n    // FIXME: The loops in this method run O(n^2) => no good.\n    //        Maintain little ordered sweep event trees?\n    //        Can we maintaining an ordering that avoids the need\n    //        for the re-sorting with getLeftmostComparator in geom-out?\n\n    // Compare each pair of events to see if other events also match\n    const numEvents = this.point.events.length;\n    for (let i = 0; i < numEvents; i++) {\n      const evt1 = this.point.events[i];\n      if (evt1.segment.consumedBy !== undefined) continue;\n      for (let j = i + 1; j < numEvents; j++) {\n        const evt2 = this.point.events[j];\n        if (evt2.consumedBy !== undefined) continue;\n        if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n        evt1.segment.consume(evt2.segment);\n      }\n    }\n  }\n  getAvailableLinkedEvents() {\n    // point.events is always of length 2 or greater\n    const events = [];\n    for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {\n      const evt = this.point.events[i];\n      if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n        events.push(evt);\n      }\n    }\n    return events;\n  }\n\n  /**\n   * Returns a comparator function for sorting linked events that will\n   * favor the event that will give us the smallest left-side angle.\n   * All ring construction starts as low as possible heading to the right,\n   * so by always turning left as sharp as possible we'll get polygons\n   * without uncessary loops & holes.\n   *\n   * The comparator function has a compute cache such that it avoids\n   * re-computing already-computed values.\n   */\n  getLeftmostComparator(baseEvent) {\n    const cache = new Map();\n    const fillCache = linkedEvent => {\n      const nextEvent = linkedEvent.otherSE;\n      cache.set(linkedEvent, {\n        sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),\n        cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)\n      });\n    };\n    return (a, b) => {\n      if (!cache.has(a)) fillCache(a);\n      if (!cache.has(b)) fillCache(b);\n      const {\n        sine: asine,\n        cosine: acosine\n      } = cache.get(a);\n      const {\n        sine: bsine,\n        cosine: bcosine\n      } = cache.get(b);\n\n      // both on or above x-axis\n      if (asine >= 0 && bsine >= 0) {\n        if (acosine < bcosine) return 1;\n        if (acosine > bcosine) return -1;\n        return 0;\n      }\n\n      // both below x-axis\n      if (asine < 0 && bsine < 0) {\n        if (acosine < bcosine) return -1;\n        if (acosine > bcosine) return 1;\n        return 0;\n      }\n\n      // one above x-axis, one below\n      if (bsine < asine) return -1;\n      if (bsine > asine) return 1;\n      return 0;\n    };\n  }\n}\n\n// Give segments unique ID's to get consistent sorting of\n// segments and sweep events when all else is identical\nlet segmentId = 0;\nclass Segment {\n  /* This compare() function is for ordering segments in the sweep\n   * line tree, and does so according to the following criteria:\n   *\n   * Consider the vertical line that lies an infinestimal step to the\n   * right of the right-more of the two left endpoints of the input\n   * segments. Imagine slowly moving a point up from negative infinity\n   * in the increasing y direction. Which of the two segments will that\n   * point intersect first? That segment comes 'before' the other one.\n   *\n   * If neither segment would be intersected by such a line, (if one\n   * or more of the segments are vertical) then the line to be considered\n   * is directly on the right-more of the two left inputs.\n   */\n  static compare(a, b) {\n    const alx = a.leftSE.point.x;\n    const blx = b.leftSE.point.x;\n    const arx = a.rightSE.point.x;\n    const brx = b.rightSE.point.x;\n\n    // check if they're even in the same vertical plane\n    if (brx < alx) return 1;\n    if (arx < blx) return -1;\n    const aly = a.leftSE.point.y;\n    const bly = b.leftSE.point.y;\n    const ary = a.rightSE.point.y;\n    const bry = b.rightSE.point.y;\n\n    // is left endpoint of segment B the right-more?\n    if (alx < blx) {\n      // are the two segments in the same horizontal plane?\n      if (bly < aly && bly < ary) return 1;\n      if (bly > aly && bly > ary) return -1;\n\n      // is the B left endpoint colinear to segment A?\n      const aCmpBLeft = a.comparePoint(b.leftSE.point);\n      if (aCmpBLeft < 0) return 1;\n      if (aCmpBLeft > 0) return -1;\n\n      // is the A right endpoint colinear to segment B ?\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return -1;\n    }\n\n    // is left endpoint of segment A the right-more?\n    if (alx > blx) {\n      if (aly < bly && aly < bry) return -1;\n      if (aly > bly && aly > bry) return 1;\n\n      // is the A left endpoint colinear to segment B?\n      const bCmpALeft = b.comparePoint(a.leftSE.point);\n      if (bCmpALeft !== 0) return bCmpALeft;\n\n      // is the B right endpoint colinear to segment A?\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n\n      // colinear segments, consider the one with left-more\n      // left endpoint to be first (arbitrary?)\n      return 1;\n    }\n\n    // if we get here, the two left endpoints are in the same\n    // vertical plane, ie alx === blx\n\n    // consider the lower left-endpoint to come first\n    if (aly < bly) return -1;\n    if (aly > bly) return 1;\n\n    // left endpoints are identical\n    // check for colinearity by using the left-more right endpoint\n\n    // is the A right endpoint more left-more?\n    if (arx < brx) {\n      const bCmpARight = b.comparePoint(a.rightSE.point);\n      if (bCmpARight !== 0) return bCmpARight;\n    }\n\n    // is the B right endpoint more left-more?\n    if (arx > brx) {\n      const aCmpBRight = a.comparePoint(b.rightSE.point);\n      if (aCmpBRight < 0) return 1;\n      if (aCmpBRight > 0) return -1;\n    }\n    if (arx !== brx) {\n      // are these two [almost] vertical segments with opposite orientation?\n      // if so, the one with the lower right endpoint comes first\n      const ay = ary - aly;\n      const ax = arx - alx;\n      const by = bry - bly;\n      const bx = brx - blx;\n      if (ay > ax && by < bx) return 1;\n      if (ay < ax && by > bx) return -1;\n    }\n\n    // we have colinear segments with matching orientation\n    // consider the one with more left-more right endpoint to be first\n    if (arx > brx) return 1;\n    if (arx < brx) return -1;\n\n    // if we get here, two two right endpoints are in the same\n    // vertical plane, ie arx === brx\n\n    // consider the lower right-endpoint to come first\n    if (ary < bry) return -1;\n    if (ary > bry) return 1;\n\n    // right endpoints identical as well, so the segments are idential\n    // fall back on creation order as consistent tie-breaker\n    if (a.id < b.id) return -1;\n    if (a.id > b.id) return 1;\n\n    // identical segment, ie a === b\n    return 0;\n  }\n\n  /* Warning: a reference to ringWindings input will be stored,\n   *  and possibly will be later modified */\n  constructor(leftSE, rightSE, rings, windings) {\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings;\n    // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n  static fromRing(pt1, pt2, ring) {\n    let leftPt, rightPt, winding;\n\n    // ordering the two points according to sweep line ordering\n    const cmpPts = SweepEvent.comparePoints(pt1, pt2);\n    if (cmpPts < 0) {\n      leftPt = pt1;\n      rightPt = pt2;\n      winding = 1;\n    } else if (cmpPts > 0) {\n      leftPt = pt2;\n      rightPt = pt1;\n      winding = -1;\n    } else throw new Error(`Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`);\n    const leftSE = new SweepEvent(leftPt, true);\n    const rightSE = new SweepEvent(rightPt, false);\n    return new Segment(leftSE, rightSE, [ring], [winding]);\n  }\n\n  /* When a segment is split, the rightSE is replaced with a new sweep event */\n  replaceRightSE(newRightSE) {\n    this.rightSE = newRightSE;\n    this.rightSE.segment = this;\n    this.rightSE.otherSE = this.leftSE;\n    this.leftSE.otherSE = this.rightSE;\n  }\n  bbox() {\n    const y1 = this.leftSE.point.y;\n    const y2 = this.rightSE.point.y;\n    return {\n      ll: {\n        x: this.leftSE.point.x,\n        y: y1 < y2 ? y1 : y2\n      },\n      ur: {\n        x: this.rightSE.point.x,\n        y: y1 > y2 ? y1 : y2\n      }\n    };\n  }\n\n  /* A vector from the left point to the right */\n  vector() {\n    return {\n      x: this.rightSE.point.x - this.leftSE.point.x,\n      y: this.rightSE.point.y - this.leftSE.point.y\n    };\n  }\n  isAnEndpoint(pt) {\n    return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n  }\n\n  /* Compare this segment with a point.\n   *\n   * A point P is considered to be colinear to a segment if there\n   * exists a distance D such that if we travel along the segment\n   * from one * endpoint towards the other a distance D, we find\n   * ourselves at point P.\n   *\n   * Return value indicates:\n   *\n   *   1: point lies above the segment (to the left of vertical)\n   *   0: point is colinear to segment\n   *  -1: point lies below the segment (to the right of vertical)\n   */\n  comparePoint(point) {\n    if (this.isAnEndpoint(point)) return 0;\n    const lPt = this.leftSE.point;\n    const rPt = this.rightSE.point;\n    const v = this.vector();\n\n    // Exactly vertical segments.\n    if (lPt.x === rPt.x) {\n      if (point.x === lPt.x) return 0;\n      return point.x < lPt.x ? 1 : -1;\n    }\n\n    // Nearly vertical segments with an intersection.\n    // Check to see where a point on the line with matching Y coordinate is.\n    const yDist = (point.y - lPt.y) / v.y;\n    const xFromYDist = lPt.x + yDist * v.x;\n    if (point.x === xFromYDist) return 0;\n\n    // General case.\n    // Check to see where a point on the line with matching X coordinate is.\n    const xDist = (point.x - lPt.x) / v.x;\n    const yFromXDist = lPt.y + xDist * v.y;\n    if (point.y === yFromXDist) return 0;\n    return point.y < yFromXDist ? -1 : 1;\n  }\n\n  /**\n   * Given another segment, returns the first non-trivial intersection\n   * between the two segments (in terms of sweep line ordering), if it exists.\n   *\n   * A 'non-trivial' intersection is one that will cause one or both of the\n   * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n   *\n   *   * endpoint of segA with endpoint of segB --> trivial\n   *   * endpoint of segA with point along segB --> non-trivial\n   *   * endpoint of segB with point along segA --> non-trivial\n   *   * point along segA with point along segB --> non-trivial\n   *\n   * If no non-trivial intersection exists, return null\n   * Else, return null.\n   */\n  getIntersection(other) {\n    // If bboxes don't overlap, there can't be any intersections\n    const tBbox = this.bbox();\n    const oBbox = other.bbox();\n    const bboxOverlap = getBboxOverlap(tBbox, oBbox);\n    if (bboxOverlap === null) return null;\n\n    // We first check to see if the endpoints can be considered intersections.\n    // This will 'snap' intersections to endpoints if possible, and will\n    // handle cases of colinearity.\n\n    const tlp = this.leftSE.point;\n    const trp = this.rightSE.point;\n    const olp = other.leftSE.point;\n    const orp = other.rightSE.point;\n\n    // does each endpoint touch the other segment?\n    // note that we restrict the 'touching' definition to only allow segments\n    // to touch endpoints that lie forward from where we are in the sweep line pass\n    const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n    const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n    const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n    const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;\n\n    // do left endpoints match?\n    if (touchesThisLSE && touchesOtherLSE) {\n      // these two cases are for colinear segments with matching left\n      // endpoints, and one segment being longer than the other\n      if (touchesThisRSE && !touchesOtherRSE) return trp;\n      if (!touchesThisRSE && touchesOtherRSE) return orp;\n      // either the two segments match exactly (two trival intersections)\n      // or just on their left endpoint (one trivial intersection\n      return null;\n    }\n\n    // does this left endpoint matches (other doesn't)\n    if (touchesThisLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesOtherRSE) {\n        if (tlp.x === orp.x && tlp.y === orp.y) return null;\n      }\n      // t-intersection on left endpoint\n      return tlp;\n    }\n\n    // does other left endpoint matches (this doesn't)\n    if (touchesOtherLSE) {\n      // check for segments that just intersect on opposing endpoints\n      if (touchesThisRSE) {\n        if (trp.x === olp.x && trp.y === olp.y) return null;\n      }\n      // t-intersection on left endpoint\n      return olp;\n    }\n\n    // trivial intersection on right endpoints\n    if (touchesThisRSE && touchesOtherRSE) return null;\n\n    // t-intersections on just one right endpoint\n    if (touchesThisRSE) return trp;\n    if (touchesOtherRSE) return orp;\n\n    // None of our endpoints intersect. Look for a general intersection between\n    // infinite lines laid over the segments\n    const pt = intersection$1(tlp, this.vector(), olp, other.vector());\n\n    // are the segments parrallel? Note that if they were colinear with overlap,\n    // they would have an endpoint intersection and that case was already handled above\n    if (pt === null) return null;\n\n    // is the intersection found between the lines not on the segments?\n    if (!isInBbox(bboxOverlap, pt)) return null;\n\n    // round the the computed point if needed\n    return rounder.round(pt.x, pt.y);\n  }\n\n  /**\n   * Split the given segment into multiple segments on the given points.\n   *  * Each existing segment will retain its leftSE and a new rightSE will be\n   *    generated for it.\n   *  * A new segment will be generated which will adopt the original segment's\n   *    rightSE, and a new leftSE will be generated for it.\n   *  * If there are more than two points given to split on, new segments\n   *    in the middle will be generated with new leftSE and rightSE's.\n   *  * An array of the newly generated SweepEvents will be returned.\n   *\n   * Warning: input array of points is modified\n   */\n  split(point) {\n    const newEvents = [];\n    const alreadyLinked = point.events !== undefined;\n    const newLeftSE = new SweepEvent(point, true);\n    const newRightSE = new SweepEvent(point, false);\n    const oldRightSE = this.rightSE;\n    this.replaceRightSE(newRightSE);\n    newEvents.push(newRightSE);\n    newEvents.push(newLeftSE);\n    const newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice());\n\n    // when splitting a nearly vertical downward-facing segment,\n    // sometimes one of the resulting new segments is vertical, in which\n    // case its left and right events may need to be swapped\n    if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n      newSeg.swapEvents();\n    }\n    if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n      this.swapEvents();\n    }\n\n    // in the point we just used to create new sweep events with was already\n    // linked to other events, we need to check if either of the affected\n    // segments should be consumed\n    if (alreadyLinked) {\n      newLeftSE.checkForConsuming();\n      newRightSE.checkForConsuming();\n    }\n    return newEvents;\n  }\n\n  /* Swap which event is left and right */\n  swapEvents() {\n    const tmpEvt = this.rightSE;\n    this.rightSE = this.leftSE;\n    this.leftSE = tmpEvt;\n    this.leftSE.isLeft = true;\n    this.rightSE.isLeft = false;\n    for (let i = 0, iMax = this.windings.length; i < iMax; i++) {\n      this.windings[i] *= -1;\n    }\n  }\n\n  /* Consume another segment. We take their rings under our wing\n   * and mark them as consumed. Use for perfectly overlapping segments */\n  consume(other) {\n    let consumer = this;\n    let consumee = other;\n    while (consumer.consumedBy) consumer = consumer.consumedBy;\n    while (consumee.consumedBy) consumee = consumee.consumedBy;\n    const cmp = Segment.compare(consumer, consumee);\n    if (cmp === 0) return; // already consumed\n    // the winner of the consumption is the earlier segment\n    // according to sweep line ordering\n    if (cmp > 0) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n\n    // make sure a segment doesn't consume it's prev\n    if (consumer.prev === consumee) {\n      const tmp = consumer;\n      consumer = consumee;\n      consumee = tmp;\n    }\n    for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n      const ring = consumee.rings[i];\n      const winding = consumee.windings[i];\n      const index = consumer.rings.indexOf(ring);\n      if (index === -1) {\n        consumer.rings.push(ring);\n        consumer.windings.push(winding);\n      } else consumer.windings[index] += winding;\n    }\n    consumee.rings = null;\n    consumee.windings = null;\n    consumee.consumedBy = consumer;\n\n    // mark sweep events consumed as to maintain ordering in sweep event queue\n    consumee.leftSE.consumedBy = consumer.leftSE;\n    consumee.rightSE.consumedBy = consumer.rightSE;\n  }\n\n  /* The first segment previous segment chain that is in the result */\n  prevInResult() {\n    if (this._prevInResult !== undefined) return this._prevInResult;\n    if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n    return this._prevInResult;\n  }\n  beforeState() {\n    if (this._beforeState !== undefined) return this._beforeState;\n    if (!this.prev) this._beforeState = {\n      rings: [],\n      windings: [],\n      multiPolys: []\n    };else {\n      const seg = this.prev.consumedBy || this.prev;\n      this._beforeState = seg.afterState();\n    }\n    return this._beforeState;\n  }\n  afterState() {\n    if (this._afterState !== undefined) return this._afterState;\n    const beforeState = this.beforeState();\n    this._afterState = {\n      rings: beforeState.rings.slice(0),\n      windings: beforeState.windings.slice(0),\n      multiPolys: []\n    };\n    const ringsAfter = this._afterState.rings;\n    const windingsAfter = this._afterState.windings;\n    const mpsAfter = this._afterState.multiPolys;\n\n    // calculate ringsAfter, windingsAfter\n    for (let i = 0, iMax = this.rings.length; i < iMax; i++) {\n      const ring = this.rings[i];\n      const winding = this.windings[i];\n      const index = ringsAfter.indexOf(ring);\n      if (index === -1) {\n        ringsAfter.push(ring);\n        windingsAfter.push(winding);\n      } else windingsAfter[index] += winding;\n    }\n\n    // calcualte polysAfter\n    const polysAfter = [];\n    const polysExclude = [];\n    for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {\n      if (windingsAfter[i] === 0) continue; // non-zero rule\n      const ring = ringsAfter[i];\n      const poly = ring.poly;\n      if (polysExclude.indexOf(poly) !== -1) continue;\n      if (ring.isExterior) polysAfter.push(poly);else {\n        if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n        const index = polysAfter.indexOf(ring.poly);\n        if (index !== -1) polysAfter.splice(index, 1);\n      }\n    }\n\n    // calculate multiPolysAfter\n    for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {\n      const mp = polysAfter[i].multiPoly;\n      if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n    }\n    return this._afterState;\n  }\n\n  /* Is this segment part of the final result? */\n  isInResult() {\n    // if we've been consumed, we're not in the result\n    if (this.consumedBy) return false;\n    if (this._isInResult !== undefined) return this._isInResult;\n    const mpsBefore = this.beforeState().multiPolys;\n    const mpsAfter = this.afterState().multiPolys;\n    switch (operation.type) {\n      case \"union\":\n        {\n          // UNION - included iff:\n          //  * On one side of us there is 0 poly interiors AND\n          //  * On the other side there is 1 or more.\n          const noBefores = mpsBefore.length === 0;\n          const noAfters = mpsAfter.length === 0;\n          this._isInResult = noBefores !== noAfters;\n          break;\n        }\n      case \"intersection\":\n        {\n          // INTERSECTION - included iff:\n          //  * on one side of us all multipolys are rep. with poly interiors AND\n          //  * on the other side of us, not all multipolys are repsented\n          //    with poly interiors\n          let least;\n          let most;\n          if (mpsBefore.length < mpsAfter.length) {\n            least = mpsBefore.length;\n            most = mpsAfter.length;\n          } else {\n            least = mpsAfter.length;\n            most = mpsBefore.length;\n          }\n          this._isInResult = most === operation.numMultiPolys && least < most;\n          break;\n        }\n      case \"xor\":\n        {\n          // XOR - included iff:\n          //  * the difference between the number of multipolys represented\n          //    with poly interiors on our two sides is an odd number\n          const diff = Math.abs(mpsBefore.length - mpsAfter.length);\n          this._isInResult = diff % 2 === 1;\n          break;\n        }\n      case \"difference\":\n        {\n          // DIFFERENCE included iff:\n          //  * on exactly one side, we have just the subject\n          const isJustSubject = mps => mps.length === 1 && mps[0].isSubject;\n          this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n          break;\n        }\n      default:\n        throw new Error(`Unrecognized operation type found ${operation.type}`);\n    }\n    return this._isInResult;\n  }\n}\n\nclass RingIn {\n  constructor(geomRing, poly, isExterior) {\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n    if (typeof geomRing[0][0] !== \"number\" || typeof geomRing[0][1] !== \"number\") {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    const firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    let prevPoint = firstPoint;\n    for (let i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== \"number\" || typeof geomRing[i][1] !== \"number\") {\n        throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n      }\n      let point = rounder.round(geomRing[i][0], geomRing[i][1]);\n      // skip repeated points\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    }\n    // add segment from last to first if last is not the same as first\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.segments.length; i < iMax; i++) {\n      const segment = this.segments[i];\n      sweepEvents.push(segment.leftSE);\n      sweepEvents.push(segment.rightSE);\n    }\n    return sweepEvents;\n  }\n}\nclass PolyIn {\n  constructor(geomPoly, multiPoly) {\n    if (!Array.isArray(geomPoly)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    this.exteriorRing = new RingIn(geomPoly[0], this, true);\n    // copy by value\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n    for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      const ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n    this.multiPoly = multiPoly;\n  }\n  getSweepEvents() {\n    const sweepEvents = this.exteriorRing.getSweepEvents();\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringSweepEvents = this.interiorRings[i].getSweepEvents();\n      for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(ringSweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n}\nclass MultiPolyIn {\n  constructor(geom, isSubject) {\n    if (!Array.isArray(geom)) {\n      throw new Error(\"Input geometry is not a valid Polygon or MultiPolygon\");\n    }\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === \"number\") geom = [geom];\n    } catch (ex) {\n      // The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n    for (let i = 0, iMax = geom.length; i < iMax; i++) {\n      const poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n    this.isSubject = isSubject;\n  }\n  getSweepEvents() {\n    const sweepEvents = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polySweepEvents = this.polys[i].getSweepEvents();\n      for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n        sweepEvents.push(polySweepEvents[j]);\n      }\n    }\n    return sweepEvents;\n  }\n}\n\nclass RingOut {\n  /* Given the segments from the sweep line pass, compute & return a series\n   * of closed rings from all the segments marked to be part of the result */\n  static factory(allSegments) {\n    const ringsOut = [];\n    for (let i = 0, iMax = allSegments.length; i < iMax; i++) {\n      const segment = allSegments[i];\n      if (!segment.isInResult() || segment.ringOut) continue;\n      let prevEvent = null;\n      let event = segment.leftSE;\n      let nextEvent = segment.rightSE;\n      const events = [event];\n      const startingPoint = event.point;\n      const intersectionLEs = [];\n\n      /* Walk the chain of linked events to form a closed ring */\n      while (true) {\n        prevEvent = event;\n        event = nextEvent;\n        events.push(event);\n\n        /* Is the ring complete? */\n        if (event.point === startingPoint) break;\n        while (true) {\n          const availableLEs = event.getAvailableLinkedEvents();\n\n          /* Did we hit a dead end? This shouldn't happen.\n           * Indicates some earlier part of the algorithm malfunctioned. */\n          if (availableLEs.length === 0) {\n            const firstPt = events[0].point;\n            const lastPt = events[events.length - 1].point;\n            throw new Error(`Unable to complete output ring starting at [${firstPt.x},` + ` ${firstPt.y}]. Last matching segment found ends at` + ` [${lastPt.x}, ${lastPt.y}].`);\n          }\n\n          /* Only one way to go, so cotinue on the path */\n          if (availableLEs.length === 1) {\n            nextEvent = availableLEs[0].otherSE;\n            break;\n          }\n\n          /* We must have an intersection. Check for a completed loop */\n          let indexLE = null;\n          for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n            if (intersectionLEs[j].point === event.point) {\n              indexLE = j;\n              break;\n            }\n          }\n          /* Found a completed loop. Cut that off and make a ring */\n          if (indexLE !== null) {\n            const intersectionLE = intersectionLEs.splice(indexLE)[0];\n            const ringEvents = events.splice(intersectionLE.index);\n            ringEvents.unshift(ringEvents[0].otherSE);\n            ringsOut.push(new RingOut(ringEvents.reverse()));\n            continue;\n          }\n          /* register the intersection */\n          intersectionLEs.push({\n            index: events.length,\n            point: event.point\n          });\n          /* Choose the left-most option to continue the walk */\n          const comparator = event.getLeftmostComparator(prevEvent);\n          nextEvent = availableLEs.sort(comparator)[0].otherSE;\n          break;\n        }\n      }\n      ringsOut.push(new RingOut(events));\n    }\n    return ringsOut;\n  }\n  constructor(events) {\n    this.events = events;\n    for (let i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n    this.poly = null;\n  }\n  getGeom() {\n    // Remove superfluous points (ie extra points along a straight line),\n    let prevPt = this.events[0].point;\n    const points = [prevPt];\n    for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n      const pt = this.events[i].point;\n      const nextPt = this.events[i + 1].point;\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) continue;\n      points.push(pt);\n      prevPt = pt;\n    }\n\n    // ring was all (within rounding error of angle calc) colinear points\n    if (points.length === 1) return null;\n\n    // check if the starting point is necessary\n    const pt = points[0];\n    const nextPt = points[1];\n    if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n    points.push(points[0]);\n    const step = this.isExteriorRing() ? 1 : -1;\n    const iStart = this.isExteriorRing() ? 0 : points.length - 1;\n    const iEnd = this.isExteriorRing() ? points.length : -1;\n    const orderedPoints = [];\n    for (let i = iStart; i != iEnd; i += step) orderedPoints.push([points[i].x, points[i].y]);\n    return orderedPoints;\n  }\n  isExteriorRing() {\n    if (this._isExteriorRing === undefined) {\n      const enclosing = this.enclosingRing();\n      this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n    }\n    return this._isExteriorRing;\n  }\n  enclosingRing() {\n    if (this._enclosingRing === undefined) {\n      this._enclosingRing = this._calcEnclosingRing();\n    }\n    return this._enclosingRing;\n  }\n\n  /* Returns the ring that encloses this one, if any */\n  _calcEnclosingRing() {\n    // start with the ealier sweep line event so that the prevSeg\n    // chain doesn't lead us inside of a loop of ours\n    let leftMostEvt = this.events[0];\n    for (let i = 1, iMax = this.events.length; i < iMax; i++) {\n      const evt = this.events[i];\n      if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n    }\n    let prevSeg = leftMostEvt.segment.prevInResult();\n    let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    while (true) {\n      // no segment found, thus no ring can enclose us\n      if (!prevSeg) return null;\n\n      // no segments below prev segment found, thus the ring of the prev\n      // segment must loop back around and enclose us\n      if (!prevPrevSeg) return prevSeg.ringOut;\n\n      // if the two segments are of different rings, the ring of the prev\n      // segment must either loop around us or the ring of the prev prev\n      // seg, which would make us and the ring of the prev peers\n      if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n        if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n          return prevSeg.ringOut;\n        } else return prevSeg.ringOut.enclosingRing();\n      }\n\n      // two segments are from the same ring, so this was a penisula\n      // of that ring. iterate downward, keep searching\n      prevSeg = prevPrevSeg.prevInResult();\n      prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n    }\n  }\n}\nclass PolyOut {\n  constructor(exteriorRing) {\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n  addInterior(ring) {\n    this.interiorRings.push(ring);\n    ring.poly = this;\n  }\n  getGeom() {\n    const geom = [this.exteriorRing.getGeom()];\n    // exterior ring was all (within rounding error of angle calc) colinear points\n    if (geom[0] === null) return null;\n    for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n      const ringGeom = this.interiorRings[i].getGeom();\n      // interior ring was all (within rounding error of angle calc) colinear points\n      if (ringGeom === null) continue;\n      geom.push(ringGeom);\n    }\n    return geom;\n  }\n}\nclass MultiPolyOut {\n  constructor(rings) {\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n  getGeom() {\n    const geom = [];\n    for (let i = 0, iMax = this.polys.length; i < iMax; i++) {\n      const polyGeom = this.polys[i].getGeom();\n      // exterior ring was all (within rounding error of angle calc) colinear points\n      if (polyGeom === null) continue;\n      geom.push(polyGeom);\n    }\n    return geom;\n  }\n  _composePolys(rings) {\n    const polys = [];\n    for (let i = 0, iMax = rings.length; i < iMax; i++) {\n      const ring = rings[i];\n      if (ring.poly) continue;\n      if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n        const enclosingRing = ring.enclosingRing();\n        if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n        enclosingRing.poly.addInterior(ring);\n      }\n    }\n    return polys;\n  }\n}\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nclass SweepLine {\n  constructor(queue) {\n    let comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n    this.queue = queue;\n    this.tree = new splaytree__WEBPACK_IMPORTED_MODULE_0__[\"default\"](comparator);\n    this.segments = [];\n  }\n  process(event) {\n    const segment = event.segment;\n    const newEvents = [];\n\n    // if we've already been consumed by another segment,\n    // clean up our body parts and get out\n    if (event.consumedBy) {\n      if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n      return newEvents;\n    }\n    const node = event.isLeft ? this.tree.add(segment) : this.tree.find(segment);\n    if (!node) throw new Error(`Unable to find segment #${segment.id} ` + `[${segment.leftSE.point.x}, ${segment.leftSE.point.y}] -> ` + `[${segment.rightSE.point.x}, ${segment.rightSE.point.y}] ` + \"in SweepLine tree.\");\n    let prevNode = node;\n    let nextNode = node;\n    let prevSeg = undefined;\n    let nextSeg = undefined;\n\n    // skip consumed segments still in tree\n    while (prevSeg === undefined) {\n      prevNode = this.tree.prev(prevNode);\n      if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n    }\n\n    // skip consumed segments still in tree\n    while (nextSeg === undefined) {\n      nextNode = this.tree.next(nextNode);\n      if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n    }\n    if (event.isLeft) {\n      // Check for intersections against the previous segment in the sweep line\n      let prevMySplitter = null;\n      if (prevSeg) {\n        const prevInter = prevSeg.getIntersection(segment);\n        if (prevInter !== null) {\n          if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n          if (!prevSeg.isAnEndpoint(prevInter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n\n      // Check for intersections against the next segment in the sweep line\n      let nextMySplitter = null;\n      if (nextSeg) {\n        const nextInter = nextSeg.getIntersection(segment);\n        if (nextInter !== null) {\n          if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n          if (!nextSeg.isAnEndpoint(nextInter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n\n      // For simplicity, even if we find more than one intersection we only\n      // spilt on the 'earliest' (sweep-line style) of the intersections.\n      // The other intersection will be handled in a future process().\n      if (prevMySplitter !== null || nextMySplitter !== null) {\n        let mySplitter = null;\n        if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n          const cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n          mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n        }\n\n        // Rounding errors can cause changes in ordering,\n        // so remove afected segments and right sweep events before splitting\n        this.queue.remove(segment.rightSE);\n        newEvents.push(segment.rightSE);\n        const newEventsFromSplit = segment.split(mySplitter);\n        for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n          newEvents.push(newEventsFromSplit[i]);\n        }\n      }\n      if (newEvents.length > 0) {\n        // We found some intersections, so re-do the current event to\n        // make sure sweep line ordering is totally consistent for later\n        // use with the segment 'prev' pointers\n        this.tree.remove(segment);\n        newEvents.push(event);\n      } else {\n        // done with left event\n        this.segments.push(segment);\n        segment.prev = prevSeg;\n      }\n    } else {\n      // event.isRight\n\n      // since we're about to be removed from the sweep line, check for\n      // intersections between our previous and next segments\n      if (prevSeg && nextSeg) {\n        const inter = prevSeg.getIntersection(nextSeg);\n        if (inter !== null) {\n          if (!prevSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(prevSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n          if (!nextSeg.isAnEndpoint(inter)) {\n            const newEventsFromSplit = this._splitSafely(nextSeg, inter);\n            for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n              newEvents.push(newEventsFromSplit[i]);\n            }\n          }\n        }\n      }\n      this.tree.remove(segment);\n    }\n    return newEvents;\n  }\n\n  /* Safely split a segment that is currently in the datastructures\n   * IE - a segment other than the one that is currently being processed. */\n  _splitSafely(seg, pt) {\n    // Rounding errors can cause changes in ordering,\n    // so remove afected segments and right sweep events before splitting\n    // removeNode() doesn't work, so have re-find the seg\n    // https://github.com/w8r/splay-tree/pull/5\n    this.tree.remove(seg);\n    const rightSE = seg.rightSE;\n    this.queue.remove(rightSE);\n    const newEvents = seg.split(pt);\n    newEvents.push(rightSE);\n    // splitting can trigger consumption\n    if (seg.consumedBy === undefined) this.tree.add(seg);\n    return newEvents;\n  }\n}\n\n// Limits on iterative processes to prevent infinite loops - usually caused by floating-point math round-off errors.\nconst POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nconst POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== \"undefined\" && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nclass Operation {\n  run(type, geom, moreGeoms) {\n    operation.type = type;\n    rounder.reset();\n\n    /* Convert inputs to MultiPoly objects */\n    const multipolys = [new MultiPolyIn(geom, true)];\n    for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n      multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n    }\n    operation.numMultiPolys = multipolys.length;\n\n    /* BBox optimization for difference operation\n     * If the bbox of a multipolygon that's part of the clipping doesn't\n     * intersect the bbox of the subject at all, we can just drop that\n     * multiploygon. */\n    if (operation.type === \"difference\") {\n      // in place removal\n      const subject = multipolys[0];\n      let i = 1;\n      while (i < multipolys.length) {\n        if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null) i++;else multipolys.splice(i, 1);\n      }\n    }\n\n    /* BBox optimization for intersection operation\n     * If we can find any pair of multipolygons whose bbox does not overlap,\n     * then the result will be empty. */\n    if (operation.type === \"intersection\") {\n      // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n      //       it could be optimized to O(n * ln(n))\n      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n        const mpA = multipolys[i];\n        for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {\n          if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n        }\n      }\n    }\n\n    /* Put segment endpoints in a priority queue */\n    const queue = new splaytree__WEBPACK_IMPORTED_MODULE_0__[\"default\"](SweepEvent.compare);\n    for (let i = 0, iMax = multipolys.length; i < iMax; i++) {\n      const sweepEvents = multipolys[i].getSweepEvents();\n      for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {\n        queue.insert(sweepEvents[j]);\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error(\"Infinite loop when putting segment endpoints in a priority queue \" + \"(queue size too big).\");\n        }\n      }\n    }\n\n    /* Pass the sweep line over those endpoints */\n    const sweepLine = new SweepLine(queue);\n    let prevQueueSize = queue.size;\n    let node = queue.pop();\n    while (node) {\n      const evt = node.key;\n      if (queue.size === prevQueueSize) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        const seg = evt.segment;\n        throw new Error(`Unable to pop() ${evt.isLeft ? \"left\" : \"right\"} SweepEvent ` + `[${evt.point.x}, ${evt.point.y}] from segment #${seg.id} ` + `[${seg.leftSE.point.x}, ${seg.leftSE.point.y}] -> ` + `[${seg.rightSE.point.x}, ${seg.rightSE.point.y}] from queue.`);\n      }\n      if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(queue size too big).\");\n      }\n      if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n        // prevents an infinite loop, an otherwise common manifestation of bugs\n        throw new Error(\"Infinite loop when passing sweep line over endpoints \" + \"(too many sweep line segments).\");\n      }\n      const newEvents = sweepLine.process(evt);\n      for (let i = 0, iMax = newEvents.length; i < iMax; i++) {\n        const evt = newEvents[i];\n        if (evt.consumedBy === undefined) queue.insert(evt);\n      }\n      prevQueueSize = queue.size;\n      node = queue.pop();\n    }\n\n    // free some memory we don't need anymore\n    rounder.reset();\n\n    /* Collect and compile segments we're keeping into a multipolygon */\n    const ringsOut = RingOut.factory(sweepLine.segments);\n    const result = new MultiPolyOut(ringsOut);\n    return result.getGeom();\n  }\n}\n\n// singleton available by import\nconst operation = new Operation();\n\nconst union = function (geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n  return operation.run(\"union\", geom, moreGeoms);\n};\nconst intersection = function (geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n  return operation.run(\"intersection\", geom, moreGeoms);\n};\nconst xor = function (geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n  return operation.run(\"xor\", geom, moreGeoms);\n};\nconst difference = function (subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n  return operation.run(\"difference\", subjectGeom, clippingGeoms);\n};\nvar index = {\n  union: union,\n  intersection: intersection,\n  xor: xor,\n  difference: difference\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9seWdvbi1jbGlwcGluZy9kaXN0L3BvbHlnb24tY2xpcHBpbmcuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrQztBQUNXOztBQUU3QztBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQU0sa0JBQWtCLFFBQVE7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpREFBUztBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMkRBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxVQUFVO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU0sK0RBQStELE1BQU0sSUFBSSxNQUFNO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsZ0VBQWdFO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxlQUFlO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxVQUFVO0FBQ2hFO0FBQ0EscURBQXFELFVBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQSxxREFBcUQsVUFBVTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLFVBQVUsU0FBUyxVQUFVLCtDQUErQyxTQUFTLElBQUksU0FBUztBQUM3Szs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsV0FBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsVUFBVTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVksUUFBUSx1QkFBdUIsSUFBSSx1QkFBdUIsYUFBYSx3QkFBd0IsSUFBSSx3QkFBd0I7QUFDak07QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxVQUFVO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSw4REFBOEQ7QUFDL0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVU7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxVQUFVO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRDtBQUNBLHNEQUFzRCxVQUFVO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGlEQUFTO0FBQy9CLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtCQUErQixtQkFBbUIsWUFBWSxJQUFJLFlBQVksa0JBQWtCLFFBQVEsUUFBUSxtQkFBbUIsSUFBSSxtQkFBbUIsYUFBYSxvQkFBb0IsSUFBSSxvQkFBb0I7QUFDOVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhGQUE4RixhQUFhO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csZUFBZTtBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHLGVBQWU7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxlQUFlO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0QiIsInNvdXJjZXMiOlsid2VicGFjazovL2J1ZGJhc2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcG9seWdvbi1jbGlwcGluZy9kaXN0L3BvbHlnb24tY2xpcHBpbmcuZXNtLmpzP2Q5OGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFNwbGF5VHJlZSBmcm9tICdzcGxheXRyZWUnO1xuaW1wb3J0IHsgb3JpZW50MmQgfSBmcm9tICdyb2J1c3QtcHJlZGljYXRlcyc7XG5cbi8qKlxuICogQSBib3VuZGluZyBib3ggaGFzIHRoZSBmb3JtYXQ6XG4gKlxuICogIHsgbGw6IHsgeDogeG1pbiwgeTogeW1pbiB9LCB1cjogeyB4OiB4bWF4LCB5OiB5bWF4IH0gfVxuICpcbiAqL1xuXG5jb25zdCBpc0luQmJveCA9IChiYm94LCBwb2ludCkgPT4ge1xuICByZXR1cm4gYmJveC5sbC54IDw9IHBvaW50LnggJiYgcG9pbnQueCA8PSBiYm94LnVyLnggJiYgYmJveC5sbC55IDw9IHBvaW50LnkgJiYgcG9pbnQueSA8PSBiYm94LnVyLnk7XG59O1xuXG4vKiBSZXR1cm5zIGVpdGhlciBudWxsLCBvciBhIGJib3ggKGFrYSBhbiBvcmRlcmVkIHBhaXIgb2YgcG9pbnRzKVxuICogSWYgdGhlcmUgaXMgb25seSBvbmUgcG9pbnQgb2Ygb3ZlcmxhcCwgYSBiYm94IHdpdGggaWRlbnRpY2FsIHBvaW50c1xuICogd2lsbCBiZSByZXR1cm5lZCAqL1xuY29uc3QgZ2V0QmJveE92ZXJsYXAgPSAoYjEsIGIyKSA9PiB7XG4gIC8vIGNoZWNrIGlmIHRoZSBiYm94ZXMgb3ZlcmxhcCBhdCBhbGxcbiAgaWYgKGIyLnVyLnggPCBiMS5sbC54IHx8IGIxLnVyLnggPCBiMi5sbC54IHx8IGIyLnVyLnkgPCBiMS5sbC55IHx8IGIxLnVyLnkgPCBiMi5sbC55KSByZXR1cm4gbnVsbDtcblxuICAvLyBmaW5kIHRoZSBtaWRkbGUgdHdvIFggdmFsdWVzXG4gIGNvbnN0IGxvd2VyWCA9IGIxLmxsLnggPCBiMi5sbC54ID8gYjIubGwueCA6IGIxLmxsLng7XG4gIGNvbnN0IHVwcGVyWCA9IGIxLnVyLnggPCBiMi51ci54ID8gYjEudXIueCA6IGIyLnVyLng7XG5cbiAgLy8gZmluZCB0aGUgbWlkZGxlIHR3byBZIHZhbHVlc1xuICBjb25zdCBsb3dlclkgPSBiMS5sbC55IDwgYjIubGwueSA/IGIyLmxsLnkgOiBiMS5sbC55O1xuICBjb25zdCB1cHBlclkgPSBiMS51ci55IDwgYjIudXIueSA/IGIxLnVyLnkgOiBiMi51ci55O1xuXG4gIC8vIHB1dCB0aG9zZSBtaWRkbGUgdmFsdWVzIHRvZ2V0aGVyIHRvIGdldCB0aGUgb3ZlcmxhcFxuICByZXR1cm4ge1xuICAgIGxsOiB7XG4gICAgICB4OiBsb3dlclgsXG4gICAgICB5OiBsb3dlcllcbiAgICB9LFxuICAgIHVyOiB7XG4gICAgICB4OiB1cHBlclgsXG4gICAgICB5OiB1cHBlcllcbiAgICB9XG4gIH07XG59O1xuXG4vKiBKYXZhc2NyaXB0IGRvZXNuJ3QgZG8gaW50ZWdlciBtYXRoLiBFdmVyeXRoaW5nIGlzXG4gKiBmbG9hdGluZyBwb2ludCB3aXRoIHBlcmNpc2lvbiBOdW1iZXIuRVBTSUxPTi5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvRVBTSUxPTlxuICovXG5cbmxldCBlcHNpbG9uID0gTnVtYmVyLkVQU0lMT047XG5cbi8vIElFIFBvbHlmaWxsXG5pZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSBlcHNpbG9uID0gTWF0aC5wb3coMiwgLTUyKTtcbmNvbnN0IEVQU0lMT05fU1EgPSBlcHNpbG9uICogZXBzaWxvbjtcblxuLyogRkxQIGNvbXBhcmF0b3IgKi9cbmNvbnN0IGNtcCA9IChhLCBiKSA9PiB7XG4gIC8vIGNoZWNrIGlmIHRoZXkncmUgYm90aCAwXG4gIGlmICgtZXBzaWxvbiA8IGEgJiYgYSA8IGVwc2lsb24pIHtcbiAgICBpZiAoLWVwc2lsb24gPCBiICYmIGIgPCBlcHNpbG9uKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICAvLyBjaGVjayBpZiB0aGV5J3JlIGZscCBlcXVhbFxuICBjb25zdCBhYiA9IGEgLSBiO1xuICBpZiAoYWIgKiBhYiA8IEVQU0lMT05fU1EgKiBhICogYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gbm9ybWFsIGNvbXBhcmlzb25cbiAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xufTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIHJvdW5kcyBpbmNvbWluZyB2YWx1ZXMgc3VmZmljaWVudGx5IHNvIHRoYXRcbiAqIGZsb2F0aW5nIHBvaW50cyBwcm9ibGVtcyBhcmUsIGZvciB0aGUgbW9zdCBwYXJ0LCBhdm9pZGVkLlxuICpcbiAqIEluY29taW5nIHBvaW50cyBhcmUgaGF2ZSB0aGVpciB4ICYgeSB2YWx1ZXMgdGVzdGVkIGFnYWluc3RcbiAqIGFsbCBwcmV2aW91c2x5IHNlZW4geCAmIHkgdmFsdWVzLiBJZiBlaXRoZXIgaXMgJ3RvbyBjbG9zZSdcbiAqIHRvIGEgcHJldmlvdXNseSBzZWVuIHZhbHVlLCBpdCdzIHZhbHVlIGlzICdzbmFwcGVkJyB0byB0aGVcbiAqIHByZXZpb3VzbHkgc2VlbiB2YWx1ZS5cbiAqXG4gKiBBbGwgcG9pbnRzIHNob3VsZCBiZSByb3VuZGVkIGJ5IHRoaXMgY2xhc3MgYmVmb3JlIGJlaW5nXG4gKiBzdG9yZWQgaW4gYW55IGRhdGEgc3RydWN0dXJlcyBpbiB0aGUgcmVzdCBvZiB0aGlzIGFsZ29yaXRobS5cbiAqL1xuXG5jbGFzcyBQdFJvdW5kZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy54Um91bmRlciA9IG5ldyBDb29yZFJvdW5kZXIoKTtcbiAgICB0aGlzLnlSb3VuZGVyID0gbmV3IENvb3JkUm91bmRlcigpO1xuICB9XG4gIHJvdW5kKHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy54Um91bmRlci5yb3VuZCh4KSxcbiAgICAgIHk6IHRoaXMueVJvdW5kZXIucm91bmQoeSlcbiAgICB9O1xuICB9XG59XG5jbGFzcyBDb29yZFJvdW5kZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRyZWUgPSBuZXcgU3BsYXlUcmVlKCk7XG4gICAgLy8gcHJlc2VlZCB3aXRoIDAgc28gd2UgZG9uJ3QgZW5kIHVwIHdpdGggdmFsdWVzIDwgTnVtYmVyLkVQU0lMT05cbiAgICB0aGlzLnJvdW5kKDApO1xuICB9XG5cbiAgLy8gTm90ZTogdGhpcyBjYW4gcm91bmRzIGlucHV0IHZhbHVlcyBiYWNrd2FyZHMgb3IgZm9yd2FyZHMuXG4gIC8vICAgICAgIFlvdSBtaWdodCBhc2ssIHdoeSBub3QgcmVzdHJpY3QgdGhpcyB0byBqdXN0IHJvdW5kaW5nXG4gIC8vICAgICAgIGZvcndhcmRzPyBXb3VsZG4ndCB0aGF0IGFsbG93IGxlZnQgZW5kcG9pbnRzIHRvIGFsd2F5c1xuICAvLyAgICAgICByZW1haW4gbGVmdCBlbmRwb2ludHMgZHVyaW5nIHNwbGl0dGluZyAobmV2ZXIgY2hhbmdlIHRvXG4gIC8vICAgICAgIHJpZ2h0KS4gTm8gLSBpdCB3b3VsZG4ndCwgYmVjYXVzZSB3ZSBzbmFwIGludGVyc2VjdGlvbnNcbiAgLy8gICAgICAgdG8gZW5kcG9pbnRzICh0byBlc3RhYmxpc2ggaW5kZXBlbmRlbmNlIGZyb20gdGhlIHNlZ21lbnRcbiAgLy8gICAgICAgYW5nbGUgZm9yIHQtaW50ZXJzZWN0aW9ucykuXG4gIHJvdW5kKGNvb3JkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMudHJlZS5hZGQoY29vcmQpO1xuICAgIGNvbnN0IHByZXZOb2RlID0gdGhpcy50cmVlLnByZXYobm9kZSk7XG4gICAgaWYgKHByZXZOb2RlICE9PSBudWxsICYmIGNtcChub2RlLmtleSwgcHJldk5vZGUua2V5KSA9PT0gMCkge1xuICAgICAgdGhpcy50cmVlLnJlbW92ZShjb29yZCk7XG4gICAgICByZXR1cm4gcHJldk5vZGUua2V5O1xuICAgIH1cbiAgICBjb25zdCBuZXh0Tm9kZSA9IHRoaXMudHJlZS5uZXh0KG5vZGUpO1xuICAgIGlmIChuZXh0Tm9kZSAhPT0gbnVsbCAmJiBjbXAobm9kZS5rZXksIG5leHROb2RlLmtleSkgPT09IDApIHtcbiAgICAgIHRoaXMudHJlZS5yZW1vdmUoY29vcmQpO1xuICAgICAgcmV0dXJuIG5leHROb2RlLmtleTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkO1xuICB9XG59XG5cbi8vIHNpbmdsZXRvbiBhdmFpbGFibGUgYnkgaW1wb3J0XG5jb25zdCByb3VuZGVyID0gbmV3IFB0Um91bmRlcigpO1xuXG4vKiBDcm9zcyBQcm9kdWN0IG9mIHR3byB2ZWN0b3JzIHdpdGggZmlyc3QgcG9pbnQgYXQgb3JpZ2luICovXG5jb25zdCBjcm9zc1Byb2R1Y3QgPSAoYSwgYikgPT4gYS54ICogYi55IC0gYS55ICogYi54O1xuXG4vKiBEb3QgUHJvZHVjdCBvZiB0d28gdmVjdG9ycyB3aXRoIGZpcnN0IHBvaW50IGF0IG9yaWdpbiAqL1xuY29uc3QgZG90UHJvZHVjdCA9IChhLCBiKSA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XG5cbi8qIENvbXBhcmF0b3IgZm9yIHR3byB2ZWN0b3JzIHdpdGggc2FtZSBzdGFydGluZyBwb2ludCAqL1xuY29uc3QgY29tcGFyZVZlY3RvckFuZ2xlcyA9IChiYXNlUHQsIGVuZFB0MSwgZW5kUHQyKSA9PiB7XG4gIGNvbnN0IHJlcyA9IG9yaWVudDJkKGJhc2VQdC54LCBiYXNlUHQueSwgZW5kUHQxLngsIGVuZFB0MS55LCBlbmRQdDIueCwgZW5kUHQyLnkpO1xuICBpZiAocmVzID4gMCkgcmV0dXJuIC0xO1xuICBpZiAocmVzIDwgMCkgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufTtcbmNvbnN0IGxlbmd0aCA9IHYgPT4gTWF0aC5zcXJ0KGRvdFByb2R1Y3QodiwgdikpO1xuXG4vKiBHZXQgdGhlIHNpbmUgb2YgdGhlIGFuZ2xlIGZyb20gcFNoYXJlZCAtPiBwQW5nbGUgdG8gcFNoYWVkIC0+IHBCYXNlICovXG5jb25zdCBzaW5lT2ZBbmdsZSA9IChwU2hhcmVkLCBwQmFzZSwgcEFuZ2xlKSA9PiB7XG4gIGNvbnN0IHZCYXNlID0ge1xuICAgIHg6IHBCYXNlLnggLSBwU2hhcmVkLngsXG4gICAgeTogcEJhc2UueSAtIHBTaGFyZWQueVxuICB9O1xuICBjb25zdCB2QW5nbGUgPSB7XG4gICAgeDogcEFuZ2xlLnggLSBwU2hhcmVkLngsXG4gICAgeTogcEFuZ2xlLnkgLSBwU2hhcmVkLnlcbiAgfTtcbiAgcmV0dXJuIGNyb3NzUHJvZHVjdCh2QW5nbGUsIHZCYXNlKSAvIGxlbmd0aCh2QW5nbGUpIC8gbGVuZ3RoKHZCYXNlKTtcbn07XG5cbi8qIEdldCB0aGUgY29zaW5lIG9mIHRoZSBhbmdsZSBmcm9tIHBTaGFyZWQgLT4gcEFuZ2xlIHRvIHBTaGFlZCAtPiBwQmFzZSAqL1xuY29uc3QgY29zaW5lT2ZBbmdsZSA9IChwU2hhcmVkLCBwQmFzZSwgcEFuZ2xlKSA9PiB7XG4gIGNvbnN0IHZCYXNlID0ge1xuICAgIHg6IHBCYXNlLnggLSBwU2hhcmVkLngsXG4gICAgeTogcEJhc2UueSAtIHBTaGFyZWQueVxuICB9O1xuICBjb25zdCB2QW5nbGUgPSB7XG4gICAgeDogcEFuZ2xlLnggLSBwU2hhcmVkLngsXG4gICAgeTogcEFuZ2xlLnkgLSBwU2hhcmVkLnlcbiAgfTtcbiAgcmV0dXJuIGRvdFByb2R1Y3QodkFuZ2xlLCB2QmFzZSkgLyBsZW5ndGgodkFuZ2xlKSAvIGxlbmd0aCh2QmFzZSk7XG59O1xuXG4vKiBHZXQgdGhlIHggY29vcmRpbmF0ZSB3aGVyZSB0aGUgZ2l2ZW4gbGluZSAoZGVmaW5lZCBieSBhIHBvaW50IGFuZCB2ZWN0b3IpXG4gKiBjcm9zc2VzIHRoZSBob3Jpem9udGFsIGxpbmUgd2l0aCB0aGUgZ2l2ZW4geSBjb29yZGlhbnRlLlxuICogSW4gdGhlIGNhc2Ugb2YgcGFycmFsbGVsIGxpbmVzIChpbmNsdWRpbmcgb3ZlcmxhcHBpbmcgb25lcykgcmV0dXJucyBudWxsLiAqL1xuY29uc3QgaG9yaXpvbnRhbEludGVyc2VjdGlvbiA9IChwdCwgdiwgeSkgPT4ge1xuICBpZiAodi55ID09PSAwKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIHtcbiAgICB4OiBwdC54ICsgdi54IC8gdi55ICogKHkgLSBwdC55KSxcbiAgICB5OiB5XG4gIH07XG59O1xuXG4vKiBHZXQgdGhlIHkgY29vcmRpbmF0ZSB3aGVyZSB0aGUgZ2l2ZW4gbGluZSAoZGVmaW5lZCBieSBhIHBvaW50IGFuZCB2ZWN0b3IpXG4gKiBjcm9zc2VzIHRoZSB2ZXJ0aWNhbCBsaW5lIHdpdGggdGhlIGdpdmVuIHggY29vcmRpYW50ZS5cbiAqIEluIHRoZSBjYXNlIG9mIHBhcnJhbGxlbCBsaW5lcyAoaW5jbHVkaW5nIG92ZXJsYXBwaW5nIG9uZXMpIHJldHVybnMgbnVsbC4gKi9cbmNvbnN0IHZlcnRpY2FsSW50ZXJzZWN0aW9uID0gKHB0LCB2LCB4KSA9PiB7XG4gIGlmICh2LnggPT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogcHQueSArIHYueSAvIHYueCAqICh4IC0gcHQueClcbiAgfTtcbn07XG5cbi8qIEdldCB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBsaW5lcywgZWFjaCBkZWZpbmVkIGJ5IGEgYmFzZSBwb2ludCBhbmQgYSB2ZWN0b3IuXG4gKiBJbiB0aGUgY2FzZSBvZiBwYXJyYWxsZWwgbGluZXMgKGluY2x1ZGluZyBvdmVybGFwcGluZyBvbmVzKSByZXR1cm5zIG51bGwuICovXG5jb25zdCBpbnRlcnNlY3Rpb24kMSA9IChwdDEsIHYxLCBwdDIsIHYyKSA9PiB7XG4gIC8vIHRha2Ugc29tZSBzaG9ydGN1dHMgZm9yIHZlcnRpY2FsIGFuZCBob3Jpem9udGFsIGxpbmVzXG4gIC8vIHRoaXMgYWxzbyBlbnN1cmVzIHdlIGRvbid0IGNhbGN1bGF0ZSBhbiBpbnRlcnNlY3Rpb24gYW5kIHRoZW4gZGlzY292ZXJcbiAgLy8gaXQncyBhY3R1YWxseSBvdXRzaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIGxpbmVcbiAgaWYgKHYxLnggPT09IDApIHJldHVybiB2ZXJ0aWNhbEludGVyc2VjdGlvbihwdDIsIHYyLCBwdDEueCk7XG4gIGlmICh2Mi54ID09PSAwKSByZXR1cm4gdmVydGljYWxJbnRlcnNlY3Rpb24ocHQxLCB2MSwgcHQyLngpO1xuICBpZiAodjEueSA9PT0gMCkgcmV0dXJuIGhvcml6b250YWxJbnRlcnNlY3Rpb24ocHQyLCB2MiwgcHQxLnkpO1xuICBpZiAodjIueSA9PT0gMCkgcmV0dXJuIGhvcml6b250YWxJbnRlcnNlY3Rpb24ocHQxLCB2MSwgcHQyLnkpO1xuXG4gIC8vIEdlbmVyYWwgY2FzZSBmb3Igbm9uLW92ZXJsYXBwaW5nIHNlZ21lbnRzLlxuICAvLyBUaGlzIGFsZ29yaXRobSBpcyBiYXNlZCBvbiBTY2huZWlkZXIgYW5kIEViZXJseS5cbiAgLy8gaHR0cDovL3d3dy5jaW1lYy5vcmcuYXIvfm5jYWx2by9TY2huZWlkZXJfRWJlcmx5LnBkZiAtIHBnIDI0NFxuXG4gIGNvbnN0IGtyb3NzID0gY3Jvc3NQcm9kdWN0KHYxLCB2Mik7XG4gIGlmIChrcm9zcyA9PSAwKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgdmUgPSB7XG4gICAgeDogcHQyLnggLSBwdDEueCxcbiAgICB5OiBwdDIueSAtIHB0MS55XG4gIH07XG4gIGNvbnN0IGQxID0gY3Jvc3NQcm9kdWN0KHZlLCB2MSkgLyBrcm9zcztcbiAgY29uc3QgZDIgPSBjcm9zc1Byb2R1Y3QodmUsIHYyKSAvIGtyb3NzO1xuXG4gIC8vIHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBjYWxjdWxhdGlvbnMgdG8gbWluaW1pemUgcm91bmRpbmcgZXJyb3JcbiAgY29uc3QgeDEgPSBwdDEueCArIGQyICogdjEueCxcbiAgICB4MiA9IHB0Mi54ICsgZDEgKiB2Mi54O1xuICBjb25zdCB5MSA9IHB0MS55ICsgZDIgKiB2MS55LFxuICAgIHkyID0gcHQyLnkgKyBkMSAqIHYyLnk7XG4gIGNvbnN0IHggPSAoeDEgKyB4MikgLyAyO1xuICBjb25zdCB5ID0gKHkxICsgeTIpIC8gMjtcbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn07XG5cbmNsYXNzIFN3ZWVwRXZlbnQge1xuICAvLyBmb3Igb3JkZXJpbmcgc3dlZXAgZXZlbnRzIGluIHRoZSBzd2VlcCBldmVudCBxdWV1ZVxuICBzdGF0aWMgY29tcGFyZShhLCBiKSB7XG4gICAgLy8gZmF2b3IgZXZlbnQgd2l0aCBhIHBvaW50IHRoYXQgdGhlIHN3ZWVwIGxpbmUgaGl0cyBmaXJzdFxuICAgIGNvbnN0IHB0Q21wID0gU3dlZXBFdmVudC5jb21wYXJlUG9pbnRzKGEucG9pbnQsIGIucG9pbnQpO1xuICAgIGlmIChwdENtcCAhPT0gMCkgcmV0dXJuIHB0Q21wO1xuXG4gICAgLy8gdGhlIHBvaW50cyBhcmUgdGhlIHNhbWUsIHNvIGxpbmsgdGhlbSBpZiBuZWVkZWRcbiAgICBpZiAoYS5wb2ludCAhPT0gYi5wb2ludCkgYS5saW5rKGIpO1xuXG4gICAgLy8gZmF2b3IgcmlnaHQgZXZlbnRzIG92ZXIgbGVmdFxuICAgIGlmIChhLmlzTGVmdCAhPT0gYi5pc0xlZnQpIHJldHVybiBhLmlzTGVmdCA/IDEgOiAtMTtcblxuICAgIC8vIHdlIGhhdmUgdHdvIG1hdGNoaW5nIGxlZnQgb3IgcmlnaHQgZW5kcG9pbnRzXG4gICAgLy8gb3JkZXJpbmcgb2YgdGhpcyBjYXNlIGlzIHRoZSBzYW1lIGFzIGZvciB0aGVpciBzZWdtZW50c1xuICAgIHJldHVybiBTZWdtZW50LmNvbXBhcmUoYS5zZWdtZW50LCBiLnNlZ21lbnQpO1xuICB9XG5cbiAgLy8gZm9yIG9yZGVyaW5nIHBvaW50cyBpbiBzd2VlcCBsaW5lIG9yZGVyXG4gIHN0YXRpYyBjb21wYXJlUG9pbnRzKGFQdCwgYlB0KSB7XG4gICAgaWYgKGFQdC54IDwgYlB0LngpIHJldHVybiAtMTtcbiAgICBpZiAoYVB0LnggPiBiUHQueCkgcmV0dXJuIDE7XG4gICAgaWYgKGFQdC55IDwgYlB0LnkpIHJldHVybiAtMTtcbiAgICBpZiAoYVB0LnkgPiBiUHQueSkgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBXYXJuaW5nOiAncG9pbnQnIGlucHV0IHdpbGwgYmUgbW9kaWZpZWQgYW5kIHJlLXVzZWQgKGZvciBwZXJmb3JtYW5jZSlcbiAgY29uc3RydWN0b3IocG9pbnQsIGlzTGVmdCkge1xuICAgIGlmIChwb2ludC5ldmVudHMgPT09IHVuZGVmaW5lZCkgcG9pbnQuZXZlbnRzID0gW3RoaXNdO2Vsc2UgcG9pbnQuZXZlbnRzLnB1c2godGhpcyk7XG4gICAgdGhpcy5wb2ludCA9IHBvaW50O1xuICAgIHRoaXMuaXNMZWZ0ID0gaXNMZWZ0O1xuICAgIC8vIHRoaXMuc2VnbWVudCwgdGhpcy5vdGhlclNFIHNldCBieSBmYWN0b3J5XG4gIH1cbiAgbGluayhvdGhlcikge1xuICAgIGlmIChvdGhlci5wb2ludCA9PT0gdGhpcy5wb2ludCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gbGluayBhbHJlYWR5IGxpbmtlZCBldmVudHNcIik7XG4gICAgfVxuICAgIGNvbnN0IG90aGVyRXZlbnRzID0gb3RoZXIucG9pbnQuZXZlbnRzO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gb3RoZXJFdmVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBldnQgPSBvdGhlckV2ZW50c1tpXTtcbiAgICAgIHRoaXMucG9pbnQuZXZlbnRzLnB1c2goZXZ0KTtcbiAgICAgIGV2dC5wb2ludCA9IHRoaXMucG9pbnQ7XG4gICAgfVxuICAgIHRoaXMuY2hlY2tGb3JDb25zdW1pbmcoKTtcbiAgfVxuXG4gIC8qIERvIGEgcGFzcyBvdmVyIG91ciBsaW5rZWQgZXZlbnRzIGFuZCBjaGVjayB0byBzZWUgaWYgYW55IHBhaXJcbiAgICogb2Ygc2VnbWVudHMgbWF0Y2gsIGFuZCBzaG91bGQgYmUgY29uc3VtZWQuICovXG4gIGNoZWNrRm9yQ29uc3VtaW5nKCkge1xuICAgIC8vIEZJWE1FOiBUaGUgbG9vcHMgaW4gdGhpcyBtZXRob2QgcnVuIE8obl4yKSA9PiBubyBnb29kLlxuICAgIC8vICAgICAgICBNYWludGFpbiBsaXR0bGUgb3JkZXJlZCBzd2VlcCBldmVudCB0cmVlcz9cbiAgICAvLyAgICAgICAgQ2FuIHdlIG1haW50YWluaW5nIGFuIG9yZGVyaW5nIHRoYXQgYXZvaWRzIHRoZSBuZWVkXG4gICAgLy8gICAgICAgIGZvciB0aGUgcmUtc29ydGluZyB3aXRoIGdldExlZnRtb3N0Q29tcGFyYXRvciBpbiBnZW9tLW91dD9cblxuICAgIC8vIENvbXBhcmUgZWFjaCBwYWlyIG9mIGV2ZW50cyB0byBzZWUgaWYgb3RoZXIgZXZlbnRzIGFsc28gbWF0Y2hcbiAgICBjb25zdCBudW1FdmVudHMgPSB0aGlzLnBvaW50LmV2ZW50cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FdmVudHM7IGkrKykge1xuICAgICAgY29uc3QgZXZ0MSA9IHRoaXMucG9pbnQuZXZlbnRzW2ldO1xuICAgICAgaWYgKGV2dDEuc2VnbWVudC5jb25zdW1lZEJ5ICE9PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbnVtRXZlbnRzOyBqKyspIHtcbiAgICAgICAgY29uc3QgZXZ0MiA9IHRoaXMucG9pbnQuZXZlbnRzW2pdO1xuICAgICAgICBpZiAoZXZ0Mi5jb25zdW1lZEJ5ICE9PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoZXZ0MS5vdGhlclNFLnBvaW50LmV2ZW50cyAhPT0gZXZ0Mi5vdGhlclNFLnBvaW50LmV2ZW50cykgY29udGludWU7XG4gICAgICAgIGV2dDEuc2VnbWVudC5jb25zdW1lKGV2dDIuc2VnbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEF2YWlsYWJsZUxpbmtlZEV2ZW50cygpIHtcbiAgICAvLyBwb2ludC5ldmVudHMgaXMgYWx3YXlzIG9mIGxlbmd0aCAyIG9yIGdyZWF0ZXJcbiAgICBjb25zdCBldmVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMucG9pbnQuZXZlbnRzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgZXZ0ID0gdGhpcy5wb2ludC5ldmVudHNbaV07XG4gICAgICBpZiAoZXZ0ICE9PSB0aGlzICYmICFldnQuc2VnbWVudC5yaW5nT3V0ICYmIGV2dC5zZWdtZW50LmlzSW5SZXN1bHQoKSkge1xuICAgICAgICBldmVudHMucHVzaChldnQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBzb3J0aW5nIGxpbmtlZCBldmVudHMgdGhhdCB3aWxsXG4gICAqIGZhdm9yIHRoZSBldmVudCB0aGF0IHdpbGwgZ2l2ZSB1cyB0aGUgc21hbGxlc3QgbGVmdC1zaWRlIGFuZ2xlLlxuICAgKiBBbGwgcmluZyBjb25zdHJ1Y3Rpb24gc3RhcnRzIGFzIGxvdyBhcyBwb3NzaWJsZSBoZWFkaW5nIHRvIHRoZSByaWdodCxcbiAgICogc28gYnkgYWx3YXlzIHR1cm5pbmcgbGVmdCBhcyBzaGFycCBhcyBwb3NzaWJsZSB3ZSdsbCBnZXQgcG9seWdvbnNcbiAgICogd2l0aG91dCB1bmNlc3NhcnkgbG9vcHMgJiBob2xlcy5cbiAgICpcbiAgICogVGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24gaGFzIGEgY29tcHV0ZSBjYWNoZSBzdWNoIHRoYXQgaXQgYXZvaWRzXG4gICAqIHJlLWNvbXB1dGluZyBhbHJlYWR5LWNvbXB1dGVkIHZhbHVlcy5cbiAgICovXG4gIGdldExlZnRtb3N0Q29tcGFyYXRvcihiYXNlRXZlbnQpIHtcbiAgICBjb25zdCBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBmaWxsQ2FjaGUgPSBsaW5rZWRFdmVudCA9PiB7XG4gICAgICBjb25zdCBuZXh0RXZlbnQgPSBsaW5rZWRFdmVudC5vdGhlclNFO1xuICAgICAgY2FjaGUuc2V0KGxpbmtlZEV2ZW50LCB7XG4gICAgICAgIHNpbmU6IHNpbmVPZkFuZ2xlKHRoaXMucG9pbnQsIGJhc2VFdmVudC5wb2ludCwgbmV4dEV2ZW50LnBvaW50KSxcbiAgICAgICAgY29zaW5lOiBjb3NpbmVPZkFuZ2xlKHRoaXMucG9pbnQsIGJhc2VFdmVudC5wb2ludCwgbmV4dEV2ZW50LnBvaW50KVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKGEsIGIpID0+IHtcbiAgICAgIGlmICghY2FjaGUuaGFzKGEpKSBmaWxsQ2FjaGUoYSk7XG4gICAgICBpZiAoIWNhY2hlLmhhcyhiKSkgZmlsbENhY2hlKGIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaW5lOiBhc2luZSxcbiAgICAgICAgY29zaW5lOiBhY29zaW5lXG4gICAgICB9ID0gY2FjaGUuZ2V0KGEpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaW5lOiBic2luZSxcbiAgICAgICAgY29zaW5lOiBiY29zaW5lXG4gICAgICB9ID0gY2FjaGUuZ2V0KGIpO1xuXG4gICAgICAvLyBib3RoIG9uIG9yIGFib3ZlIHgtYXhpc1xuICAgICAgaWYgKGFzaW5lID49IDAgJiYgYnNpbmUgPj0gMCkge1xuICAgICAgICBpZiAoYWNvc2luZSA8IGJjb3NpbmUpIHJldHVybiAxO1xuICAgICAgICBpZiAoYWNvc2luZSA+IGJjb3NpbmUpIHJldHVybiAtMTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIGJvdGggYmVsb3cgeC1heGlzXG4gICAgICBpZiAoYXNpbmUgPCAwICYmIGJzaW5lIDwgMCkge1xuICAgICAgICBpZiAoYWNvc2luZSA8IGJjb3NpbmUpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGFjb3NpbmUgPiBiY29zaW5lKSByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIG9uZSBhYm92ZSB4LWF4aXMsIG9uZSBiZWxvd1xuICAgICAgaWYgKGJzaW5lIDwgYXNpbmUpIHJldHVybiAtMTtcbiAgICAgIGlmIChic2luZSA+IGFzaW5lKSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH07XG4gIH1cbn1cblxuLy8gR2l2ZSBzZWdtZW50cyB1bmlxdWUgSUQncyB0byBnZXQgY29uc2lzdGVudCBzb3J0aW5nIG9mXG4vLyBzZWdtZW50cyBhbmQgc3dlZXAgZXZlbnRzIHdoZW4gYWxsIGVsc2UgaXMgaWRlbnRpY2FsXG5sZXQgc2VnbWVudElkID0gMDtcbmNsYXNzIFNlZ21lbnQge1xuICAvKiBUaGlzIGNvbXBhcmUoKSBmdW5jdGlvbiBpcyBmb3Igb3JkZXJpbmcgc2VnbWVudHMgaW4gdGhlIHN3ZWVwXG4gICAqIGxpbmUgdHJlZSwgYW5kIGRvZXMgc28gYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgY3JpdGVyaWE6XG4gICAqXG4gICAqIENvbnNpZGVyIHRoZSB2ZXJ0aWNhbCBsaW5lIHRoYXQgbGllcyBhbiBpbmZpbmVzdGltYWwgc3RlcCB0byB0aGVcbiAgICogcmlnaHQgb2YgdGhlIHJpZ2h0LW1vcmUgb2YgdGhlIHR3byBsZWZ0IGVuZHBvaW50cyBvZiB0aGUgaW5wdXRcbiAgICogc2VnbWVudHMuIEltYWdpbmUgc2xvd2x5IG1vdmluZyBhIHBvaW50IHVwIGZyb20gbmVnYXRpdmUgaW5maW5pdHlcbiAgICogaW4gdGhlIGluY3JlYXNpbmcgeSBkaXJlY3Rpb24uIFdoaWNoIG9mIHRoZSB0d28gc2VnbWVudHMgd2lsbCB0aGF0XG4gICAqIHBvaW50IGludGVyc2VjdCBmaXJzdD8gVGhhdCBzZWdtZW50IGNvbWVzICdiZWZvcmUnIHRoZSBvdGhlciBvbmUuXG4gICAqXG4gICAqIElmIG5laXRoZXIgc2VnbWVudCB3b3VsZCBiZSBpbnRlcnNlY3RlZCBieSBzdWNoIGEgbGluZSwgKGlmIG9uZVxuICAgKiBvciBtb3JlIG9mIHRoZSBzZWdtZW50cyBhcmUgdmVydGljYWwpIHRoZW4gdGhlIGxpbmUgdG8gYmUgY29uc2lkZXJlZFxuICAgKiBpcyBkaXJlY3RseSBvbiB0aGUgcmlnaHQtbW9yZSBvZiB0aGUgdHdvIGxlZnQgaW5wdXRzLlxuICAgKi9cbiAgc3RhdGljIGNvbXBhcmUoYSwgYikge1xuICAgIGNvbnN0IGFseCA9IGEubGVmdFNFLnBvaW50Lng7XG4gICAgY29uc3QgYmx4ID0gYi5sZWZ0U0UucG9pbnQueDtcbiAgICBjb25zdCBhcnggPSBhLnJpZ2h0U0UucG9pbnQueDtcbiAgICBjb25zdCBicnggPSBiLnJpZ2h0U0UucG9pbnQueDtcblxuICAgIC8vIGNoZWNrIGlmIHRoZXkncmUgZXZlbiBpbiB0aGUgc2FtZSB2ZXJ0aWNhbCBwbGFuZVxuICAgIGlmIChicnggPCBhbHgpIHJldHVybiAxO1xuICAgIGlmIChhcnggPCBibHgpIHJldHVybiAtMTtcbiAgICBjb25zdCBhbHkgPSBhLmxlZnRTRS5wb2ludC55O1xuICAgIGNvbnN0IGJseSA9IGIubGVmdFNFLnBvaW50Lnk7XG4gICAgY29uc3QgYXJ5ID0gYS5yaWdodFNFLnBvaW50Lnk7XG4gICAgY29uc3QgYnJ5ID0gYi5yaWdodFNFLnBvaW50Lnk7XG5cbiAgICAvLyBpcyBsZWZ0IGVuZHBvaW50IG9mIHNlZ21lbnQgQiB0aGUgcmlnaHQtbW9yZT9cbiAgICBpZiAoYWx4IDwgYmx4KSB7XG4gICAgICAvLyBhcmUgdGhlIHR3byBzZWdtZW50cyBpbiB0aGUgc2FtZSBob3Jpem9udGFsIHBsYW5lP1xuICAgICAgaWYgKGJseSA8IGFseSAmJiBibHkgPCBhcnkpIHJldHVybiAxO1xuICAgICAgaWYgKGJseSA+IGFseSAmJiBibHkgPiBhcnkpIHJldHVybiAtMTtcblxuICAgICAgLy8gaXMgdGhlIEIgbGVmdCBlbmRwb2ludCBjb2xpbmVhciB0byBzZWdtZW50IEE/XG4gICAgICBjb25zdCBhQ21wQkxlZnQgPSBhLmNvbXBhcmVQb2ludChiLmxlZnRTRS5wb2ludCk7XG4gICAgICBpZiAoYUNtcEJMZWZ0IDwgMCkgcmV0dXJuIDE7XG4gICAgICBpZiAoYUNtcEJMZWZ0ID4gMCkgcmV0dXJuIC0xO1xuXG4gICAgICAvLyBpcyB0aGUgQSByaWdodCBlbmRwb2ludCBjb2xpbmVhciB0byBzZWdtZW50IEIgP1xuICAgICAgY29uc3QgYkNtcEFSaWdodCA9IGIuY29tcGFyZVBvaW50KGEucmlnaHRTRS5wb2ludCk7XG4gICAgICBpZiAoYkNtcEFSaWdodCAhPT0gMCkgcmV0dXJuIGJDbXBBUmlnaHQ7XG5cbiAgICAgIC8vIGNvbGluZWFyIHNlZ21lbnRzLCBjb25zaWRlciB0aGUgb25lIHdpdGggbGVmdC1tb3JlXG4gICAgICAvLyBsZWZ0IGVuZHBvaW50IHRvIGJlIGZpcnN0IChhcmJpdHJhcnk/KVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8vIGlzIGxlZnQgZW5kcG9pbnQgb2Ygc2VnbWVudCBBIHRoZSByaWdodC1tb3JlP1xuICAgIGlmIChhbHggPiBibHgpIHtcbiAgICAgIGlmIChhbHkgPCBibHkgJiYgYWx5IDwgYnJ5KSByZXR1cm4gLTE7XG4gICAgICBpZiAoYWx5ID4gYmx5ICYmIGFseSA+IGJyeSkgcmV0dXJuIDE7XG5cbiAgICAgIC8vIGlzIHRoZSBBIGxlZnQgZW5kcG9pbnQgY29saW5lYXIgdG8gc2VnbWVudCBCP1xuICAgICAgY29uc3QgYkNtcEFMZWZ0ID0gYi5jb21wYXJlUG9pbnQoYS5sZWZ0U0UucG9pbnQpO1xuICAgICAgaWYgKGJDbXBBTGVmdCAhPT0gMCkgcmV0dXJuIGJDbXBBTGVmdDtcblxuICAgICAgLy8gaXMgdGhlIEIgcmlnaHQgZW5kcG9pbnQgY29saW5lYXIgdG8gc2VnbWVudCBBP1xuICAgICAgY29uc3QgYUNtcEJSaWdodCA9IGEuY29tcGFyZVBvaW50KGIucmlnaHRTRS5wb2ludCk7XG4gICAgICBpZiAoYUNtcEJSaWdodCA8IDApIHJldHVybiAxO1xuICAgICAgaWYgKGFDbXBCUmlnaHQgPiAwKSByZXR1cm4gLTE7XG5cbiAgICAgIC8vIGNvbGluZWFyIHNlZ21lbnRzLCBjb25zaWRlciB0aGUgb25lIHdpdGggbGVmdC1tb3JlXG4gICAgICAvLyBsZWZ0IGVuZHBvaW50IHRvIGJlIGZpcnN0IChhcmJpdHJhcnk/KVxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZ2V0IGhlcmUsIHRoZSB0d28gbGVmdCBlbmRwb2ludHMgYXJlIGluIHRoZSBzYW1lXG4gICAgLy8gdmVydGljYWwgcGxhbmUsIGllIGFseCA9PT0gYmx4XG5cbiAgICAvLyBjb25zaWRlciB0aGUgbG93ZXIgbGVmdC1lbmRwb2ludCB0byBjb21lIGZpcnN0XG4gICAgaWYgKGFseSA8IGJseSkgcmV0dXJuIC0xO1xuICAgIGlmIChhbHkgPiBibHkpIHJldHVybiAxO1xuXG4gICAgLy8gbGVmdCBlbmRwb2ludHMgYXJlIGlkZW50aWNhbFxuICAgIC8vIGNoZWNrIGZvciBjb2xpbmVhcml0eSBieSB1c2luZyB0aGUgbGVmdC1tb3JlIHJpZ2h0IGVuZHBvaW50XG5cbiAgICAvLyBpcyB0aGUgQSByaWdodCBlbmRwb2ludCBtb3JlIGxlZnQtbW9yZT9cbiAgICBpZiAoYXJ4IDwgYnJ4KSB7XG4gICAgICBjb25zdCBiQ21wQVJpZ2h0ID0gYi5jb21wYXJlUG9pbnQoYS5yaWdodFNFLnBvaW50KTtcbiAgICAgIGlmIChiQ21wQVJpZ2h0ICE9PSAwKSByZXR1cm4gYkNtcEFSaWdodDtcbiAgICB9XG5cbiAgICAvLyBpcyB0aGUgQiByaWdodCBlbmRwb2ludCBtb3JlIGxlZnQtbW9yZT9cbiAgICBpZiAoYXJ4ID4gYnJ4KSB7XG4gICAgICBjb25zdCBhQ21wQlJpZ2h0ID0gYS5jb21wYXJlUG9pbnQoYi5yaWdodFNFLnBvaW50KTtcbiAgICAgIGlmIChhQ21wQlJpZ2h0IDwgMCkgcmV0dXJuIDE7XG4gICAgICBpZiAoYUNtcEJSaWdodCA+IDApIHJldHVybiAtMTtcbiAgICB9XG4gICAgaWYgKGFyeCAhPT0gYnJ4KSB7XG4gICAgICAvLyBhcmUgdGhlc2UgdHdvIFthbG1vc3RdIHZlcnRpY2FsIHNlZ21lbnRzIHdpdGggb3Bwb3NpdGUgb3JpZW50YXRpb24/XG4gICAgICAvLyBpZiBzbywgdGhlIG9uZSB3aXRoIHRoZSBsb3dlciByaWdodCBlbmRwb2ludCBjb21lcyBmaXJzdFxuICAgICAgY29uc3QgYXkgPSBhcnkgLSBhbHk7XG4gICAgICBjb25zdCBheCA9IGFyeCAtIGFseDtcbiAgICAgIGNvbnN0IGJ5ID0gYnJ5IC0gYmx5O1xuICAgICAgY29uc3QgYnggPSBicnggLSBibHg7XG4gICAgICBpZiAoYXkgPiBheCAmJiBieSA8IGJ4KSByZXR1cm4gMTtcbiAgICAgIGlmIChheSA8IGF4ICYmIGJ5ID4gYngpIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyB3ZSBoYXZlIGNvbGluZWFyIHNlZ21lbnRzIHdpdGggbWF0Y2hpbmcgb3JpZW50YXRpb25cbiAgICAvLyBjb25zaWRlciB0aGUgb25lIHdpdGggbW9yZSBsZWZ0LW1vcmUgcmlnaHQgZW5kcG9pbnQgdG8gYmUgZmlyc3RcbiAgICBpZiAoYXJ4ID4gYnJ4KSByZXR1cm4gMTtcbiAgICBpZiAoYXJ4IDwgYnJ4KSByZXR1cm4gLTE7XG5cbiAgICAvLyBpZiB3ZSBnZXQgaGVyZSwgdHdvIHR3byByaWdodCBlbmRwb2ludHMgYXJlIGluIHRoZSBzYW1lXG4gICAgLy8gdmVydGljYWwgcGxhbmUsIGllIGFyeCA9PT0gYnJ4XG5cbiAgICAvLyBjb25zaWRlciB0aGUgbG93ZXIgcmlnaHQtZW5kcG9pbnQgdG8gY29tZSBmaXJzdFxuICAgIGlmIChhcnkgPCBicnkpIHJldHVybiAtMTtcbiAgICBpZiAoYXJ5ID4gYnJ5KSByZXR1cm4gMTtcblxuICAgIC8vIHJpZ2h0IGVuZHBvaW50cyBpZGVudGljYWwgYXMgd2VsbCwgc28gdGhlIHNlZ21lbnRzIGFyZSBpZGVudGlhbFxuICAgIC8vIGZhbGwgYmFjayBvbiBjcmVhdGlvbiBvcmRlciBhcyBjb25zaXN0ZW50IHRpZS1icmVha2VyXG4gICAgaWYgKGEuaWQgPCBiLmlkKSByZXR1cm4gLTE7XG4gICAgaWYgKGEuaWQgPiBiLmlkKSByZXR1cm4gMTtcblxuICAgIC8vIGlkZW50aWNhbCBzZWdtZW50LCBpZSBhID09PSBiXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKiBXYXJuaW5nOiBhIHJlZmVyZW5jZSB0byByaW5nV2luZGluZ3MgaW5wdXQgd2lsbCBiZSBzdG9yZWQsXG4gICAqICBhbmQgcG9zc2libHkgd2lsbCBiZSBsYXRlciBtb2RpZmllZCAqL1xuICBjb25zdHJ1Y3RvcihsZWZ0U0UsIHJpZ2h0U0UsIHJpbmdzLCB3aW5kaW5ncykge1xuICAgIHRoaXMuaWQgPSArK3NlZ21lbnRJZDtcbiAgICB0aGlzLmxlZnRTRSA9IGxlZnRTRTtcbiAgICBsZWZ0U0Uuc2VnbWVudCA9IHRoaXM7XG4gICAgbGVmdFNFLm90aGVyU0UgPSByaWdodFNFO1xuICAgIHRoaXMucmlnaHRTRSA9IHJpZ2h0U0U7XG4gICAgcmlnaHRTRS5zZWdtZW50ID0gdGhpcztcbiAgICByaWdodFNFLm90aGVyU0UgPSBsZWZ0U0U7XG4gICAgdGhpcy5yaW5ncyA9IHJpbmdzO1xuICAgIHRoaXMud2luZGluZ3MgPSB3aW5kaW5ncztcbiAgICAvLyBsZWZ0IHVuc2V0IGZvciBwZXJmb3JtYW5jZSwgc2V0IGxhdGVyIGluIGFsZ29yaXRobVxuICAgIC8vIHRoaXMucmluZ091dCwgdGhpcy5jb25zdW1lZEJ5LCB0aGlzLnByZXZcbiAgfVxuICBzdGF0aWMgZnJvbVJpbmcocHQxLCBwdDIsIHJpbmcpIHtcbiAgICBsZXQgbGVmdFB0LCByaWdodFB0LCB3aW5kaW5nO1xuXG4gICAgLy8gb3JkZXJpbmcgdGhlIHR3byBwb2ludHMgYWNjb3JkaW5nIHRvIHN3ZWVwIGxpbmUgb3JkZXJpbmdcbiAgICBjb25zdCBjbXBQdHMgPSBTd2VlcEV2ZW50LmNvbXBhcmVQb2ludHMocHQxLCBwdDIpO1xuICAgIGlmIChjbXBQdHMgPCAwKSB7XG4gICAgICBsZWZ0UHQgPSBwdDE7XG4gICAgICByaWdodFB0ID0gcHQyO1xuICAgICAgd2luZGluZyA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXBQdHMgPiAwKSB7XG4gICAgICBsZWZ0UHQgPSBwdDI7XG4gICAgICByaWdodFB0ID0gcHQxO1xuICAgICAgd2luZGluZyA9IC0xO1xuICAgIH0gZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIGNyZWF0ZSBkZWdlbmVyYXRlIHNlZ21lbnQgYXQgWyR7cHQxLnh9LCAke3B0MS55fV1gKTtcbiAgICBjb25zdCBsZWZ0U0UgPSBuZXcgU3dlZXBFdmVudChsZWZ0UHQsIHRydWUpO1xuICAgIGNvbnN0IHJpZ2h0U0UgPSBuZXcgU3dlZXBFdmVudChyaWdodFB0LCBmYWxzZSk7XG4gICAgcmV0dXJuIG5ldyBTZWdtZW50KGxlZnRTRSwgcmlnaHRTRSwgW3JpbmddLCBbd2luZGluZ10pO1xuICB9XG5cbiAgLyogV2hlbiBhIHNlZ21lbnQgaXMgc3BsaXQsIHRoZSByaWdodFNFIGlzIHJlcGxhY2VkIHdpdGggYSBuZXcgc3dlZXAgZXZlbnQgKi9cbiAgcmVwbGFjZVJpZ2h0U0UobmV3UmlnaHRTRSkge1xuICAgIHRoaXMucmlnaHRTRSA9IG5ld1JpZ2h0U0U7XG4gICAgdGhpcy5yaWdodFNFLnNlZ21lbnQgPSB0aGlzO1xuICAgIHRoaXMucmlnaHRTRS5vdGhlclNFID0gdGhpcy5sZWZ0U0U7XG4gICAgdGhpcy5sZWZ0U0Uub3RoZXJTRSA9IHRoaXMucmlnaHRTRTtcbiAgfVxuICBiYm94KCkge1xuICAgIGNvbnN0IHkxID0gdGhpcy5sZWZ0U0UucG9pbnQueTtcbiAgICBjb25zdCB5MiA9IHRoaXMucmlnaHRTRS5wb2ludC55O1xuICAgIHJldHVybiB7XG4gICAgICBsbDoge1xuICAgICAgICB4OiB0aGlzLmxlZnRTRS5wb2ludC54LFxuICAgICAgICB5OiB5MSA8IHkyID8geTEgOiB5MlxuICAgICAgfSxcbiAgICAgIHVyOiB7XG4gICAgICAgIHg6IHRoaXMucmlnaHRTRS5wb2ludC54LFxuICAgICAgICB5OiB5MSA+IHkyID8geTEgOiB5MlxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKiBBIHZlY3RvciBmcm9tIHRoZSBsZWZ0IHBvaW50IHRvIHRoZSByaWdodCAqL1xuICB2ZWN0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHRoaXMucmlnaHRTRS5wb2ludC54IC0gdGhpcy5sZWZ0U0UucG9pbnQueCxcbiAgICAgIHk6IHRoaXMucmlnaHRTRS5wb2ludC55IC0gdGhpcy5sZWZ0U0UucG9pbnQueVxuICAgIH07XG4gIH1cbiAgaXNBbkVuZHBvaW50KHB0KSB7XG4gICAgcmV0dXJuIHB0LnggPT09IHRoaXMubGVmdFNFLnBvaW50LnggJiYgcHQueSA9PT0gdGhpcy5sZWZ0U0UucG9pbnQueSB8fCBwdC54ID09PSB0aGlzLnJpZ2h0U0UucG9pbnQueCAmJiBwdC55ID09PSB0aGlzLnJpZ2h0U0UucG9pbnQueTtcbiAgfVxuXG4gIC8qIENvbXBhcmUgdGhpcyBzZWdtZW50IHdpdGggYSBwb2ludC5cbiAgICpcbiAgICogQSBwb2ludCBQIGlzIGNvbnNpZGVyZWQgdG8gYmUgY29saW5lYXIgdG8gYSBzZWdtZW50IGlmIHRoZXJlXG4gICAqIGV4aXN0cyBhIGRpc3RhbmNlIEQgc3VjaCB0aGF0IGlmIHdlIHRyYXZlbCBhbG9uZyB0aGUgc2VnbWVudFxuICAgKiBmcm9tIG9uZSAqIGVuZHBvaW50IHRvd2FyZHMgdGhlIG90aGVyIGEgZGlzdGFuY2UgRCwgd2UgZmluZFxuICAgKiBvdXJzZWx2ZXMgYXQgcG9pbnQgUC5cbiAgICpcbiAgICogUmV0dXJuIHZhbHVlIGluZGljYXRlczpcbiAgICpcbiAgICogICAxOiBwb2ludCBsaWVzIGFib3ZlIHRoZSBzZWdtZW50ICh0byB0aGUgbGVmdCBvZiB2ZXJ0aWNhbClcbiAgICogICAwOiBwb2ludCBpcyBjb2xpbmVhciB0byBzZWdtZW50XG4gICAqICAtMTogcG9pbnQgbGllcyBiZWxvdyB0aGUgc2VnbWVudCAodG8gdGhlIHJpZ2h0IG9mIHZlcnRpY2FsKVxuICAgKi9cbiAgY29tcGFyZVBvaW50KHBvaW50KSB7XG4gICAgaWYgKHRoaXMuaXNBbkVuZHBvaW50KHBvaW50KSkgcmV0dXJuIDA7XG4gICAgY29uc3QgbFB0ID0gdGhpcy5sZWZ0U0UucG9pbnQ7XG4gICAgY29uc3QgclB0ID0gdGhpcy5yaWdodFNFLnBvaW50O1xuICAgIGNvbnN0IHYgPSB0aGlzLnZlY3RvcigpO1xuXG4gICAgLy8gRXhhY3RseSB2ZXJ0aWNhbCBzZWdtZW50cy5cbiAgICBpZiAobFB0LnggPT09IHJQdC54KSB7XG4gICAgICBpZiAocG9pbnQueCA9PT0gbFB0LngpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHBvaW50LnggPCBsUHQueCA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICAvLyBOZWFybHkgdmVydGljYWwgc2VnbWVudHMgd2l0aCBhbiBpbnRlcnNlY3Rpb24uXG4gICAgLy8gQ2hlY2sgdG8gc2VlIHdoZXJlIGEgcG9pbnQgb24gdGhlIGxpbmUgd2l0aCBtYXRjaGluZyBZIGNvb3JkaW5hdGUgaXMuXG4gICAgY29uc3QgeURpc3QgPSAocG9pbnQueSAtIGxQdC55KSAvIHYueTtcbiAgICBjb25zdCB4RnJvbVlEaXN0ID0gbFB0LnggKyB5RGlzdCAqIHYueDtcbiAgICBpZiAocG9pbnQueCA9PT0geEZyb21ZRGlzdCkgcmV0dXJuIDA7XG5cbiAgICAvLyBHZW5lcmFsIGNhc2UuXG4gICAgLy8gQ2hlY2sgdG8gc2VlIHdoZXJlIGEgcG9pbnQgb24gdGhlIGxpbmUgd2l0aCBtYXRjaGluZyBYIGNvb3JkaW5hdGUgaXMuXG4gICAgY29uc3QgeERpc3QgPSAocG9pbnQueCAtIGxQdC54KSAvIHYueDtcbiAgICBjb25zdCB5RnJvbVhEaXN0ID0gbFB0LnkgKyB4RGlzdCAqIHYueTtcbiAgICBpZiAocG9pbnQueSA9PT0geUZyb21YRGlzdCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIHBvaW50LnkgPCB5RnJvbVhEaXN0ID8gLTEgOiAxO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGFub3RoZXIgc2VnbWVudCwgcmV0dXJucyB0aGUgZmlyc3Qgbm9uLXRyaXZpYWwgaW50ZXJzZWN0aW9uXG4gICAqIGJldHdlZW4gdGhlIHR3byBzZWdtZW50cyAoaW4gdGVybXMgb2Ygc3dlZXAgbGluZSBvcmRlcmluZyksIGlmIGl0IGV4aXN0cy5cbiAgICpcbiAgICogQSAnbm9uLXRyaXZpYWwnIGludGVyc2VjdGlvbiBpcyBvbmUgdGhhdCB3aWxsIGNhdXNlIG9uZSBvciBib3RoIG9mIHRoZVxuICAgKiBzZWdtZW50cyB0byBiZSBzcGxpdCgpLiBBcyBzdWNoLCAndHJpdmlhbCcgdnMuICdub24tdHJpdmlhbCcgaW50ZXJzZWN0aW9uOlxuICAgKlxuICAgKiAgICogZW5kcG9pbnQgb2Ygc2VnQSB3aXRoIGVuZHBvaW50IG9mIHNlZ0IgLS0+IHRyaXZpYWxcbiAgICogICAqIGVuZHBvaW50IG9mIHNlZ0Egd2l0aCBwb2ludCBhbG9uZyBzZWdCIC0tPiBub24tdHJpdmlhbFxuICAgKiAgICogZW5kcG9pbnQgb2Ygc2VnQiB3aXRoIHBvaW50IGFsb25nIHNlZ0EgLS0+IG5vbi10cml2aWFsXG4gICAqICAgKiBwb2ludCBhbG9uZyBzZWdBIHdpdGggcG9pbnQgYWxvbmcgc2VnQiAtLT4gbm9uLXRyaXZpYWxcbiAgICpcbiAgICogSWYgbm8gbm9uLXRyaXZpYWwgaW50ZXJzZWN0aW9uIGV4aXN0cywgcmV0dXJuIG51bGxcbiAgICogRWxzZSwgcmV0dXJuIG51bGwuXG4gICAqL1xuICBnZXRJbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiAgICAvLyBJZiBiYm94ZXMgZG9uJ3Qgb3ZlcmxhcCwgdGhlcmUgY2FuJ3QgYmUgYW55IGludGVyc2VjdGlvbnNcbiAgICBjb25zdCB0QmJveCA9IHRoaXMuYmJveCgpO1xuICAgIGNvbnN0IG9CYm94ID0gb3RoZXIuYmJveCgpO1xuICAgIGNvbnN0IGJib3hPdmVybGFwID0gZ2V0QmJveE92ZXJsYXAodEJib3gsIG9CYm94KTtcbiAgICBpZiAoYmJveE92ZXJsYXAgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgLy8gV2UgZmlyc3QgY2hlY2sgdG8gc2VlIGlmIHRoZSBlbmRwb2ludHMgY2FuIGJlIGNvbnNpZGVyZWQgaW50ZXJzZWN0aW9ucy5cbiAgICAvLyBUaGlzIHdpbGwgJ3NuYXAnIGludGVyc2VjdGlvbnMgdG8gZW5kcG9pbnRzIGlmIHBvc3NpYmxlLCBhbmQgd2lsbFxuICAgIC8vIGhhbmRsZSBjYXNlcyBvZiBjb2xpbmVhcml0eS5cblxuICAgIGNvbnN0IHRscCA9IHRoaXMubGVmdFNFLnBvaW50O1xuICAgIGNvbnN0IHRycCA9IHRoaXMucmlnaHRTRS5wb2ludDtcbiAgICBjb25zdCBvbHAgPSBvdGhlci5sZWZ0U0UucG9pbnQ7XG4gICAgY29uc3Qgb3JwID0gb3RoZXIucmlnaHRTRS5wb2ludDtcblxuICAgIC8vIGRvZXMgZWFjaCBlbmRwb2ludCB0b3VjaCB0aGUgb3RoZXIgc2VnbWVudD9cbiAgICAvLyBub3RlIHRoYXQgd2UgcmVzdHJpY3QgdGhlICd0b3VjaGluZycgZGVmaW5pdGlvbiB0byBvbmx5IGFsbG93IHNlZ21lbnRzXG4gICAgLy8gdG8gdG91Y2ggZW5kcG9pbnRzIHRoYXQgbGllIGZvcndhcmQgZnJvbSB3aGVyZSB3ZSBhcmUgaW4gdGhlIHN3ZWVwIGxpbmUgcGFzc1xuICAgIGNvbnN0IHRvdWNoZXNPdGhlckxTRSA9IGlzSW5CYm94KHRCYm94LCBvbHApICYmIHRoaXMuY29tcGFyZVBvaW50KG9scCkgPT09IDA7XG4gICAgY29uc3QgdG91Y2hlc1RoaXNMU0UgPSBpc0luQmJveChvQmJveCwgdGxwKSAmJiBvdGhlci5jb21wYXJlUG9pbnQodGxwKSA9PT0gMDtcbiAgICBjb25zdCB0b3VjaGVzT3RoZXJSU0UgPSBpc0luQmJveCh0QmJveCwgb3JwKSAmJiB0aGlzLmNvbXBhcmVQb2ludChvcnApID09PSAwO1xuICAgIGNvbnN0IHRvdWNoZXNUaGlzUlNFID0gaXNJbkJib3gob0Jib3gsIHRycCkgJiYgb3RoZXIuY29tcGFyZVBvaW50KHRycCkgPT09IDA7XG5cbiAgICAvLyBkbyBsZWZ0IGVuZHBvaW50cyBtYXRjaD9cbiAgICBpZiAodG91Y2hlc1RoaXNMU0UgJiYgdG91Y2hlc090aGVyTFNFKSB7XG4gICAgICAvLyB0aGVzZSB0d28gY2FzZXMgYXJlIGZvciBjb2xpbmVhciBzZWdtZW50cyB3aXRoIG1hdGNoaW5nIGxlZnRcbiAgICAgIC8vIGVuZHBvaW50cywgYW5kIG9uZSBzZWdtZW50IGJlaW5nIGxvbmdlciB0aGFuIHRoZSBvdGhlclxuICAgICAgaWYgKHRvdWNoZXNUaGlzUlNFICYmICF0b3VjaGVzT3RoZXJSU0UpIHJldHVybiB0cnA7XG4gICAgICBpZiAoIXRvdWNoZXNUaGlzUlNFICYmIHRvdWNoZXNPdGhlclJTRSkgcmV0dXJuIG9ycDtcbiAgICAgIC8vIGVpdGhlciB0aGUgdHdvIHNlZ21lbnRzIG1hdGNoIGV4YWN0bHkgKHR3byB0cml2YWwgaW50ZXJzZWN0aW9ucylcbiAgICAgIC8vIG9yIGp1c3Qgb24gdGhlaXIgbGVmdCBlbmRwb2ludCAob25lIHRyaXZpYWwgaW50ZXJzZWN0aW9uXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBkb2VzIHRoaXMgbGVmdCBlbmRwb2ludCBtYXRjaGVzIChvdGhlciBkb2Vzbid0KVxuICAgIGlmICh0b3VjaGVzVGhpc0xTRSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHNlZ21lbnRzIHRoYXQganVzdCBpbnRlcnNlY3Qgb24gb3Bwb3NpbmcgZW5kcG9pbnRzXG4gICAgICBpZiAodG91Y2hlc090aGVyUlNFKSB7XG4gICAgICAgIGlmICh0bHAueCA9PT0gb3JwLnggJiYgdGxwLnkgPT09IG9ycC55KSByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIHQtaW50ZXJzZWN0aW9uIG9uIGxlZnQgZW5kcG9pbnRcbiAgICAgIHJldHVybiB0bHA7XG4gICAgfVxuXG4gICAgLy8gZG9lcyBvdGhlciBsZWZ0IGVuZHBvaW50IG1hdGNoZXMgKHRoaXMgZG9lc24ndClcbiAgICBpZiAodG91Y2hlc090aGVyTFNFKSB7XG4gICAgICAvLyBjaGVjayBmb3Igc2VnbWVudHMgdGhhdCBqdXN0IGludGVyc2VjdCBvbiBvcHBvc2luZyBlbmRwb2ludHNcbiAgICAgIGlmICh0b3VjaGVzVGhpc1JTRSkge1xuICAgICAgICBpZiAodHJwLnggPT09IG9scC54ICYmIHRycC55ID09PSBvbHAueSkgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyB0LWludGVyc2VjdGlvbiBvbiBsZWZ0IGVuZHBvaW50XG4gICAgICByZXR1cm4gb2xwO1xuICAgIH1cblxuICAgIC8vIHRyaXZpYWwgaW50ZXJzZWN0aW9uIG9uIHJpZ2h0IGVuZHBvaW50c1xuICAgIGlmICh0b3VjaGVzVGhpc1JTRSAmJiB0b3VjaGVzT3RoZXJSU0UpIHJldHVybiBudWxsO1xuXG4gICAgLy8gdC1pbnRlcnNlY3Rpb25zIG9uIGp1c3Qgb25lIHJpZ2h0IGVuZHBvaW50XG4gICAgaWYgKHRvdWNoZXNUaGlzUlNFKSByZXR1cm4gdHJwO1xuICAgIGlmICh0b3VjaGVzT3RoZXJSU0UpIHJldHVybiBvcnA7XG5cbiAgICAvLyBOb25lIG9mIG91ciBlbmRwb2ludHMgaW50ZXJzZWN0LiBMb29rIGZvciBhIGdlbmVyYWwgaW50ZXJzZWN0aW9uIGJldHdlZW5cbiAgICAvLyBpbmZpbml0ZSBsaW5lcyBsYWlkIG92ZXIgdGhlIHNlZ21lbnRzXG4gICAgY29uc3QgcHQgPSBpbnRlcnNlY3Rpb24kMSh0bHAsIHRoaXMudmVjdG9yKCksIG9scCwgb3RoZXIudmVjdG9yKCkpO1xuXG4gICAgLy8gYXJlIHRoZSBzZWdtZW50cyBwYXJyYWxsZWw/IE5vdGUgdGhhdCBpZiB0aGV5IHdlcmUgY29saW5lYXIgd2l0aCBvdmVybGFwLFxuICAgIC8vIHRoZXkgd291bGQgaGF2ZSBhbiBlbmRwb2ludCBpbnRlcnNlY3Rpb24gYW5kIHRoYXQgY2FzZSB3YXMgYWxyZWFkeSBoYW5kbGVkIGFib3ZlXG4gICAgaWYgKHB0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGlzIHRoZSBpbnRlcnNlY3Rpb24gZm91bmQgYmV0d2VlbiB0aGUgbGluZXMgbm90IG9uIHRoZSBzZWdtZW50cz9cbiAgICBpZiAoIWlzSW5CYm94KGJib3hPdmVybGFwLCBwdCkpIHJldHVybiBudWxsO1xuXG4gICAgLy8gcm91bmQgdGhlIHRoZSBjb21wdXRlZCBwb2ludCBpZiBuZWVkZWRcbiAgICByZXR1cm4gcm91bmRlci5yb3VuZChwdC54LCBwdC55KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdCB0aGUgZ2l2ZW4gc2VnbWVudCBpbnRvIG11bHRpcGxlIHNlZ21lbnRzIG9uIHRoZSBnaXZlbiBwb2ludHMuXG4gICAqICAqIEVhY2ggZXhpc3Rpbmcgc2VnbWVudCB3aWxsIHJldGFpbiBpdHMgbGVmdFNFIGFuZCBhIG5ldyByaWdodFNFIHdpbGwgYmVcbiAgICogICAgZ2VuZXJhdGVkIGZvciBpdC5cbiAgICogICogQSBuZXcgc2VnbWVudCB3aWxsIGJlIGdlbmVyYXRlZCB3aGljaCB3aWxsIGFkb3B0IHRoZSBvcmlnaW5hbCBzZWdtZW50J3NcbiAgICogICAgcmlnaHRTRSwgYW5kIGEgbmV3IGxlZnRTRSB3aWxsIGJlIGdlbmVyYXRlZCBmb3IgaXQuXG4gICAqICAqIElmIHRoZXJlIGFyZSBtb3JlIHRoYW4gdHdvIHBvaW50cyBnaXZlbiB0byBzcGxpdCBvbiwgbmV3IHNlZ21lbnRzXG4gICAqICAgIGluIHRoZSBtaWRkbGUgd2lsbCBiZSBnZW5lcmF0ZWQgd2l0aCBuZXcgbGVmdFNFIGFuZCByaWdodFNFJ3MuXG4gICAqICAqIEFuIGFycmF5IG9mIHRoZSBuZXdseSBnZW5lcmF0ZWQgU3dlZXBFdmVudHMgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogV2FybmluZzogaW5wdXQgYXJyYXkgb2YgcG9pbnRzIGlzIG1vZGlmaWVkXG4gICAqL1xuICBzcGxpdChwb2ludCkge1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IFtdO1xuICAgIGNvbnN0IGFscmVhZHlMaW5rZWQgPSBwb2ludC5ldmVudHMgIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBuZXdMZWZ0U0UgPSBuZXcgU3dlZXBFdmVudChwb2ludCwgdHJ1ZSk7XG4gICAgY29uc3QgbmV3UmlnaHRTRSA9IG5ldyBTd2VlcEV2ZW50KHBvaW50LCBmYWxzZSk7XG4gICAgY29uc3Qgb2xkUmlnaHRTRSA9IHRoaXMucmlnaHRTRTtcbiAgICB0aGlzLnJlcGxhY2VSaWdodFNFKG5ld1JpZ2h0U0UpO1xuICAgIG5ld0V2ZW50cy5wdXNoKG5ld1JpZ2h0U0UpO1xuICAgIG5ld0V2ZW50cy5wdXNoKG5ld0xlZnRTRSk7XG4gICAgY29uc3QgbmV3U2VnID0gbmV3IFNlZ21lbnQobmV3TGVmdFNFLCBvbGRSaWdodFNFLCB0aGlzLnJpbmdzLnNsaWNlKCksIHRoaXMud2luZGluZ3Muc2xpY2UoKSk7XG5cbiAgICAvLyB3aGVuIHNwbGl0dGluZyBhIG5lYXJseSB2ZXJ0aWNhbCBkb3dud2FyZC1mYWNpbmcgc2VnbWVudCxcbiAgICAvLyBzb21ldGltZXMgb25lIG9mIHRoZSByZXN1bHRpbmcgbmV3IHNlZ21lbnRzIGlzIHZlcnRpY2FsLCBpbiB3aGljaFxuICAgIC8vIGNhc2UgaXRzIGxlZnQgYW5kIHJpZ2h0IGV2ZW50cyBtYXkgbmVlZCB0byBiZSBzd2FwcGVkXG4gICAgaWYgKFN3ZWVwRXZlbnQuY29tcGFyZVBvaW50cyhuZXdTZWcubGVmdFNFLnBvaW50LCBuZXdTZWcucmlnaHRTRS5wb2ludCkgPiAwKSB7XG4gICAgICBuZXdTZWcuc3dhcEV2ZW50cygpO1xuICAgIH1cbiAgICBpZiAoU3dlZXBFdmVudC5jb21wYXJlUG9pbnRzKHRoaXMubGVmdFNFLnBvaW50LCB0aGlzLnJpZ2h0U0UucG9pbnQpID4gMCkge1xuICAgICAgdGhpcy5zd2FwRXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLy8gaW4gdGhlIHBvaW50IHdlIGp1c3QgdXNlZCB0byBjcmVhdGUgbmV3IHN3ZWVwIGV2ZW50cyB3aXRoIHdhcyBhbHJlYWR5XG4gICAgLy8gbGlua2VkIHRvIG90aGVyIGV2ZW50cywgd2UgbmVlZCB0byBjaGVjayBpZiBlaXRoZXIgb2YgdGhlIGFmZmVjdGVkXG4gICAgLy8gc2VnbWVudHMgc2hvdWxkIGJlIGNvbnN1bWVkXG4gICAgaWYgKGFscmVhZHlMaW5rZWQpIHtcbiAgICAgIG5ld0xlZnRTRS5jaGVja0ZvckNvbnN1bWluZygpO1xuICAgICAgbmV3UmlnaHRTRS5jaGVja0ZvckNvbnN1bWluZygpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3RXZlbnRzO1xuICB9XG5cbiAgLyogU3dhcCB3aGljaCBldmVudCBpcyBsZWZ0IGFuZCByaWdodCAqL1xuICBzd2FwRXZlbnRzKCkge1xuICAgIGNvbnN0IHRtcEV2dCA9IHRoaXMucmlnaHRTRTtcbiAgICB0aGlzLnJpZ2h0U0UgPSB0aGlzLmxlZnRTRTtcbiAgICB0aGlzLmxlZnRTRSA9IHRtcEV2dDtcbiAgICB0aGlzLmxlZnRTRS5pc0xlZnQgPSB0cnVlO1xuICAgIHRoaXMucmlnaHRTRS5pc0xlZnQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMud2luZGluZ3MubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICB0aGlzLndpbmRpbmdzW2ldICo9IC0xO1xuICAgIH1cbiAgfVxuXG4gIC8qIENvbnN1bWUgYW5vdGhlciBzZWdtZW50LiBXZSB0YWtlIHRoZWlyIHJpbmdzIHVuZGVyIG91ciB3aW5nXG4gICAqIGFuZCBtYXJrIHRoZW0gYXMgY29uc3VtZWQuIFVzZSBmb3IgcGVyZmVjdGx5IG92ZXJsYXBwaW5nIHNlZ21lbnRzICovXG4gIGNvbnN1bWUob3RoZXIpIHtcbiAgICBsZXQgY29uc3VtZXIgPSB0aGlzO1xuICAgIGxldCBjb25zdW1lZSA9IG90aGVyO1xuICAgIHdoaWxlIChjb25zdW1lci5jb25zdW1lZEJ5KSBjb25zdW1lciA9IGNvbnN1bWVyLmNvbnN1bWVkQnk7XG4gICAgd2hpbGUgKGNvbnN1bWVlLmNvbnN1bWVkQnkpIGNvbnN1bWVlID0gY29uc3VtZWUuY29uc3VtZWRCeTtcbiAgICBjb25zdCBjbXAgPSBTZWdtZW50LmNvbXBhcmUoY29uc3VtZXIsIGNvbnN1bWVlKTtcbiAgICBpZiAoY21wID09PSAwKSByZXR1cm47IC8vIGFscmVhZHkgY29uc3VtZWRcbiAgICAvLyB0aGUgd2lubmVyIG9mIHRoZSBjb25zdW1wdGlvbiBpcyB0aGUgZWFybGllciBzZWdtZW50XG4gICAgLy8gYWNjb3JkaW5nIHRvIHN3ZWVwIGxpbmUgb3JkZXJpbmdcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgY29uc3QgdG1wID0gY29uc3VtZXI7XG4gICAgICBjb25zdW1lciA9IGNvbnN1bWVlO1xuICAgICAgY29uc3VtZWUgPSB0bXA7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIGEgc2VnbWVudCBkb2Vzbid0IGNvbnN1bWUgaXQncyBwcmV2XG4gICAgaWYgKGNvbnN1bWVyLnByZXYgPT09IGNvbnN1bWVlKSB7XG4gICAgICBjb25zdCB0bXAgPSBjb25zdW1lcjtcbiAgICAgIGNvbnN1bWVyID0gY29uc3VtZWU7XG4gICAgICBjb25zdW1lZSA9IHRtcDtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBjb25zdW1lZS5yaW5ncy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHJpbmcgPSBjb25zdW1lZS5yaW5nc1tpXTtcbiAgICAgIGNvbnN0IHdpbmRpbmcgPSBjb25zdW1lZS53aW5kaW5nc1tpXTtcbiAgICAgIGNvbnN0IGluZGV4ID0gY29uc3VtZXIucmluZ3MuaW5kZXhPZihyaW5nKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgY29uc3VtZXIucmluZ3MucHVzaChyaW5nKTtcbiAgICAgICAgY29uc3VtZXIud2luZGluZ3MucHVzaCh3aW5kaW5nKTtcbiAgICAgIH0gZWxzZSBjb25zdW1lci53aW5kaW5nc1tpbmRleF0gKz0gd2luZGluZztcbiAgICB9XG4gICAgY29uc3VtZWUucmluZ3MgPSBudWxsO1xuICAgIGNvbnN1bWVlLndpbmRpbmdzID0gbnVsbDtcbiAgICBjb25zdW1lZS5jb25zdW1lZEJ5ID0gY29uc3VtZXI7XG5cbiAgICAvLyBtYXJrIHN3ZWVwIGV2ZW50cyBjb25zdW1lZCBhcyB0byBtYWludGFpbiBvcmRlcmluZyBpbiBzd2VlcCBldmVudCBxdWV1ZVxuICAgIGNvbnN1bWVlLmxlZnRTRS5jb25zdW1lZEJ5ID0gY29uc3VtZXIubGVmdFNFO1xuICAgIGNvbnN1bWVlLnJpZ2h0U0UuY29uc3VtZWRCeSA9IGNvbnN1bWVyLnJpZ2h0U0U7XG4gIH1cblxuICAvKiBUaGUgZmlyc3Qgc2VnbWVudCBwcmV2aW91cyBzZWdtZW50IGNoYWluIHRoYXQgaXMgaW4gdGhlIHJlc3VsdCAqL1xuICBwcmV2SW5SZXN1bHQoKSB7XG4gICAgaWYgKHRoaXMuX3ByZXZJblJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fcHJldkluUmVzdWx0O1xuICAgIGlmICghdGhpcy5wcmV2KSB0aGlzLl9wcmV2SW5SZXN1bHQgPSBudWxsO2Vsc2UgaWYgKHRoaXMucHJldi5pc0luUmVzdWx0KCkpIHRoaXMuX3ByZXZJblJlc3VsdCA9IHRoaXMucHJldjtlbHNlIHRoaXMuX3ByZXZJblJlc3VsdCA9IHRoaXMucHJldi5wcmV2SW5SZXN1bHQoKTtcbiAgICByZXR1cm4gdGhpcy5fcHJldkluUmVzdWx0O1xuICB9XG4gIGJlZm9yZVN0YXRlKCkge1xuICAgIGlmICh0aGlzLl9iZWZvcmVTdGF0ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fYmVmb3JlU3RhdGU7XG4gICAgaWYgKCF0aGlzLnByZXYpIHRoaXMuX2JlZm9yZVN0YXRlID0ge1xuICAgICAgcmluZ3M6IFtdLFxuICAgICAgd2luZGluZ3M6IFtdLFxuICAgICAgbXVsdGlQb2x5czogW11cbiAgICB9O2Vsc2Uge1xuICAgICAgY29uc3Qgc2VnID0gdGhpcy5wcmV2LmNvbnN1bWVkQnkgfHwgdGhpcy5wcmV2O1xuICAgICAgdGhpcy5fYmVmb3JlU3RhdGUgPSBzZWcuYWZ0ZXJTdGF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYmVmb3JlU3RhdGU7XG4gIH1cbiAgYWZ0ZXJTdGF0ZSgpIHtcbiAgICBpZiAodGhpcy5fYWZ0ZXJTdGF0ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fYWZ0ZXJTdGF0ZTtcbiAgICBjb25zdCBiZWZvcmVTdGF0ZSA9IHRoaXMuYmVmb3JlU3RhdGUoKTtcbiAgICB0aGlzLl9hZnRlclN0YXRlID0ge1xuICAgICAgcmluZ3M6IGJlZm9yZVN0YXRlLnJpbmdzLnNsaWNlKDApLFxuICAgICAgd2luZGluZ3M6IGJlZm9yZVN0YXRlLndpbmRpbmdzLnNsaWNlKDApLFxuICAgICAgbXVsdGlQb2x5czogW11cbiAgICB9O1xuICAgIGNvbnN0IHJpbmdzQWZ0ZXIgPSB0aGlzLl9hZnRlclN0YXRlLnJpbmdzO1xuICAgIGNvbnN0IHdpbmRpbmdzQWZ0ZXIgPSB0aGlzLl9hZnRlclN0YXRlLndpbmRpbmdzO1xuICAgIGNvbnN0IG1wc0FmdGVyID0gdGhpcy5fYWZ0ZXJTdGF0ZS5tdWx0aVBvbHlzO1xuXG4gICAgLy8gY2FsY3VsYXRlIHJpbmdzQWZ0ZXIsIHdpbmRpbmdzQWZ0ZXJcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMucmluZ3MubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCByaW5nID0gdGhpcy5yaW5nc1tpXTtcbiAgICAgIGNvbnN0IHdpbmRpbmcgPSB0aGlzLndpbmRpbmdzW2ldO1xuICAgICAgY29uc3QgaW5kZXggPSByaW5nc0FmdGVyLmluZGV4T2YocmluZyk7XG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJpbmdzQWZ0ZXIucHVzaChyaW5nKTtcbiAgICAgICAgd2luZGluZ3NBZnRlci5wdXNoKHdpbmRpbmcpO1xuICAgICAgfSBlbHNlIHdpbmRpbmdzQWZ0ZXJbaW5kZXhdICs9IHdpbmRpbmc7XG4gICAgfVxuXG4gICAgLy8gY2FsY3VhbHRlIHBvbHlzQWZ0ZXJcbiAgICBjb25zdCBwb2x5c0FmdGVyID0gW107XG4gICAgY29uc3QgcG9seXNFeGNsdWRlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSByaW5nc0FmdGVyLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgaWYgKHdpbmRpbmdzQWZ0ZXJbaV0gPT09IDApIGNvbnRpbnVlOyAvLyBub24temVybyBydWxlXG4gICAgICBjb25zdCByaW5nID0gcmluZ3NBZnRlcltpXTtcbiAgICAgIGNvbnN0IHBvbHkgPSByaW5nLnBvbHk7XG4gICAgICBpZiAocG9seXNFeGNsdWRlLmluZGV4T2YocG9seSkgIT09IC0xKSBjb250aW51ZTtcbiAgICAgIGlmIChyaW5nLmlzRXh0ZXJpb3IpIHBvbHlzQWZ0ZXIucHVzaChwb2x5KTtlbHNlIHtcbiAgICAgICAgaWYgKHBvbHlzRXhjbHVkZS5pbmRleE9mKHBvbHkpID09PSAtMSkgcG9seXNFeGNsdWRlLnB1c2gocG9seSk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcG9seXNBZnRlci5pbmRleE9mKHJpbmcucG9seSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHBvbHlzQWZ0ZXIuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgbXVsdGlQb2x5c0FmdGVyXG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBwb2x5c0FmdGVyLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgbXAgPSBwb2x5c0FmdGVyW2ldLm11bHRpUG9seTtcbiAgICAgIGlmIChtcHNBZnRlci5pbmRleE9mKG1wKSA9PT0gLTEpIG1wc0FmdGVyLnB1c2gobXApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWZ0ZXJTdGF0ZTtcbiAgfVxuXG4gIC8qIElzIHRoaXMgc2VnbWVudCBwYXJ0IG9mIHRoZSBmaW5hbCByZXN1bHQ/ICovXG4gIGlzSW5SZXN1bHQoKSB7XG4gICAgLy8gaWYgd2UndmUgYmVlbiBjb25zdW1lZCwgd2UncmUgbm90IGluIHRoZSByZXN1bHRcbiAgICBpZiAodGhpcy5jb25zdW1lZEJ5KSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRoaXMuX2lzSW5SZXN1bHQgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX2lzSW5SZXN1bHQ7XG4gICAgY29uc3QgbXBzQmVmb3JlID0gdGhpcy5iZWZvcmVTdGF0ZSgpLm11bHRpUG9seXM7XG4gICAgY29uc3QgbXBzQWZ0ZXIgPSB0aGlzLmFmdGVyU3RhdGUoKS5tdWx0aVBvbHlzO1xuICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ1bmlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVU5JT04gLSBpbmNsdWRlZCBpZmY6XG4gICAgICAgICAgLy8gICogT24gb25lIHNpZGUgb2YgdXMgdGhlcmUgaXMgMCBwb2x5IGludGVyaW9ycyBBTkRcbiAgICAgICAgICAvLyAgKiBPbiB0aGUgb3RoZXIgc2lkZSB0aGVyZSBpcyAxIG9yIG1vcmUuXG4gICAgICAgICAgY29uc3Qgbm9CZWZvcmVzID0gbXBzQmVmb3JlLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICBjb25zdCBub0FmdGVycyA9IG1wc0FmdGVyLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICB0aGlzLl9pc0luUmVzdWx0ID0gbm9CZWZvcmVzICE9PSBub0FmdGVycztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcImludGVyc2VjdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gSU5URVJTRUNUSU9OIC0gaW5jbHVkZWQgaWZmOlxuICAgICAgICAgIC8vICAqIG9uIG9uZSBzaWRlIG9mIHVzIGFsbCBtdWx0aXBvbHlzIGFyZSByZXAuIHdpdGggcG9seSBpbnRlcmlvcnMgQU5EXG4gICAgICAgICAgLy8gICogb24gdGhlIG90aGVyIHNpZGUgb2YgdXMsIG5vdCBhbGwgbXVsdGlwb2x5cyBhcmUgcmVwc2VudGVkXG4gICAgICAgICAgLy8gICAgd2l0aCBwb2x5IGludGVyaW9yc1xuICAgICAgICAgIGxldCBsZWFzdDtcbiAgICAgICAgICBsZXQgbW9zdDtcbiAgICAgICAgICBpZiAobXBzQmVmb3JlLmxlbmd0aCA8IG1wc0FmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGVhc3QgPSBtcHNCZWZvcmUubGVuZ3RoO1xuICAgICAgICAgICAgbW9zdCA9IG1wc0FmdGVyLmxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVhc3QgPSBtcHNBZnRlci5sZW5ndGg7XG4gICAgICAgICAgICBtb3N0ID0gbXBzQmVmb3JlLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faXNJblJlc3VsdCA9IG1vc3QgPT09IG9wZXJhdGlvbi5udW1NdWx0aVBvbHlzICYmIGxlYXN0IDwgbW9zdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcInhvclwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gWE9SIC0gaW5jbHVkZWQgaWZmOlxuICAgICAgICAgIC8vICAqIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG51bWJlciBvZiBtdWx0aXBvbHlzIHJlcHJlc2VudGVkXG4gICAgICAgICAgLy8gICAgd2l0aCBwb2x5IGludGVyaW9ycyBvbiBvdXIgdHdvIHNpZGVzIGlzIGFuIG9kZCBudW1iZXJcbiAgICAgICAgICBjb25zdCBkaWZmID0gTWF0aC5hYnMobXBzQmVmb3JlLmxlbmd0aCAtIG1wc0FmdGVyLmxlbmd0aCk7XG4gICAgICAgICAgdGhpcy5faXNJblJlc3VsdCA9IGRpZmYgJSAyID09PSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiZGlmZmVyZW5jZVwiOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gRElGRkVSRU5DRSBpbmNsdWRlZCBpZmY6XG4gICAgICAgICAgLy8gICogb24gZXhhY3RseSBvbmUgc2lkZSwgd2UgaGF2ZSBqdXN0IHRoZSBzdWJqZWN0XG4gICAgICAgICAgY29uc3QgaXNKdXN0U3ViamVjdCA9IG1wcyA9PiBtcHMubGVuZ3RoID09PSAxICYmIG1wc1swXS5pc1N1YmplY3Q7XG4gICAgICAgICAgdGhpcy5faXNJblJlc3VsdCA9IGlzSnVzdFN1YmplY3QobXBzQmVmb3JlKSAhPT0gaXNKdXN0U3ViamVjdChtcHNBZnRlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG9wZXJhdGlvbiB0eXBlIGZvdW5kICR7b3BlcmF0aW9uLnR5cGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pc0luUmVzdWx0O1xuICB9XG59XG5cbmNsYXNzIFJpbmdJbiB7XG4gIGNvbnN0cnVjdG9yKGdlb21SaW5nLCBwb2x5LCBpc0V4dGVyaW9yKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGdlb21SaW5nKSB8fCBnZW9tUmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGdlb21ldHJ5IGlzIG5vdCBhIHZhbGlkIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXCIpO1xuICAgIH1cbiAgICB0aGlzLnBvbHkgPSBwb2x5O1xuICAgIHRoaXMuaXNFeHRlcmlvciA9IGlzRXh0ZXJpb3I7XG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICAgIGlmICh0eXBlb2YgZ2VvbVJpbmdbMF1bMF0gIT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGdlb21SaW5nWzBdWzFdICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBnZW9tZXRyeSBpcyBub3QgYSB2YWxpZCBQb2x5Z29uIG9yIE11bHRpUG9seWdvblwiKTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHJvdW5kZXIucm91bmQoZ2VvbVJpbmdbMF1bMF0sIGdlb21SaW5nWzBdWzFdKTtcbiAgICB0aGlzLmJib3ggPSB7XG4gICAgICBsbDoge1xuICAgICAgICB4OiBmaXJzdFBvaW50LngsXG4gICAgICAgIHk6IGZpcnN0UG9pbnQueVxuICAgICAgfSxcbiAgICAgIHVyOiB7XG4gICAgICAgIHg6IGZpcnN0UG9pbnQueCxcbiAgICAgICAgeTogZmlyc3RQb2ludC55XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgcHJldlBvaW50ID0gZmlyc3RQb2ludDtcbiAgICBmb3IgKGxldCBpID0gMSwgaU1heCA9IGdlb21SaW5nLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgaWYgKHR5cGVvZiBnZW9tUmluZ1tpXVswXSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgZ2VvbVJpbmdbaV1bMV0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZ2VvbWV0cnkgaXMgbm90IGEgdmFsaWQgUG9seWdvbiBvciBNdWx0aVBvbHlnb25cIik7XG4gICAgICB9XG4gICAgICBsZXQgcG9pbnQgPSByb3VuZGVyLnJvdW5kKGdlb21SaW5nW2ldWzBdLCBnZW9tUmluZ1tpXVsxXSk7XG4gICAgICAvLyBza2lwIHJlcGVhdGVkIHBvaW50c1xuICAgICAgaWYgKHBvaW50LnggPT09IHByZXZQb2ludC54ICYmIHBvaW50LnkgPT09IHByZXZQb2ludC55KSBjb250aW51ZTtcbiAgICAgIHRoaXMuc2VnbWVudHMucHVzaChTZWdtZW50LmZyb21SaW5nKHByZXZQb2ludCwgcG9pbnQsIHRoaXMpKTtcbiAgICAgIGlmIChwb2ludC54IDwgdGhpcy5iYm94LmxsLngpIHRoaXMuYmJveC5sbC54ID0gcG9pbnQueDtcbiAgICAgIGlmIChwb2ludC55IDwgdGhpcy5iYm94LmxsLnkpIHRoaXMuYmJveC5sbC55ID0gcG9pbnQueTtcbiAgICAgIGlmIChwb2ludC54ID4gdGhpcy5iYm94LnVyLngpIHRoaXMuYmJveC51ci54ID0gcG9pbnQueDtcbiAgICAgIGlmIChwb2ludC55ID4gdGhpcy5iYm94LnVyLnkpIHRoaXMuYmJveC51ci55ID0gcG9pbnQueTtcbiAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgIH1cbiAgICAvLyBhZGQgc2VnbWVudCBmcm9tIGxhc3QgdG8gZmlyc3QgaWYgbGFzdCBpcyBub3QgdGhlIHNhbWUgYXMgZmlyc3RcbiAgICBpZiAoZmlyc3RQb2ludC54ICE9PSBwcmV2UG9pbnQueCB8fCBmaXJzdFBvaW50LnkgIT09IHByZXZQb2ludC55KSB7XG4gICAgICB0aGlzLnNlZ21lbnRzLnB1c2goU2VnbWVudC5mcm9tUmluZyhwcmV2UG9pbnQsIGZpcnN0UG9pbnQsIHRoaXMpKTtcbiAgICB9XG4gIH1cbiAgZ2V0U3dlZXBFdmVudHMoKSB7XG4gICAgY29uc3Qgc3dlZXBFdmVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMuc2VnbWVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXTtcbiAgICAgIHN3ZWVwRXZlbnRzLnB1c2goc2VnbWVudC5sZWZ0U0UpO1xuICAgICAgc3dlZXBFdmVudHMucHVzaChzZWdtZW50LnJpZ2h0U0UpO1xuICAgIH1cbiAgICByZXR1cm4gc3dlZXBFdmVudHM7XG4gIH1cbn1cbmNsYXNzIFBvbHlJbiB7XG4gIGNvbnN0cnVjdG9yKGdlb21Qb2x5LCBtdWx0aVBvbHkpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZ2VvbVBvbHkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBnZW9tZXRyeSBpcyBub3QgYSB2YWxpZCBQb2x5Z29uIG9yIE11bHRpUG9seWdvblwiKTtcbiAgICB9XG4gICAgdGhpcy5leHRlcmlvclJpbmcgPSBuZXcgUmluZ0luKGdlb21Qb2x5WzBdLCB0aGlzLCB0cnVlKTtcbiAgICAvLyBjb3B5IGJ5IHZhbHVlXG4gICAgdGhpcy5iYm94ID0ge1xuICAgICAgbGw6IHtcbiAgICAgICAgeDogdGhpcy5leHRlcmlvclJpbmcuYmJveC5sbC54LFxuICAgICAgICB5OiB0aGlzLmV4dGVyaW9yUmluZy5iYm94LmxsLnlcbiAgICAgIH0sXG4gICAgICB1cjoge1xuICAgICAgICB4OiB0aGlzLmV4dGVyaW9yUmluZy5iYm94LnVyLngsXG4gICAgICAgIHk6IHRoaXMuZXh0ZXJpb3JSaW5nLmJib3gudXIueVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbnRlcmlvclJpbmdzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDEsIGlNYXggPSBnZW9tUG9seS5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHJpbmcgPSBuZXcgUmluZ0luKGdlb21Qb2x5W2ldLCB0aGlzLCBmYWxzZSk7XG4gICAgICBpZiAocmluZy5iYm94LmxsLnggPCB0aGlzLmJib3gubGwueCkgdGhpcy5iYm94LmxsLnggPSByaW5nLmJib3gubGwueDtcbiAgICAgIGlmIChyaW5nLmJib3gubGwueSA8IHRoaXMuYmJveC5sbC55KSB0aGlzLmJib3gubGwueSA9IHJpbmcuYmJveC5sbC55O1xuICAgICAgaWYgKHJpbmcuYmJveC51ci54ID4gdGhpcy5iYm94LnVyLngpIHRoaXMuYmJveC51ci54ID0gcmluZy5iYm94LnVyLng7XG4gICAgICBpZiAocmluZy5iYm94LnVyLnkgPiB0aGlzLmJib3gudXIueSkgdGhpcy5iYm94LnVyLnkgPSByaW5nLmJib3gudXIueTtcbiAgICAgIHRoaXMuaW50ZXJpb3JSaW5ncy5wdXNoKHJpbmcpO1xuICAgIH1cbiAgICB0aGlzLm11bHRpUG9seSA9IG11bHRpUG9seTtcbiAgfVxuICBnZXRTd2VlcEV2ZW50cygpIHtcbiAgICBjb25zdCBzd2VlcEV2ZW50cyA9IHRoaXMuZXh0ZXJpb3JSaW5nLmdldFN3ZWVwRXZlbnRzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSB0aGlzLmludGVyaW9yUmluZ3MubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCByaW5nU3dlZXBFdmVudHMgPSB0aGlzLmludGVyaW9yUmluZ3NbaV0uZ2V0U3dlZXBFdmVudHMoKTtcbiAgICAgIGZvciAobGV0IGogPSAwLCBqTWF4ID0gcmluZ1N3ZWVwRXZlbnRzLmxlbmd0aDsgaiA8IGpNYXg7IGorKykge1xuICAgICAgICBzd2VlcEV2ZW50cy5wdXNoKHJpbmdTd2VlcEV2ZW50c1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzd2VlcEV2ZW50cztcbiAgfVxufVxuY2xhc3MgTXVsdGlQb2x5SW4ge1xuICBjb25zdHJ1Y3RvcihnZW9tLCBpc1N1YmplY3QpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZ2VvbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGdlb21ldHJ5IGlzIG5vdCBhIHZhbGlkIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uXCIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gaWYgdGhlIGlucHV0IGxvb2tzIGxpa2UgYSBwb2x5Z29uLCBjb252ZXJ0IGl0IHRvIGEgbXVsdGlwb2x5Z29uXG4gICAgICBpZiAodHlwZW9mIGdlb21bMF1bMF1bMF0gPT09IFwibnVtYmVyXCIpIGdlb20gPSBbZ2VvbV07XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIC8vIFRoZSBpbnB1dCBpcyBlaXRoZXIgbWFsZm9ybWVkIG9yIGhhcyBlbXB0eSBhcnJheXMuXG4gICAgICAvLyBJbiBlaXRoZXIgY2FzZSwgaXQgd2lsbCBiZSBoYW5kbGVkIGxhdGVyIG9uLlxuICAgIH1cbiAgICB0aGlzLnBvbHlzID0gW107XG4gICAgdGhpcy5iYm94ID0ge1xuICAgICAgbGw6IHtcbiAgICAgICAgeDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICB5OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgIH0sXG4gICAgICB1cjoge1xuICAgICAgICB4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgIHk6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBnZW9tLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgcG9seSA9IG5ldyBQb2x5SW4oZ2VvbVtpXSwgdGhpcyk7XG4gICAgICBpZiAocG9seS5iYm94LmxsLnggPCB0aGlzLmJib3gubGwueCkgdGhpcy5iYm94LmxsLnggPSBwb2x5LmJib3gubGwueDtcbiAgICAgIGlmIChwb2x5LmJib3gubGwueSA8IHRoaXMuYmJveC5sbC55KSB0aGlzLmJib3gubGwueSA9IHBvbHkuYmJveC5sbC55O1xuICAgICAgaWYgKHBvbHkuYmJveC51ci54ID4gdGhpcy5iYm94LnVyLngpIHRoaXMuYmJveC51ci54ID0gcG9seS5iYm94LnVyLng7XG4gICAgICBpZiAocG9seS5iYm94LnVyLnkgPiB0aGlzLmJib3gudXIueSkgdGhpcy5iYm94LnVyLnkgPSBwb2x5LmJib3gudXIueTtcbiAgICAgIHRoaXMucG9seXMucHVzaChwb2x5KTtcbiAgICB9XG4gICAgdGhpcy5pc1N1YmplY3QgPSBpc1N1YmplY3Q7XG4gIH1cbiAgZ2V0U3dlZXBFdmVudHMoKSB7XG4gICAgY29uc3Qgc3dlZXBFdmVudHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHRoaXMucG9seXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2x5U3dlZXBFdmVudHMgPSB0aGlzLnBvbHlzW2ldLmdldFN3ZWVwRXZlbnRzKCk7XG4gICAgICBmb3IgKGxldCBqID0gMCwgak1heCA9IHBvbHlTd2VlcEV2ZW50cy5sZW5ndGg7IGogPCBqTWF4OyBqKyspIHtcbiAgICAgICAgc3dlZXBFdmVudHMucHVzaChwb2x5U3dlZXBFdmVudHNbal0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3dlZXBFdmVudHM7XG4gIH1cbn1cblxuY2xhc3MgUmluZ091dCB7XG4gIC8qIEdpdmVuIHRoZSBzZWdtZW50cyBmcm9tIHRoZSBzd2VlcCBsaW5lIHBhc3MsIGNvbXB1dGUgJiByZXR1cm4gYSBzZXJpZXNcbiAgICogb2YgY2xvc2VkIHJpbmdzIGZyb20gYWxsIHRoZSBzZWdtZW50cyBtYXJrZWQgdG8gYmUgcGFydCBvZiB0aGUgcmVzdWx0ICovXG4gIHN0YXRpYyBmYWN0b3J5KGFsbFNlZ21lbnRzKSB7XG4gICAgY29uc3QgcmluZ3NPdXQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IGFsbFNlZ21lbnRzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3Qgc2VnbWVudCA9IGFsbFNlZ21lbnRzW2ldO1xuICAgICAgaWYgKCFzZWdtZW50LmlzSW5SZXN1bHQoKSB8fCBzZWdtZW50LnJpbmdPdXQpIGNvbnRpbnVlO1xuICAgICAgbGV0IHByZXZFdmVudCA9IG51bGw7XG4gICAgICBsZXQgZXZlbnQgPSBzZWdtZW50LmxlZnRTRTtcbiAgICAgIGxldCBuZXh0RXZlbnQgPSBzZWdtZW50LnJpZ2h0U0U7XG4gICAgICBjb25zdCBldmVudHMgPSBbZXZlbnRdO1xuICAgICAgY29uc3Qgc3RhcnRpbmdQb2ludCA9IGV2ZW50LnBvaW50O1xuICAgICAgY29uc3QgaW50ZXJzZWN0aW9uTEVzID0gW107XG5cbiAgICAgIC8qIFdhbGsgdGhlIGNoYWluIG9mIGxpbmtlZCBldmVudHMgdG8gZm9ybSBhIGNsb3NlZCByaW5nICovXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwcmV2RXZlbnQgPSBldmVudDtcbiAgICAgICAgZXZlbnQgPSBuZXh0RXZlbnQ7XG4gICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcblxuICAgICAgICAvKiBJcyB0aGUgcmluZyBjb21wbGV0ZT8gKi9cbiAgICAgICAgaWYgKGV2ZW50LnBvaW50ID09PSBzdGFydGluZ1BvaW50KSBicmVhaztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCBhdmFpbGFibGVMRXMgPSBldmVudC5nZXRBdmFpbGFibGVMaW5rZWRFdmVudHMoKTtcblxuICAgICAgICAgIC8qIERpZCB3ZSBoaXQgYSBkZWFkIGVuZD8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuLlxuICAgICAgICAgICAqIEluZGljYXRlcyBzb21lIGVhcmxpZXIgcGFydCBvZiB0aGUgYWxnb3JpdGhtIG1hbGZ1bmN0aW9uZWQuICovXG4gICAgICAgICAgaWYgKGF2YWlsYWJsZUxFcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0UHQgPSBldmVudHNbMF0ucG9pbnQ7XG4gICAgICAgICAgICBjb25zdCBsYXN0UHQgPSBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdLnBvaW50O1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gY29tcGxldGUgb3V0cHV0IHJpbmcgc3RhcnRpbmcgYXQgWyR7Zmlyc3RQdC54fSxgICsgYCAke2ZpcnN0UHQueX1dLiBMYXN0IG1hdGNoaW5nIHNlZ21lbnQgZm91bmQgZW5kcyBhdGAgKyBgIFske2xhc3RQdC54fSwgJHtsYXN0UHQueX1dLmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIE9ubHkgb25lIHdheSB0byBnbywgc28gY290aW51ZSBvbiB0aGUgcGF0aCAqL1xuICAgICAgICAgIGlmIChhdmFpbGFibGVMRXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBuZXh0RXZlbnQgPSBhdmFpbGFibGVMRXNbMF0ub3RoZXJTRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qIFdlIG11c3QgaGF2ZSBhbiBpbnRlcnNlY3Rpb24uIENoZWNrIGZvciBhIGNvbXBsZXRlZCBsb29wICovXG4gICAgICAgICAgbGV0IGluZGV4TEUgPSBudWxsO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwLCBqTWF4ID0gaW50ZXJzZWN0aW9uTEVzLmxlbmd0aDsgaiA8IGpNYXg7IGorKykge1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbkxFc1tqXS5wb2ludCA9PT0gZXZlbnQucG9pbnQpIHtcbiAgICAgICAgICAgICAgaW5kZXhMRSA9IGo7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBGb3VuZCBhIGNvbXBsZXRlZCBsb29wLiBDdXQgdGhhdCBvZmYgYW5kIG1ha2UgYSByaW5nICovXG4gICAgICAgICAgaWYgKGluZGV4TEUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdGlvbkxFID0gaW50ZXJzZWN0aW9uTEVzLnNwbGljZShpbmRleExFKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHJpbmdFdmVudHMgPSBldmVudHMuc3BsaWNlKGludGVyc2VjdGlvbkxFLmluZGV4KTtcbiAgICAgICAgICAgIHJpbmdFdmVudHMudW5zaGlmdChyaW5nRXZlbnRzWzBdLm90aGVyU0UpO1xuICAgICAgICAgICAgcmluZ3NPdXQucHVzaChuZXcgUmluZ091dChyaW5nRXZlbnRzLnJldmVyc2UoKSkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIHJlZ2lzdGVyIHRoZSBpbnRlcnNlY3Rpb24gKi9cbiAgICAgICAgICBpbnRlcnNlY3Rpb25MRXMucHVzaCh7XG4gICAgICAgICAgICBpbmRleDogZXZlbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIHBvaW50OiBldmVudC5wb2ludFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8qIENob29zZSB0aGUgbGVmdC1tb3N0IG9wdGlvbiB0byBjb250aW51ZSB0aGUgd2FsayAqL1xuICAgICAgICAgIGNvbnN0IGNvbXBhcmF0b3IgPSBldmVudC5nZXRMZWZ0bW9zdENvbXBhcmF0b3IocHJldkV2ZW50KTtcbiAgICAgICAgICBuZXh0RXZlbnQgPSBhdmFpbGFibGVMRXMuc29ydChjb21wYXJhdG9yKVswXS5vdGhlclNFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByaW5nc091dC5wdXNoKG5ldyBSaW5nT3V0KGV2ZW50cykpO1xuICAgIH1cbiAgICByZXR1cm4gcmluZ3NPdXQ7XG4gIH1cbiAgY29uc3RydWN0b3IoZXZlbnRzKSB7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBldmVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBldmVudHNbaV0uc2VnbWVudC5yaW5nT3V0ID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5wb2x5ID0gbnVsbDtcbiAgfVxuICBnZXRHZW9tKCkge1xuICAgIC8vIFJlbW92ZSBzdXBlcmZsdW91cyBwb2ludHMgKGllIGV4dHJhIHBvaW50cyBhbG9uZyBhIHN0cmFpZ2h0IGxpbmUpLFxuICAgIGxldCBwcmV2UHQgPSB0aGlzLmV2ZW50c1swXS5wb2ludDtcbiAgICBjb25zdCBwb2ludHMgPSBbcHJldlB0XTtcbiAgICBmb3IgKGxldCBpID0gMSwgaU1heCA9IHRoaXMuZXZlbnRzLmxlbmd0aCAtIDE7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHB0ID0gdGhpcy5ldmVudHNbaV0ucG9pbnQ7XG4gICAgICBjb25zdCBuZXh0UHQgPSB0aGlzLmV2ZW50c1tpICsgMV0ucG9pbnQ7XG4gICAgICBpZiAoY29tcGFyZVZlY3RvckFuZ2xlcyhwdCwgcHJldlB0LCBuZXh0UHQpID09PSAwKSBjb250aW51ZTtcbiAgICAgIHBvaW50cy5wdXNoKHB0KTtcbiAgICAgIHByZXZQdCA9IHB0O1xuICAgIH1cblxuICAgIC8vIHJpbmcgd2FzIGFsbCAod2l0aGluIHJvdW5kaW5nIGVycm9yIG9mIGFuZ2xlIGNhbGMpIGNvbGluZWFyIHBvaW50c1xuICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAxKSByZXR1cm4gbnVsbDtcblxuICAgIC8vIGNoZWNrIGlmIHRoZSBzdGFydGluZyBwb2ludCBpcyBuZWNlc3NhcnlcbiAgICBjb25zdCBwdCA9IHBvaW50c1swXTtcbiAgICBjb25zdCBuZXh0UHQgPSBwb2ludHNbMV07XG4gICAgaWYgKGNvbXBhcmVWZWN0b3JBbmdsZXMocHQsIHByZXZQdCwgbmV4dFB0KSA9PT0gMCkgcG9pbnRzLnNoaWZ0KCk7XG4gICAgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTtcbiAgICBjb25zdCBzdGVwID0gdGhpcy5pc0V4dGVyaW9yUmluZygpID8gMSA6IC0xO1xuICAgIGNvbnN0IGlTdGFydCA9IHRoaXMuaXNFeHRlcmlvclJpbmcoKSA/IDAgOiBwb2ludHMubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBpRW5kID0gdGhpcy5pc0V4dGVyaW9yUmluZygpID8gcG9pbnRzLmxlbmd0aCA6IC0xO1xuICAgIGNvbnN0IG9yZGVyZWRQb2ludHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gaVN0YXJ0OyBpICE9IGlFbmQ7IGkgKz0gc3RlcCkgb3JkZXJlZFBvaW50cy5wdXNoKFtwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnldKTtcbiAgICByZXR1cm4gb3JkZXJlZFBvaW50cztcbiAgfVxuICBpc0V4dGVyaW9yUmluZygpIHtcbiAgICBpZiAodGhpcy5faXNFeHRlcmlvclJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZW5jbG9zaW5nID0gdGhpcy5lbmNsb3NpbmdSaW5nKCk7XG4gICAgICB0aGlzLl9pc0V4dGVyaW9yUmluZyA9IGVuY2xvc2luZyA/ICFlbmNsb3NpbmcuaXNFeHRlcmlvclJpbmcoKSA6IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9pc0V4dGVyaW9yUmluZztcbiAgfVxuICBlbmNsb3NpbmdSaW5nKCkge1xuICAgIGlmICh0aGlzLl9lbmNsb3NpbmdSaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2VuY2xvc2luZ1JpbmcgPSB0aGlzLl9jYWxjRW5jbG9zaW5nUmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW5jbG9zaW5nUmluZztcbiAgfVxuXG4gIC8qIFJldHVybnMgdGhlIHJpbmcgdGhhdCBlbmNsb3NlcyB0aGlzIG9uZSwgaWYgYW55ICovXG4gIF9jYWxjRW5jbG9zaW5nUmluZygpIHtcbiAgICAvLyBzdGFydCB3aXRoIHRoZSBlYWxpZXIgc3dlZXAgbGluZSBldmVudCBzbyB0aGF0IHRoZSBwcmV2U2VnXG4gICAgLy8gY2hhaW4gZG9lc24ndCBsZWFkIHVzIGluc2lkZSBvZiBhIGxvb3Agb2Ygb3Vyc1xuICAgIGxldCBsZWZ0TW9zdEV2dCA9IHRoaXMuZXZlbnRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxLCBpTWF4ID0gdGhpcy5ldmVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBjb25zdCBldnQgPSB0aGlzLmV2ZW50c1tpXTtcbiAgICAgIGlmIChTd2VlcEV2ZW50LmNvbXBhcmUobGVmdE1vc3RFdnQsIGV2dCkgPiAwKSBsZWZ0TW9zdEV2dCA9IGV2dDtcbiAgICB9XG4gICAgbGV0IHByZXZTZWcgPSBsZWZ0TW9zdEV2dC5zZWdtZW50LnByZXZJblJlc3VsdCgpO1xuICAgIGxldCBwcmV2UHJldlNlZyA9IHByZXZTZWcgPyBwcmV2U2VnLnByZXZJblJlc3VsdCgpIDogbnVsbDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gbm8gc2VnbWVudCBmb3VuZCwgdGh1cyBubyByaW5nIGNhbiBlbmNsb3NlIHVzXG4gICAgICBpZiAoIXByZXZTZWcpIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBubyBzZWdtZW50cyBiZWxvdyBwcmV2IHNlZ21lbnQgZm91bmQsIHRodXMgdGhlIHJpbmcgb2YgdGhlIHByZXZcbiAgICAgIC8vIHNlZ21lbnQgbXVzdCBsb29wIGJhY2sgYXJvdW5kIGFuZCBlbmNsb3NlIHVzXG4gICAgICBpZiAoIXByZXZQcmV2U2VnKSByZXR1cm4gcHJldlNlZy5yaW5nT3V0O1xuXG4gICAgICAvLyBpZiB0aGUgdHdvIHNlZ21lbnRzIGFyZSBvZiBkaWZmZXJlbnQgcmluZ3MsIHRoZSByaW5nIG9mIHRoZSBwcmV2XG4gICAgICAvLyBzZWdtZW50IG11c3QgZWl0aGVyIGxvb3AgYXJvdW5kIHVzIG9yIHRoZSByaW5nIG9mIHRoZSBwcmV2IHByZXZcbiAgICAgIC8vIHNlZywgd2hpY2ggd291bGQgbWFrZSB1cyBhbmQgdGhlIHJpbmcgb2YgdGhlIHByZXYgcGVlcnNcbiAgICAgIGlmIChwcmV2UHJldlNlZy5yaW5nT3V0ICE9PSBwcmV2U2VnLnJpbmdPdXQpIHtcbiAgICAgICAgaWYgKHByZXZQcmV2U2VnLnJpbmdPdXQuZW5jbG9zaW5nUmluZygpICE9PSBwcmV2U2VnLnJpbmdPdXQpIHtcbiAgICAgICAgICByZXR1cm4gcHJldlNlZy5yaW5nT3V0O1xuICAgICAgICB9IGVsc2UgcmV0dXJuIHByZXZTZWcucmluZ091dC5lbmNsb3NpbmdSaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHR3byBzZWdtZW50cyBhcmUgZnJvbSB0aGUgc2FtZSByaW5nLCBzbyB0aGlzIHdhcyBhIHBlbmlzdWxhXG4gICAgICAvLyBvZiB0aGF0IHJpbmcuIGl0ZXJhdGUgZG93bndhcmQsIGtlZXAgc2VhcmNoaW5nXG4gICAgICBwcmV2U2VnID0gcHJldlByZXZTZWcucHJldkluUmVzdWx0KCk7XG4gICAgICBwcmV2UHJldlNlZyA9IHByZXZTZWcgPyBwcmV2U2VnLnByZXZJblJlc3VsdCgpIDogbnVsbDtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFBvbHlPdXQge1xuICBjb25zdHJ1Y3RvcihleHRlcmlvclJpbmcpIHtcbiAgICB0aGlzLmV4dGVyaW9yUmluZyA9IGV4dGVyaW9yUmluZztcbiAgICBleHRlcmlvclJpbmcucG9seSA9IHRoaXM7XG4gICAgdGhpcy5pbnRlcmlvclJpbmdzID0gW107XG4gIH1cbiAgYWRkSW50ZXJpb3IocmluZykge1xuICAgIHRoaXMuaW50ZXJpb3JSaW5ncy5wdXNoKHJpbmcpO1xuICAgIHJpbmcucG9seSA9IHRoaXM7XG4gIH1cbiAgZ2V0R2VvbSgpIHtcbiAgICBjb25zdCBnZW9tID0gW3RoaXMuZXh0ZXJpb3JSaW5nLmdldEdlb20oKV07XG4gICAgLy8gZXh0ZXJpb3IgcmluZyB3YXMgYWxsICh3aXRoaW4gcm91bmRpbmcgZXJyb3Igb2YgYW5nbGUgY2FsYykgY29saW5lYXIgcG9pbnRzXG4gICAgaWYgKGdlb21bMF0gPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gdGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgcmluZ0dlb20gPSB0aGlzLmludGVyaW9yUmluZ3NbaV0uZ2V0R2VvbSgpO1xuICAgICAgLy8gaW50ZXJpb3IgcmluZyB3YXMgYWxsICh3aXRoaW4gcm91bmRpbmcgZXJyb3Igb2YgYW5nbGUgY2FsYykgY29saW5lYXIgcG9pbnRzXG4gICAgICBpZiAocmluZ0dlb20gPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgZ2VvbS5wdXNoKHJpbmdHZW9tKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlb207XG4gIH1cbn1cbmNsYXNzIE11bHRpUG9seU91dCB7XG4gIGNvbnN0cnVjdG9yKHJpbmdzKSB7XG4gICAgdGhpcy5yaW5ncyA9IHJpbmdzO1xuICAgIHRoaXMucG9seXMgPSB0aGlzLl9jb21wb3NlUG9seXMocmluZ3MpO1xuICB9XG4gIGdldEdlb20oKSB7XG4gICAgY29uc3QgZ2VvbSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gdGhpcy5wb2x5cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvbHlHZW9tID0gdGhpcy5wb2x5c1tpXS5nZXRHZW9tKCk7XG4gICAgICAvLyBleHRlcmlvciByaW5nIHdhcyBhbGwgKHdpdGhpbiByb3VuZGluZyBlcnJvciBvZiBhbmdsZSBjYWxjKSBjb2xpbmVhciBwb2ludHNcbiAgICAgIGlmIChwb2x5R2VvbSA9PT0gbnVsbCkgY29udGludWU7XG4gICAgICBnZW9tLnB1c2gocG9seUdlb20pO1xuICAgIH1cbiAgICByZXR1cm4gZ2VvbTtcbiAgfVxuICBfY29tcG9zZVBvbHlzKHJpbmdzKSB7XG4gICAgY29uc3QgcG9seXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IHJpbmdzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgY29uc3QgcmluZyA9IHJpbmdzW2ldO1xuICAgICAgaWYgKHJpbmcucG9seSkgY29udGludWU7XG4gICAgICBpZiAocmluZy5pc0V4dGVyaW9yUmluZygpKSBwb2x5cy5wdXNoKG5ldyBQb2x5T3V0KHJpbmcpKTtlbHNlIHtcbiAgICAgICAgY29uc3QgZW5jbG9zaW5nUmluZyA9IHJpbmcuZW5jbG9zaW5nUmluZygpO1xuICAgICAgICBpZiAoIWVuY2xvc2luZ1JpbmcucG9seSkgcG9seXMucHVzaChuZXcgUG9seU91dChlbmNsb3NpbmdSaW5nKSk7XG4gICAgICAgIGVuY2xvc2luZ1JpbmcucG9seS5hZGRJbnRlcmlvcihyaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvbHlzO1xuICB9XG59XG5cbi8qKlxuICogTk9URTogIFdlIG11c3QgYmUgY2FyZWZ1bCBub3QgdG8gY2hhbmdlIGFueSBzZWdtZW50cyB3aGlsZVxuICogICAgICAgIHRoZXkgYXJlIGluIHRoZSBTcGxheVRyZWUuIEFGQUlLLCB0aGVyZSdzIG5vIHdheSB0byB0ZWxsXG4gKiAgICAgICAgdGhlIHRyZWUgdG8gcmViYWxhbmNlIGl0c2VsZiAtIHRodXMgYmVmb3JlIHNwbGl0dGluZ1xuICogICAgICAgIGEgc2VnbWVudCB0aGF0J3MgaW4gdGhlIHRyZWUsIHdlIHJlbW92ZSBpdCBmcm9tIHRoZSB0cmVlLFxuICogICAgICAgIGRvIHRoZSBzcGxpdCwgdGhlbiByZS1pbnNlcnQgaXQuIChFdmVuIHRob3VnaCBzcGxpdHRpbmcgYVxuICogICAgICAgIHNlZ21lbnQgKnNob3VsZG4ndCogY2hhbmdlIGl0cyBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZVxuICogICAgICAgIHN3ZWVwIGxpbmUgdHJlZSwgdGhlIHJlYWxpdHkgaXMgYmVjYXVzZSBvZiByb3VuZGluZyBlcnJvcnMsXG4gKiAgICAgICAgaXQgc29tZXRpbWVzIGRvZXMuKVxuICovXG5cbmNsYXNzIFN3ZWVwTGluZSB7XG4gIGNvbnN0cnVjdG9yKHF1ZXVlKSB7XG4gICAgbGV0IGNvbXBhcmF0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFNlZ21lbnQuY29tcGFyZTtcbiAgICB0aGlzLnF1ZXVlID0gcXVldWU7XG4gICAgdGhpcy50cmVlID0gbmV3IFNwbGF5VHJlZShjb21wYXJhdG9yKTtcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gIH1cbiAgcHJvY2VzcyhldmVudCkge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBldmVudC5zZWdtZW50O1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IFtdO1xuXG4gICAgLy8gaWYgd2UndmUgYWxyZWFkeSBiZWVuIGNvbnN1bWVkIGJ5IGFub3RoZXIgc2VnbWVudCxcbiAgICAvLyBjbGVhbiB1cCBvdXIgYm9keSBwYXJ0cyBhbmQgZ2V0IG91dFxuICAgIGlmIChldmVudC5jb25zdW1lZEJ5KSB7XG4gICAgICBpZiAoZXZlbnQuaXNMZWZ0KSB0aGlzLnF1ZXVlLnJlbW92ZShldmVudC5vdGhlclNFKTtlbHNlIHRoaXMudHJlZS5yZW1vdmUoc2VnbWVudCk7XG4gICAgICByZXR1cm4gbmV3RXZlbnRzO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gZXZlbnQuaXNMZWZ0ID8gdGhpcy50cmVlLmFkZChzZWdtZW50KSA6IHRoaXMudHJlZS5maW5kKHNlZ21lbnQpO1xuICAgIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBzZWdtZW50ICMke3NlZ21lbnQuaWR9IGAgKyBgWyR7c2VnbWVudC5sZWZ0U0UucG9pbnQueH0sICR7c2VnbWVudC5sZWZ0U0UucG9pbnQueX1dIC0+IGAgKyBgWyR7c2VnbWVudC5yaWdodFNFLnBvaW50Lnh9LCAke3NlZ21lbnQucmlnaHRTRS5wb2ludC55fV0gYCArIFwiaW4gU3dlZXBMaW5lIHRyZWUuXCIpO1xuICAgIGxldCBwcmV2Tm9kZSA9IG5vZGU7XG4gICAgbGV0IG5leHROb2RlID0gbm9kZTtcbiAgICBsZXQgcHJldlNlZyA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbmV4dFNlZyA9IHVuZGVmaW5lZDtcblxuICAgIC8vIHNraXAgY29uc3VtZWQgc2VnbWVudHMgc3RpbGwgaW4gdHJlZVxuICAgIHdoaWxlIChwcmV2U2VnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHByZXZOb2RlID0gdGhpcy50cmVlLnByZXYocHJldk5vZGUpO1xuICAgICAgaWYgKHByZXZOb2RlID09PSBudWxsKSBwcmV2U2VnID0gbnVsbDtlbHNlIGlmIChwcmV2Tm9kZS5rZXkuY29uc3VtZWRCeSA9PT0gdW5kZWZpbmVkKSBwcmV2U2VnID0gcHJldk5vZGUua2V5O1xuICAgIH1cblxuICAgIC8vIHNraXAgY29uc3VtZWQgc2VnbWVudHMgc3RpbGwgaW4gdHJlZVxuICAgIHdoaWxlIChuZXh0U2VnID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5leHROb2RlID0gdGhpcy50cmVlLm5leHQobmV4dE5vZGUpO1xuICAgICAgaWYgKG5leHROb2RlID09PSBudWxsKSBuZXh0U2VnID0gbnVsbDtlbHNlIGlmIChuZXh0Tm9kZS5rZXkuY29uc3VtZWRCeSA9PT0gdW5kZWZpbmVkKSBuZXh0U2VnID0gbmV4dE5vZGUua2V5O1xuICAgIH1cbiAgICBpZiAoZXZlbnQuaXNMZWZ0KSB7XG4gICAgICAvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9ucyBhZ2FpbnN0IHRoZSBwcmV2aW91cyBzZWdtZW50IGluIHRoZSBzd2VlcCBsaW5lXG4gICAgICBsZXQgcHJldk15U3BsaXR0ZXIgPSBudWxsO1xuICAgICAgaWYgKHByZXZTZWcpIHtcbiAgICAgICAgY29uc3QgcHJldkludGVyID0gcHJldlNlZy5nZXRJbnRlcnNlY3Rpb24oc2VnbWVudCk7XG4gICAgICAgIGlmIChwcmV2SW50ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIXNlZ21lbnQuaXNBbkVuZHBvaW50KHByZXZJbnRlcikpIHByZXZNeVNwbGl0dGVyID0gcHJldkludGVyO1xuICAgICAgICAgIGlmICghcHJldlNlZy5pc0FuRW5kcG9pbnQocHJldkludGVyKSkge1xuICAgICAgICAgICAgY29uc3QgbmV3RXZlbnRzRnJvbVNwbGl0ID0gdGhpcy5fc3BsaXRTYWZlbHkocHJldlNlZywgcHJldkludGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gbmV3RXZlbnRzRnJvbVNwbGl0Lmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICAgICAgICBuZXdFdmVudHMucHVzaChuZXdFdmVudHNGcm9tU3BsaXRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9ucyBhZ2FpbnN0IHRoZSBuZXh0IHNlZ21lbnQgaW4gdGhlIHN3ZWVwIGxpbmVcbiAgICAgIGxldCBuZXh0TXlTcGxpdHRlciA9IG51bGw7XG4gICAgICBpZiAobmV4dFNlZykge1xuICAgICAgICBjb25zdCBuZXh0SW50ZXIgPSBuZXh0U2VnLmdldEludGVyc2VjdGlvbihzZWdtZW50KTtcbiAgICAgICAgaWYgKG5leHRJbnRlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghc2VnbWVudC5pc0FuRW5kcG9pbnQobmV4dEludGVyKSkgbmV4dE15U3BsaXR0ZXIgPSBuZXh0SW50ZXI7XG4gICAgICAgICAgaWYgKCFuZXh0U2VnLmlzQW5FbmRwb2ludChuZXh0SW50ZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudHNGcm9tU3BsaXQgPSB0aGlzLl9zcGxpdFNhZmVseShuZXh0U2VnLCBuZXh0SW50ZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBuZXdFdmVudHNGcm9tU3BsaXQubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgICAgICAgIG5ld0V2ZW50cy5wdXNoKG5ld0V2ZW50c0Zyb21TcGxpdFtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZvciBzaW1wbGljaXR5LCBldmVuIGlmIHdlIGZpbmQgbW9yZSB0aGFuIG9uZSBpbnRlcnNlY3Rpb24gd2Ugb25seVxuICAgICAgLy8gc3BpbHQgb24gdGhlICdlYXJsaWVzdCcgKHN3ZWVwLWxpbmUgc3R5bGUpIG9mIHRoZSBpbnRlcnNlY3Rpb25zLlxuICAgICAgLy8gVGhlIG90aGVyIGludGVyc2VjdGlvbiB3aWxsIGJlIGhhbmRsZWQgaW4gYSBmdXR1cmUgcHJvY2VzcygpLlxuICAgICAgaWYgKHByZXZNeVNwbGl0dGVyICE9PSBudWxsIHx8IG5leHRNeVNwbGl0dGVyICE9PSBudWxsKSB7XG4gICAgICAgIGxldCBteVNwbGl0dGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHByZXZNeVNwbGl0dGVyID09PSBudWxsKSBteVNwbGl0dGVyID0gbmV4dE15U3BsaXR0ZXI7ZWxzZSBpZiAobmV4dE15U3BsaXR0ZXIgPT09IG51bGwpIG15U3BsaXR0ZXIgPSBwcmV2TXlTcGxpdHRlcjtlbHNlIHtcbiAgICAgICAgICBjb25zdCBjbXBTcGxpdHRlcnMgPSBTd2VlcEV2ZW50LmNvbXBhcmVQb2ludHMocHJldk15U3BsaXR0ZXIsIG5leHRNeVNwbGl0dGVyKTtcbiAgICAgICAgICBteVNwbGl0dGVyID0gY21wU3BsaXR0ZXJzIDw9IDAgPyBwcmV2TXlTcGxpdHRlciA6IG5leHRNeVNwbGl0dGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm91bmRpbmcgZXJyb3JzIGNhbiBjYXVzZSBjaGFuZ2VzIGluIG9yZGVyaW5nLFxuICAgICAgICAvLyBzbyByZW1vdmUgYWZlY3RlZCBzZWdtZW50cyBhbmQgcmlnaHQgc3dlZXAgZXZlbnRzIGJlZm9yZSBzcGxpdHRpbmdcbiAgICAgICAgdGhpcy5xdWV1ZS5yZW1vdmUoc2VnbWVudC5yaWdodFNFKTtcbiAgICAgICAgbmV3RXZlbnRzLnB1c2goc2VnbWVudC5yaWdodFNFKTtcbiAgICAgICAgY29uc3QgbmV3RXZlbnRzRnJvbVNwbGl0ID0gc2VnbWVudC5zcGxpdChteVNwbGl0dGVyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBuZXdFdmVudHNGcm9tU3BsaXQubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgICAgbmV3RXZlbnRzLnB1c2gobmV3RXZlbnRzRnJvbVNwbGl0W2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld0V2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIFdlIGZvdW5kIHNvbWUgaW50ZXJzZWN0aW9ucywgc28gcmUtZG8gdGhlIGN1cnJlbnQgZXZlbnQgdG9cbiAgICAgICAgLy8gbWFrZSBzdXJlIHN3ZWVwIGxpbmUgb3JkZXJpbmcgaXMgdG90YWxseSBjb25zaXN0ZW50IGZvciBsYXRlclxuICAgICAgICAvLyB1c2Ugd2l0aCB0aGUgc2VnbWVudCAncHJldicgcG9pbnRlcnNcbiAgICAgICAgdGhpcy50cmVlLnJlbW92ZShzZWdtZW50KTtcbiAgICAgICAgbmV3RXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG9uZSB3aXRoIGxlZnQgZXZlbnRcbiAgICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICBzZWdtZW50LnByZXYgPSBwcmV2U2VnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBldmVudC5pc1JpZ2h0XG5cbiAgICAgIC8vIHNpbmNlIHdlJ3JlIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgc3dlZXAgbGluZSwgY2hlY2sgZm9yXG4gICAgICAvLyBpbnRlcnNlY3Rpb25zIGJldHdlZW4gb3VyIHByZXZpb3VzIGFuZCBuZXh0IHNlZ21lbnRzXG4gICAgICBpZiAocHJldlNlZyAmJiBuZXh0U2VnKSB7XG4gICAgICAgIGNvbnN0IGludGVyID0gcHJldlNlZy5nZXRJbnRlcnNlY3Rpb24obmV4dFNlZyk7XG4gICAgICAgIGlmIChpbnRlciAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghcHJldlNlZy5pc0FuRW5kcG9pbnQoaW50ZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudHNGcm9tU3BsaXQgPSB0aGlzLl9zcGxpdFNhZmVseShwcmV2U2VnLCBpbnRlcik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IG5ld0V2ZW50c0Zyb21TcGxpdC5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgbmV3RXZlbnRzLnB1c2gobmV3RXZlbnRzRnJvbVNwbGl0W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFuZXh0U2VnLmlzQW5FbmRwb2ludChpbnRlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0V2ZW50c0Zyb21TcGxpdCA9IHRoaXMuX3NwbGl0U2FmZWx5KG5leHRTZWcsIGludGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gbmV3RXZlbnRzRnJvbVNwbGl0Lmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICAgICAgICBuZXdFdmVudHMucHVzaChuZXdFdmVudHNGcm9tU3BsaXRbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50cmVlLnJlbW92ZShzZWdtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0V2ZW50cztcbiAgfVxuXG4gIC8qIFNhZmVseSBzcGxpdCBhIHNlZ21lbnQgdGhhdCBpcyBjdXJyZW50bHkgaW4gdGhlIGRhdGFzdHJ1Y3R1cmVzXG4gICAqIElFIC0gYSBzZWdtZW50IG90aGVyIHRoYW4gdGhlIG9uZSB0aGF0IGlzIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuICovXG4gIF9zcGxpdFNhZmVseShzZWcsIHB0KSB7XG4gICAgLy8gUm91bmRpbmcgZXJyb3JzIGNhbiBjYXVzZSBjaGFuZ2VzIGluIG9yZGVyaW5nLFxuICAgIC8vIHNvIHJlbW92ZSBhZmVjdGVkIHNlZ21lbnRzIGFuZCByaWdodCBzd2VlcCBldmVudHMgYmVmb3JlIHNwbGl0dGluZ1xuICAgIC8vIHJlbW92ZU5vZGUoKSBkb2Vzbid0IHdvcmssIHNvIGhhdmUgcmUtZmluZCB0aGUgc2VnXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3c4ci9zcGxheS10cmVlL3B1bGwvNVxuICAgIHRoaXMudHJlZS5yZW1vdmUoc2VnKTtcbiAgICBjb25zdCByaWdodFNFID0gc2VnLnJpZ2h0U0U7XG4gICAgdGhpcy5xdWV1ZS5yZW1vdmUocmlnaHRTRSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gc2VnLnNwbGl0KHB0KTtcbiAgICBuZXdFdmVudHMucHVzaChyaWdodFNFKTtcbiAgICAvLyBzcGxpdHRpbmcgY2FuIHRyaWdnZXIgY29uc3VtcHRpb25cbiAgICBpZiAoc2VnLmNvbnN1bWVkQnkgPT09IHVuZGVmaW5lZCkgdGhpcy50cmVlLmFkZChzZWcpO1xuICAgIHJldHVybiBuZXdFdmVudHM7XG4gIH1cbn1cblxuLy8gTGltaXRzIG9uIGl0ZXJhdGl2ZSBwcm9jZXNzZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcyAtIHVzdWFsbHkgY2F1c2VkIGJ5IGZsb2F0aW5nLXBvaW50IG1hdGggcm91bmQtb2ZmIGVycm9ycy5cbmNvbnN0IFBPTFlHT05fQ0xJUFBJTkdfTUFYX1FVRVVFX1NJWkUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5QT0xZR09OX0NMSVBQSU5HX01BWF9RVUVVRV9TSVpFIHx8IDEwMDAwMDA7XG5jb25zdCBQT0xZR09OX0NMSVBQSU5HX01BWF9TV0VFUExJTkVfU0VHTUVOVFMgPSB0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudi5QT0xZR09OX0NMSVBQSU5HX01BWF9TV0VFUExJTkVfU0VHTUVOVFMgfHwgMTAwMDAwMDtcbmNsYXNzIE9wZXJhdGlvbiB7XG4gIHJ1bih0eXBlLCBnZW9tLCBtb3JlR2VvbXMpIHtcbiAgICBvcGVyYXRpb24udHlwZSA9IHR5cGU7XG4gICAgcm91bmRlci5yZXNldCgpO1xuXG4gICAgLyogQ29udmVydCBpbnB1dHMgdG8gTXVsdGlQb2x5IG9iamVjdHMgKi9cbiAgICBjb25zdCBtdWx0aXBvbHlzID0gW25ldyBNdWx0aVBvbHlJbihnZW9tLCB0cnVlKV07XG4gICAgZm9yIChsZXQgaSA9IDAsIGlNYXggPSBtb3JlR2VvbXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICBtdWx0aXBvbHlzLnB1c2gobmV3IE11bHRpUG9seUluKG1vcmVHZW9tc1tpXSwgZmFsc2UpKTtcbiAgICB9XG4gICAgb3BlcmF0aW9uLm51bU11bHRpUG9seXMgPSBtdWx0aXBvbHlzLmxlbmd0aDtcblxuICAgIC8qIEJCb3ggb3B0aW1pemF0aW9uIGZvciBkaWZmZXJlbmNlIG9wZXJhdGlvblxuICAgICAqIElmIHRoZSBiYm94IG9mIGEgbXVsdGlwb2x5Z29uIHRoYXQncyBwYXJ0IG9mIHRoZSBjbGlwcGluZyBkb2Vzbid0XG4gICAgICogaW50ZXJzZWN0IHRoZSBiYm94IG9mIHRoZSBzdWJqZWN0IGF0IGFsbCwgd2UgY2FuIGp1c3QgZHJvcCB0aGF0XG4gICAgICogbXVsdGlwbG95Z29uLiAqL1xuICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gXCJkaWZmZXJlbmNlXCIpIHtcbiAgICAgIC8vIGluIHBsYWNlIHJlbW92YWxcbiAgICAgIGNvbnN0IHN1YmplY3QgPSBtdWx0aXBvbHlzWzBdO1xuICAgICAgbGV0IGkgPSAxO1xuICAgICAgd2hpbGUgKGkgPCBtdWx0aXBvbHlzLmxlbmd0aCkge1xuICAgICAgICBpZiAoZ2V0QmJveE92ZXJsYXAobXVsdGlwb2x5c1tpXS5iYm94LCBzdWJqZWN0LmJib3gpICE9PSBudWxsKSBpKys7ZWxzZSBtdWx0aXBvbHlzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBCQm94IG9wdGltaXphdGlvbiBmb3IgaW50ZXJzZWN0aW9uIG9wZXJhdGlvblxuICAgICAqIElmIHdlIGNhbiBmaW5kIGFueSBwYWlyIG9mIG11bHRpcG9seWdvbnMgd2hvc2UgYmJveCBkb2VzIG5vdCBvdmVybGFwLFxuICAgICAqIHRoZW4gdGhlIHJlc3VsdCB3aWxsIGJlIGVtcHR5LiAqL1xuICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gXCJpbnRlcnNlY3Rpb25cIikge1xuICAgICAgLy8gVE9ETzogdGhpcyBpcyBPKG5eMikgaW4gbnVtYmVyIG9mIHBvbHlnb25zLiBCeSBzb3J0aW5nIHRoZSBiYm94ZXMsXG4gICAgICAvLyAgICAgICBpdCBjb3VsZCBiZSBvcHRpbWl6ZWQgdG8gTyhuICogbG4obikpXG4gICAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IG11bHRpcG9seXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG1wQSA9IG11bHRpcG9seXNbaV07XG4gICAgICAgIGZvciAobGV0IGogPSBpICsgMSwgak1heCA9IG11bHRpcG9seXMubGVuZ3RoOyBqIDwgak1heDsgaisrKSB7XG4gICAgICAgICAgaWYgKGdldEJib3hPdmVybGFwKG1wQS5iYm94LCBtdWx0aXBvbHlzW2pdLmJib3gpID09PSBudWxsKSByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBQdXQgc2VnbWVudCBlbmRwb2ludHMgaW4gYSBwcmlvcml0eSBxdWV1ZSAqL1xuICAgIGNvbnN0IHF1ZXVlID0gbmV3IFNwbGF5VHJlZShTd2VlcEV2ZW50LmNvbXBhcmUpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpTWF4ID0gbXVsdGlwb2x5cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGNvbnN0IHN3ZWVwRXZlbnRzID0gbXVsdGlwb2x5c1tpXS5nZXRTd2VlcEV2ZW50cygpO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpNYXggPSBzd2VlcEV2ZW50cy5sZW5ndGg7IGogPCBqTWF4OyBqKyspIHtcbiAgICAgICAgcXVldWUuaW5zZXJ0KHN3ZWVwRXZlbnRzW2pdKTtcbiAgICAgICAgaWYgKHF1ZXVlLnNpemUgPiBQT0xZR09OX0NMSVBQSU5HX01BWF9RVUVVRV9TSVpFKSB7XG4gICAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbmZpbml0ZSBsb29wIHdoZW4gcHV0dGluZyBzZWdtZW50IGVuZHBvaW50cyBpbiBhIHByaW9yaXR5IHF1ZXVlIFwiICsgXCIocXVldWUgc2l6ZSB0b28gYmlnKS5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBQYXNzIHRoZSBzd2VlcCBsaW5lIG92ZXIgdGhvc2UgZW5kcG9pbnRzICovXG4gICAgY29uc3Qgc3dlZXBMaW5lID0gbmV3IFN3ZWVwTGluZShxdWV1ZSk7XG4gICAgbGV0IHByZXZRdWV1ZVNpemUgPSBxdWV1ZS5zaXplO1xuICAgIGxldCBub2RlID0gcXVldWUucG9wKCk7XG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIGNvbnN0IGV2dCA9IG5vZGUua2V5O1xuICAgICAgaWYgKHF1ZXVlLnNpemUgPT09IHByZXZRdWV1ZVNpemUpIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgY29uc3Qgc2VnID0gZXZ0LnNlZ21lbnQ7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBvcCgpICR7ZXZ0LmlzTGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwifSBTd2VlcEV2ZW50IGAgKyBgWyR7ZXZ0LnBvaW50Lnh9LCAke2V2dC5wb2ludC55fV0gZnJvbSBzZWdtZW50ICMke3NlZy5pZH0gYCArIGBbJHtzZWcubGVmdFNFLnBvaW50Lnh9LCAke3NlZy5sZWZ0U0UucG9pbnQueX1dIC0+IGAgKyBgWyR7c2VnLnJpZ2h0U0UucG9pbnQueH0sICR7c2VnLnJpZ2h0U0UucG9pbnQueX1dIGZyb20gcXVldWUuYCk7XG4gICAgICB9XG4gICAgICBpZiAocXVldWUuc2l6ZSA+IFBPTFlHT05fQ0xJUFBJTkdfTUFYX1FVRVVFX1NJWkUpIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5maW5pdGUgbG9vcCB3aGVuIHBhc3Npbmcgc3dlZXAgbGluZSBvdmVyIGVuZHBvaW50cyBcIiArIFwiKHF1ZXVlIHNpemUgdG9vIGJpZykuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHN3ZWVwTGluZS5zZWdtZW50cy5sZW5ndGggPiBQT0xZR09OX0NMSVBQSU5HX01BWF9TV0VFUExJTkVfU0VHTUVOVFMpIHtcbiAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5maW5pdGUgbG9vcCB3aGVuIHBhc3Npbmcgc3dlZXAgbGluZSBvdmVyIGVuZHBvaW50cyBcIiArIFwiKHRvbyBtYW55IHN3ZWVwIGxpbmUgc2VnbWVudHMpLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0V2ZW50cyA9IHN3ZWVwTGluZS5wcm9jZXNzKGV2dCk7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaU1heCA9IG5ld0V2ZW50cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgY29uc3QgZXZ0ID0gbmV3RXZlbnRzW2ldO1xuICAgICAgICBpZiAoZXZ0LmNvbnN1bWVkQnkgPT09IHVuZGVmaW5lZCkgcXVldWUuaW5zZXJ0KGV2dCk7XG4gICAgICB9XG4gICAgICBwcmV2UXVldWVTaXplID0gcXVldWUuc2l6ZTtcbiAgICAgIG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICB9XG5cbiAgICAvLyBmcmVlIHNvbWUgbWVtb3J5IHdlIGRvbid0IG5lZWQgYW55bW9yZVxuICAgIHJvdW5kZXIucmVzZXQoKTtcblxuICAgIC8qIENvbGxlY3QgYW5kIGNvbXBpbGUgc2VnbWVudHMgd2UncmUga2VlcGluZyBpbnRvIGEgbXVsdGlwb2x5Z29uICovXG4gICAgY29uc3QgcmluZ3NPdXQgPSBSaW5nT3V0LmZhY3Rvcnkoc3dlZXBMaW5lLnNlZ21lbnRzKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTXVsdGlQb2x5T3V0KHJpbmdzT3V0KTtcbiAgICByZXR1cm4gcmVzdWx0LmdldEdlb20oKTtcbiAgfVxufVxuXG4vLyBzaW5nbGV0b24gYXZhaWxhYmxlIGJ5IGltcG9ydFxuY29uc3Qgb3BlcmF0aW9uID0gbmV3IE9wZXJhdGlvbigpO1xuXG5jb25zdCB1bmlvbiA9IGZ1bmN0aW9uIChnZW9tKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBtb3JlR2VvbXMgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIG1vcmVHZW9tc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbi5ydW4oXCJ1bmlvblwiLCBnZW9tLCBtb3JlR2VvbXMpO1xufTtcbmNvbnN0IGludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChnZW9tKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbW9yZUdlb21zID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBtb3JlR2VvbXNbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbi5ydW4oXCJpbnRlcnNlY3Rpb25cIiwgZ2VvbSwgbW9yZUdlb21zKTtcbn07XG5jb25zdCB4b3IgPSBmdW5jdGlvbiAoZ2VvbSkge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIG1vcmVHZW9tcyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgbW9yZUdlb21zW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG4gIHJldHVybiBvcGVyYXRpb24ucnVuKFwieG9yXCIsIGdlb20sIG1vcmVHZW9tcyk7XG59O1xuY29uc3QgZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChzdWJqZWN0R2VvbSkge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGNsaXBwaW5nR2VvbXMgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGNsaXBwaW5nR2VvbXNbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cbiAgcmV0dXJuIG9wZXJhdGlvbi5ydW4oXCJkaWZmZXJlbmNlXCIsIHN1YmplY3RHZW9tLCBjbGlwcGluZ0dlb21zKTtcbn07XG52YXIgaW5kZXggPSB7XG4gIHVuaW9uOiB1bmlvbixcbiAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb24sXG4gIHhvcjogeG9yLFxuICBkaWZmZXJlbmNlOiBkaWZmZXJlbmNlXG59O1xuXG5leHBvcnQgeyBpbmRleCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polygon-clipping/dist/polygon-clipping.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/polygon-clipping/node_modules/splaytree/dist/splay.esm.js":
/*!********************************************************************************!*\
  !*** ./node_modules/polygon-clipping/node_modules/splaytree/dist/splay.esm.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * splaytree v3.1.2\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar Node = /** @class */ (function () {\r\n    function Node(key, data) {\r\n        this.next = null;\r\n        this.key = key;\r\n        this.data = data;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n    return Node;\r\n}());\n\n/* follows \"An implementation of top-down splaying\"\r\n * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n */\r\nfunction DEFAULT_COMPARE(a, b) {\r\n    return a > b ? 1 : a < b ? -1 : 0;\r\n}\r\n/**\r\n * Simple top down splay, not requiring i to be in the tree t.\r\n */\r\nfunction splay(i, t, comparator) {\r\n    var N = new Node(null, null);\r\n    var l = N;\r\n    var r = N;\r\n    while (true) {\r\n        var cmp = comparator(i, t.key);\r\n        //if (i < t.key) {\r\n        if (cmp < 0) {\r\n            if (t.left === null)\r\n                break;\r\n            //if (i < t.left.key) {\r\n            if (comparator(i, t.left.key) < 0) {\r\n                var y = t.left; /* rotate right */\r\n                t.left = y.right;\r\n                y.right = t;\r\n                t = y;\r\n                if (t.left === null)\r\n                    break;\r\n            }\r\n            r.left = t; /* link right */\r\n            r = t;\r\n            t = t.left;\r\n            //} else if (i > t.key) {\r\n        }\r\n        else if (cmp > 0) {\r\n            if (t.right === null)\r\n                break;\r\n            //if (i > t.right.key) {\r\n            if (comparator(i, t.right.key) > 0) {\r\n                var y = t.right; /* rotate left */\r\n                t.right = y.left;\r\n                y.left = t;\r\n                t = y;\r\n                if (t.right === null)\r\n                    break;\r\n            }\r\n            l.right = t; /* link left */\r\n            l = t;\r\n            t = t.right;\r\n        }\r\n        else\r\n            break;\r\n    }\r\n    /* assemble */\r\n    l.right = t.left;\r\n    r.left = t.right;\r\n    t.left = N.right;\r\n    t.right = N.left;\r\n    return t;\r\n}\r\nfunction insert(i, data, t, comparator) {\r\n    var node = new Node(i, data);\r\n    if (t === null) {\r\n        node.left = node.right = null;\r\n        return node;\r\n    }\r\n    t = splay(i, t, comparator);\r\n    var cmp = comparator(i, t.key);\r\n    if (cmp < 0) {\r\n        node.left = t.left;\r\n        node.right = t;\r\n        t.left = null;\r\n    }\r\n    else if (cmp >= 0) {\r\n        node.right = t.right;\r\n        node.left = t;\r\n        t.right = null;\r\n    }\r\n    return node;\r\n}\r\nfunction split(key, v, comparator) {\r\n    var left = null;\r\n    var right = null;\r\n    if (v) {\r\n        v = splay(key, v, comparator);\r\n        var cmp = comparator(v.key, key);\r\n        if (cmp === 0) {\r\n            left = v.left;\r\n            right = v.right;\r\n        }\r\n        else if (cmp < 0) {\r\n            right = v.right;\r\n            v.right = null;\r\n            left = v;\r\n        }\r\n        else {\r\n            left = v.left;\r\n            v.left = null;\r\n            right = v;\r\n        }\r\n    }\r\n    return { left: left, right: right };\r\n}\r\nfunction merge(left, right, comparator) {\r\n    if (right === null)\r\n        return left;\r\n    if (left === null)\r\n        return right;\r\n    right = splay(left.key, right, comparator);\r\n    right.left = left;\r\n    return right;\r\n}\r\n/**\r\n * Prints level of the tree\r\n */\r\nfunction printRow(root, prefix, isTail, out, printNode) {\r\n    if (root) {\r\n        out(\"\" + prefix + (isTail ? ' ' : ' ') + printNode(root) + \"\\n\");\r\n        var indent = prefix + (isTail ? '    ' : '   ');\r\n        if (root.left)\r\n            printRow(root.left, indent, false, out, printNode);\r\n        if (root.right)\r\n            printRow(root.right, indent, true, out, printNode);\r\n    }\r\n}\r\nvar Tree = /** @class */ (function () {\r\n    function Tree(comparator) {\r\n        if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\r\n        this._root = null;\r\n        this._size = 0;\r\n        this._comparator = comparator;\r\n    }\r\n    /**\r\n     * Inserts a key, allows duplicates\r\n     */\r\n    Tree.prototype.insert = function (key, data) {\r\n        this._size++;\r\n        return this._root = insert(key, data, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Adds a key, if it is not present in the tree\r\n     */\r\n    Tree.prototype.add = function (key, data) {\r\n        var node = new Node(key, data);\r\n        if (this._root === null) {\r\n            node.left = node.right = null;\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        var comparator = this._comparator;\r\n        var t = splay(key, this._root, comparator);\r\n        var cmp = comparator(key, t.key);\r\n        if (cmp === 0)\r\n            this._root = t;\r\n        else {\r\n            if (cmp < 0) {\r\n                node.left = t.left;\r\n                node.right = t;\r\n                t.left = null;\r\n            }\r\n            else if (cmp > 0) {\r\n                node.right = t.right;\r\n                node.left = t;\r\n                t.right = null;\r\n            }\r\n            this._size++;\r\n            this._root = node;\r\n        }\r\n        return this._root;\r\n    };\r\n    /**\r\n     * @param  {Key} key\r\n     * @return {Node|null}\r\n     */\r\n    Tree.prototype.remove = function (key) {\r\n        this._root = this._remove(key, this._root, this._comparator);\r\n    };\r\n    /**\r\n     * Deletes i from the tree if it's there\r\n     */\r\n    Tree.prototype._remove = function (i, t, comparator) {\r\n        var x;\r\n        if (t === null)\r\n            return null;\r\n        t = splay(i, t, comparator);\r\n        var cmp = comparator(i, t.key);\r\n        if (cmp === 0) { /* found it */\r\n            if (t.left === null) {\r\n                x = t.right;\r\n            }\r\n            else {\r\n                x = splay(i, t.left, comparator);\r\n                x.right = t.right;\r\n            }\r\n            this._size--;\r\n            return x;\r\n        }\r\n        return t; /* It wasn't there */\r\n    };\r\n    /**\r\n     * Removes and returns the node with smallest key\r\n     */\r\n    Tree.prototype.pop = function () {\r\n        var node = this._root;\r\n        if (node) {\r\n            while (node.left)\r\n                node = node.left;\r\n            this._root = splay(node.key, this._root, this._comparator);\r\n            this._root = this._remove(node.key, this._root, this._comparator);\r\n            return { key: node.key, data: node.data };\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Find without splaying\r\n     */\r\n    Tree.prototype.findStatic = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return current;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.find = function (key) {\r\n        if (this._root) {\r\n            this._root = splay(key, this._root, this._comparator);\r\n            if (this._comparator(key, this._root.key) !== 0)\r\n                return null;\r\n        }\r\n        return this._root;\r\n    };\r\n    Tree.prototype.contains = function (key) {\r\n        var current = this._root;\r\n        var compare = this._comparator;\r\n        while (current) {\r\n            var cmp = compare(key, current.key);\r\n            if (cmp === 0)\r\n                return true;\r\n            else if (cmp < 0)\r\n                current = current.left;\r\n            else\r\n                current = current.right;\r\n        }\r\n        return false;\r\n    };\r\n    Tree.prototype.forEach = function (visitor, ctx) {\r\n        var current = this._root;\r\n        var Q = []; /* Initialize stack s */\r\n        var done = false;\r\n        while (!done) {\r\n            if (current !== null) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length !== 0) {\r\n                    current = Q.pop();\r\n                    visitor.call(ctx, current);\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n     */\r\n    Tree.prototype.range = function (low, high, fn, ctx) {\r\n        var Q = [];\r\n        var compare = this._comparator;\r\n        var node = this._root;\r\n        var cmp;\r\n        while (Q.length !== 0 || node) {\r\n            if (node) {\r\n                Q.push(node);\r\n                node = node.left;\r\n            }\r\n            else {\r\n                node = Q.pop();\r\n                cmp = compare(node.key, high);\r\n                if (cmp > 0) {\r\n                    break;\r\n                }\r\n                else if (compare(node.key, low) >= 0) {\r\n                    if (fn.call(ctx, node))\r\n                        return this; // stop if smth is returned\r\n                }\r\n                node = node.right;\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    /**\r\n     * Returns array of keys\r\n     */\r\n    Tree.prototype.keys = function () {\r\n        var keys = [];\r\n        this.forEach(function (_a) {\r\n            var key = _a.key;\r\n            return keys.push(key);\r\n        });\r\n        return keys;\r\n    };\r\n    /**\r\n     * Returns array of all the data in the nodes\r\n     */\r\n    Tree.prototype.values = function () {\r\n        var values = [];\r\n        this.forEach(function (_a) {\r\n            var data = _a.data;\r\n            return values.push(data);\r\n        });\r\n        return values;\r\n    };\r\n    Tree.prototype.min = function () {\r\n        if (this._root)\r\n            return this.minNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.max = function () {\r\n        if (this._root)\r\n            return this.maxNode(this._root).key;\r\n        return null;\r\n    };\r\n    Tree.prototype.minNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.left)\r\n                t = t.left;\r\n        return t;\r\n    };\r\n    Tree.prototype.maxNode = function (t) {\r\n        if (t === void 0) { t = this._root; }\r\n        if (t)\r\n            while (t.right)\r\n                t = t.right;\r\n        return t;\r\n    };\r\n    /**\r\n     * Returns node at given index\r\n     */\r\n    Tree.prototype.at = function (index) {\r\n        var current = this._root;\r\n        var done = false;\r\n        var i = 0;\r\n        var Q = [];\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = Q.pop();\r\n                    if (i === index)\r\n                        return current;\r\n                    i++;\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    Tree.prototype.next = function (d) {\r\n        var root = this._root;\r\n        var successor = null;\r\n        if (d.right) {\r\n            successor = d.right;\r\n            while (successor.left)\r\n                successor = successor.left;\r\n            return successor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0) {\r\n                successor = root;\r\n                root = root.left;\r\n            }\r\n            else\r\n                root = root.right;\r\n        }\r\n        return successor;\r\n    };\r\n    Tree.prototype.prev = function (d) {\r\n        var root = this._root;\r\n        var predecessor = null;\r\n        if (d.left !== null) {\r\n            predecessor = d.left;\r\n            while (predecessor.right)\r\n                predecessor = predecessor.right;\r\n            return predecessor;\r\n        }\r\n        var comparator = this._comparator;\r\n        while (root) {\r\n            var cmp = comparator(d.key, root.key);\r\n            if (cmp === 0)\r\n                break;\r\n            else if (cmp < 0)\r\n                root = root.left;\r\n            else {\r\n                predecessor = root;\r\n                root = root.right;\r\n            }\r\n        }\r\n        return predecessor;\r\n    };\r\n    Tree.prototype.clear = function () {\r\n        this._root = null;\r\n        this._size = 0;\r\n        return this;\r\n    };\r\n    Tree.prototype.toList = function () {\r\n        return toList(this._root);\r\n    };\r\n    /**\r\n     * Bulk-load items. Both array have to be same size\r\n     */\r\n    Tree.prototype.load = function (keys, values, presort) {\r\n        if (values === void 0) { values = []; }\r\n        if (presort === void 0) { presort = false; }\r\n        var size = keys.length;\r\n        var comparator = this._comparator;\r\n        // sort if needed\r\n        if (presort)\r\n            sort(keys, values, 0, size - 1, comparator);\r\n        if (this._root === null) { // empty tree\r\n            this._root = loadRecursive(keys, values, 0, size);\r\n            this._size = size;\r\n        }\r\n        else { // that re-builds the whole tree from two in-order traversals\r\n            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n            size = this._size + size;\r\n            this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n        }\r\n        return this;\r\n    };\r\n    Tree.prototype.isEmpty = function () { return this._root === null; };\r\n    Object.defineProperty(Tree.prototype, \"size\", {\r\n        get: function () { return this._size; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Tree.prototype, \"root\", {\r\n        get: function () { return this._root; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Tree.prototype.toString = function (printNode) {\r\n        if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\r\n        var out = [];\r\n        printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\r\n        return out.join('');\r\n    };\r\n    Tree.prototype.update = function (key, newKey, newData) {\r\n        var comparator = this._comparator;\r\n        var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\r\n        if (comparator(key, newKey) < 0) {\r\n            right = insert(newKey, newData, right, comparator);\r\n        }\r\n        else {\r\n            left = insert(newKey, newData, left, comparator);\r\n        }\r\n        this._root = merge(left, right, comparator);\r\n    };\r\n    Tree.prototype.split = function (key) {\r\n        return split(key, this._root, this._comparator);\r\n    };\r\n    Tree.prototype[Symbol.iterator] = function () {\r\n        var current, Q, done;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    current = this._root;\r\n                    Q = [];\r\n                    done = false;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!!done) return [3 /*break*/, 6];\r\n                    if (!(current !== null)) return [3 /*break*/, 2];\r\n                    Q.push(current);\r\n                    current = current.left;\r\n                    return [3 /*break*/, 5];\r\n                case 2:\r\n                    if (!(Q.length !== 0)) return [3 /*break*/, 4];\r\n                    current = Q.pop();\r\n                    return [4 /*yield*/, current];\r\n                case 3:\r\n                    _a.sent();\r\n                    current = current.right;\r\n                    return [3 /*break*/, 5];\r\n                case 4:\r\n                    done = true;\r\n                    _a.label = 5;\r\n                case 5: return [3 /*break*/, 1];\r\n                case 6: return [2 /*return*/];\r\n            }\r\n        });\r\n    };\r\n    return Tree;\r\n}());\r\nfunction loadRecursive(keys, values, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var key = keys[middle];\r\n        var data = values[middle];\r\n        var node = new Node(key, data);\r\n        node.left = loadRecursive(keys, values, start, middle);\r\n        node.right = loadRecursive(keys, values, middle + 1, end);\r\n        return node;\r\n    }\r\n    return null;\r\n}\r\nfunction createList(keys, values) {\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    for (var i = 0; i < keys.length; i++) {\r\n        p = p.next = new Node(keys[i], values[i]);\r\n    }\r\n    p.next = null;\r\n    return head.next;\r\n}\r\nfunction toList(root) {\r\n    var current = root;\r\n    var Q = [];\r\n    var done = false;\r\n    var head = new Node(null, null);\r\n    var p = head;\r\n    while (!done) {\r\n        if (current) {\r\n            Q.push(current);\r\n            current = current.left;\r\n        }\r\n        else {\r\n            if (Q.length > 0) {\r\n                current = p = p.next = Q.pop();\r\n                current = current.right;\r\n            }\r\n            else\r\n                done = true;\r\n        }\r\n    }\r\n    p.next = null; // that'll work even if the tree was empty\r\n    return head.next;\r\n}\r\nfunction sortedListToBST(list, start, end) {\r\n    var size = end - start;\r\n    if (size > 0) {\r\n        var middle = start + Math.floor(size / 2);\r\n        var left = sortedListToBST(list, start, middle);\r\n        var root = list.head;\r\n        root.left = left;\r\n        list.head = list.head.next;\r\n        root.right = sortedListToBST(list, middle + 1, end);\r\n        return root;\r\n    }\r\n    return null;\r\n}\r\nfunction mergeLists(l1, l2, compare) {\r\n    var head = new Node(null, null); // dummy\r\n    var p = head;\r\n    var p1 = l1;\r\n    var p2 = l2;\r\n    while (p1 !== null && p2 !== null) {\r\n        if (compare(p1.key, p2.key) < 0) {\r\n            p.next = p1;\r\n            p1 = p1.next;\r\n        }\r\n        else {\r\n            p.next = p2;\r\n            p2 = p2.next;\r\n        }\r\n        p = p.next;\r\n    }\r\n    if (p1 !== null) {\r\n        p.next = p1;\r\n    }\r\n    else if (p2 !== null) {\r\n        p.next = p2;\r\n    }\r\n    return head.next;\r\n}\r\nfunction sort(keys, values, left, right, compare) {\r\n    if (left >= right)\r\n        return;\r\n    var pivot = keys[(left + right) >> 1];\r\n    var i = left - 1;\r\n    var j = right + 1;\r\n    while (true) {\r\n        do\r\n            i++;\r\n        while (compare(keys[i], pivot) < 0);\r\n        do\r\n            j--;\r\n        while (compare(keys[j], pivot) > 0);\r\n        if (i >= j)\r\n            break;\r\n        var tmp = keys[i];\r\n        keys[i] = keys[j];\r\n        keys[j] = tmp;\r\n        tmp = values[i];\r\n        values[i] = values[j];\r\n        values[j] = tmp;\r\n    }\r\n    sort(keys, values, left, j, compare);\r\n    sort(keys, values, j + 1, right, compare);\r\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Tree);\n//# sourceMappingURL=splay.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9seWdvbi1jbGlwcGluZy9ub2RlX21vZHVsZXMvc3BsYXl0cmVlL2Rpc3Qvc3BsYXkuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUs7QUFDckIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvQ0FBb0MsMkJBQTJCO0FBQy9EO0FBQ0Esc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpRUFBZSxJQUFJLEVBQUM7QUFDcEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9idWRiYXNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3BvbHlnb24tY2xpcHBpbmcvbm9kZV9tb2R1bGVzL3NwbGF5dHJlZS9kaXN0L3NwbGF5LmVzbS5qcz9jODdhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogc3BsYXl0cmVlIHYzLjEuMlxuICogRmFzdCBTcGxheSB0cmVlIGZvciBOb2RlIGFuZCBicm93c2VyXG4gKlxuICogQGF1dGhvciBBbGV4YW5kZXIgTWlsZXZza2kgPGluZm9AdzhyLm5hbWU+XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBwcmVzZXJ2ZVxuICovXG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxuXG52YXIgTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE5vZGUoa2V5LCBkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTm9kZTtcclxufSgpKTtcblxuLyogZm9sbG93cyBcIkFuIGltcGxlbWVudGF0aW9uIG9mIHRvcC1kb3duIHNwbGF5aW5nXCJcclxuICogYnkgRC4gU2xlYXRvciA8c2xlYXRvckBjcy5jbXUuZWR1PiBNYXJjaCAxOTkyXHJcbiAqL1xyXG5mdW5jdGlvbiBERUZBVUxUX0NPTVBBUkUoYSwgYikge1xyXG4gICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xyXG59XHJcbi8qKlxyXG4gKiBTaW1wbGUgdG9wIGRvd24gc3BsYXksIG5vdCByZXF1aXJpbmcgaSB0byBiZSBpbiB0aGUgdHJlZSB0LlxyXG4gKi9cclxuZnVuY3Rpb24gc3BsYXkoaSwgdCwgY29tcGFyYXRvcikge1xyXG4gICAgdmFyIE4gPSBuZXcgTm9kZShudWxsLCBudWxsKTtcclxuICAgIHZhciBsID0gTjtcclxuICAgIHZhciByID0gTjtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xyXG4gICAgICAgIC8vaWYgKGkgPCB0LmtleSkge1xyXG4gICAgICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0LmxlZnQgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgLy9pZiAoaSA8IHQubGVmdC5rZXkpIHtcclxuICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3IoaSwgdC5sZWZ0LmtleSkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHQubGVmdDsgLyogcm90YXRlIHJpZ2h0ICovXHJcbiAgICAgICAgICAgICAgICB0LmxlZnQgPSB5LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgeS5yaWdodCA9IHQ7XHJcbiAgICAgICAgICAgICAgICB0ID0geTtcclxuICAgICAgICAgICAgICAgIGlmICh0LmxlZnQgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgci5sZWZ0ID0gdDsgLyogbGluayByaWdodCAqL1xyXG4gICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgdCA9IHQubGVmdDtcclxuICAgICAgICAgICAgLy99IGVsc2UgaWYgKGkgPiB0LmtleSkge1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0LnJpZ2h0ID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIC8vaWYgKGkgPiB0LnJpZ2h0LmtleSkge1xyXG4gICAgICAgICAgICBpZiAoY29tcGFyYXRvcihpLCB0LnJpZ2h0LmtleSkgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeSA9IHQucmlnaHQ7IC8qIHJvdGF0ZSBsZWZ0ICovXHJcbiAgICAgICAgICAgICAgICB0LnJpZ2h0ID0geS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgeS5sZWZ0ID0gdDtcclxuICAgICAgICAgICAgICAgIHQgPSB5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHQucmlnaHQgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbC5yaWdodCA9IHQ7IC8qIGxpbmsgbGVmdCAqL1xyXG4gICAgICAgICAgICBsID0gdDtcclxuICAgICAgICAgICAgdCA9IHQucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICAvKiBhc3NlbWJsZSAqL1xyXG4gICAgbC5yaWdodCA9IHQubGVmdDtcclxuICAgIHIubGVmdCA9IHQucmlnaHQ7XHJcbiAgICB0LmxlZnQgPSBOLnJpZ2h0O1xyXG4gICAgdC5yaWdodCA9IE4ubGVmdDtcclxuICAgIHJldHVybiB0O1xyXG59XHJcbmZ1bmN0aW9uIGluc2VydChpLCBkYXRhLCB0LCBjb21wYXJhdG9yKSB7XHJcbiAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKGksIGRhdGEpO1xyXG4gICAgaWYgKHQgPT09IG51bGwpIHtcclxuICAgICAgICBub2RlLmxlZnQgPSBub2RlLnJpZ2h0ID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuICAgIHQgPSBzcGxheShpLCB0LCBjb21wYXJhdG9yKTtcclxuICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGksIHQua2V5KTtcclxuICAgIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgbm9kZS5sZWZ0ID0gdC5sZWZ0O1xyXG4gICAgICAgIG5vZGUucmlnaHQgPSB0O1xyXG4gICAgICAgIHQubGVmdCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjbXAgPj0gMCkge1xyXG4gICAgICAgIG5vZGUucmlnaHQgPSB0LnJpZ2h0O1xyXG4gICAgICAgIG5vZGUubGVmdCA9IHQ7XHJcbiAgICAgICAgdC5yaWdodCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbm9kZTtcclxufVxyXG5mdW5jdGlvbiBzcGxpdChrZXksIHYsIGNvbXBhcmF0b3IpIHtcclxuICAgIHZhciBsZWZ0ID0gbnVsbDtcclxuICAgIHZhciByaWdodCA9IG51bGw7XHJcbiAgICBpZiAodikge1xyXG4gICAgICAgIHYgPSBzcGxheShrZXksIHYsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKHYua2V5LCBrZXkpO1xyXG4gICAgICAgIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgbGVmdCA9IHYubGVmdDtcclxuICAgICAgICAgICAgcmlnaHQgPSB2LnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgIHJpZ2h0ID0gdi5yaWdodDtcclxuICAgICAgICAgICAgdi5yaWdodCA9IG51bGw7XHJcbiAgICAgICAgICAgIGxlZnQgPSB2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGVmdCA9IHYubGVmdDtcclxuICAgICAgICAgICAgdi5sZWZ0ID0gbnVsbDtcclxuICAgICAgICAgICAgcmlnaHQgPSB2O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB7IGxlZnQ6IGxlZnQsIHJpZ2h0OiByaWdodCB9O1xyXG59XHJcbmZ1bmN0aW9uIG1lcmdlKGxlZnQsIHJpZ2h0LCBjb21wYXJhdG9yKSB7XHJcbiAgICBpZiAocmlnaHQgPT09IG51bGwpXHJcbiAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICBpZiAobGVmdCA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICByaWdodCA9IHNwbGF5KGxlZnQua2V5LCByaWdodCwgY29tcGFyYXRvcik7XHJcbiAgICByaWdodC5sZWZ0ID0gbGVmdDtcclxuICAgIHJldHVybiByaWdodDtcclxufVxyXG4vKipcclxuICogUHJpbnRzIGxldmVsIG9mIHRoZSB0cmVlXHJcbiAqL1xyXG5mdW5jdGlvbiBwcmludFJvdyhyb290LCBwcmVmaXgsIGlzVGFpbCwgb3V0LCBwcmludE5vZGUpIHtcclxuICAgIGlmIChyb290KSB7XHJcbiAgICAgICAgb3V0KFwiXCIgKyBwcmVmaXggKyAoaXNUYWlsID8gJ+KUlOKUgOKUgCAnIDogJ+KUnOKUgOKUgCAnKSArIHByaW50Tm9kZShyb290KSArIFwiXFxuXCIpO1xyXG4gICAgICAgIHZhciBpbmRlbnQgPSBwcmVmaXggKyAoaXNUYWlsID8gJyAgICAnIDogJ+KUgiAgICcpO1xyXG4gICAgICAgIGlmIChyb290LmxlZnQpXHJcbiAgICAgICAgICAgIHByaW50Um93KHJvb3QubGVmdCwgaW5kZW50LCBmYWxzZSwgb3V0LCBwcmludE5vZGUpO1xyXG4gICAgICAgIGlmIChyb290LnJpZ2h0KVxyXG4gICAgICAgICAgICBwcmludFJvdyhyb290LnJpZ2h0LCBpbmRlbnQsIHRydWUsIG91dCwgcHJpbnROb2RlKTtcclxuICAgIH1cclxufVxyXG52YXIgVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRyZWUoY29tcGFyYXRvcikge1xyXG4gICAgICAgIGlmIChjb21wYXJhdG9yID09PSB2b2lkIDApIHsgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSRTsgfVxyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2NvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIGEga2V5LCBhbGxvd3MgZHVwbGljYXRlc1xyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoa2V5LCBkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290ID0gaW5zZXJ0KGtleSwgZGF0YSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEga2V5LCBpZiBpdCBpcyBub3QgcHJlc2VudCBpbiB0aGUgdHJlZVxyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5LCBkYXRhKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZShrZXksIGRhdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLl9yb290ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG5vZGUubGVmdCA9IG5vZGUucmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9zaXplKys7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgdmFyIHQgPSBzcGxheShrZXksIHRoaXMuX3Jvb3QsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGtleSwgdC5rZXkpO1xyXG4gICAgICAgIGlmIChjbXAgPT09IDApXHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSB0O1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0ID0gdC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgbm9kZS5yaWdodCA9IHQ7XHJcbiAgICAgICAgICAgICAgICB0LmxlZnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgIG5vZGUucmlnaHQgPSB0LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgbm9kZS5sZWZ0ID0gdDtcclxuICAgICAgICAgICAgICAgIHQucmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemUrKztcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290O1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtICB7S2V5fSBrZXlcclxuICAgICAqIEByZXR1cm4ge05vZGV8bnVsbH1cclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLl9yZW1vdmUoa2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgaSBmcm9tIHRoZSB0cmVlIGlmIGl0J3MgdGhlcmVcclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUuX3JlbW92ZSA9IGZ1bmN0aW9uIChpLCB0LCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIHg7XHJcbiAgICAgICAgaWYgKHQgPT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIHQgPSBzcGxheShpLCB0LCBjb21wYXJhdG9yKTtcclxuICAgICAgICB2YXIgY21wID0gY29tcGFyYXRvcihpLCB0LmtleSk7XHJcbiAgICAgICAgaWYgKGNtcCA9PT0gMCkgeyAvKiBmb3VuZCBpdCAqL1xyXG4gICAgICAgICAgICBpZiAodC5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gdC5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHggPSBzcGxheShpLCB0LmxlZnQsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgeC5yaWdodCA9IHQucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2l6ZS0tO1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7IC8qIEl0IHdhc24ndCB0aGVyZSAqL1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbmQgcmV0dXJucyB0aGUgbm9kZSB3aXRoIHNtYWxsZXN0IGtleVxyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIGlmIChub2RlKSB7XHJcbiAgICAgICAgICAgIHdoaWxlIChub2RlLmxlZnQpXHJcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gc3BsYXkobm9kZS5rZXksIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5fcmVtb3ZlKG5vZGUua2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBub2RlLmtleSwgZGF0YTogbm9kZS5kYXRhIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRmluZCB3aXRob3V0IHNwbGF5aW5nXHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLmZpbmRTdGF0aWMgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHZhciBjb21wYXJlID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICB2YXIgY21wID0gY29tcGFyZShrZXksIGN1cnJlbnQua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMClcclxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHNwbGF5KGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wYXJhdG9yKGtleSwgdGhpcy5fcm9vdC5rZXkpICE9PSAwKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb290O1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcclxuICAgICAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmUoa2V5LCBjdXJyZW50LmtleSk7XHJcbiAgICAgICAgICAgIGlmIChjbXAgPT09IDApXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMClcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uICh2aXNpdG9yLCBjdHgpIHtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgdmFyIFEgPSBbXTsgLyogSW5pdGlhbGl6ZSBzdGFjayBzICovXHJcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIFEucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gUS5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpdG9yLmNhbGwoY3R4LCBjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdhbGsga2V5IHJhbmdlIGZyb20gYGxvd2AgdG8gYGhpZ2hgLiBTdG9wcyBpZiBgZm5gIHJldHVybnMgYSB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUucmFuZ2UgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBmbiwgY3R4KSB7XHJcbiAgICAgICAgdmFyIFEgPSBbXTtcclxuICAgICAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHZhciBjbXA7XHJcbiAgICAgICAgd2hpbGUgKFEubGVuZ3RoICE9PSAwIHx8IG5vZGUpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIFEucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBub2RlID0gUS5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUobm9kZS5rZXksIGhpZ2gpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBhcmUobm9kZS5rZXksIGxvdykgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmbi5jYWxsKGN0eCwgbm9kZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBzdG9wIGlmIHNtdGggaXMgcmV0dXJuZWRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhcnJheSBvZiBrZXlzXHJcbiAgICAgKi9cclxuICAgIFRyZWUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcclxuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYS5rZXk7XHJcbiAgICAgICAgICAgIHJldHVybiBrZXlzLnB1c2goa2V5KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4ga2V5cztcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYXJyYXkgb2YgYWxsIHRoZSBkYXRhIGluIHRoZSBub2Rlc1xyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBfYS5kYXRhO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbk5vZGUodGhpcy5fcm9vdCkua2V5O1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIFRyZWUucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4Tm9kZSh0aGlzLl9yb290KS5rZXk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUubWluTm9kZSA9IGZ1bmN0aW9uICh0KSB7XHJcbiAgICAgICAgaWYgKHQgPT09IHZvaWQgMCkgeyB0ID0gdGhpcy5fcm9vdDsgfVxyXG4gICAgICAgIGlmICh0KVxyXG4gICAgICAgICAgICB3aGlsZSAodC5sZWZ0KVxyXG4gICAgICAgICAgICAgICAgdCA9IHQubGVmdDtcclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5tYXhOb2RlID0gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICBpZiAodCA9PT0gdm9pZCAwKSB7IHQgPSB0aGlzLl9yb290OyB9XHJcbiAgICAgICAgaWYgKHQpXHJcbiAgICAgICAgICAgIHdoaWxlICh0LnJpZ2h0KVxyXG4gICAgICAgICAgICAgICAgdCA9IHQucmlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIG5vZGUgYXQgZ2l2ZW4gaW5kZXhcclxuICAgICAqL1xyXG4gICAgVHJlZS5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIFEgPSBbXTtcclxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIFEucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IGluZGV4KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xyXG4gICAgICAgIHZhciBzdWNjZXNzb3IgPSBudWxsO1xyXG4gICAgICAgIGlmIChkLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3NvciA9IGQucmlnaHQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChzdWNjZXNzb3IubGVmdClcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NvciA9IHN1Y2Nlc3Nvci5sZWZ0O1xyXG4gICAgICAgICAgICByZXR1cm4gc3VjY2Vzc29yO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgd2hpbGUgKHJvb3QpIHtcclxuICAgICAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoZC5rZXksIHJvb3Qua2V5KTtcclxuICAgICAgICAgICAgaWYgKGNtcCA9PT0gMClcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzb3IgPSByb290O1xyXG4gICAgICAgICAgICAgICAgcm9vdCA9IHJvb3QubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByb290ID0gcm9vdC5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3NvcjtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgdmFyIHByZWRlY2Vzc29yID0gbnVsbDtcclxuICAgICAgICBpZiAoZC5sZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHByZWRlY2Vzc29yID0gZC5sZWZ0O1xyXG4gICAgICAgICAgICB3aGlsZSAocHJlZGVjZXNzb3IucmlnaHQpXHJcbiAgICAgICAgICAgICAgICBwcmVkZWNlc3NvciA9IHByZWRlY2Vzc29yLnJpZ2h0O1xyXG4gICAgICAgICAgICByZXR1cm4gcHJlZGVjZXNzb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICB3aGlsZSAocm9vdCkge1xyXG4gICAgICAgICAgICB2YXIgY21wID0gY29tcGFyYXRvcihkLmtleSwgcm9vdC5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApXHJcbiAgICAgICAgICAgICAgICByb290ID0gcm9vdC5sZWZ0O1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHByZWRlY2Vzc29yID0gcm9vdDtcclxuICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwcmVkZWNlc3NvcjtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zaXplID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS50b0xpc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRvTGlzdCh0aGlzLl9yb290KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEJ1bGstbG9hZCBpdGVtcy4gQm90aCBhcnJheSBoYXZlIHRvIGJlIHNhbWUgc2l6ZVxyXG4gICAgICovXHJcbiAgICBUcmVlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGtleXMsIHZhbHVlcywgcHJlc29ydCkge1xyXG4gICAgICAgIGlmICh2YWx1ZXMgPT09IHZvaWQgMCkgeyB2YWx1ZXMgPSBbXTsgfVxyXG4gICAgICAgIGlmIChwcmVzb3J0ID09PSB2b2lkIDApIHsgcHJlc29ydCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIHNpemUgPSBrZXlzLmxlbmd0aDtcclxuICAgICAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgLy8gc29ydCBpZiBuZWVkZWRcclxuICAgICAgICBpZiAocHJlc29ydClcclxuICAgICAgICAgICAgc29ydChrZXlzLCB2YWx1ZXMsIDAsIHNpemUgLSAxLCBjb21wYXJhdG9yKTtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdCA9PT0gbnVsbCkgeyAvLyBlbXB0eSB0cmVlXHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBsb2FkUmVjdXJzaXZlKGtleXMsIHZhbHVlcywgMCwgc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NpemUgPSBzaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHsgLy8gdGhhdCByZS1idWlsZHMgdGhlIHdob2xlIHRyZWUgZnJvbSB0d28gaW4tb3JkZXIgdHJhdmVyc2Fsc1xyXG4gICAgICAgICAgICB2YXIgbWVyZ2VkTGlzdCA9IG1lcmdlTGlzdHModGhpcy50b0xpc3QoKSwgY3JlYXRlTGlzdChrZXlzLCB2YWx1ZXMpLCBjb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgc2l6ZSA9IHRoaXMuX3NpemUgKyBzaXplO1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gc29ydGVkTGlzdFRvQlNUKHsgaGVhZDogbWVyZ2VkTGlzdCB9LCAwLCBzaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgVHJlZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3QgPT09IG51bGw7IH07XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJlZS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zaXplOyB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmVlLnByb3RvdHlwZSwgXCJyb290XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3Q7IH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgVHJlZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAocHJpbnROb2RlKSB7XHJcbiAgICAgICAgaWYgKHByaW50Tm9kZSA9PT0gdm9pZCAwKSB7IHByaW50Tm9kZSA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBTdHJpbmcobi5rZXkpOyB9OyB9XHJcbiAgICAgICAgdmFyIG91dCA9IFtdO1xyXG4gICAgICAgIHByaW50Um93KHRoaXMuX3Jvb3QsICcnLCB0cnVlLCBmdW5jdGlvbiAodikgeyByZXR1cm4gb3V0LnB1c2godik7IH0sIHByaW50Tm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIG91dC5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoa2V5LCBuZXdLZXksIG5ld0RhdGEpIHtcclxuICAgICAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgdmFyIF9hID0gc3BsaXQoa2V5LCB0aGlzLl9yb290LCBjb21wYXJhdG9yKSwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQ7XHJcbiAgICAgICAgaWYgKGNvbXBhcmF0b3Ioa2V5LCBuZXdLZXkpIDwgMCkge1xyXG4gICAgICAgICAgICByaWdodCA9IGluc2VydChuZXdLZXksIG5ld0RhdGEsIHJpZ2h0LCBjb21wYXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSBpbnNlcnQobmV3S2V5LCBuZXdEYXRhLCBsZWZ0LCBjb21wYXJhdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcm9vdCA9IG1lcmdlKGxlZnQsIHJpZ2h0LCBjb21wYXJhdG9yKTtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gc3BsaXQoa2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcclxuICAgIH07XHJcbiAgICBUcmVlLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50LCBRLCBkb25lO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0aGlzLl9yb290O1xyXG4gICAgICAgICAgICAgICAgICAgIFEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBkb25lID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghIWRvbmUpIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnQgIT09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgICAgICBRLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShRLmxlbmd0aCAhPT0gMCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGN1cnJlbnRdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVHJlZTtcclxufSgpKTtcclxuZnVuY3Rpb24gbG9hZFJlY3Vyc2l2ZShrZXlzLCB2YWx1ZXMsIHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBzaXplID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBpZiAoc2l6ZSA+IDApIHtcclxuICAgICAgICB2YXIgbWlkZGxlID0gc3RhcnQgKyBNYXRoLmZsb29yKHNpemUgLyAyKTtcclxuICAgICAgICB2YXIga2V5ID0ga2V5c1ttaWRkbGVdO1xyXG4gICAgICAgIHZhciBkYXRhID0gdmFsdWVzW21pZGRsZV07XHJcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZShrZXksIGRhdGEpO1xyXG4gICAgICAgIG5vZGUubGVmdCA9IGxvYWRSZWN1cnNpdmUoa2V5cywgdmFsdWVzLCBzdGFydCwgbWlkZGxlKTtcclxuICAgICAgICBub2RlLnJpZ2h0ID0gbG9hZFJlY3Vyc2l2ZShrZXlzLCB2YWx1ZXMsIG1pZGRsZSArIDEsIGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVMaXN0KGtleXMsIHZhbHVlcykge1xyXG4gICAgdmFyIGhlYWQgPSBuZXcgTm9kZShudWxsLCBudWxsKTtcclxuICAgIHZhciBwID0gaGVhZDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHAgPSBwLm5leHQgPSBuZXcgTm9kZShrZXlzW2ldLCB2YWx1ZXNbaV0pO1xyXG4gICAgfVxyXG4gICAgcC5uZXh0ID0gbnVsbDtcclxuICAgIHJldHVybiBoZWFkLm5leHQ7XHJcbn1cclxuZnVuY3Rpb24gdG9MaXN0KHJvb3QpIHtcclxuICAgIHZhciBjdXJyZW50ID0gcm9vdDtcclxuICAgIHZhciBRID0gW107XHJcbiAgICB2YXIgZG9uZSA9IGZhbHNlO1xyXG4gICAgdmFyIGhlYWQgPSBuZXcgTm9kZShudWxsLCBudWxsKTtcclxuICAgIHZhciBwID0gaGVhZDtcclxuICAgIHdoaWxlICghZG9uZSkge1xyXG4gICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIFEucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChRLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBwID0gcC5uZXh0ID0gUS5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHAubmV4dCA9IG51bGw7IC8vIHRoYXQnbGwgd29yayBldmVuIGlmIHRoZSB0cmVlIHdhcyBlbXB0eVxyXG4gICAgcmV0dXJuIGhlYWQubmV4dDtcclxufVxyXG5mdW5jdGlvbiBzb3J0ZWRMaXN0VG9CU1QobGlzdCwgc3RhcnQsIGVuZCkge1xyXG4gICAgdmFyIHNpemUgPSBlbmQgLSBzdGFydDtcclxuICAgIGlmIChzaXplID4gMCkge1xyXG4gICAgICAgIHZhciBtaWRkbGUgPSBzdGFydCArIE1hdGguZmxvb3Ioc2l6ZSAvIDIpO1xyXG4gICAgICAgIHZhciBsZWZ0ID0gc29ydGVkTGlzdFRvQlNUKGxpc3QsIHN0YXJ0LCBtaWRkbGUpO1xyXG4gICAgICAgIHZhciByb290ID0gbGlzdC5oZWFkO1xyXG4gICAgICAgIHJvb3QubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgbGlzdC5oZWFkID0gbGlzdC5oZWFkLm5leHQ7XHJcbiAgICAgICAgcm9vdC5yaWdodCA9IHNvcnRlZExpc3RUb0JTVChsaXN0LCBtaWRkbGUgKyAxLCBlbmQpO1xyXG4gICAgICAgIHJldHVybiByb290O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZnVuY3Rpb24gbWVyZ2VMaXN0cyhsMSwgbDIsIGNvbXBhcmUpIHtcclxuICAgIHZhciBoZWFkID0gbmV3IE5vZGUobnVsbCwgbnVsbCk7IC8vIGR1bW15XHJcbiAgICB2YXIgcCA9IGhlYWQ7XHJcbiAgICB2YXIgcDEgPSBsMTtcclxuICAgIHZhciBwMiA9IGwyO1xyXG4gICAgd2hpbGUgKHAxICE9PSBudWxsICYmIHAyICE9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGNvbXBhcmUocDEua2V5LCBwMi5rZXkpIDwgMCkge1xyXG4gICAgICAgICAgICBwLm5leHQgPSBwMTtcclxuICAgICAgICAgICAgcDEgPSBwMS5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcC5uZXh0ID0gcDI7XHJcbiAgICAgICAgICAgIHAyID0gcDIubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcCA9IHAubmV4dDtcclxuICAgIH1cclxuICAgIGlmIChwMSAhPT0gbnVsbCkge1xyXG4gICAgICAgIHAubmV4dCA9IHAxO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocDIgIT09IG51bGwpIHtcclxuICAgICAgICBwLm5leHQgPSBwMjtcclxuICAgIH1cclxuICAgIHJldHVybiBoZWFkLm5leHQ7XHJcbn1cclxuZnVuY3Rpb24gc29ydChrZXlzLCB2YWx1ZXMsIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XHJcbiAgICBpZiAobGVmdCA+PSByaWdodClcclxuICAgICAgICByZXR1cm47XHJcbiAgICB2YXIgcGl2b3QgPSBrZXlzWyhsZWZ0ICsgcmlnaHQpID4+IDFdO1xyXG4gICAgdmFyIGkgPSBsZWZ0IC0gMTtcclxuICAgIHZhciBqID0gcmlnaHQgKyAxO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBkb1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgd2hpbGUgKGNvbXBhcmUoa2V5c1tpXSwgcGl2b3QpIDwgMCk7XHJcbiAgICAgICAgZG9cclxuICAgICAgICAgICAgai0tO1xyXG4gICAgICAgIHdoaWxlIChjb21wYXJlKGtleXNbal0sIHBpdm90KSA+IDApO1xyXG4gICAgICAgIGlmIChpID49IGopXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIHZhciB0bXAgPSBrZXlzW2ldO1xyXG4gICAgICAgIGtleXNbaV0gPSBrZXlzW2pdO1xyXG4gICAgICAgIGtleXNbal0gPSB0bXA7XHJcbiAgICAgICAgdG1wID0gdmFsdWVzW2ldO1xyXG4gICAgICAgIHZhbHVlc1tpXSA9IHZhbHVlc1tqXTtcclxuICAgICAgICB2YWx1ZXNbal0gPSB0bXA7XHJcbiAgICB9XHJcbiAgICBzb3J0KGtleXMsIHZhbHVlcywgbGVmdCwgaiwgY29tcGFyZSk7XHJcbiAgICBzb3J0KGtleXMsIHZhbHVlcywgaiArIDEsIHJpZ2h0LCBjb21wYXJlKTtcclxufVxuXG5leHBvcnQgZGVmYXVsdCBUcmVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BsYXkuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/polygon-clipping/node_modules/splaytree/dist/splay.esm.js\n");

/***/ })

};
;